; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33030.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__4A250794_concurrencysal@h DB 01H
__64794009_sal@h DB 01H
__A3E7195B_vadefs@h DB 01H
__978626E5_vcruntime@h DB 01H
__735B63F8_xkeycheck@h DB 01H
__142C9C9C_yvals_core@h DB 01H
__DBEA773D_stdint@h DB 01H
__87335CDF_cstdint DB 01H
__1B0272D9_corecrt@h DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__659C5902_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__3A6DBDA2_cstdlib DB 01H
__B9985323_float@h DB 01H
__3FBCF6F4_cfloat DB 01H
__BE829F50_climits DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__4CF83D73_cstdio DB 01H
__61CC25A1_errno@h DB 01H
__4CB5F942_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__8ECB7138_corecrt_share@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__D673EB20_cwchar DB 01H
__9A2CA802_xtr1common DB 01H
__51ADDFC3_intrin0@inl@h DB 01H
__FC9FC984_intrin0@h DB 01H
__595ABB90_limits DB 01H
__84C50014_vcruntime_new@h DB 01H
__7A6EC116_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__E5B2708F_crtdefs@h DB 01H
__61229A4B_use_ansi@h DB 01H
__8C2D0B1D_yvals@h DB 01H
__9FA6670F_cstddef DB 01H
__3DF2A533_type_traits DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__35BB339F_eh@h DB 01H
__7280C444_vcruntime_exception@h DB 01H
__2DED1E19_exception DB 01H
__A5D71DBC_new DB 01H
__27E192CF_xatomic@h DB 01H
__50E371A7_initializer_list DB 01H
__339AE60A_concepts DB 01H
__C3788713_compare DB 01H
__0D603829_utility DB 01H
__874288EA___msvc_iter_core@hpp DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__E8295E1E_string@h DB 01H
__76FF1542_cstring DB 01H
__B7320FC0_xutility DB 01H
__A0E057FF_tuple DB 01H
__67F55BEA_xmemory DB 01H
__A0A2F5C0_xpolymorphic_allocator@h DB 01H
__52656974_list DB 01H
__06C34EBE_cmath DB 01H
__F3EA4CCC___msvc_bit_utils@hpp DB 01H
__C671E263___msvc_sanitizer_annotate_container@hpp DB 01H
__14F7CB70_vector DB 01H
__B566F9C5_xbit_ops@h DB 01H
__1B8E3698_xnode_handle@h DB 01H
__696C8ED8_xhash DB 01H
__3DA11C4D_unordered_map DB 01H
__4818932A_unordered_set DB 01H
__014E33A8_TMemory@h DB 01H
__AA61B192_TMemory@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z	; std::_Fnv1a_append_bytes
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QEAA@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??0_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QEAA@AEBU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_unlocked
PUBLIC	?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_locked
PUBLIC	?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked
PUBLIC	?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
PUBLIC	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
PUBLIC	?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
PUBLIC	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IEAA@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?_Floor_of_log_2@std@@YAK_K@Z			; std::_Floor_of_log_2
PUBLIC	?_Ceiling_of_log_2@std@@YAK_K@Z			; std::_Ceiling_of_log_2
PUBLIC	??0Bucket@@QEAA@XZ				; Bucket::Bucket
PUBLIC	??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()
PUBLIC	?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z		; std::hash<unsigned __int64>::_Do_hash
PUBLIC	??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z		; std::equal_to<unsigned __int64>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
PUBLIC	??0?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,Bucket> >::allocator<std::pair<unsigned __int64 const ,Bucket> >
PUBLIC	??0?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::max_size
PUBLIC	??0?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
PUBLIC	??1?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::~list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Make_iter
PUBLIC	?max_size@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::max_size
PUBLIC	?_Unchecked_erase@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_erase
PUBLIC	?clear@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::clear
PUBLIC	?_Tidy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
PUBLIC	?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Orphan_non_end
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_splice
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_end
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket_count
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::max_load_factor
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_erase
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::clear
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Rehash_for_1
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Min_load_factor_buckets
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Forced_rehash
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::max_size
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::max_size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >
PUBLIC	??0?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
PUBLIC	??1?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::~unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
PUBLIC	??0?$allocator@_K@std@@QEAA@XZ			; std::allocator<unsigned __int64>::allocator<unsigned __int64>
PUBLIC	??0?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>
PUBLIC	?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
PUBLIC	?deallocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAXQEAU?$_List_node@_KPEAX@2@_K@Z ; std::allocator<std::_List_node<unsigned __int64,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@_K@Z ; std::allocator<std::_List_node<unsigned __int64,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@QEAU?$_List_node@_KPEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::max_size
PUBLIC	??0?$list@_KV?$allocator@_K@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::list<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	??1?$list@_KV?$allocator@_K@std@@@std@@QEAA@XZ	; std::list<unsigned __int64,std::allocator<unsigned __int64> >::~list<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	?begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::begin
PUBLIC	?end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::end
PUBLIC	?_Unchecked_begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter
PUBLIC	?max_size@?$list@_KV?$allocator@_K@std@@@std@@QEBA_KXZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::max_size
PUBLIC	?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@QEAU32@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_erase
PUBLIC	?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_erase
PUBLIC	?clear@?$list@_KV?$allocator@_K@std@@@std@@QEAAXXZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::clear
PUBLIC	?_Tidy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
PUBLIC	?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_List_val<std::_List_simple_types<unsigned __int64> >
PUBLIC	?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXPEAU?$_List_node@_KPEAX@2@@Z ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Orphan_ptr2
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Orphan_non_end
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Unchecked_splice
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >
PUBLIC	?begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::begin
PUBLIC	?end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::end
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_end
PUBLIC	?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket_count
PUBLIC	?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket
PUBLIC	?max_load_factor@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::max_load_factor
PUBLIC	?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@AEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::insert
PUBLIC	?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@$$QEA_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::insert
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_erase
PUBLIC	?erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA_KAEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::erase
PUBLIC	?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::clear
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@_KPEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Rehash_for_1
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@_KPEAX@2@_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Erase_bucket
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Min_load_factor_buckets
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Forced_rehash
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::max_size
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::max_size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::~_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::~_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >
PUBLIC	??0?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ ; std::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >
PUBLIC	??1?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ ; std::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >::~unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >
PUBLIC	??0TMemory@@QEAA@XZ				; TMemory::TMemory
PUBLIC	?Allocate@TMemory@@QEAA?AUBucket@@_K@Z		; TMemory::Allocate
PUBLIC	?Delete@TMemory@@QEAAXAEAUBucket@@@Z		; TMemory::Delete
PUBLIC	??1TMemory@@QEAA@XZ				; TMemory::~TMemory
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>
PUBLIC	??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBAAEB_KXZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::operator*
PUBLIC	?_Verify_range@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@0@Z ; std::_Verify_range
PUBLIC	?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_Unwrapped
PUBLIC	?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_Seek_to
PUBLIC	??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::~_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@AEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
PUBLIC	??1?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@XZ ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::~pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator==
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUBucket@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator++
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
PUBLIC	??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z ; std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >
PUBLIC	??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Erase<unsigned __int64>
PUBLIC	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
PUBLIC	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
PUBLIC	??$make_pair@AEA_KAEAUBucket@@@std@@YA?AU?$pair@_KUBucket@@@0@AEA_KAEAUBucket@@@Z ; std::make_pair<unsigned __int64 &,Bucket &>
PUBLIC	??$?0_KUBucket@@$0A@@?$pair@$$CB_KUBucket@@@std@@QEAA@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::pair<unsigned __int64 const ,Bucket>::pair<unsigned __int64 const ,Bucket><unsigned __int64,Bucket,0>
PUBLIC	??$insert@U?$pair@_KUBucket@@@std@@$0A@@?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::insert<std::pair<unsigned __int64,Bucket>,0>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>
PUBLIC	??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>
PUBLIC	??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
PUBLIC	??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
PUBLIC	??1?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@XZ ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>::~pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
PUBLIC	??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64>
PUBLIC	??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64 const &>
PUBLIC	??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::~_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
PUBLIC	??$?0U?$_List_node@_KPEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<unsigned __int64,void *> >
PUBLIC	??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
PUBLIC	??$?0U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator==
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
PUBLIC	??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > ><std::allocator<unsigned __int64> const &,0>
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned __int64,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Freenode0<std::allocator<std::_List_node<unsigned __int64,void *> > >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<unsigned __int64> > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > ><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &,0>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
PUBLIC	??$fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1><std::allocator<unsigned __int64> const &>
PUBLIC	??$?0_K@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ; std::allocator<std::_List_node<unsigned __int64,void *> >::allocator<std::_List_node<unsigned __int64,void *> ><unsigned __int64>
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &>
PUBLIC	??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> ><std::pair<unsigned __int64 const ,Bucket> >
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * &>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * &>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z		; std::_Get_size_of_n<24>
PUBLIC	??$_Get_size_of_n@$0DA@@std@@YA_K_K@Z		; std::_Get_size_of_n<48>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z		; std::_Get_size_of_n<16>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
PUBLIC	??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z ; std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::less<void> >
PUBLIC	??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Find_last<unsigned __int64>
PUBLIC	??$?0AEA_KAEAUBucket@@$0A@@?$pair@_KUBucket@@@std@@QEAA@AEA_KAEAUBucket@@@Z ; std::pair<unsigned __int64,Bucket>::pair<unsigned __int64,Bucket><unsigned __int64 &,Bucket &,0>
PUBLIC	??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::emplace<std::pair<unsigned __int64,Bucket> >
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	?_Extract@?$_In_place_key_extract_set@_K_K@std@@SAAEB_KAEB_K@Z ; std::_In_place_key_extract_set<unsigned __int64,unsigned __int64>::_Extract
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >
PUBLIC	??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool,0>
PUBLIC	??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64 const &>
PUBLIC	??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1><std::allocator<unsigned __int64> const &>
PUBLIC	??$?0_K@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> ><unsigned __int64>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Freenode<std::allocator<std::_List_node<unsigned __int64,void *> > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@_KPEAX@std@@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<unsigned __int64,void *> *>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &>
PUBLIC	??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > ><std::pair<unsigned __int64 const ,Bucket> >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> * const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::~_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > * const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<unsigned __int64,void *> *>
PUBLIC	??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * &,0>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * &,0>
PUBLIC	??$addressof@_K@std@@YAPEA_KAEA_K@Z		; std::addressof<unsigned __int64>
PUBLIC	??$destroy@_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::destroy<unsigned __int64>
PUBLIC	??$exchange@PEAU?$_List_node@_KPEAX@std@@$$T@std@@YAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<unsigned __int64,void *> *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * const &>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<unsigned __int64> > const >
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Clear_guard::~_Clear_guard
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@AEAV?$list@_KV?$allocator@_K@std@@@2@QEAU?$_List_node@_KPEAX@2@@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::~_Range_eraser
PUBLIC	??$_Adl_verify_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V12@@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >
PUBLIC	??$_Get_unwrapped@AEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?A_TAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > &>
PUBLIC	??$_Pass_fn@U?$less@X@std@@@std@@YA?A_PAEAU?$less@X@0@@Z ; std::_Pass_fn<std::less<void> >
PUBLIC	??$_Min_element_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@U?$less@X@2@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@V10@0U?$less@X@0@@Z ; std::_Min_element_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::less<void> >
PUBLIC	??$_Seek_wrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@$$QEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Seek_wrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
PUBLIC	?_Extract@?$_In_place_key_extract_map@_KU?$pair@_KUBucket@@@std@@@std@@SAAEB_KAEBU?$pair@_KUBucket@@@2@@Z ; std::_In_place_key_extract_map<unsigned __int64,std::pair<unsigned __int64,Bucket> >::_Extract
PUBLIC	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Find_last<unsigned __int64>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
PUBLIC	??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > ><std::pair<unsigned __int64,Bucket> >
PUBLIC	??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool,0>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$construct@_K_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K$$QEA_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::construct<unsigned __int64,unsigned __int64>
PUBLIC	??$construct@_KAEB_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_KAEB_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::construct<unsigned __int64,unsigned __int64 const &>
PUBLIC	??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,Bucket> >
PUBLIC	??$destroy@U?$pair@$$CB_KUBucket@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::destroy<std::pair<unsigned __int64 const ,Bucket> >
PUBLIC	??$_Verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXQEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &>
PUBLIC	??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAXQEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z ; std::_Verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &>
PUBLIC	??$destroy_at@_K@std@@YAXQEA_K@Z		; std::destroy_at<unsigned __int64>
PUBLIC	??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * const &,0>
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * const &>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > const >
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	??$_Hash_representation@_K@std@@YA_KAEB_K@Z	; std::_Hash_representation<unsigned __int64>
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	??$_Debug_lt_pred@AEAU?$less@X@std@@AEB_KAEB_K$0A@@std@@YA_NAEAU?$less@X@0@AEB_K1@Z ; std::_Debug_lt_pred<std::less<void> &,unsigned __int64 const &,unsigned __int64 const &,0>
PUBLIC	??$?RAEB_KAEB_K@?$less@X@std@@QEBA_NAEB_K0@Z	; std::less<void>::operator()<unsigned __int64 const &,unsigned __int64 const &>
PUBLIC	??$construct@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::construct<std::pair<unsigned __int64 const ,Bucket>,std::pair<unsigned __int64,Bucket> >
PUBLIC	??$construct_at@_K_K$0A@@std@@YAPEA_KQEA_K$$QEA_K@Z ; std::construct_at<unsigned __int64,unsigned __int64,0>
PUBLIC	??$construct_at@_KAEB_K$0A@@std@@YAPEA_KQEA_KAEB_K@Z ; std::construct_at<unsigned __int64,unsigned __int64 const &,0>
PUBLIC	??$destroy_at@U?$pair@$$CB_KUBucket@@@std@@@std@@YAXQEAU?$pair@$$CB_KUBucket@@@0@@Z ; std::destroy_at<std::pair<unsigned __int64 const ,Bucket> >
PUBLIC	??$addressof@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
PUBLIC	??$construct_at@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &,0>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
PUBLIC	??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &,0>
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * const &,0>
PUBLIC	??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z	; std::_Fnv1a_append_value<unsigned __int64>
PUBLIC	??$construct_at@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@$0A@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@QEAU10@$$QEAU?$pair@_KUBucket@@@0@@Z ; std::construct_at<std::pair<unsigned __int64 const ,Bucket>,std::pair<unsigned __int64,Bucket>,0>
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ ; `string'
PUBLIC	??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ ; `string'
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Min_buckets
PUBLIC	?_Min_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Min_buckets
PUBLIC	??_C@_0DD@MBIHGLJE@cannot?5dereference?5value?9initia@ ; `string'
PUBLIC	??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1GK@NKIMOCIG@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CF@JCBFHMPL@cannot?5dereference?5end?5list?5ite@ ; `string'
PUBLIC	??_C@_1EO@CNEFBDCF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ ; `string'
PUBLIC	??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ ; `string'
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ ; `string'
PUBLIC	??_C@_0DG@GAGDEJEE@list?5iterators?5in?5range?5are?5fro@ ; `string'
PUBLIC	??_C@_1HA@KAMKPLHN@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs@ ; `string'
PUBLIC	??_C@_0BD@FEEMDEPI@invalid?5comparator@		; `string'
PUBLIC	??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f800000
PUBLIC	__real@5f000000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__imp__invalid_parameter:PROC
EXTRN	__imp_ceilf:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	_CxxThrowException:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_constant_evaluated@std@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?is_constant_evaluated@std@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max@?$numeric_limits@_J@std@@SA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?max@?$numeric_limits@_J@std@@SA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??2@YAPEAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??2@YAPEAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD imagerel $LN6
	DD	imagerel $LN6+136
	DD	imagerel $unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN21
	DD	imagerel $LN21+433
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_base12@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0_Container_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+114
	DD	imagerel $unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Iterator_base12@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??0_Iterator_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Iterator_base12@std@@QEAA@AEBU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$??0_Iterator_base12@std@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Iterator_base12@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$??1_Iterator_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z DD imagerel $LN6
	DD	imagerel $LN6+96
	DD	imagerel $unwind$?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+257
	DD	imagerel $unwind$?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+115
	DD	imagerel $unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Floor_of_log_2@std@@YAK_K@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$?_Floor_of_log_2@std@@YAK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ceiling_of_log_2@std@@YAK_K@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?_Ceiling_of_log_2@std@@YAK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Bucket@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0Bucket@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+79
	DD	imagerel $unwind$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??0?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+193
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??0?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$??1?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?_Unchecked_begin@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?_Make_iter@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?max_size@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN16
	DD	imagerel $LN16+490
	DD	imagerel $unwind$?_Unchecked_erase@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+142
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+196
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+170
	DD	imagerel $unwind$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z DD imagerel $LN3
	DD	imagerel $LN3+167
	DD	imagerel $unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+229
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA DD imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_load_factor@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN25
	DD	imagerel $LN25+721
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+218
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_KQEAU32@1@Z DD imagerel $LN8
	DD	imagerel $LN8+374
	DD	imagerel $unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_KQEAU32@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+212
	DD	imagerel $unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN6
	DD	imagerel $LN6+168
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+148
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN16
	DD	imagerel $LN16+804
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+196
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+312
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+162
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+113
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$??0?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$allocator@_K@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??0?$allocator@_K@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAXQEAU?$_List_node@_KPEAX@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+193
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAXQEAU?$_List_node@_KPEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@QEAU?$_List_node@_KPEAX@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@QEAU?$_List_node@_KPEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@_KV?$allocator@_K@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??0?$list@_KV?$allocator@_K@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@_KV?$allocator@_K@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$??1?$list@_KV?$allocator@_K@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$?end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?_Unchecked_begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Unchecked_end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$list@_KV?$allocator@_K@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?max_size@?$list@_KV?$allocator@_K@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@QEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+145
	DD	imagerel $unwind$?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN16
	DD	imagerel $LN16+490
	DD	imagerel $unwind$?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@_KV?$allocator@_K@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+142
	DD	imagerel $unwind$?clear@?$list@_KV?$allocator@_K@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?_Tidy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+196
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$??0?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXPEAU?$_List_node@_KPEAX@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+202
	DD	imagerel $unwind$?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXPEAU?$_List_node@_KPEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+170
	DD	imagerel $unwind$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z DD imagerel $LN3
	DD	imagerel $LN3+167
	DD	imagerel $unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+237
	DD	imagerel $unwind$??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA DD imagerel ?dtor$1@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?_Unchecked_begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?_Unchecked_end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_load_factor@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?max_load_factor@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@AEB_K@Z DD imagerel $LN5
	DD	imagerel $LN5+80
	DD	imagerel $unwind$?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@AEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@$$QEA_K@Z DD imagerel $LN5
	DD	imagerel $LN5+80
	DD	imagerel $unwind$?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@$$QEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN25
	DD	imagerel $LN25+721
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+218
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_new_node_before@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@_KPEAX@2@_KQEAU32@1@Z DD imagerel $LN8
	DD	imagerel $LN8+374
	DD	imagerel $unwind$?_Insert_new_node_before@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@_KPEAX@2@_KQEAU32@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_rehash_required_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+212
	DD	imagerel $unwind$?_Check_rehash_required_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Erase_bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@_KPEAX@2@_K@Z DD imagerel $LN8
	DD	imagerel $LN8+205
	DD	imagerel $unwind$?_Erase_bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@_KPEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN6
	DD	imagerel $LN6+168
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+148
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN16
	DD	imagerel $LN16+804
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAAEBMXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAAEBMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+196
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+312
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+162
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+113
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??1?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$??0?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TMemory@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+147
	DD	imagerel $unwind$??0TMemory@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0TMemory@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0TMemory@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0TMemory@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0TMemory@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0TMemory@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0TMemory@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0TMemory@@QEAA@XZ@4HA+32
	DD	imagerel $unwind$?dtor$1@?0???0TMemory@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Allocate@TMemory@@QEAA?AUBucket@@_K@Z DD imagerel $LN10
	DD	imagerel $LN10+581
	DD	imagerel $unwind$?Allocate@TMemory@@QEAA?AUBucket@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Delete@TMemory@@QEAAXAEAUBucket@@@Z DD imagerel $LN5
	DD	imagerel $LN5+165
	DD	imagerel $unwind$?Delete@TMemory@@QEAAXAEAUBucket@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1TMemory@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+165
	DD	imagerel $unwind$??1TMemory@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBAAEB_KXZ DD imagerel $LN21
	DD	imagerel $LN21+320
	DD	imagerel $unwind$??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBAAEB_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Verify_range@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@0@Z DD imagerel $LN12
	DD	imagerel $LN12+191
	DD	imagerel $unwind$?_Verify_range@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??1?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUBucket@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUBucket@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z DD imagerel $LN9
	DD	imagerel $LN9+277
	DD	imagerel $unwind$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA DD imagerel ?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA
	DD	imagerel ?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA DD imagerel ?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA
	DD	imagerel ?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z DD imagerel $LN4
	DD	imagerel $LN4+191
	DD	imagerel $unwind$??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+103
	DD	imagerel $unwind$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_pair@AEA_KAEAUBucket@@@std@@YA?AU?$pair@_KUBucket@@@0@AEA_KAEAUBucket@@@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??$make_pair@AEA_KAEAUBucket@@@std@@YA?AU?$pair@_KUBucket@@@0@AEA_KAEAUBucket@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_KUBucket@@$0A@@?$pair@$$CB_KUBucket@@@std@@QEAA@$$QEAU?$pair@_KUBucket@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$??$?0_KUBucket@@$0A@@?$pair@$$CB_KUBucket@@@std@@QEAA@$$QEAU?$pair@_KUBucket@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$insert@U?$pair@_KUBucket@@@std@@$0A@@?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+80
	DD	imagerel $unwind$??$insert@U?$pair@_KUBucket@@@std@@$0A@@?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??1?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+193
	DD	imagerel $unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z DD imagerel $LN10
	DD	imagerel $LN10+577
	DD	imagerel $unwind$??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z@4HA DD imagerel ?dtor$2@?0???$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z@4HA
	DD	imagerel ?dtor$2@?0???$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$2@?0???$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z DD imagerel $LN10
	DD	imagerel $LN10+577
	DD	imagerel $unwind$??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z@4HA DD imagerel ?dtor$2@?0???$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z@4HA
	DD	imagerel ?dtor$2@?0???$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$2@?0???$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$_List_node@_KPEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0U?$_List_node@_KPEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z DD imagerel $LN7
	DD	imagerel $LN7+130
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_K@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0_K@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN7
	DD	imagerel $LN7+130
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+86
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@0@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@0@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0DA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$??$_Get_size_of_n@$0DA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+314
	DD	imagerel $unwind$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA DD imagerel ?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA DD imagerel ?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA
	DD	imagerel ?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z DD imagerel $LN9
	DD	imagerel $LN9+357
	DD	imagerel $unwind$??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEA_KAEAUBucket@@$0A@@?$pair@_KUBucket@@@std@@QEAA@AEA_KAEAUBucket@@@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$??$?0AEA_KAEAUBucket@@$0A@@?$pair@_KUBucket@@@std@@QEAA@AEA_KAEAUBucket@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z DD imagerel $LN10
	DD	imagerel $LN10+577
	DD	imagerel $unwind$??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA DD imagerel ?dtor$2@?0???$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA
	DD	imagerel ?dtor$2@?0???$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA+25
	DD	imagerel $unwind$?dtor$2@?0???$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Extract@?$_In_place_key_extract_set@_K_K@std@@SAAEB_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Extract@?$_In_place_key_extract_set@_K_K@std@@SAAEB_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z DD imagerel $LN4
	DD	imagerel $LN4+123
	DD	imagerel $unwind$??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z@4HA DD imagerel ?dtor$0@?0???$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z DD imagerel $LN4
	DD	imagerel $LN4+123
	DD	imagerel $unwind$??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z@4HA DD imagerel ?dtor$0@?0???$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_K@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0_K@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAU?$_List_node@_KPEAX@std@@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$_Destroy_in_place@PEAU?$_List_node@_KPEAX@std@@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adl_verify_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??$_Adl_verify_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN13
	DD	imagerel $LN13+266
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEAPEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEAPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@_K@std@@YAPEA_KAEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@_K@std@@YAPEA_KAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$destroy@_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@_KPEAX@std@@$$T@std@@YAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@_KPEAX@std@@$$T@std@@YAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@AEBQEAU10@@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@$$CBV?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@$$CBV?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@QEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??0_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@AEAV?$list@_KV?$allocator@_K@std@@@2@QEAU?$_List_node@_KPEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??0_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@AEAV?$list@_KV?$allocator@_K@std@@@2@QEAU?$_List_node@_KPEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adl_verify_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V12@@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$_Adl_verify_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V12@@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?A_TAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??$_Get_unwrapped@AEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?A_TAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pass_fn@U?$less@X@std@@@std@@YA?A_PAEAU?$less@X@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??$_Pass_fn@U?$less@X@std@@@std@@YA?A_PAEAU?$less@X@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Min_element_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@U?$less@X@2@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@V10@0U?$less@X@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+191
	DD	imagerel $unwind$??$_Min_element_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@U?$less@X@2@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@V10@0U?$less@X@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Seek_wrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@$$QEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Seek_wrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@$$QEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Extract@?$_In_place_key_extract_map@_KU?$pair@_KUBucket@@@std@@@std@@SAAEB_KAEBU?$pair@_KUBucket@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Extract@?$_In_place_key_extract_map@_KU?$pair@_KUBucket@@@std@@@std@@SAAEB_KAEBU?$pair@_KUBucket@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@AEB_K_K@Z DD imagerel $LN9
	DD	imagerel $LN9+357
	DD	imagerel $unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+123
	DD	imagerel $unwind$??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@_K_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K$$QEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$construct@_K_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K$$QEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@_KAEB_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$construct@_KAEB_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CB_KUBucket@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$destroy@U?$pair@$$CB_KUBucket@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXQEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z DD imagerel $LN12
	DD	imagerel $LN12+163
	DD	imagerel $unwind$??$_Verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXQEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEBV10@@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAXQEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z DD imagerel $LN12
	DD	imagerel $LN12+163
	DD	imagerel $unwind$??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAXQEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@_K@std@@YAXQEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$destroy_at@_K@std@@YAXQEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEBQEAU10@@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Hash_representation@_K@std@@YA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$_Hash_representation@_K@std@@YA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Debug_lt_pred@AEAU?$less@X@std@@AEB_KAEB_K$0A@@std@@YA_NAEAU?$less@X@0@AEB_K1@Z DD imagerel $LN13
	DD	imagerel $LN13+225
	DD	imagerel $unwind$??$_Debug_lt_pred@AEAU?$less@X@std@@AEB_KAEB_K$0A@@std@@YA_NAEAU?$less@X@0@AEB_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RAEB_KAEB_K@?$less@X@std@@QEBA_NAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+79
	DD	imagerel $unwind$??$?RAEB_KAEB_K@?$less@X@std@@QEBA_NAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$construct@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@_K_K$0A@@std@@YAPEA_KQEA_K$$QEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@_K_K$0A@@std@@YAPEA_KQEA_K$$QEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@_KAEB_K$0A@@std@@YAPEA_KQEA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@_KAEB_K$0A@@std@@YAPEA_KQEA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@U?$pair@$$CB_KUBucket@@@std@@@std@@YAXQEAU?$pair@$$CB_KUBucket@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$destroy_at@U?$pair@$$CB_KUBucket@@@std@@@std@@YAXQEAU?$pair@$$CB_KUBucket@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@$0A@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@QEAU10@$$QEAU?$pair@_KUBucket@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@$0A@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@QEAU10@$$QEAU?$pair@_KUBucket@@@0@@Z
pdata	ENDS
;	COMDAT __real@5f000000
CONST	SEGMENT
__real@5f000000 DD 05f000000r			; 9.22337e+18
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
CONST	SEGMENT
??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FEEMDEPI@invalid?5comparator@
CONST	SEGMENT
??_C@_0BD@FEEMDEPI@invalid?5comparator@ DB 'invalid comparator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@KAMKPLHN@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs@
CONST	SEGMENT
??_C@_1HA@KAMKPLHN@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs@ DB '"'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'r', 00H
	DB	'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'r'
	DB	00H, 'e', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H
	DB	' ', 00H, 'd', 00H, 'i', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GAGDEJEE@list?5iterators?5in?5range?5are?5fro@
CONST	SEGMENT
??_C@_0DG@GAGDEJEE@list?5iterators?5in?5range?5are?5fro@ DB 'list iterato'
	DB	'rs in range are from different containers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ DB '"'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't', 00H, 'i'
	DB	00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38'
	DB	'.33030\include\xutility', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
CONST	SEGMENT
??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ DB 'invalid hash bucket '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ DB 'unordered_map/set t'
	DB	'oo long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@CNEFBDCF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1EO@CNEFBDCF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JCBFHMPL@cannot?5dereference?5end?5list?5ite@
CONST	SEGMENT
??_C@_0CF@JCBFHMPL@cannot?5dereference?5end?5list?5ite@ DB 'cannot derefe'
	DB	'rence end list iterator', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@NKIMOCIG@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1GK@NKIMOCIG@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38'
	DB	'.33030\include\list', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MBIHGLJE@cannot?5dereference?5value?9initia@
CONST	SEGMENT
??_C@_0DD@MBIHGLJE@cannot?5dereference?5value?9initia@ DB 'cannot derefer'
	DB	'ence value-initialized list iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
CONST	SEGMENT
??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DB '"'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'O', 00H, 'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T'
	DB	00H, ' ', 00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H
	DB	'P', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
CONST	SEGMENT
??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DB 'ITERATOR LIST CORRU'
	DB	'PTED!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e', 00H, 'm'
	DB	00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program Fi'
	DB	'les\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.'
	DB	'33030\include\xmemory', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA DD 09aH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@$0A@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@QEAU10@$$QEAU?$pair@_KUBucket@@@0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEAV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@AEBV10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@U?$pair@$$CB_KUBucket@@@std@@@std@@YAXQEAU?$pair@$$CB_KUBucket@@@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@_KAEB_K$0A@@std@@YAPEA_KQEA_KAEB_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@_K_K$0A@@std@@YAPEA_KQEA_K$$QEA_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RAEB_KAEB_K@?$less@X@std@@QEBA_NAEB_K0@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Debug_lt_pred@AEAU?$less@X@std@@AEB_KAEB_K$0A@@std@@YA_NAEAU?$less@X@0@AEB_K1@Z DD 035031c01H
	DD	0f217331cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Hash_representation@_K@std@@YA_KAEB_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@0@AEBV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEBQEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEBQEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@_K@std@@YAXQEA_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEBV10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAXQEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z DD 035031401H
	DD	0d20f3314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEBV10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXQEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z DD 035031401H
	DD	0d20f3314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CB_KUBucket@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@_KAEB_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_KAEB_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@_K_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K$$QEA_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@$$QEA_N@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'f'
	DB	02H
	DB	'|'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z
	DD	imagerel $ip2state$??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z DD 025031911H
	DD	0d2142319H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@AEB_K_K@Z DD 025042101H
	DD	011c2321H
	DD	050150012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Extract@?$_In_place_key_extract_map@_KU?$pair@_KUBucket@@@std@@@std@@SAAEB_KAEBU?$pair@_KUBucket@@@2@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Seek_wrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@$$QEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Min_element_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@U?$less@X@2@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@V10@0U?$less@X@0@@Z DD 025032101H
	DD	0f21c2321H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pass_fn@U?$less@X@std@@@std@@YA?A_PAEAU?$less@X@0@@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?A_TAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adl_verify_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V12@@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@AEAV?$list@_KV?$allocator@_K@std@@@2@QEAU?$_List_node@_KPEAX@2@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@QEAV12@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@$$CBV?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEBV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@AEBQEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@_KPEAX@std@@$$T@std@@YAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@_K@std@@YAPEA_KAEA_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEAPEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 035041201H
	DD	010d3312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adl_verify_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DB 060H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAU?$_List_node@_KPEAX@std@@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DB 060H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_K@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'f'
	DB	02H
	DB	'|'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z
	DD	imagerel $ip2state$??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z DD 025031911H
	DD	0d2142319H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'f'
	DB	02H
	DB	'|'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z
	DD	imagerel $ip2state$??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z DD 025031911H
	DD	0d2142319H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Extract@?$_In_place_key_extract_set@_K_K@std@@SAAEB_KAEB_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	0c9H, 04H
	DB	02H
	DB	0d1H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$2@?0???$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z
	DD	imagerel $ip2state$??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z DD 025061e11H
	DD	0119231eH
	DD	070120020H
	DD	050106011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEA_KAEAUBucket@@$0A@@?$pair@_KUBucket@@@std@@QEAA@AEA_KAEAUBucket@@@Z DD 025051b01H
	DD	0b216231bH
	DD	060117012H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z DD 025042101H
	DD	011c2321H
	DD	050150012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z DB 08H
	DB	00H
	DB	00H
	DB	'V'
	DB	04H
	DB	099H, 03H
	DB	02H
	DB	01aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z
	DD	imagerel $ip2state$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z DD 025042111H
	DD	011c2321H
	DD	050150018H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0DA@@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0baH
	DB	02H
	DB	'L'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 025031c11H
	DD	0f217231cH
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_K@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0baH
	DB	02H
	DB	'L'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z DD 025031c11H
	DD	0f217231cH
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD 025031d01H
	DD	0d218231dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DB 060H
	DD	imagerel $ip2state$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DB 060H
	DD	imagerel $ip2state$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD 025031419H
	DD	0d20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEAV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DB 060H
	DD	imagerel $ip2state$??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DB 060H
	DD	imagerel $ip2state$??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DD 025031419H
	DD	0d20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$_List_node@_KPEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z DB 06H
	DB	00H
	DB	00H
	DB	0c9H, 04H
	DB	02H
	DB	0d1H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$2@?0???$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z
	DD	imagerel $ip2state$??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z DD 025061e11H
	DD	0119231eH
	DD	070120020H
	DD	050106011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z DB 06H
	DB	00H
	DB	00H
	DB	0c9H, 04H
	DB	02H
	DB	0d1H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$2@?0???$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z
	DD	imagerel $ip2state$??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z DD 025061e11H
	DD	0119231eH
	DD	070120020H
	DD	050106011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$insert@U?$pair@_KUBucket@@@std@@$0A@@?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_KUBucket@@$0A@@?$pair@$$CB_KUBucket@@@std@@QEAA@$$QEAU?$pair@_KUBucket@@@1@@Z DD 025051601H
	DD	0b2112316H
	DD	0600c700dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_pair@AEA_KAEAUBucket@@@std@@YA?AU?$pair@_KUBucket@@@0@AEA_KAEAUBucket@@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z DB 060H
	DD	imagerel $ip2state$??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z DD 025041719H
	DD	01122317H
	DD	0500b0012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z DB 08H
	DB	00H
	DB	00H
	DB	'N'
	DB	04H
	DB	011H, 03H
	DB	02H
	DB	01aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z DB 028H
	DD	imagerel $stateUnwindMap$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z
	DD	imagerel $ip2state$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z DD 025051d11H
	DD	0118231dH
	DD	07011001bH
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUBucket@@@1@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Verify_range@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@0@Z DD 035031701H
	DD	0f2123317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBAAEB_KXZ DD 035031201H
	DD	0f20d3312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1TMemory@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1TMemory@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1TMemory@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1TMemory@@QEAA@XZ DD 025031219H
	DD	0f20d2312H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1TMemory@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Delete@TMemory@@QEAAXAEAUBucket@@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Allocate@TMemory@@QEAA?AUBucket@@_K@Z DD 025061e01H
	DD	0119231eH
	DD	07012002aH
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0TMemory@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0TMemory@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0TMemory@@QEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	'\'
	DB	02H
	DB	'('
	DB	04H
	DB	088H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0TMemory@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0TMemory@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0TMemory@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0TMemory@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0TMemory@@QEAA@XZ
	DD	imagerel $ip2state$??0TMemory@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TMemory@@QEAA@XZ DD 025041211H
	DD	010d2312H
	DD	050060012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0TMemory@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ DD 025031219H
	DD	0f20d2312H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z DD 025041c01H
	DD	0117231cH
	DD	050100012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAAEBMXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAAEAMXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAX_K@Z DD 025041701H
	DD	01122317H
	DD	0500b0018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Erase_bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@_KPEAX@2@_K@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_rehash_required_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_NXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_new_node_before@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@_KPEAX@2@_KQEAU32@1@Z DD 025042101H
	DD	011c2321H
	DD	050150012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ DD 025041219H
	DD	010d2312H
	DD	050060012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA_KAEB_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z DD 025041c01H
	DD	0117231cH
	DD	050100022H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@$$QEA_K@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@AEB_K@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_load_factor@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBAMXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	0b4H
	DB	02H
	DB	':'
	DB	04H
	DB	0d8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z DD 025031c11H
	DD	0f217231cH
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXPEAU?$_List_node@_KPEAX@2@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ DB 06H
	DB	00H
	DB	00H
	DB	0acH
	DB	02H
	DB	0beH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ
	DD	imagerel $ip2state$?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ DD 025041211H
	DD	010d2312H
	DD	050060012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@_KV?$allocator@_K@std@@@std@@QEAAXXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z DD 025041c01H
	DD	0117231cH
	DD	050100016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@QEAU32@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$list@_KV?$allocator@_K@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@_KV?$allocator@_K@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@_KV?$allocator@_K@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@QEAU?$_List_node@_KPEAX@2@_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAXQEAU?$_List_node@_KPEAX@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$allocator@_K@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 025031219H
	DD	0f20d2312H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@@Z DD 025041c01H
	DD	0117231cH
	DD	050100012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD 025041701H
	DD	01122317H
	DD	0500b0018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_KQEAU32@1@Z DD 025042101H
	DD	011c2321H
	DD	050150012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD 025041219H
	DD	010d2312H
	DD	050060012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 025041c01H
	DD	0117231cH
	DD	050100022H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBAMXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	0b4H
	DB	02H
	DB	':'
	DB	04H
	DB	0c8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD 025031c11H
	DD	0f217231cH
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAAXXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ DB 06H
	DB	00H
	DB	00H
	DB	0acH
	DB	02H
	DB	0beH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ
	DD	imagerel $ip2state$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ DD 025041211H
	DD	010d2312H
	DD	050060012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAAXXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 025041c01H
	DD	0117231cH
	DD	050100016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA_KXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Bucket@@QEAA@XZ DD 05030d01H
	DD	0720a030dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ceiling_of_log_2@std@@YAK_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Floor_of_log_2@std@@YAK_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ DD 035031201H
	DD	0f20d3312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Iterator_base12@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Iterator_base12@std@@QEAA@AEBU01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Iterator_base12@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_base12@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 035041701H
	DD	01123317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 025030e01H
	DD	0f209230eH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 025041501H
	DD	0c2102315H
	DD	0500b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 025041a01H
	DD	0c215231aH
	DD	050107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??2@YAPEAX_KPEAX@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max@?$numeric_limits@_J@std@@SA_JXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_constant_evaluated@std@@YA_NXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@$0A@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@QEAU10@$$QEAU?$pair@_KUBucket@@@0@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@$0A@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@QEAU10@$$QEAU?$pair@_KUBucket@@@0@@Z PROC ; std::construct_at<std::pair<unsigned __int64 const ,Bucket>,std::pair<unsigned __int64,Bucket>,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00036	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003a	e8 00 00 00 00	 call	 ??$?0_KUBucket@@$0A@@?$pair@$$CB_KUBucket@@@std@@QEAA@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::pair<unsigned __int64 const ,Bucket>::pair<unsigned __int64 const ,Bucket><unsigned __int64,Bucket,0>

; 243  : }

  0003f	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00043	5d		 pop	 rbp
  00044	c3		 ret	 0
??$construct_at@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@$0A@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@QEAU10@$$QEAU?$pair@_KUBucket@@@0@@Z ENDP ; std::construct_at<std::pair<unsigned __int64 const ,Bucket>,std::pair<unsigned __int64,Bucket>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z
_TEXT	SEGMENT
_Val$ = 80
_Keyval$ = 88
??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z PROC	; std::_Fnv1a_append_value<unsigned __int64>, COMDAT

; 2344 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2345 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2346 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));

  00020	41 b8 08 00 00
	00		 mov	 r8d, 8
  00026	48 8b 55 58	 mov	 rdx, QWORD PTR _Keyval$[rbp]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR _Val$[rbp]
  0002e	e8 00 00 00 00	 call	 ?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ; std::_Fnv1a_append_bytes

; 2347 : }

  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z ENDP	; std::_Fnv1a_append_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z PROC ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003d	48 89 01	 mov	 QWORD PTR [rcx], rax
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ENDP ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@AEBV10@@Z PROC ; std::construct_at<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003d	48 89 01	 mov	 QWORD PTR [rcx], rax
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@AEBV10@@Z ENDP ; std::construct_at<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@$$CB_KUBucket@@@std@@@std@@YAXQEAU?$pair@$$CB_KUBucket@@@0@@Z
_TEXT	SEGMENT
_Location$ = 80
??$destroy_at@U?$pair@$$CB_KUBucket@@@std@@@std@@YAXQEAU?$pair@$$CB_KUBucket@@@0@@Z PROC ; std::destroy_at<std::pair<unsigned __int64 const ,Bucket> >, COMDAT

; 313  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 314  : #if _HAS_CXX20
; 315  :     if constexpr (is_array_v<_Ty>) {
; 316  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 317  :     } else
; 318  : #endif // _HAS_CXX20
; 319  :     {
; 320  :         _Location->~_Ty();
; 321  :     }
; 322  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$destroy_at@U?$pair@$$CB_KUBucket@@@std@@@std@@YAXQEAU?$pair@$$CB_KUBucket@@@0@@Z ENDP ; std::destroy_at<std::pair<unsigned __int64 const ,Bucket> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@_KAEB_K$0A@@std@@YAPEA_KQEA_KAEB_K@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@_KAEB_K$0A@@std@@YAPEA_KQEA_KAEB_K@Z PROC ; std::construct_at<unsigned __int64,unsigned __int64 const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@_KAEB_K$0A@@std@@YAPEA_KQEA_KAEB_K@Z ENDP ; std::construct_at<unsigned __int64,unsigned __int64 const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@_K_K$0A@@std@@YAPEA_KQEA_K$$QEA_K@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@_K_K$0A@@std@@YAPEA_KQEA_K$$QEA_K@Z PROC ; std::construct_at<unsigned __int64,unsigned __int64,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@_K_K$0A@@std@@YAPEA_KQEA_K$$QEA_K@Z ENDP ; std::construct_at<unsigned __int64,unsigned __int64,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::construct<std::pair<unsigned __int64 const ,Bucket>,std::pair<unsigned __int64,Bucket> >, COMDAT

; 719  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 720  : #if _HAS_CXX20
; 721  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00025	48 8b 55 60	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$construct_at@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@$0A@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@QEAU10@$$QEAU?$pair@_KUBucket@@@0@@Z ; std::construct_at<std::pair<unsigned __int64 const ,Bucket>,std::pair<unsigned __int64,Bucket>,0>

; 722  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 723  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 724  : #endif // ^^^ !_HAS_CXX20 ^^^
; 725  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$construct@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::construct<std::pair<unsigned __int64 const ,Bucket>,std::pair<unsigned __int64,Bucket> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$?RAEB_KAEB_K@?$less@X@std@@QEBA_NAEB_K0@Z
_TEXT	SEGMENT
tv65 = 64
this$ = 96
_Left$ = 104
_Right$ = 112
??$?RAEB_KAEB_K@?$less@X@std@@QEBA_NAEB_K0@Z PROC	; std::less<void>::operator()<unsigned __int64 const &,unsigned __int64 const &>, COMDAT

; 2455 :         -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2456 :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00025	48 8b 45 68	 mov	 rax, QWORD PTR _Left$[rbp]
  00029	48 8b 4d 70	 mov	 rcx, QWORD PTR _Right$[rbp]
  0002d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00030	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00033	73 09		 jae	 SHORT $LN3@operator
  00035	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv65[rbp], 1
  0003c	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0003e	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv65[rbp], 0
$LN4@operator:
  00045	0f b6 45 40	 movzx	 eax, BYTE PTR tv65[rbp]

; 2457 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??$?RAEB_KAEB_K@?$less@X@std@@QEBA_NAEB_K0@Z ENDP	; std::less<void>::operator()<unsigned __int64 const &,unsigned __int64 const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Debug_lt_pred@AEAU?$less@X@std@@AEB_KAEB_K$0A@@std@@YA_NAEAU?$less@X@0@AEB_K1@Z
_TEXT	SEGMENT
_Result$ = 0
_Pred$ = 96
_Left$ = 104
_Right$ = 112
??$_Debug_lt_pred@AEAU?$less@X@std@@AEB_KAEB_K$0A@@std@@YA_NAEAU?$less@X@0@AEB_K1@Z PROC ; std::_Debug_lt_pred<std::less<void> &,unsigned __int64 const &,unsigned __int64 const &,0>, COMDAT

; 1368 :     noexcept(_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left))) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1369 :     // test if _Pred(_Left, _Right) and _Pred is strict weak ordering, when the arguments are the cv-same-type
; 1370 :     const auto _Result = static_cast<bool>(_Pred(_Left, _Right));

  00028	4c 8b 45 70	 mov	 r8, QWORD PTR _Right$[rbp]
  0002c	48 8b 55 68	 mov	 rdx, QWORD PTR _Left$[rbp]
  00030	48 8b 4d 60	 mov	 rcx, QWORD PTR _Pred$[rbp]
  00034	e8 00 00 00 00	 call	 ??$?RAEB_KAEB_K@?$less@X@std@@QEBA_NAEB_K0@Z ; std::less<void>::operator()<unsigned __int64 const &,unsigned __int64 const &>
  00039	88 45 00	 mov	 BYTE PTR _Result$[rbp], al

; 1371 :     if (_Result) {

  0003c	0f b6 45 00	 movzx	 eax, BYTE PTR _Result$[rbp]
  00040	85 c0		 test	 eax, eax
  00042	0f 84 8f 00 00
	00		 je	 $LN8@Debug_lt_p
$LN4@Debug_lt_p:

; 1372 :         _STL_VERIFY(!_Pred(_Right, _Left), "invalid comparator");

  00048	4c 8b 45 68	 mov	 r8, QWORD PTR _Left$[rbp]
  0004c	48 8b 55 70	 mov	 rdx, QWORD PTR _Right$[rbp]
  00050	48 8b 4d 60	 mov	 rcx, QWORD PTR _Pred$[rbp]
  00054	e8 00 00 00 00	 call	 ??$?RAEB_KAEB_K@?$less@X@std@@QEBA_NAEB_K0@Z ; std::less<void>::operator()<unsigned __int64 const &,unsigned __int64 const &>
  00059	0f b6 c0	 movzx	 eax, al
  0005c	85 c0		 test	 eax, eax
  0005e	75 02		 jne	 SHORT $LN7@Debug_lt_p
  00060	eb 6b		 jmp	 SHORT $LN10@Debug_lt_p
$LN7@Debug_lt_p:
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@FEEMDEPI@invalid?5comparator@
  00069	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00075	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007a	45 33 c9	 xor	 r9d, r9d
  0007d	41 b8 5c 05 00
	00		 mov	 r8d, 1372		; 0000055cH
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@
  0008a	b9 02 00 00 00	 mov	 ecx, 2
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00095	83 f8 01	 cmp	 eax, 1
  00098	75 03		 jne	 SHORT $LN12@Debug_lt_p
  0009a	cc		 int	 3
  0009b	33 c0		 xor	 eax, eax
$LN12@Debug_lt_p:
  0009d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000a6	41 b9 5c 05 00
	00		 mov	 r9d, 1372		; 0000055cH
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 95		 jne	 SHORT $LN7@Debug_lt_p
$LN10@Debug_lt_p:
  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	0f 85 71 ff ff
	ff		 jne	 $LN4@Debug_lt_p
$LN8@Debug_lt_p:

; 1373 :     }
; 1374 : 
; 1375 :     return _Result;

  000d7	0f b6 45 00	 movzx	 eax, BYTE PTR _Result$[rbp]

; 1376 : }

  000db	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000df	5d		 pop	 rbp
  000e0	c3		 ret	 0
??$_Debug_lt_pred@AEAU?$less@X@std@@AEB_KAEB_K$0A@@std@@YA_NAEAU?$less@X@0@AEB_K1@Z ENDP ; std::_Debug_lt_pred<std::less<void> &,unsigned __int64 const &,unsigned __int64 const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 64
this$ = 96
??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 997  :         ~_Range_eraser() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 998  :             _List._Unchecked_erase(_First, _Next);

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 89 45 40	 mov	 QWORD PTR tv72[rbp], rax
  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  0002e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00036	48 8b 4d 40	 mov	 rcx, QWORD PTR tv72[rbp]
  0003a	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_erase

; 999  :         }

  0003f	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00043	5d		 pop	 rbp
  00044	c3		 ret	 0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 993  :         void _Bump_erased() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 994  :             _Next = _Next->_Next;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00023	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 995  :         }

  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 80
_List_$ = 88
_First_$ = 96
??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 991  :             : _List(_List_), _First(_First_), _Next(_First_) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _List_$[rbp]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 4d 60	 mov	 rcx, QWORD PTR _First_$[rbp]
  00038	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 4d 60	 mov	 rcx, QWORD PTR _First_$[rbp]
  00044	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$_Hash_representation@_K@std@@YA_KAEB_K@Z
_TEXT	SEGMENT
_Keyval$ = 80
??$_Hash_representation@_K@std@@YA_KAEB_K@Z PROC	; std::_Hash_representation<unsigned __int64>, COMDAT

; 2350 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2351 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

  0001b	48 8b 55 50	 mov	 rdx, QWORD PTR _Keyval$[rbp]
  0001f	48 b9 25 23 22
	84 e4 9c f2 cb	 mov	 rcx, -3750763034362895579 ; cbf29ce484222325H
  00029	e8 00 00 00 00	 call	 ??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z ; std::_Fnv1a_append_value<unsigned __int64>

; 2352 : }

  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??$_Hash_representation@_K@std@@YA_KAEB_K@Z ENDP	; std::_Hash_representation<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 483  :         ~_Clear_guard() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 484  :             if (_Target) {

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 0c		 je	 SHORT $LN2@Clear_guar

; 485  :                 _Target->clear();

  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002c	e8 00 00 00 00	 call	 ?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::clear
$LN2@Clear_guar:

; 486  :             }
; 487  :         }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 80
_Target_$ = 88
??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 478  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Target_$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > const >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * const &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy_at@_K@std@@YAXQEA_K@Z
_TEXT	SEGMENT
_Location$ = 80
??$destroy_at@_K@std@@YAXQEA_K@Z PROC			; std::destroy_at<unsigned __int64>, COMDAT

; 313  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 314  : #if _HAS_CXX20
; 315  :     if constexpr (is_array_v<_Ty>) {
; 316  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 317  :     } else
; 318  : #endif // _HAS_CXX20
; 319  :     {
; 320  :         _Location->~_Ty();
; 321  :     }
; 322  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$destroy_at@_K@std@@YAXQEA_K@Z ENDP			; std::destroy_at<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00061	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00064	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00068	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAXQEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAXQEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >, COMDAT

; 1126 : constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@Verify_ran:

; 1127 :     // special case range verification for pointers
; 1128 :     _STL_VERIFY(_First <= _Last, "transposed pointer range");

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Last$[rbp]
  00024	48 39 45 50	 cmp	 QWORD PTR _First$[rbp], rax
  00028	77 02		 ja	 SHORT $LN7@Verify_ran
  0002a	eb 6b		 jmp	 SHORT $LN9@Verify_ran
$LN7@Verify_ran:
  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0003f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00044	45 33 c9	 xor	 r9d, r9d
  00047	41 b8 68 04 00
	00		 mov	 r8d, 1128		; 00000468H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@
  00054	b9 02 00 00 00	 mov	 ecx, 2
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  0005f	83 f8 01	 cmp	 eax, 1
  00062	75 03		 jne	 SHORT $LN11@Verify_ran
  00064	cc		 int	 3
  00065	33 c0		 xor	 eax, eax
$LN11@Verify_ran:
  00067	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00070	41 b9 68 04 00
	00		 mov	 r9d, 1128		; 00000468H
  00076	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 95		 jne	 SHORT $LN7@Verify_ran
$LN9@Verify_ran:
  00097	33 c0		 xor	 eax, eax
  00099	85 c0		 test	 eax, eax
  0009b	75 83		 jne	 SHORT $LN4@Verify_ran

; 1129 : }

  0009d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000a1	5d		 pop	 rbp
  000a2	c3		 ret	 0
??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAXQEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00061	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00064	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00068	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXQEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXQEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >, COMDAT

; 1126 : constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@Verify_ran:

; 1127 :     // special case range verification for pointers
; 1128 :     _STL_VERIFY(_First <= _Last, "transposed pointer range");

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Last$[rbp]
  00024	48 39 45 50	 cmp	 QWORD PTR _First$[rbp], rax
  00028	77 02		 ja	 SHORT $LN7@Verify_ran
  0002a	eb 6b		 jmp	 SHORT $LN9@Verify_ran
$LN7@Verify_ran:
  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0003f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00044	45 33 c9	 xor	 r9d, r9d
  00047	41 b8 68 04 00
	00		 mov	 r8d, 1128		; 00000468H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@
  00054	b9 02 00 00 00	 mov	 ecx, 2
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  0005f	83 f8 01	 cmp	 eax, 1
  00062	75 03		 jne	 SHORT $LN11@Verify_ran
  00064	cc		 int	 3
  00065	33 c0		 xor	 eax, eax
$LN11@Verify_ran:
  00067	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00070	41 b9 68 04 00
	00		 mov	 r9d, 1128		; 00000468H
  00076	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 95		 jne	 SHORT $LN7@Verify_ran
$LN9@Verify_ran:
  00097	33 c0		 xor	 eax, eax
  00099	85 c0		 test	 eax, eax
  0009b	75 83		 jne	 SHORT $LN4@Verify_ran

; 1129 : }

  0009d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000a1	5d		 pop	 rbp
  000a2	c3		 ret	 0
??$_Verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXQEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CB_KUBucket@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
??$destroy@U?$pair@$$CB_KUBucket@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::destroy<std::pair<unsigned __int64 const ,Bucket> >, COMDAT

; 728  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 729  : #if _HAS_CXX20
; 730  :         _STD destroy_at(_Ptr);

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00024	e8 00 00 00 00	 call	 ??$destroy_at@U?$pair@$$CB_KUBucket@@@std@@@std@@YAXQEAU?$pair@$$CB_KUBucket@@@0@@Z ; std::destroy_at<std::pair<unsigned __int64 const ,Bucket> >

; 731  : #else // _HAS_CXX20
; 732  :         _Ptr->~_Uty();
; 733  : #endif // _HAS_CXX20
; 734  :     }

  00029	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
??$destroy@U?$pair@$$CB_KUBucket@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::destroy<std::pair<unsigned __int64 const ,Bucket> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<unsigned __int64 const ,Bucket> >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<unsigned __int64 const ,Bucket> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$construct@_KAEB_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_KAEB_K@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@_KAEB_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_KAEB_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::construct<unsigned __int64,unsigned __int64 const &>, COMDAT

; 719  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 720  : #if _HAS_CXX20
; 721  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00025	48 8b 55 60	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$construct_at@_KAEB_K$0A@@std@@YAPEA_KQEA_KAEB_K@Z ; std::construct_at<unsigned __int64,unsigned __int64 const &,0>

; 722  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 723  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 724  : #endif // ^^^ !_HAS_CXX20 ^^^
; 725  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$construct@_KAEB_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_KAEB_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::construct<unsigned __int64,unsigned __int64 const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$construct@_K_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K$$QEA_K@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@_K_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K$$QEA_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::construct<unsigned __int64,unsigned __int64>, COMDAT

; 719  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 720  : #if _HAS_CXX20
; 721  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00025	48 8b 55 60	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$construct_at@_K_K$0A@@std@@YAPEA_KQEA_K$$QEA_K@Z ; std::construct_at<unsigned __int64,unsigned __int64,0>

; 722  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 723  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 724  : #endif // ^^^ !_HAS_CXX20 ^^^
; 725  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$construct@_K_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K$$QEA_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::construct<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@deallocate

; 709  :             _Al.deallocate(_Ptr, _Count);

  00031	4c 8b 45 60	 mov	 r8, QWORD PTR _Count$[rbp]
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00039	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate

; 710  :         } else

  00042	eb 11		 jmp	 SHORT $LN3@deallocate
$LN2@deallocate:

; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00044	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>
$LN3@deallocate:

; 715  :         }
; 716  :     }

  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
tv69 = 64
this$ = 96
_Val1$ = 104
_Val2$ = 112
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool,0>, COMDAT

; 250  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  0002d	48 8b 55 68	 mov	 rdx, QWORD PTR _Val1$[rbp]
  00031	48 8b 4d 40	 mov	 rcx, QWORD PTR tv69[rbp]
  00035	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 8b 4d 70	 mov	 rcx, QWORD PTR _Val2$[rbp]
  00042	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00045	88 48 18	 mov	 BYTE PTR [rax+24], cl

; 251  :     }

  00048	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\unordered_map
;	COMDAT ??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z
_TEXT	SEGMENT
_Val$ = 80
??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>, COMDAT

; 54   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DA11C4D_unordered_map
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   :         return _Val.first;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 56   :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z
_TEXT	SEGMENT
tv132 = 64
tv130 = 72
this$ = 96
_Al_$ = 104
<_Vals_0>$ = 112
??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > ><std::pair<unsigned __int64,Bucket> >, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 55 68	 mov	 rdx, QWORD PTR _Al_$[rbp]
  00029	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002d	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
  00032	90		 npad	 1

; 584  :         this->_Allocate();

  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Allocate

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0003c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 83 c0 10	 add	 rax, 16
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,Bucket> >
  00050	48 89 45 40	 mov	 QWORD PTR tv132[rbp], rax
  00054	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005b	48 89 45 48	 mov	 QWORD PTR tv130[rbp], rax
  0005f	4c 8b 45 70	 mov	 r8, QWORD PTR <_Vals_0>$[rbp]
  00063	48 8b 55 40	 mov	 rdx, QWORD PTR tv132[rbp]
  00067	48 8b 4d 48	 mov	 rcx, QWORD PTR tv130[rbp]
  0006b	e8 00 00 00 00	 call	 ??$construct@U?$pair@$$CB_KUBucket@@@std@@U?$pair@_KUBucket@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::construct<std::pair<unsigned __int64 const ,Bucket>,std::pair<unsigned __int64,Bucket> >
  00070	90		 npad	 1

; 586  :     }

  00071	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00075	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00079	5d		 pop	 rbp
  0007a	c3		 ret	 0
??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > ><std::pair<unsigned __int64,Bucket> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
tv132 = 64
tv130 = 72
this$ = 96
_Al_$ = 104
<_Vals_0>$ = 112
?dtor$0@?0???$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > ><std::pair<unsigned __int64,Bucket> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > ><std::pair<unsigned __int64,Bucket> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv93 = 64
tv91 = 72
this$ = 96
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 589  :         if (this->_Ptr != pointer{}) {

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00024	74 30		 je	 SHORT $LN2@List_node_

; 590  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002e	48 83 c0 10	 add	 rax, 16
  00032	48 8b c8	 mov	 rcx, rax
  00035	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,Bucket> >
  0003a	48 89 45 40	 mov	 QWORD PTR tv93[rbp], rax
  0003e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	48 89 45 48	 mov	 QWORD PTR tv91[rbp], rax
  00049	48 8b 55 40	 mov	 rdx, QWORD PTR tv93[rbp]
  0004d	48 8b 4d 48	 mov	 rcx, QWORD PTR tv91[rbp]
  00051	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CB_KUBucket@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::destroy<std::pair<unsigned __int64 const ,Bucket> >
$LN2@List_node_:

; 591  :         }
; 592  :     }

  00056	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0005a	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
  0005f	90		 npad	 1
  00060	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 64
this$ = 96
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >, COMDAT

; 1159 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1160 :         if (_Ptr) {

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00024	74 23		 je	 SHORT $LN2@Alloc_cons

; 1161 :             _Al.deallocate(_Ptr, 1);

  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 45 40	 mov	 QWORD PTR tv72[rbp], rax
  00031	41 b8 01 00 00
	00		 mov	 r8d, 1
  00037	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0003f	48 8b 4d 40	 mov	 rcx, QWORD PTR tv72[rbp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::deallocate
  00048	90		 npad	 1
$LN2@Alloc_cons:

; 1162 :         }
; 1163 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 64
this$ = 96
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Allocate, COMDAT

; 1154 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1155 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1156 :         _Ptr = _Al.allocate(1);

  00027	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 89 45 40	 mov	 QWORD PTR tv73[rbp], rax
  00032	ba 01 00 00 00	 mov	 edx, 1
  00037	48 8b 4d 40	 mov	 rcx, QWORD PTR tv73[rbp]
  0003b	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::allocate
  00040	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00044	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1157 :     }

  00048	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
$T1 = 64
this$ = 96
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Release, COMDAT

; 1150 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1151 :         return _STD exchange(_Ptr, nullptr);

  0001b	48 c7 45 40 00
	00 00 00	 mov	 QWORD PTR $T1[rbp], 0
  00023	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 83 c0 08	 add	 rax, 8
  0002b	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 ??$exchange@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::nullptr_t>

; 1152 :     }

  00037	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003b	5d		 pop	 rbp
  0003c	c3		 ret	 0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Al_$ = 88
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >, COMDAT

; 1148 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@AEB_K_K@Z
_TEXT	SEGMENT
_Bucket$ = 0
_Where$ = 8
_End$ = 16
_Bucket_lo$ = 24
tv143 = 96
this$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
_Hashval$ = 152
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Find_last<unsigned __int64>, COMDAT

; 1566 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1567 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1568 :         const size_type _Bucket = _Hashval & _Mask;

  0002d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00038	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Hashval$[rbp]
  0003f	48 23 c8	 and	 rcx, rax
  00042	48 8b c1	 mov	 rax, rcx
  00045	48 89 45 00	 mov	 QWORD PTR _Bucket$[rbp], rax

; 1569 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

  00049	48 8b 45 00	 mov	 rax, QWORD PTR _Bucket$[rbp]
  0004d	48 d1 e0	 shl	 rax, 1
  00050	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00057	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0005b	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00060	48 89 45 08	 mov	 QWORD PTR _Where$[rbp], rax

; 1570 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

  00064	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	48 89 45 10	 mov	 QWORD PTR _End$[rbp], rax

; 1571 :         if (_Where == _End) {

  00073	48 8b 45 10	 mov	 rax, QWORD PTR _End$[rbp]
  00077	48 39 45 08	 cmp	 QWORD PTR _Where$[rbp], rax
  0007b	75 29		 jne	 SHORT $LN5@Find_last

; 1572 :             return {_End, _Nodeptr{}};

  0007d	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00084	48 8b 4d 10	 mov	 rcx, QWORD PTR _End$[rbp]
  00088	48 89 08	 mov	 QWORD PTR [rax], rcx
  0008b	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00092	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0009a	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000a1	e9 b9 00 00 00	 jmp	 $LN1@Find_last
$LN5@Find_last:

; 1573 :         }
; 1574 : 
; 1575 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

  000a6	48 8b 45 00	 mov	 rax, QWORD PTR _Bucket$[rbp]
  000aa	48 d1 e0	 shl	 rax, 1
  000ad	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b4	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000b8	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000bc	48 89 45 18	 mov	 QWORD PTR _Bucket_lo$[rbp], rax
$LN2@Find_last:

; 1576 :         for (;;) {
; 1577 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1578 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

  000c0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c7	48 89 45 60	 mov	 QWORD PTR tv143[rbp], rax
  000cb	48 8b 45 08	 mov	 rax, QWORD PTR _Where$[rbp]
  000cf	48 83 c0 10	 add	 rax, 16
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 ??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>
  000db	4c 8b c0	 mov	 r8, rax
  000de	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR _Keyval$[rbp]
  000e5	48 8b 4d 60	 mov	 rcx, QWORD PTR tv143[rbp]
  000e9	e8 00 00 00 00	 call	 ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
  000ee	0f b6 c0	 movzx	 eax, al
  000f1	85 c0		 test	 eax, eax
  000f3	75 29		 jne	 SHORT $LN6@Find_last

; 1579 :                 if constexpr (!_Traits::_Standard) {
; 1580 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1581 :                         return {_Where->_Next, _Nodeptr{}};
; 1582 :                     }
; 1583 :                 }
; 1584 : 
; 1585 :                 return {_Where->_Next, _Where};

  000f5	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000fc	48 8b 4d 08	 mov	 rcx, QWORD PTR _Where$[rbp]
  00100	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00103	48 89 08	 mov	 QWORD PTR [rax], rcx
  00106	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0010d	48 8b 4d 08	 mov	 rcx, QWORD PTR _Where$[rbp]
  00111	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00115	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0011c	eb 41		 jmp	 SHORT $LN1@Find_last
$LN6@Find_last:

; 1586 :             }
; 1587 : 
; 1588 :             if (_Where == _Bucket_lo) {

  0011e	48 8b 45 18	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00122	48 39 45 08	 cmp	 QWORD PTR _Where$[rbp], rax
  00126	75 26		 jne	 SHORT $LN7@Find_last

; 1589 :                 return {_Where, _Nodeptr{}};

  00128	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0012f	48 8b 4d 08	 mov	 rcx, QWORD PTR _Where$[rbp]
  00133	48 89 08	 mov	 QWORD PTR [rax], rcx
  00136	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0013d	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00145	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0014c	eb 11		 jmp	 SHORT $LN1@Find_last
$LN7@Find_last:

; 1590 :             }
; 1591 : 
; 1592 :             _Where = _Where->_Prev;

  0014e	48 8b 45 08	 mov	 rax, QWORD PTR _Where$[rbp]
  00152	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00156	48 89 45 08	 mov	 QWORD PTR _Where$[rbp], rax

; 1593 :         }

  0015a	e9 61 ff ff ff	 jmp	 $LN2@Find_last
$LN1@Find_last:

; 1594 :     }

  0015f	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00163	5d		 pop	 rbp
  00164	c3		 ret	 0
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Find_last<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map@_KU?$pair@_KUBucket@@@std@@@std@@SAAEB_KAEBU?$pair@_KUBucket@@@2@@Z
_TEXT	SEGMENT
_Val$ = 80
?_Extract@?$_In_place_key_extract_map@_KU?$pair@_KUBucket@@@std@@@std@@SAAEB_KAEBU?$pair@_KUBucket@@@2@@Z PROC ; std::_In_place_key_extract_map<unsigned __int64,std::pair<unsigned __int64,Bucket> >::_Extract, COMDAT

; 2111 :     static const _Key& _Extract(const pair<_First, _Second>& _Val) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2112 :         return _Val.first;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 2113 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Extract@?$_In_place_key_extract_map@_KU?$pair@_KUBucket@@@std@@@std@@SAAEB_KAEBU?$pair@_KUBucket@@@2@@Z ENDP ; std::_In_place_key_extract_map<unsigned __int64,std::pair<unsigned __int64,Bucket> >::_Extract
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@$$QEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
_It$ = 80
_UIt$ = 88
??$_Seek_wrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@$$QEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Seek_wrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >, COMDAT

; 1271 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1272 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1273 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _UIt$[rbp]
  00024	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR _It$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_Seek_to

; 1274 :     } else {
; 1275 :         _It = _STD forward<_UIter>(_UIt);
; 1276 :     }
; 1277 : }

  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??$_Seek_wrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@$$QEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Seek_wrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Min_element_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@U?$less@X@2@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@V10@0U?$less@X@0@@Z
_TEXT	SEGMENT
tv89 = 72
tv75 = 72
tv87 = 80
__$ReturnUdt$ = 112
_First$ = 120
_Last$ = 128
_Pred$ = 136
??$_Min_element_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@U?$less@X@2@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@V10@0U?$less@X@0@@Z PROC ; std::_Min_element_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::less<void> >, COMDAT

; 6825 : constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find smallest element

$LN7:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6826 : #if _USE_STD_VECTOR_ALGORITHMS
; 6827 :     if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
; 6828 :         if (!_Is_constant_evaluated()) {
; 6829 :             const auto _First_ptr = _To_address(_First);
; 6830 :             const auto _Result    = __std_min_element(_First_ptr, _To_address(_Last));
; 6831 :             if constexpr (is_pointer_v<_FwdIt>) {
; 6832 :                 return _Result;
; 6833 :             } else {
; 6834 :                 return _First + (_Result - _First_ptr);
; 6835 :             }
; 6836 :         }
; 6837 :     }
; 6838 : #endif // _USE_STD_VECTOR_ALGORITHMS
; 6839 : 
; 6840 :     _FwdIt _Found = _First;

  0002d	48 8b 45 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00031	48 8b 4d 78	 mov	 rcx, QWORD PTR _First$[rbp]
  00035	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6841 :     if (_First != _Last) {

  00038	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR _Last$[rbp]
  0003f	48 8d 4d 78	 lea	 rcx, QWORD PTR _First$[rbp]
  00043	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator==
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	75 66		 jne	 SHORT $LN4@Min_elemen
$LN2@Min_elemen:

; 6842 :         while (++_First != _Last) {

  0004f	48 8d 4d 78	 lea	 rcx, QWORD PTR _First$[rbp]
  00053	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator++
  00058	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  0005c	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR _Last$[rbp]
  00063	48 8b 4d 48	 mov	 rcx, QWORD PTR tv75[rbp]
  00067	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator==
  0006c	0f b6 c0	 movzx	 eax, al
  0006f	85 c0		 test	 eax, eax
  00071	75 42		 jne	 SHORT $LN3@Min_elemen

; 6843 :             if (_DEBUG_LT_PRED(_Pred, *_First, *_Found)) {

  00073	48 8b 4d 70	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00077	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator*
  0007c	48 89 45 48	 mov	 QWORD PTR tv89[rbp], rax
  00080	48 8d 4d 78	 lea	 rcx, QWORD PTR _First$[rbp]
  00084	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator*
  00089	48 89 45 50	 mov	 QWORD PTR tv87[rbp], rax
  0008d	4c 8b 45 48	 mov	 r8, QWORD PTR tv89[rbp]
  00091	48 8b 55 50	 mov	 rdx, QWORD PTR tv87[rbp]
  00095	48 8d 8d 88 00
	00 00		 lea	 rcx, QWORD PTR _Pred$[rbp]
  0009c	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@AEAU?$less@X@std@@AEB_KAEB_K$0A@@std@@YA_NAEAU?$less@X@0@AEB_K1@Z ; std::_Debug_lt_pred<std::less<void> &,unsigned __int64 const &,unsigned __int64 const &,0>
  000a1	0f b6 c0	 movzx	 eax, al
  000a4	85 c0		 test	 eax, eax
  000a6	74 0b		 je	 SHORT $LN5@Min_elemen

; 6844 :                 _Found = _First;

  000a8	48 8b 45 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000ac	48 8b 4d 78	 mov	 rcx, QWORD PTR _First$[rbp]
  000b0	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Min_elemen:

; 6845 :             }
; 6846 :         }

  000b3	eb 9a		 jmp	 SHORT $LN2@Min_elemen
$LN3@Min_elemen:
$LN4@Min_elemen:

; 6847 :     }
; 6848 : 
; 6849 :     return _Found;

  000b5	48 8b 45 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 6850 : }

  000b9	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000bd	5d		 pop	 rbp
  000be	c3		 ret	 0
??$_Min_element_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@U?$less@X@2@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@V10@0U?$less@X@0@@Z ENDP ; std::_Min_element_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Pass_fn@U?$less@X@std@@@std@@YA?A_PAEAU?$less@X@0@@Z
_TEXT	SEGMENT
_Pass_by_value$ = 0
_Func$ = 96
??$_Pass_fn@U?$less@X@std@@@std@@YA?A_PAEAU?$less@X@0@@Z PROC ; std::_Pass_fn<std::less<void> >, COMDAT

; 556  : _NODISCARD constexpr auto _Pass_fn(_Fn& _Func) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 557  :     constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,

  0001b	c6 45 00 01	 mov	 BYTE PTR _Pass_by_value$[rbp], 1

; 558  :         is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
; 559  :     if constexpr (_Pass_by_value) {
; 560  :         return _Func;

  0001f	48 8b 45 60	 mov	 rax, QWORD PTR _Func$[rbp]
  00023	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 561  :     } else {
; 562  :         return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
; 563  :     }
; 564  : }

  00026	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??$_Pass_fn@U?$less@X@std@@@std@@YA?A_PAEAU?$less@X@0@@Z ENDP ; std::_Pass_fn<std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?A_TAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 80
_It$ = 88
??$_Get_unwrapped@AEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?A_TAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > &>, COMDAT

; 1171 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1172 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1173 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1174 :         return _It + 0;
; 1175 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1176 :         return static_cast<_Iter&&>(_It)._Unwrapped();

  00020	48 8b 55 50	 mov	 rdx, QWORD PTR __$ReturnUdt$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _It$[rbp]
  00028	e8 00 00 00 00	 call	 ?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_Unwrapped
  0002d	48 8b 45 50	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1177 :     } else {
; 1178 :         return static_cast<_Iter&&>(_It);
; 1179 :     }
; 1180 : }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
??$_Get_unwrapped@AEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?A_TAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V12@@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Adl_verify_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V12@@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >, COMDAT

; 1148 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1149 :     // check that [_First, _Last) forms an iterator range
; 1150 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1151 :         _Verify_range(_First, _Last);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Last$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR _First$[rbp]
  00028	e8 00 00 00 00	 call	 ?_Verify_range@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@0@Z ; std::_Verify_range

; 1152 :     }
; 1153 : }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
??$_Adl_verify_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V12@@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 64
this$ = 96
??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 997  :         ~_Range_eraser() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 998  :             _List._Unchecked_erase(_First, _Next);

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 89 45 40	 mov	 QWORD PTR tv72[rbp], rax
  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  0002e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00036	48 8b 4d 40	 mov	 rcx, QWORD PTR tv72[rbp]
  0003a	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_erase

; 999  :         }

  0003f	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00043	5d		 pop	 rbp
  00044	c3		 ret	 0
??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::_Bump_erased, COMDAT

; 993  :         void _Bump_erased() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 994  :             _Next = _Next->_Next;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00023	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 995  :         }

  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@AEAV?$list@_KV?$allocator@_K@std@@@2@QEAU?$_List_node@_KPEAX@2@@Z
_TEXT	SEGMENT
this$ = 80
_List_$ = 88
_First_$ = 96
??0_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@AEAV?$list@_KV?$allocator@_K@std@@@2@QEAU?$_List_node@_KPEAX@2@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::_Range_eraser, COMDAT

; 991  :             : _List(_List_), _First(_First_), _Next(_First_) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _List_$[rbp]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 4d 60	 mov	 rcx, QWORD PTR _First_$[rbp]
  00038	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 4d 60	 mov	 rcx, QWORD PTR _First_$[rbp]
  00044	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??0_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@AEAV?$list@_KV?$allocator@_K@std@@@2@QEAU?$_List_node@_KPEAX@2@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
$T1 = 64
tv65 = 72
_Left$ = 96
_Right$ = 104
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 98   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 99   :     // return smaller of _Left and _Right
; 100  :     return _Right < _Left ? _Right : _Left;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00024	48 8b 4d 60	 mov	 rcx, QWORD PTR _Left$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	73 0a		 jae	 SHORT $LN3@min
  00030	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00034	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
  00038	eb 08		 jmp	 SHORT $LN4@min
$LN3@min:
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR _Left$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
$LN4@min:
  00042	48 8b 45 48	 mov	 rax, QWORD PTR tv65[rbp]
  00046	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0004a	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 101  : }

  0004e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 483  :         ~_Clear_guard() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 484  :             if (_Target) {

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 0c		 je	 SHORT $LN2@Clear_guar

; 485  :                 _Target->clear();

  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002c	e8 00 00 00 00	 call	 ?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::clear
$LN2@Clear_guar:

; 486  :             }
; 487  :         }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
??1_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 80
_Target_$ = 88
??0_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Clear_guard::_Clear_guard, COMDAT

; 478  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Target_$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??0_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<unsigned __int64> > const >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<unsigned __int64> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<unsigned __int64,void *> *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * const &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<unsigned __int64,void *> *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@_KPEAX@std@@$$T@std@@YAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU?$_List_node@_KPEAX@std@@$$T@std@@YAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<unsigned __int64,void *> *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU?$_List_node@_KPEAX@std@@$$T@std@@YAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<unsigned __int64,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy@_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
??$destroy@_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::destroy<unsigned __int64>, COMDAT

; 728  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 729  : #if _HAS_CXX20
; 730  :         _STD destroy_at(_Ptr);

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00024	e8 00 00 00 00	 call	 ??$destroy_at@_K@std@@YAXQEA_K@Z ; std::destroy_at<unsigned __int64>

; 731  : #else // _HAS_CXX20
; 732  :         _Ptr->~_Uty();
; 733  : #endif // _HAS_CXX20
; 734  :     }

  00029	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
??$destroy@_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::destroy<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@_K@std@@YAPEA_KAEA_K@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@_K@std@@YAPEA_KAEA_K@Z PROC		; std::addressof<unsigned __int64>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@_K@std@@YAPEA_KAEA_K@Z ENDP		; std::addressof<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEAPEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEAPEAU10@@Z PROC ; std::construct_at<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEAPEAU10@@Z ENDP ; std::construct_at<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<unsigned __int64,void *> *>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<unsigned __int64,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Block_size$ = 0
_Ptr_container$ = 8
_Ptr$ = 16
_Bytes$ = 112
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 136  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 137  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 138  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR _Bytes$[rbp]
  00022	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  00026	48 89 45 00	 mov	 QWORD PTR _Block_size$[rbp], rax

; 139  :     if (_Block_size <= _Bytes) {

  0002a	48 8b 45 70	 mov	 rax, QWORD PTR _Bytes$[rbp]
  0002e	48 39 45 00	 cmp	 QWORD PTR _Block_size$[rbp], rax
  00032	77 05		 ja	 SHORT $LN8@Allocate_m

; 140  :         _Throw_bad_array_new_length(); // add overflow

  00034	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 141  :     }
; 142  : 
; 143  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00039	48 8b 4d 00	 mov	 rcx, QWORD PTR _Block_size$[rbp]
  0003d	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  00042	48 89 45 08	 mov	 QWORD PTR _Ptr_container$[rbp], rax
$LN4@Allocate_m:

; 144  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00046	48 83 7d 08 00	 cmp	 QWORD PTR _Ptr_container$[rbp], 0
  0004b	74 02		 je	 SHORT $LN9@Allocate_m
  0004d	eb 6b		 jmp	 SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  00056	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00062	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00067	45 33 c9	 xor	 r9d, r9d
  0006a	41 b8 90 00 00
	00		 mov	 r8d, 144		; 00000090H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  00077	b9 02 00 00 00	 mov	 ecx, 2
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00082	83 f8 01	 cmp	 eax, 1
  00085	75 03		 jne	 SHORT $LN12@Allocate_m
  00087	cc		 int	 3
  00088	33 c0		 xor	 eax, eax
$LN12@Allocate_m:
  0008a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00093	41 b9 90 00 00
	00		 mov	 r9d, 144		; 00000090H
  00099	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	75 95		 jne	 SHORT $LN7@Allocate_m
$LN10@Allocate_m:
  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	75 86		 jne	 SHORT $LN4@Allocate_m

; 145  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000c0	48 8b 45 08	 mov	 rax, QWORD PTR _Ptr_container$[rbp]
  000c4	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  000c8	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H
  000cc	48 89 45 10	 mov	 QWORD PTR _Ptr$[rbp], rax

; 146  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000d0	b8 08 00 00 00	 mov	 eax, 8
  000d5	48 6b c0 ff	 imul	 rax, rax, -1
  000d9	48 8b 4d 10	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000dd	48 8b 55 08	 mov	 rdx, QWORD PTR _Ptr_container$[rbp]
  000e1	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 147  : 
; 148  : #ifdef _DEBUG
; 149  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000e5	b8 08 00 00 00	 mov	 eax, 8
  000ea	48 6b c0 fe	 imul	 rax, rax, -2
  000ee	48 8b 4d 10	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000f2	48 ba fa fa fa
	fa fa fa fa fa	 mov	 rdx, -361700864190383366 ; fafafafafafafafaH
  000fc	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 150  : #endif // _DEBUG
; 151  :     return _Ptr;

  00100	48 8b 45 10	 mov	 rax, QWORD PTR _Ptr$[rbp]
$LN11@Allocate_m:

; 152  : }

  00104	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00108	5d		 pop	 rbp
  00109	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &>, COMDAT

; 1618 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1619 :         // construct a new element at *_Last and increment
; 1620 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR <_Vals_0>$[rbp]
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002c	e8 00 00 00 00	 call	 ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &>

; 1621 :         ++_Last;

  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00039	48 83 c0 08	 add	 rax, 8
  0003d	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00041	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1622 :     }

  00045	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Release, COMDAT

; 1624 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1625 :         _First = _Last;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00027	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1626 :         return _Last;

  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1627 :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>, COMDAT

; 1613 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :         _Destroy_range(_First, _Last);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00023	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002a	e8 00 00 00 00	 call	 ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>

; 1615 :     }

  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Dest$ = 88
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>, COMDAT

; 1606 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Dest$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8b 4d 58	 mov	 rcx, QWORD PTR _Dest$[rbp]
  00033	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>, COMDAT

; 1148 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1149 :     // check that [_First, _Last) forms an iterator range
; 1150 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1151 :         _Verify_range(_First, _Last);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Last$[rbp]
  00024	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00027	48 8b 45 50	 mov	 rax, QWORD PTR _First$[rbp]
  0002b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002e	e8 00 00 00 00	 call	 ??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YAXQEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z ; std::_Verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >

; 1152 :     }
; 1153 : }

  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 80
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > * const &>, COMDAT

; 1171 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1172 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1173 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1174 :         return _It + 0;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _It$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1175 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1176 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1177 :     } else {
; 1178 :         return static_cast<_Iter&&>(_It);
; 1179 :     }
; 1180 : }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@AEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &>, COMDAT

; 1618 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1619 :         // construct a new element at *_Last and increment
; 1620 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR <_Vals_0>$[rbp]
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002c	e8 00 00 00 00	 call	 ??$_Construct_in_place@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &>

; 1621 :         ++_Last;

  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00039	48 83 c0 08	 add	 rax, 8
  0003d	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00041	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1622 :     }

  00045	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
??$_Emplace_back@AEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Release, COMDAT

; 1624 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1625 :         _First = _Last;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00027	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1626 :         return _Last;

  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1627 :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::~_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>, COMDAT

; 1613 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :         _Destroy_range(_First, _Last);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00023	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002a	e8 00 00 00 00	 call	 ??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>

; 1615 :     }

  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::~_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Dest$ = 88
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>, COMDAT

; 1606 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Dest$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8b 4d 58	 mov	 rcx, QWORD PTR _Dest$[rbp]
  00033	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Adl_verify_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>, COMDAT

; 1148 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1149 :     // check that [_First, _Last) forms an iterator range
; 1150 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1151 :         _Verify_range(_First, _Last);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Last$[rbp]
  00024	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00027	48 8b 45 50	 mov	 rax, QWORD PTR _First$[rbp]
  0002b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002e	e8 00 00 00 00	 call	 ??$_Verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXQEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >

; 1152 :     }
; 1153 : }

  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??$_Adl_verify_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
_It$ = 80
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> * const &>, COMDAT

; 1171 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1172 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1173 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1174 :         return _It + 0;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _It$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1175 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1176 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1177 :     } else {
; 1178 :         return static_cast<_Iter&&>(_It);
; 1179 :     }
; 1180 : }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 80
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>, COMDAT

; 303  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 304  :     if constexpr (is_array_v<_Ty>) {
; 305  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 306  :     } else {
; 307  :         _Obj.~_Ty();
; 308  :     }
; 309  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00024	48 83 c0 10	 add	 rax, 16
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CB_KUBucket@@@std@@@std@@YAPEAU?$pair@$$CB_KUBucket@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,Bucket> >
  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00037	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CB_KUBucket@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::destroy<std::pair<unsigned __int64 const ,Bucket> >

; 318  :         _Freenode0(_Al, _Ptr);

  0003c	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00040	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00044	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
  00049	90		 npad	 1

; 319  :     }

  0004a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > ><std::pair<unsigned __int64 const ,Bucket> >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > ><std::pair<unsigned __int64 const ,Bucket> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
_Val1$ = 96
??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &>, COMDAT

; 1524 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 55 60	 mov	 rdx, QWORD PTR _Val1$[rbp]
  00028	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002c	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > ><std::pair<unsigned __int64 const ,Bucket> >
  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >
  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@_KPEAX@std@@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 80
??$_Destroy_in_place@PEAU?$_List_node@_KPEAX@std@@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<unsigned __int64,void *> *>, COMDAT

; 303  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 304  :     if constexpr (is_array_v<_Ty>) {
; 305  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 306  :     } else {
; 307  :         _Obj.~_Ty();
; 308  :     }
; 309  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$_Destroy_in_place@PEAU?$_List_node@_KPEAX@std@@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<unsigned __int64,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<unsigned __int64,void *>::_Freenode<std::allocator<std::_List_node<unsigned __int64,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00024	48 83 c0 10	 add	 rax, 16
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??$addressof@_K@std@@YAPEA_KAEA_K@Z ; std::addressof<unsigned __int64>
  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00037	e8 00 00 00 00	 call	 ??$destroy@_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::destroy<unsigned __int64>

; 318  :         _Freenode0(_Al, _Ptr);

  0003c	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00040	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00044	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Freenode0<std::allocator<std::_List_node<unsigned __int64,void *> > >
  00049	90		 npad	 1

; 319  :     }

  0004a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<unsigned __int64,void *>::_Freenode<std::allocator<std::_List_node<unsigned __int64,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
_New_proxy$ = 0
$T1 = 72
this$ = 96
_Al$ = 104
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT

; 1207 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1208 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  00020	ba 01 00 00 00	 mov	 edx, 1
  00025	48 8b 4d 68	 mov	 rcx, QWORD PTR _Al$[rbp]
  00029	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00036	48 89 45 00	 mov	 QWORD PTR _New_proxy$[rbp], rax

; 1209 :         _Construct_in_place(*_New_proxy, this);

  0003a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00042	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  00046	48 8b 4d 00	 mov	 rcx, QWORD PTR _New_proxy$[rbp]
  0004a	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>

; 1210 :         _Myproxy            = _New_proxy;

  0004f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00053	48 8b 4d 00	 mov	 rcx, QWORD PTR _New_proxy$[rbp]
  00057	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1211 :         _New_proxy->_Mycont = this;

  0005a	48 8b 45 00	 mov	 rax, QWORD PTR _New_proxy$[rbp]
  0005e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00062	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1212 :     }

  00065	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0_K@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0_K@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> ><unsigned __int64>, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0_K@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> ><unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
_Val1$ = 96
??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1><std::allocator<unsigned __int64> const &>, COMDAT

; 1524 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 55 60	 mov	 rdx, QWORD PTR _Val1$[rbp]
  00028	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002c	e8 00 00 00 00	 call	 ??$?0_K@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> ><unsigned __int64>
  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >
  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1><std::allocator<unsigned __int64> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z
_TEXT	SEGMENT
tv132 = 64
tv130 = 72
this$ = 96
_Al_$ = 104
<_Vals_0>$ = 112
??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64 const &>, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 55 68	 mov	 rdx, QWORD PTR _Al_$[rbp]
  00029	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002d	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >
  00032	90		 npad	 1

; 584  :         this->_Allocate();

  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Allocate

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0003c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 83 c0 10	 add	 rax, 16
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 ??$addressof@_K@std@@YAPEA_KAEA_K@Z ; std::addressof<unsigned __int64>
  00050	48 89 45 40	 mov	 QWORD PTR tv132[rbp], rax
  00054	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005b	48 89 45 48	 mov	 QWORD PTR tv130[rbp], rax
  0005f	4c 8b 45 70	 mov	 r8, QWORD PTR <_Vals_0>$[rbp]
  00063	48 8b 55 40	 mov	 rdx, QWORD PTR tv132[rbp]
  00067	48 8b 4d 48	 mov	 rcx, QWORD PTR tv130[rbp]
  0006b	e8 00 00 00 00	 call	 ??$construct@_KAEB_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_KAEB_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::construct<unsigned __int64,unsigned __int64 const &>
  00070	90		 npad	 1

; 586  :     }

  00071	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00075	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00079	5d		 pop	 rbp
  0007a	c3		 ret	 0
??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64 const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
tv132 = 64
tv130 = 72
this$ = 96
_Al_$ = 104
<_Vals_0>$ = 112
?dtor$0@?0???$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64 const &>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64 const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
tv73 = 64
this$ = 96
_Val1$ = 104
_Val2$ = 112
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool,0>, COMDAT

; 250  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 89 45 40	 mov	 QWORD PTR tv73[rbp], rax
  0002d	48 8b 55 68	 mov	 rdx, QWORD PTR _Val1$[rbp]
  00031	48 8b 4d 40	 mov	 rcx, QWORD PTR tv73[rbp]
  00035	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 8b 4d 70	 mov	 rcx, QWORD PTR _Val2$[rbp]
  00042	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00045	88 48 18	 mov	 BYTE PTR [rax+24], cl

; 251  :     }

  00048	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z
_TEXT	SEGMENT
tv132 = 64
tv130 = 72
this$ = 96
_Al_$ = 104
<_Vals_0>$ = 112
??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64>, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 55 68	 mov	 rdx, QWORD PTR _Al_$[rbp]
  00029	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002d	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >
  00032	90		 npad	 1

; 584  :         this->_Allocate();

  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Allocate

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0003c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 83 c0 10	 add	 rax, 16
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 ??$addressof@_K@std@@YAPEA_KAEA_K@Z ; std::addressof<unsigned __int64>
  00050	48 89 45 40	 mov	 QWORD PTR tv132[rbp], rax
  00054	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005b	48 89 45 48	 mov	 QWORD PTR tv130[rbp], rax
  0005f	4c 8b 45 70	 mov	 r8, QWORD PTR <_Vals_0>$[rbp]
  00063	48 8b 55 40	 mov	 rdx, QWORD PTR tv132[rbp]
  00067	48 8b 4d 48	 mov	 rcx, QWORD PTR tv130[rbp]
  0006b	e8 00 00 00 00	 call	 ??$construct@_K_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K$$QEA_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::construct<unsigned __int64,unsigned __int64>
  00070	90		 npad	 1

; 586  :     }

  00071	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00075	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00079	5d		 pop	 rbp
  0007a	c3		 ret	 0
??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
tv132 = 64
tv130 = 72
this$ = 96
_Al_$ = 104
<_Vals_0>$ = 112
?dtor$0@?0???$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv93 = 64
tv91 = 72
this$ = 96
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 589  :         if (this->_Ptr != pointer{}) {

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00024	74 30		 je	 SHORT $LN2@List_node_

; 590  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002e	48 83 c0 10	 add	 rax, 16
  00032	48 8b c8	 mov	 rcx, rax
  00035	e8 00 00 00 00	 call	 ??$addressof@_K@std@@YAPEA_KAEA_K@Z ; std::addressof<unsigned __int64>
  0003a	48 89 45 40	 mov	 QWORD PTR tv93[rbp], rax
  0003e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	48 89 45 48	 mov	 QWORD PTR tv91[rbp], rax
  00049	48 8b 55 40	 mov	 rdx, QWORD PTR tv93[rbp]
  0004d	48 8b 4d 48	 mov	 rcx, QWORD PTR tv91[rbp]
  00051	e8 00 00 00 00	 call	 ??$destroy@_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@QEA_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::destroy<unsigned __int64>
$LN2@List_node_:

; 591  :         }
; 592  :     }

  00056	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0005a	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >
  0005f	90		 npad	 1
  00060	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 64
this$ = 96
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >, COMDAT

; 1159 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1160 :         if (_Ptr) {

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00024	74 23		 je	 SHORT $LN2@Alloc_cons

; 1161 :             _Al.deallocate(_Ptr, 1);

  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 45 40	 mov	 QWORD PTR tv72[rbp], rax
  00031	41 b8 01 00 00
	00		 mov	 r8d, 1
  00037	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0003f	48 8b 4d 40	 mov	 rcx, QWORD PTR tv72[rbp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAXQEAU?$_List_node@_KPEAX@2@_K@Z ; std::allocator<std::_List_node<unsigned __int64,void *> >::deallocate
  00048	90		 npad	 1
$LN2@Alloc_cons:

; 1162 :         }
; 1163 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 64
this$ = 96
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Allocate, COMDAT

; 1154 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1155 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1156 :         _Ptr = _Al.allocate(1);

  00027	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 89 45 40	 mov	 QWORD PTR tv73[rbp], rax
  00032	ba 01 00 00 00	 mov	 edx, 1
  00037	48 8b 4d 40	 mov	 rcx, QWORD PTR tv73[rbp]
  0003b	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@_K@Z ; std::allocator<std::_List_node<unsigned __int64,void *> >::allocate
  00040	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00044	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1157 :     }

  00048	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@XZ
_TEXT	SEGMENT
$T1 = 64
this$ = 96
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Release, COMDAT

; 1150 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1151 :         return _STD exchange(_Ptr, nullptr);

  0001b	48 c7 45 40 00
	00 00 00	 mov	 QWORD PTR $T1[rbp], 0
  00023	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 83 c0 08	 add	 rax, 8
  0002b	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 ??$exchange@PEAU?$_List_node@_KPEAX@std@@$$T@std@@YAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<unsigned __int64,void *> *,std::nullptr_t>

; 1152 :     }

  00037	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003b	5d		 pop	 rbp
  0003c	c3		 ret	 0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Al_$ = 88
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >, COMDAT

; 1148 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_set@_K_K@std@@SAAEB_KAEB_K@Z
_TEXT	SEGMENT
_Val$ = 80
?_Extract@?$_In_place_key_extract_set@_K_K@std@@SAAEB_KAEB_K@Z PROC ; std::_In_place_key_extract_set<unsigned __int64,unsigned __int64>::_Extract, COMDAT

; 2086 :     static const _Key& _Extract(const _Key& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2087 :         return _Val;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 2088 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Extract@?$_In_place_key_extract_set@_K_K@std@@SAAEB_KAEB_K@Z ENDP ; std::_In_place_key_extract_set<unsigned __int64,unsigned __int64>::_Extract
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1123 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1124 :     // deallocate a plain pointer using an allocator
; 1125 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1126 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1127 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00020	41 b8 01 00 00
	00		 mov	 r8d, 1
  00026	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  00033	90		 npad	 1

; 1128 :     } else {
; 1129 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1130 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1131 :     }
; 1132 : }

  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z
_TEXT	SEGMENT
_Keyval$1 = 0
_Hashval$2 = 8
_Target$3 = 16
_Newnode$4 = 32
$T5 = 112
$T6 = 120
$T7 = 144
$T8 = 160
$T9 = 168
$T10 = 192
tv177 = 200
tv90 = 200
tv75 = 200
tv193 = 208
tv186 = 208
tv182 = 216
tv95 = 216
this$ = 256
__$ReturnUdt$ = 264
<_Vals_0>$ = 272
??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::emplace<std::pair<unsigned __int64,Bucket> >, COMDAT

; 590  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR $T10[rbp], 0
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 591  :         // try to insert value_type(_Vals...)
; 592  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 593  :         if constexpr (_Multi) {
; 594  :             _Check_max_size();
; 595  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 596  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 597  :             const auto _Hashval = _Traitsobj(_Keyval);
; 598  :             if (_Check_rehash_required_1()) {
; 599  :                 _Rehash_for_1();
; 600  :             }
; 601  : 
; 602  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 603  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 604  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 605  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

  00034	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR <_Vals_0>$[rbp]
  0003b	e8 00 00 00 00	 call	 ?_Extract@?$_In_place_key_extract_map@_KU?$pair@_KUBucket@@@std@@@std@@SAAEB_KAEBU?$pair@_KUBucket@@@2@@Z ; std::_In_place_key_extract_map<unsigned __int64,std::pair<unsigned __int64,Bucket> >::_Extract
  00040	48 89 45 00	 mov	 QWORD PTR _Keyval$1[rbp], rax

; 606  :             const auto _Hashval = _Traitsobj(_Keyval);

  00044	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv75[rbp], rax
  00052	48 8b 55 00	 mov	 rdx, QWORD PTR _Keyval$1[rbp]
  00056	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR tv75[rbp]
  0005d	e8 00 00 00 00	 call	 ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
  00062	48 89 45 08	 mov	 QWORD PTR _Hashval$2[rbp], rax

; 607  :             auto _Target        = _Find_last(_Keyval, _Hashval);

  00066	4c 8b 4d 08	 mov	 r9, QWORD PTR _Hashval$2[rbp]
  0006a	4c 8b 45 00	 mov	 r8, QWORD PTR _Keyval$1[rbp]
  0006e	48 8d 55 10	 lea	 rdx, QWORD PTR _Target$3[rbp]
  00072	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00079	e8 00 00 00 00	 call	 ??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Find_last<unsigned __int64>

; 608  :             if (_Target._Duplicate) {

  0007e	48 83 7d 18 00	 cmp	 QWORD PTR _Target$3[rbp+8], 0
  00083	74 7a		 je	 SHORT $LN2@emplace

; 609  :                 return {_List._Make_iter(_Target._Duplicate), false};

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 83 c0 08	 add	 rax, 8
  00090	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv90[rbp], rax
  00097	4c 8b 45 18	 mov	 r8, QWORD PTR _Target$3[rbp+8]
  0009b	48 8d 55 78	 lea	 rdx, QWORD PTR $T6[rbp]
  0009f	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR tv90[rbp]
  000a6	e8 00 00 00 00	 call	 ?_Make_iter@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Make_iter
  000ab	48 89 85 d0 00
	00 00		 mov	 QWORD PTR tv186[rbp], rax
  000b2	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR tv186[rbp]
  000b9	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv95[rbp], rax
  000c0	c6 45 70 00	 mov	 BYTE PTR $T5[rbp], 0
  000c4	4c 8d 45 70	 lea	 r8, QWORD PTR $T5[rbp]
  000c8	48 8b 95 d8 00
	00 00		 mov	 rdx, QWORD PTR tv95[rbp]
  000cf	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000d6	e8 00 00 00 00	 call	 ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool,0>
  000db	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR $T10[rbp]
  000e1	83 c8 01	 or	 eax, 1
  000e4	89 85 c0 00 00
	00		 mov	 DWORD PTR $T10[rbp], eax
  000ea	48 8d 4d 78	 lea	 rcx, QWORD PTR $T6[rbp]
  000ee	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ
  000f3	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000fa	e9 37 01 00 00	 jmp	 $LN1@emplace
$LN2@emplace:

; 610  :             }
; 611  : 
; 612  :             _Check_max_size();

  000ff	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00106	e8 00 00 00 00	 call	 ?_Check_max_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Check_max_size

; 613  :             // invalidates _Keyval:
; 614  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

  0010b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00112	48 83 c0 08	 add	 rax, 8
  00116	48 8b c8	 mov	 rcx, rax
  00119	e8 00 00 00 00	 call	 ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
  0011e	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR <_Vals_0>$[rbp]
  00125	48 8b d0	 mov	 rdx, rax
  00128	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  0012c	e8 00 00 00 00	 call	 ??$?0U?$pair@_KUBucket@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > ><std::pair<unsigned __int64,Bucket> >
  00131	90		 npad	 1

; 615  :             if (_Check_rehash_required_1()) {

  00132	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00139	e8 00 00 00 00	 call	 ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Check_rehash_required_1
  0013e	0f b6 c0	 movzx	 eax, al
  00141	85 c0		 test	 eax, eax
  00143	74 47		 je	 SHORT $LN3@emplace

; 616  :                 _Rehash_for_1();

  00145	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0014c	e8 00 00 00 00	 call	 ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Rehash_for_1

; 617  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

  00151	48 8b 45 28	 mov	 rax, QWORD PTR _Newnode$4[rbp+8]
  00155	48 83 c0 10	 add	 rax, 16
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 ??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>
  00161	4c 8b 4d 08	 mov	 r9, QWORD PTR _Hashval$2[rbp]
  00165	4c 8b c0	 mov	 r8, rax
  00168	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR $T7[rbp]
  0016f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00176	e8 00 00 00 00	 call	 ??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Find_last<unsigned __int64>
  0017b	48 8d 4d 10	 lea	 rcx, QWORD PTR _Target$3[rbp]
  0017f	48 8b f9	 mov	 rdi, rcx
  00182	48 8b f0	 mov	 rsi, rax
  00185	b9 10 00 00 00	 mov	 ecx, 16
  0018a	f3 a4		 rep movsb
$LN3@emplace:

; 618  :             }
; 619  : 
; 620  :             return {

  0018c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00193	48 83 c0 08	 add	 rax, 8
  00197	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv177[rbp], rax
  0019e	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  001a2	e8 00 00 00 00	 call	 ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::_Release
  001a7	4c 8b c8	 mov	 r9, rax
  001aa	4c 8b 45 10	 mov	 r8, QWORD PTR _Target$3[rbp]
  001ae	48 8b 55 08	 mov	 rdx, QWORD PTR _Hashval$2[rbp]
  001b2	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001b9	e8 00 00 00 00	 call	 ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Insert_new_node_before
  001be	4c 8b c0	 mov	 r8, rax
  001c1	48 8d 95 a8 00
	00 00		 lea	 rdx, QWORD PTR $T9[rbp]
  001c8	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR tv177[rbp]
  001cf	e8 00 00 00 00	 call	 ?_Make_iter@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Make_iter
  001d4	48 89 85 d0 00
	00 00		 mov	 QWORD PTR tv193[rbp], rax
  001db	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR tv193[rbp]
  001e2	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv182[rbp], rax
  001e9	c6 85 a0 00 00
	00 01		 mov	 BYTE PTR $T8[rbp], 1
  001f0	4c 8d 85 a0 00
	00 00		 lea	 r8, QWORD PTR $T8[rbp]
  001f7	48 8b 95 d8 00
	00 00		 mov	 rdx, QWORD PTR tv182[rbp]
  001fe	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00205	e8 00 00 00 00	 call	 ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool,0>
  0020a	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR $T10[rbp]
  00210	83 c8 01	 or	 eax, 1
  00213	89 85 c0 00 00
	00		 mov	 DWORD PTR $T10[rbp], eax
  00219	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00220	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ
  00225	90		 npad	 1
  00226	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  0022a	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
  0022f	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@emplace:

; 621  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 622  :         } else {
; 623  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 624  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 625  :             const auto _Hashval = _Traitsobj(_Keyval);
; 626  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 627  :             if (_Target._Duplicate) {
; 628  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 629  :             }
; 630  : 
; 631  :             _Check_max_size();
; 632  :             if (_Check_rehash_required_1()) {
; 633  :                 _Rehash_for_1();
; 634  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);
; 635  :             }
; 636  : 
; 637  :             return {
; 638  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 639  :         }
; 640  :     }

  00236	48 8d a5 e0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+224]
  0023d	5f		 pop	 rdi
  0023e	5e		 pop	 rsi
  0023f	5d		 pop	 rbp
  00240	c3		 ret	 0
??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::emplace<std::pair<unsigned __int64,Bucket> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Keyval$1 = 0
_Hashval$2 = 8
_Target$3 = 16
_Newnode$4 = 32
$T5 = 112
$T6 = 120
$T7 = 144
$T8 = 160
$T9 = 168
$T10 = 192
tv177 = 200
tv90 = 200
tv75 = 200
tv193 = 208
tv186 = 208
tv182 = 216
tv95 = 216
this$ = 256
__$ReturnUdt$ = 264
<_Vals_0>$ = 272
?dtor$2@?0???$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::emplace<std::pair<unsigned __int64,Bucket> >'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$2@?0???$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::emplace<std::pair<unsigned __int64,Bucket> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$?0AEA_KAEAUBucket@@$0A@@?$pair@_KUBucket@@@std@@QEAA@AEA_KAEAUBucket@@@Z
_TEXT	SEGMENT
this$ = 96
_Val1$ = 104
_Val2$ = 112
??$?0AEA_KAEAUBucket@@$0A@@?$pair@_KUBucket@@@std@@QEAA@AEA_KAEAUBucket@@@Z PROC ; std::pair<unsigned __int64,Bucket>::pair<unsigned __int64,Bucket><unsigned __int64 &,Bucket &,0>, COMDAT

; 250  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00027	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 8b 4d 68	 mov	 rcx, QWORD PTR _Val1$[rbp]
  0002f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00032	48 89 08	 mov	 QWORD PTR [rax], rcx
  00035	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  0003d	48 8b 75 70	 mov	 rsi, QWORD PTR _Val2$[rbp]
  00041	b9 18 00 00 00	 mov	 ecx, 24
  00046	f3 a4		 rep movsb

; 251  :     }

  00048	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5f		 pop	 rdi
  00051	5e		 pop	 rsi
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
??$?0AEA_KAEAUBucket@@$0A@@?$pair@_KUBucket@@@std@@QEAA@AEA_KAEAUBucket@@@Z ENDP ; std::pair<unsigned __int64,Bucket>::pair<unsigned __int64,Bucket><unsigned __int64 &,Bucket &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z
_TEXT	SEGMENT
_Bucket$ = 0
_Where$ = 8
_End$ = 16
_Bucket_lo$ = 24
tv135 = 96
this$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
_Hashval$ = 152
??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Find_last<unsigned __int64>, COMDAT

; 1566 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1567 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1568 :         const size_type _Bucket = _Hashval & _Mask;

  0002d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00038	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Hashval$[rbp]
  0003f	48 23 c8	 and	 rcx, rax
  00042	48 8b c1	 mov	 rax, rcx
  00045	48 89 45 00	 mov	 QWORD PTR _Bucket$[rbp], rax

; 1569 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

  00049	48 8b 45 00	 mov	 rax, QWORD PTR _Bucket$[rbp]
  0004d	48 d1 e0	 shl	 rax, 1
  00050	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00057	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0005b	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00060	48 89 45 08	 mov	 QWORD PTR _Where$[rbp], rax

; 1570 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

  00064	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	48 89 45 10	 mov	 QWORD PTR _End$[rbp], rax

; 1571 :         if (_Where == _End) {

  00073	48 8b 45 10	 mov	 rax, QWORD PTR _End$[rbp]
  00077	48 39 45 08	 cmp	 QWORD PTR _Where$[rbp], rax
  0007b	75 29		 jne	 SHORT $LN5@Find_last

; 1572 :             return {_End, _Nodeptr{}};

  0007d	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00084	48 8b 4d 10	 mov	 rcx, QWORD PTR _End$[rbp]
  00088	48 89 08	 mov	 QWORD PTR [rax], rcx
  0008b	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00092	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0009a	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000a1	e9 b9 00 00 00	 jmp	 $LN1@Find_last
$LN5@Find_last:

; 1573 :         }
; 1574 : 
; 1575 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

  000a6	48 8b 45 00	 mov	 rax, QWORD PTR _Bucket$[rbp]
  000aa	48 d1 e0	 shl	 rax, 1
  000ad	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b4	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000b8	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000bc	48 89 45 18	 mov	 QWORD PTR _Bucket_lo$[rbp], rax
$LN2@Find_last:

; 1576 :         for (;;) {
; 1577 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1578 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

  000c0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c7	48 89 45 60	 mov	 QWORD PTR tv135[rbp], rax
  000cb	48 8b 45 08	 mov	 rax, QWORD PTR _Where$[rbp]
  000cf	48 83 c0 10	 add	 rax, 16
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 ?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
  000db	4c 8b c0	 mov	 r8, rax
  000de	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR _Keyval$[rbp]
  000e5	48 8b 4d 60	 mov	 rcx, QWORD PTR tv135[rbp]
  000e9	e8 00 00 00 00	 call	 ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
  000ee	0f b6 c0	 movzx	 eax, al
  000f1	85 c0		 test	 eax, eax
  000f3	75 29		 jne	 SHORT $LN6@Find_last

; 1579 :                 if constexpr (!_Traits::_Standard) {
; 1580 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1581 :                         return {_Where->_Next, _Nodeptr{}};
; 1582 :                     }
; 1583 :                 }
; 1584 : 
; 1585 :                 return {_Where->_Next, _Where};

  000f5	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000fc	48 8b 4d 08	 mov	 rcx, QWORD PTR _Where$[rbp]
  00100	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00103	48 89 08	 mov	 QWORD PTR [rax], rcx
  00106	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0010d	48 8b 4d 08	 mov	 rcx, QWORD PTR _Where$[rbp]
  00111	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00115	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0011c	eb 41		 jmp	 SHORT $LN1@Find_last
$LN6@Find_last:

; 1586 :             }
; 1587 : 
; 1588 :             if (_Where == _Bucket_lo) {

  0011e	48 8b 45 18	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00122	48 39 45 08	 cmp	 QWORD PTR _Where$[rbp], rax
  00126	75 26		 jne	 SHORT $LN7@Find_last

; 1589 :                 return {_Where, _Nodeptr{}};

  00128	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0012f	48 8b 4d 08	 mov	 rcx, QWORD PTR _Where$[rbp]
  00133	48 89 08	 mov	 QWORD PTR [rax], rcx
  00136	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0013d	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00145	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0014c	eb 11		 jmp	 SHORT $LN1@Find_last
$LN7@Find_last:

; 1590 :             }
; 1591 : 
; 1592 :             _Where = _Where->_Prev;

  0014e	48 8b 45 08	 mov	 rax, QWORD PTR _Where$[rbp]
  00152	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00156	48 89 45 08	 mov	 QWORD PTR _Where$[rbp], rax

; 1593 :         }

  0015a	e9 61 ff ff ff	 jmp	 $LN2@Find_last
$LN1@Find_last:

; 1594 :     }

  0015f	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00163	5d		 pop	 rbp
  00164	c3		 ret	 0
??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Find_last<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
$T8 = 120
$T9 = 128
$T10 = 136
$T11 = 140
tv92 = 144
tv90 = 152
__$ReturnUdt$ = 176
_First$ = 184
_Last$ = 192
_Pred$ = 200
??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z PROC ; std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::less<void> >, COMDAT

; 6853 : _NODISCARD constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find smallest element

$LN7:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	c7 85 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR $T11[rbp], 0
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00032	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6854 :     _Adl_verify_range(_First, _Last);

  00037	48 8b 95 c0 00
	00 00		 mov	 rdx, QWORD PTR _Last$[rbp]
  0003e	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR _First$[rbp]
  00045	e8 00 00 00 00	 call	 ??$_Adl_verify_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V12@@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >

; 6855 :     _Seek_wrapped(_First, _STD _Min_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));

  0004a	48 8d 8d c8 00
	00 00		 lea	 rcx, QWORD PTR _Pred$[rbp]
  00051	e8 00 00 00 00	 call	 ??$_Pass_fn@U?$less@X@std@@@std@@YA?A_PAEAU?$less@X@0@@Z ; std::_Pass_fn<std::less<void> >
  00056	88 45 40	 mov	 BYTE PTR $T1[rbp], al
  00059	0f b6 45 40	 movzx	 eax, BYTE PTR $T1[rbp]
  0005d	88 45 78	 mov	 BYTE PTR $T8[rbp], al
  00060	0f b6 45 78	 movzx	 eax, BYTE PTR $T8[rbp]
  00064	88 85 88 00 00
	00		 mov	 BYTE PTR $T10[rbp], al
  0006a	48 8b 95 c0 00
	00 00		 mov	 rdx, QWORD PTR _Last$[rbp]
  00071	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00075	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?A_TAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > &>
  0007a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007d	48 89 45 68	 mov	 QWORD PTR $T6[rbp], rax
  00081	48 8b 45 68	 mov	 rax, QWORD PTR $T6[rbp]
  00085	48 89 85 80 00
	00 00		 mov	 QWORD PTR $T9[rbp], rax
  0008c	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _First$[rbp]
  00093	48 8d 4d 50	 lea	 rcx, QWORD PTR $T3[rbp]
  00097	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?A_TAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > &>
  0009c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009f	48 89 45 60	 mov	 QWORD PTR $T5[rbp], rax
  000a3	48 8b 45 60	 mov	 rax, QWORD PTR $T5[rbp]
  000a7	48 89 45 70	 mov	 QWORD PTR $T7[rbp], rax
  000ab	44 0f b6 8d 88
	00 00 00	 movzx	 r9d, BYTE PTR $T10[rbp]
  000b3	4c 8b 85 80 00
	00 00		 mov	 r8, QWORD PTR $T9[rbp]
  000ba	48 8b 55 70	 mov	 rdx, QWORD PTR $T7[rbp]
  000be	48 8d 4d 58	 lea	 rcx, QWORD PTR $T4[rbp]
  000c2	e8 00 00 00 00	 call	 ??$_Min_element_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@U?$less@X@2@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@V10@0U?$less@X@0@@Z ; std::_Min_element_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>,std::less<void> >
  000c7	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv92[rbp], rax
  000ce	48 8b 85 b8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  000d5	48 89 85 98 00
	00 00		 mov	 QWORD PTR tv90[rbp], rax
  000dc	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR tv92[rbp]
  000e3	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR tv90[rbp]
  000ea	e8 00 00 00 00	 call	 ??$_Seek_wrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXAEAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@$$QEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Seek_wrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >

; 6856 :     return _First;

  000ef	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _First$[rbp]
  000f6	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000fd	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z
  00102	8b 85 8c 00 00
	00		 mov	 eax, DWORD PTR $T11[rbp]
  00108	83 c8 01	 or	 eax, 1
  0010b	89 85 8c 00 00
	00		 mov	 DWORD PTR $T11[rbp], eax
  00111	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR _First$[rbp]
  00118	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  0011d	90		 npad	 1
  0011e	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  00125	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  0012a	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 6857 : }

  00131	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  00138	5d		 pop	 rbp
  00139	c3		 ret	 0
??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z ENDP ; std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
$T8 = 120
$T9 = 128
$T10 = 136
$T11 = 140
tv92 = 144
tv90 = 152
__$ReturnUdt$ = 176
_First$ = 184
_Last$ = 192
_Pred$ = 200
?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA PROC ; `std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::less<void> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA ENDP ; `std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::less<void> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
$T8 = 120
$T9 = 128
$T10 = 136
$T11 = 140
tv92 = 144
tv90 = 152
__$ReturnUdt$ = 176
_First$ = 184
_Last$ = 192
_Pred$ = 200
?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA PROC ; `std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::less<void> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR _First$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z@4HA ENDP ; `std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::less<void> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 10 00 00 00	 mov	 ecx, 16
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00036	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00039	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003d	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 243  : }

  00042	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00046	5d		 pop	 rbp
  00047	c3		 ret	 0
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Max_possible$1 = 8
_Count$ = 96
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 01	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00029	48 89 45 08	 mov	 QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

  0002d	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00037	48 39 45 60	 cmp	 QWORD PTR _Count$[rbp], rax
  0003b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

  0003d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  00042	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
$LN3@Get_size_o:

; 75   : }

  00047	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Max_possible$1 = 8
_Count$ = 96
??$_Get_size_of_n@$0DA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<48>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 01	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	48 b8 55 55 55
	55 55 55 55 05	 mov	 rax, 384307168202282325	; 0555555555555555H
  00029	48 89 45 08	 mov	 QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

  0002d	48 b8 55 55 55
	55 55 55 55 05	 mov	 rax, 384307168202282325	; 0555555555555555H
  00037	48 39 45 60	 cmp	 QWORD PTR _Count$[rbp], rax
  0003b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

  0003d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  00042	48 6b 45 60 30	 imul	 rax, QWORD PTR _Count$[rbp], 48 ; 00000030H
$LN3@Get_size_o:

; 75   : }

  00047	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
??$_Get_size_of_n@$0DA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<48>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Max_possible$1 = 8
_Count$ = 96
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<24>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 01	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	48 b8 aa aa aa
	aa aa aa aa 0a	 mov	 rax, 768614336404564650	; 0aaaaaaaaaaaaaaaH
  00029	48 89 45 08	 mov	 QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

  0002d	48 b8 aa aa aa
	aa aa aa aa 0a	 mov	 rax, 768614336404564650	; 0aaaaaaaaaaaaaaaH
  00037	48 39 45 60	 cmp	 QWORD PTR _Count$[rbp], rax
  0003b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

  0003d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  00042	48 6b 45 60 18	 imul	 rax, QWORD PTR _Count$[rbp], 24
$LN3@Get_size_o:

; 75   : }

  00047	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<24>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
_TEXT	SEGMENT
_Ptr$ = 80
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Ptr$[rbp]

; 37   : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<unsigned __int64,void *> *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@_KPEAX@std@@@std@@YAPEAPEAU?$_List_node@_KPEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<unsigned __int64,void *> *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT

; 1483 :     _CONSTEXPR20 ~_Container_proxy_ptr12() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1484 :         if (_Ptr) {

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 14		 je	 SHORT $LN2@Container_

; 1485 :             _Delete_plain_internal(_Al, _Ptr);

  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00030	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00034	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
$LN2@Container_:

; 1486 :         }
; 1487 :     }

  00039	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Al_$ = 104
_Mycont$ = 112
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT

; 1469 :     _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00029	e8 00 00 00 00	 call	 ??0_Basic_container_proxy_ptr12@std@@IEAA@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
  0002e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 4d 68	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00036	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1470 :         // create a new _Container_proxy pointing at _Mycont
; 1471 :         _Ptr = _Unfancy(_Al_.allocate(1));

  0003a	ba 01 00 00 00	 mov	 edx, 1
  0003f	48 8b 4d 68	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00043	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00050	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00054	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1472 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  00057	48 8b 4d 70	 mov	 rcx, QWORD PTR _Mycont$[rbp]
  0005b	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ; std::addressof<std::_Container_base12>
  00060	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00064	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00068	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0006c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006f	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>

; 1473 :         _Mycont._Myproxy = _Ptr;

  00074	48 8b 45 70	 mov	 rax, QWORD PTR _Mycont$[rbp]
  00078	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0007c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1474 :     }

  00082	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00086	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0008a	5d		 pop	 rbp
  0008b	c3		 ret	 0
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 80
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 230  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 231  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 232  : #if defined(_M_IX86) || defined(_M_X64)
; 233  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 234  :     if (!_STD is_constant_evaluated())

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	75 15		 jne	 SHORT $LN2@Allocate

; 235  : #endif // _HAS_CXX20
; 236  :     {
; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00027	48 81 7d 50 00
	10 00 00	 cmp	 QWORD PTR _Bytes$[rbp], 4096 ; 00001000H
  0002f	72 0b		 jb	 SHORT $LN3@Allocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00031	48 8b 4d 50	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00035	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0003a	eb 14		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:
$LN2@Allocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  0003c	48 83 7d 50 00	 cmp	 QWORD PTR _Bytes$[rbp], 0
  00041	74 0b		 je	 SHORT $LN4@Allocate

; 244  :         return _Traits::_Allocate(_Bytes);

  00043	48 8b 4d 50	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00047	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  0004c	eb 02		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  0004e	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 248  : }

  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Max_possible$1 = 8
_Count$ = 96
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 01	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00029	48 89 45 08	 mov	 QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

  0002d	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00037	48 39 45 60	 cmp	 QWORD PTR _Count$[rbp], rax
  0003b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

  0003d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  00042	48 8b 45 60	 mov	 rax, QWORD PTR _Count$[rbp]
  00046	48 c1 e0 03	 shl	 rax, 3
$LN3@Get_size_o:

; 75   : }

  0004a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> ><std::pair<unsigned __int64 const ,Bucket> >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> ><std::pair<unsigned __int64 const ,Bucket> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
_Val1$ = 96
??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &>, COMDAT

; 1524 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 55 60	 mov	 rdx, QWORD PTR _Val1$[rbp]
  00028	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002c	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CB_KUBucket@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> ><std::pair<unsigned __int64 const ,Bucket> >
  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >
  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 0
_ULast$2 = 8
_First$ = 96
_Last$ = 104
_Val$ = 112
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >, COMDAT

; 5015 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5016 :     // copy _Val through [_First, _Last)
; 5017 :     _Adl_verify_range(_First, _Last);

  00025	48 8d 55 68	 lea	 rdx, QWORD PTR _Last$[rbp]
  00029	48 8d 4d 60	 lea	 rcx, QWORD PTR _First$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>

; 5018 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5019 :         _Fill_vbool(_First, _Last, _Val);
; 5020 :     } else {
; 5021 :         auto _UFirst      = _Get_unwrapped(_First);

  00032	48 8d 4d 60	 lea	 rcx, QWORD PTR _First$[rbp]
  00036	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > * const &>
  0003b	48 89 45 00	 mov	 QWORD PTR _UFirst$1[rbp], rax

; 5022 :         const auto _ULast = _Get_unwrapped(_Last);

  0003f	48 8d 4d 68	 lea	 rcx, QWORD PTR _Last$[rbp]
  00043	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > * const &>
  00048	48 89 45 08	 mov	 QWORD PTR _ULast$2[rbp], rax

; 5023 : #if _HAS_CXX20
; 5024 :         if (!_STD is_constant_evaluated())

  0004c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00051	0f b6 c0	 movzx	 eax, al

; 5025 : #endif // _HAS_CXX20
; 5026 :         {
; 5027 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5028 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5029 :                 return;
; 5030 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5031 :                 if (_Is_all_bits_zero(_Val)) {
; 5032 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5033 :                     return;
; 5034 :                 }
; 5035 :             }
; 5036 :         }
; 5037 : 
; 5038 :         for (; _UFirst != _ULast; ++_UFirst) {

  00054	eb 0c		 jmp	 SHORT $LN4@fill
$LN2@fill:
  00056	48 8b 45 00	 mov	 rax, QWORD PTR _UFirst$1[rbp]
  0005a	48 83 c0 08	 add	 rax, 8
  0005e	48 89 45 00	 mov	 QWORD PTR _UFirst$1[rbp], rax
$LN4@fill:
  00062	48 8b 45 08	 mov	 rax, QWORD PTR _ULast$2[rbp]
  00066	48 39 45 00	 cmp	 QWORD PTR _UFirst$1[rbp], rax
  0006a	74 10		 je	 SHORT $LN3@fill

; 5039 :             *_UFirst = _Val;

  0006c	48 8b 45 70	 mov	 rax, QWORD PTR _Val$[rbp]
  00070	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00073	48 8b 4d 00	 mov	 rcx, QWORD PTR _UFirst$1[rbp]
  00077	48 89 01	 mov	 QWORD PTR [rcx], rax

; 5040 :         }

  0007a	eb da		 jmp	 SHORT $LN2@fill
$LN3@fill:

; 5041 :     }
; 5042 : }

  0007c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00080	5d		 pop	 rbp
  00081	c3		 ret	 0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Backout$1 = 16
_First$ = 112
_Last$ = 120
_Val$ = 128
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >, COMDAT

; 1985 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1986 :     // copy _Val throughout raw [_First, _Last)
; 1987 :     _Adl_verify_range(_First, _Last);

  00028	48 8d 55 78	 lea	 rdx, QWORD PTR _Last$[rbp]
  0002c	48 8d 4d 70	 lea	 rcx, QWORD PTR _First$[rbp]
  00030	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>

; 1988 :     auto _UFirst      = _Get_unwrapped(_First);

  00035	48 8d 4d 70	 lea	 rcx, QWORD PTR _First$[rbp]
  00039	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > * const &>
  0003e	48 89 45 00	 mov	 QWORD PTR _UFirst$[rbp], rax

; 1989 :     const auto _ULast = _Get_unwrapped(_Last);

  00042	48 8d 4d 78	 lea	 rcx, QWORD PTR _Last$[rbp]
  00046	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > * const &>
  0004b	48 89 45 08	 mov	 QWORD PTR _ULast$[rbp], rax

; 1990 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1991 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1992 :     } else {
; 1993 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1994 :             if (_Is_all_bits_zero(_Val)) {
; 1995 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1996 :                 return;
; 1997 :             }
; 1998 :         }
; 1999 : 
; 2000 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

  0004f	48 8b 55 00	 mov	 rdx, QWORD PTR _UFirst$[rbp]
  00053	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  00057	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
  0005c	90		 npad	 1
$LN2@uninitiali:

; 2001 :         while (_Backout._Last != _ULast) {

  0005d	48 8b 45 08	 mov	 rax, QWORD PTR _ULast$[rbp]
  00061	48 39 45 18	 cmp	 QWORD PTR _Backout$1[rbp+8], rax
  00065	74 12		 je	 SHORT $LN3@uninitiali

; 2002 :             _Backout._Emplace_back(_Val);

  00067	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Val$[rbp]
  0006e	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  00072	e8 00 00 00 00	 call	 ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > const &>

; 2003 :         }

  00077	eb e4		 jmp	 SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2004 : 
; 2005 :         _Backout._Release();

  00079	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  0007d	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::_Release
  00082	90		 npad	 1

; 2006 :     }

  00083	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  00087	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>

; 2007 : }

  0008c	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Backout$1 = 16
_First$ = 112
_Last$ = 120
_Val$ = 128
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0_K@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0_K@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z PROC ; std::allocator<std::_List_node<unsigned __int64,void *> >::allocator<std::_List_node<unsigned __int64,void *> ><unsigned __int64>, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0_K@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ENDP ; std::allocator<std::_List_node<unsigned __int64,void *> >::allocator<std::_List_node<unsigned __int64,void *> ><unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
_Val1$ = 96
??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1><std::allocator<unsigned __int64> const &>, COMDAT

; 1524 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 55 60	 mov	 rdx, QWORD PTR _Val1$[rbp]
  00028	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002c	e8 00 00 00 00	 call	 ??$?0_K@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ; std::allocator<std::_List_node<unsigned __int64,void *> >::allocator<std::_List_node<unsigned __int64,void *> ><unsigned __int64>
  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ??0?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_List_val<std::_List_simple_types<unsigned __int64> >
  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1><std::allocator<unsigned __int64> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 80
_Bytes$ = 88
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 251  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0b		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 256  :     } else

  00035	eb 25		 jmp	 SHORT $LN3@Deallocate
$LN2@Deallocate:

; 257  : #endif // _HAS_CXX20
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00037	48 81 7d 58 00
	10 00 00	 cmp	 QWORD PTR _Bytes$[rbp], 4096 ; 00001000H
  0003f	72 0d		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00041	48 8d 55 58	 lea	 rdx, QWORD PTR _Bytes$[rbp]
  00045	48 8d 4d 50	 lea	 rcx, QWORD PTR _Ptr$[rbp]
  00049	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0004e	48 8b 55 58	 mov	 rdx, QWORD PTR _Bytes$[rbp]
  00052	48 8b 4d 50	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00056	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0005b	90		 npad	 1
$LN3@Deallocate:

; 265  :     }
; 266  : }

  0005c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
$T1 = 64
tv65 = 72
_Left$ = 96
_Right$ = 104
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Left$[rbp]
  00024	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	73 0a		 jae	 SHORT $LN3@max
  00030	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00034	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
  00038	eb 08		 jmp	 SHORT $LN4@max
$LN3@max:
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR _Left$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
$LN4@max:
  00042	48 8b 45 48	 mov	 rax, QWORD PTR tv65[rbp]
  00046	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0004a	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 78   : }

  0004e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 0
_ULast$2 = 8
_First$ = 96
_Last$ = 104
_Val$ = 112
??$fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >, COMDAT

; 5015 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5016 :     // copy _Val through [_First, _Last)
; 5017 :     _Adl_verify_range(_First, _Last);

  00025	48 8d 55 68	 lea	 rdx, QWORD PTR _Last$[rbp]
  00029	48 8d 4d 60	 lea	 rcx, QWORD PTR _First$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>

; 5018 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5019 :         _Fill_vbool(_First, _Last, _Val);
; 5020 :     } else {
; 5021 :         auto _UFirst      = _Get_unwrapped(_First);

  00032	48 8d 4d 60	 lea	 rcx, QWORD PTR _First$[rbp]
  00036	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> * const &>
  0003b	48 89 45 00	 mov	 QWORD PTR _UFirst$1[rbp], rax

; 5022 :         const auto _ULast = _Get_unwrapped(_Last);

  0003f	48 8d 4d 68	 lea	 rcx, QWORD PTR _Last$[rbp]
  00043	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> * const &>
  00048	48 89 45 08	 mov	 QWORD PTR _ULast$2[rbp], rax

; 5023 : #if _HAS_CXX20
; 5024 :         if (!_STD is_constant_evaluated())

  0004c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00051	0f b6 c0	 movzx	 eax, al

; 5025 : #endif // _HAS_CXX20
; 5026 :         {
; 5027 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5028 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5029 :                 return;
; 5030 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5031 :                 if (_Is_all_bits_zero(_Val)) {
; 5032 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5033 :                     return;
; 5034 :                 }
; 5035 :             }
; 5036 :         }
; 5037 : 
; 5038 :         for (; _UFirst != _ULast; ++_UFirst) {

  00054	eb 0c		 jmp	 SHORT $LN4@fill
$LN2@fill:
  00056	48 8b 45 00	 mov	 rax, QWORD PTR _UFirst$1[rbp]
  0005a	48 83 c0 08	 add	 rax, 8
  0005e	48 89 45 00	 mov	 QWORD PTR _UFirst$1[rbp], rax
$LN4@fill:
  00062	48 8b 45 08	 mov	 rax, QWORD PTR _ULast$2[rbp]
  00066	48 39 45 00	 cmp	 QWORD PTR _UFirst$1[rbp], rax
  0006a	74 10		 je	 SHORT $LN3@fill

; 5039 :             *_UFirst = _Val;

  0006c	48 8b 45 70	 mov	 rax, QWORD PTR _Val$[rbp]
  00070	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00073	48 8b 4d 00	 mov	 rcx, QWORD PTR _UFirst$1[rbp]
  00077	48 89 01	 mov	 QWORD PTR [rcx], rax

; 5040 :         }

  0007a	eb da		 jmp	 SHORT $LN2@fill
$LN3@fill:

; 5041 :     }
; 5042 : }

  0007c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00080	5d		 pop	 rbp
  00081	c3		 ret	 0
??$fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Backout$1 = 16
_First$ = 112
_Last$ = 120
_Val$ = 128
??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >, COMDAT

; 1985 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1986 :     // copy _Val throughout raw [_First, _Last)
; 1987 :     _Adl_verify_range(_First, _Last);

  00028	48 8d 55 78	 lea	 rdx, QWORD PTR _Last$[rbp]
  0002c	48 8d 4d 70	 lea	 rcx, QWORD PTR _First$[rbp]
  00030	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>

; 1988 :     auto _UFirst      = _Get_unwrapped(_First);

  00035	48 8d 4d 70	 lea	 rcx, QWORD PTR _First$[rbp]
  00039	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> * const &>
  0003e	48 89 45 00	 mov	 QWORD PTR _UFirst$[rbp], rax

; 1989 :     const auto _ULast = _Get_unwrapped(_Last);

  00042	48 8d 4d 78	 lea	 rcx, QWORD PTR _Last$[rbp]
  00046	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> * const &>
  0004b	48 89 45 08	 mov	 QWORD PTR _ULast$[rbp], rax

; 1990 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1991 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1992 :     } else {
; 1993 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1994 :             if (_Is_all_bits_zero(_Val)) {
; 1995 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1996 :                 return;
; 1997 :             }
; 1998 :         }
; 1999 : 
; 2000 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

  0004f	48 8b 55 00	 mov	 rdx, QWORD PTR _UFirst$[rbp]
  00053	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  00057	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
  0005c	90		 npad	 1
$LN2@uninitiali:

; 2001 :         while (_Backout._Last != _ULast) {

  0005d	48 8b 45 08	 mov	 rax, QWORD PTR _ULast$[rbp]
  00061	48 39 45 18	 cmp	 QWORD PTR _Backout$1[rbp+8], rax
  00065	74 12		 je	 SHORT $LN3@uninitiali

; 2002 :             _Backout._Emplace_back(_Val);

  00067	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Val$[rbp]
  0006e	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  00072	e8 00 00 00 00	 call	 ??$_Emplace_back@AEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> const &>

; 2003 :         }

  00077	eb e4		 jmp	 SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2004 : 
; 2005 :         _Backout._Release();

  00079	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  0007d	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::_Release
  00082	90		 npad	 1

; 2006 :     }

  00083	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  00087	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::~_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>

; 2007 : }

  0008c	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Backout$1 = 16
_First$ = 112
_Last$ = 120
_Val$ = 128
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$1[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>::~_Uninitialized_backout<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
<_Val2_0>$ = 96
??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z PROC ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b 4d 60	 mov	 rcx, QWORD PTR <_Val2_0>$[rbp]
  0002c	f3 0f 10 01	 movss	 xmm0, DWORD PTR [rcx]
  00030	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ENDP ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
_TEXT	SEGMENT
tv74 = 64
this$ = 96
__formal$ = 104
<_Val2_0>$ = 112
<_Val2_1>$ = 120
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z PROC ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00029	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 89 45 40	 mov	 QWORD PTR tv74[rbp], rax
  00031	4c 8b 45 78	 mov	 r8, QWORD PTR <_Val2_1>$[rbp]
  00035	48 8b 45 70	 mov	 rax, QWORD PTR <_Val2_0>$[rbp]
  00039	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0003c	48 8b 4d 40	 mov	 rcx, QWORD PTR tv74[rbp]
  00040	e8 00 00 00 00	 call	 ??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
  00045	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ENDP ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0002c	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00030	48 83 c0 08	 add	 rax, 8
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

  0003c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00042	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00046	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0004a	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::deallocate
  0004f	90		 npad	 1

; 313  :     }

  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 0
_Pnext$1 = 8
_Al$ = 96
_Head$ = 104
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 324  :         _Head->_Prev->_Next = nullptr;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Head$[rbp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0002f	48 8b 45 68	 mov	 rax, QWORD PTR _Head$[rbp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 89 45 00	 mov	 QWORD PTR _Pnode$[rbp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0003a	eb 08		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00040	48 89 45 00	 mov	 QWORD PTR _Pnode$[rbp], rax
$LN4@Free_non_h:
  00044	48 83 7d 00 00	 cmp	 QWORD PTR _Pnode$[rbp], 0
  00049	74 1a		 je	 SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  0004b	48 8b 45 00	 mov	 rax, QWORD PTR _Pnode$[rbp]
  0004f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00052	48 89 45 08	 mov	 QWORD PTR _Pnext$1[rbp], rax

; 329  :             _Freenode(_Al, _Pnode);

  00056	48 8b 55 00	 mov	 rdx, QWORD PTR _Pnode$[rbp]
  0005a	48 8b 4d 60	 mov	 rcx, QWORD PTR _Al$[rbp]
  0005e	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >

; 330  :         }

  00063	eb d7		 jmp	 SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

  00065	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
tv85 = 72
tv70 = 72
this$ = 96
_Al$ = 104
??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > ><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &,0>, COMDAT

; 266  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 48	 mov	 QWORD PTR tv70[rbp], rax
  00028	4c 8b 45 68	 mov	 r8, QWORD PTR _Al$[rbp]
  0002c	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00030	48 8b 4d 48	 mov	 rcx, QWORD PTR tv70[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &>

; 267  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

  00039	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003d	48 89 45 48	 mov	 QWORD PTR tv85[rbp], rax
  00041	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first
  0004d	48 8b d0	 mov	 rdx, rax
  00050	48 8d 4d 41	 lea	 rcx, QWORD PTR $T2[rbp]
  00054	e8 00 00 00 00	 call	 ??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
  00059	48 8b d0	 mov	 rdx, rax
  0005c	48 8b 4d 48	 mov	 rcx, QWORD PTR tv85[rbp]
  00060	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 268  :     }

  00065	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00069	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006d	5d		 pop	 rbp
  0006e	c3		 ret	 0
??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > ><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>, COMDAT

; 1097 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1098 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1099 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1100 :         for (; _First != _Last; ++_First) {
; 1101 :             _Destroy_in_place(*_First);
; 1102 :         }
; 1103 :     }
; 1104 : }

  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<unsigned __int64> > >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<unsigned __int64,void *>::_Freenode0<std::allocator<std::_List_node<unsigned __int64,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAU?$_List_node@_KPEAX@std@@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<unsigned __int64,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0002c	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00030	48 83 c0 08	 add	 rax, 8
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAU?$_List_node@_KPEAX@std@@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<unsigned __int64,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

  0003c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00042	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00046	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0004a	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@QEAU?$_List_node@_KPEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::deallocate
  0004f	90		 npad	 1

; 313  :     }

  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<unsigned __int64,void *>::_Freenode0<std::allocator<std::_List_node<unsigned __int64,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 0
_Pnext$1 = 8
_Al$ = 96
_Head$ = 104
??$_Free_non_head@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<unsigned __int64,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned __int64,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 324  :         _Head->_Prev->_Next = nullptr;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Head$[rbp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0002f	48 8b 45 68	 mov	 rax, QWORD PTR _Head$[rbp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 89 45 00	 mov	 QWORD PTR _Pnode$[rbp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0003a	eb 08		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00040	48 89 45 00	 mov	 QWORD PTR _Pnode$[rbp], rax
$LN4@Free_non_h:
  00044	48 83 7d 00 00	 cmp	 QWORD PTR _Pnode$[rbp], 0
  00049	74 1a		 je	 SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  0004b	48 8b 45 00	 mov	 rax, QWORD PTR _Pnode$[rbp]
  0004f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00052	48 89 45 08	 mov	 QWORD PTR _Pnext$1[rbp], rax

; 329  :             _Freenode(_Al, _Pnode);

  00056	48 8b 55 00	 mov	 rdx, QWORD PTR _Pnode$[rbp]
  0005a	48 8b 4d 60	 mov	 rcx, QWORD PTR _Al$[rbp]
  0005e	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Freenode<std::allocator<std::_List_node<unsigned __int64,void *> > >

; 330  :         }

  00063	eb d7		 jmp	 SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

  00065	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<unsigned __int64,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned __int64,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
tv85 = 72
tv70 = 72
this$ = 96
_Al$ = 104
??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > ><std::allocator<unsigned __int64> const &,0>, COMDAT

; 266  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 48	 mov	 QWORD PTR tv70[rbp], rax
  00028	4c 8b 45 68	 mov	 r8, QWORD PTR _Al$[rbp]
  0002c	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00030	48 8b 4d 48	 mov	 rcx, QWORD PTR tv70[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1><std::allocator<unsigned __int64> const &>

; 267  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

  00039	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003d	48 89 45 48	 mov	 QWORD PTR tv85[rbp], rax
  00041	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first
  0004d	48 8b d0	 mov	 rdx, rax
  00050	48 8d 4d 41	 lea	 rcx, QWORD PTR $T2[rbp]
  00054	e8 00 00 00 00	 call	 ??$?0V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
  00059	48 8b d0	 mov	 rdx, rax
  0005c	48 8b 4d 48	 mov	 rcx, QWORD PTR tv85[rbp]
  00060	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 268  :     }

  00065	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00069	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006d	5d		 pop	 rbp
  0006e	c3		 ret	 0
??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > ><std::allocator<unsigned __int64> const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>, COMDAT

; 1097 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1098 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1099 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1100 :         for (; _First != _Last; ++_First) {
; 1101 :             _Destroy_in_place(*_First);
; 1102 :         }
; 1103 :     }
; 1104 : }

  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 64
this$ = 96
_Right$ = 104
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 72   :         return _Ptr == _Right._Ptr;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	75 09		 jne	 SHORT $LN3@operator
  00030	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv67[rbp], 1
  00037	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00039	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv67[rbp], 0
$LN4@operator:
  00040	0f b6 45 40	 movzx	 eax, BYTE PTR tv67[rbp]

; 73   :     }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 80
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator--, COMDAT

; 60   :     _List_unchecked_const_iterator& operator--() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 61   :         _Ptr = _Ptr->_Prev;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 62   :         return *this;

  0002d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 63   :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 80
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 50   :         _Ptr = _Ptr->_Next;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 01	 mov	 QWORD PTR [rcx], rax

; 51   :         return *this;

  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 52   :     }

  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ
_TEXT	SEGMENT
this$ = 80
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 42   :         return _Ptr->_Myval;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 83 c0 10	 add	 rax, 16

; 43   :     }

  00026	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Pnode$ = 88
_Plist$ = 96
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

  00030	48 8b 55 60	 mov	 rdx, QWORD PTR _Plist$[rbp]
  00034	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt

; 39   :     }

  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0U?$_List_node@_KPEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0U?$_List_node@_KPEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<unsigned __int64,void *> >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0U?$_List_node@_KPEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<unsigned __int64,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::~_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::~_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z
_TEXT	SEGMENT
_Keyval$1 = 0
_Hashval$2 = 8
_Target$3 = 16
_Newnode$4 = 32
$T5 = 112
$T6 = 120
$T7 = 144
$T8 = 160
$T9 = 168
$T10 = 192
tv177 = 200
tv90 = 200
tv75 = 200
tv193 = 208
tv186 = 208
tv182 = 216
tv95 = 216
this$ = 256
__$ReturnUdt$ = 264
<_Vals_0>$ = 272
??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64 const &>, COMDAT

; 590  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR $T10[rbp], 0
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 591  :         // try to insert value_type(_Vals...)
; 592  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 593  :         if constexpr (_Multi) {
; 594  :             _Check_max_size();
; 595  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 596  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 597  :             const auto _Hashval = _Traitsobj(_Keyval);
; 598  :             if (_Check_rehash_required_1()) {
; 599  :                 _Rehash_for_1();
; 600  :             }
; 601  : 
; 602  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 603  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 604  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 605  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

  00034	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR <_Vals_0>$[rbp]
  0003b	e8 00 00 00 00	 call	 ?_Extract@?$_In_place_key_extract_set@_K_K@std@@SAAEB_KAEB_K@Z ; std::_In_place_key_extract_set<unsigned __int64,unsigned __int64>::_Extract
  00040	48 89 45 00	 mov	 QWORD PTR _Keyval$1[rbp], rax

; 606  :             const auto _Hashval = _Traitsobj(_Keyval);

  00044	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv75[rbp], rax
  00052	48 8b 55 00	 mov	 rdx, QWORD PTR _Keyval$1[rbp]
  00056	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR tv75[rbp]
  0005d	e8 00 00 00 00	 call	 ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
  00062	48 89 45 08	 mov	 QWORD PTR _Hashval$2[rbp], rax

; 607  :             auto _Target        = _Find_last(_Keyval, _Hashval);

  00066	4c 8b 4d 08	 mov	 r9, QWORD PTR _Hashval$2[rbp]
  0006a	4c 8b 45 00	 mov	 r8, QWORD PTR _Keyval$1[rbp]
  0006e	48 8d 55 10	 lea	 rdx, QWORD PTR _Target$3[rbp]
  00072	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00079	e8 00 00 00 00	 call	 ??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Find_last<unsigned __int64>

; 608  :             if (_Target._Duplicate) {

  0007e	48 83 7d 18 00	 cmp	 QWORD PTR _Target$3[rbp+8], 0
  00083	74 7a		 je	 SHORT $LN2@emplace

; 609  :                 return {_List._Make_iter(_Target._Duplicate), false};

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 83 c0 08	 add	 rax, 8
  00090	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv90[rbp], rax
  00097	4c 8b 45 18	 mov	 r8, QWORD PTR _Target$3[rbp+8]
  0009b	48 8d 55 78	 lea	 rdx, QWORD PTR $T6[rbp]
  0009f	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR tv90[rbp]
  000a6	e8 00 00 00 00	 call	 ?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter
  000ab	48 89 85 d0 00
	00 00		 mov	 QWORD PTR tv186[rbp], rax
  000b2	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR tv186[rbp]
  000b9	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv95[rbp], rax
  000c0	c6 45 70 00	 mov	 BYTE PTR $T5[rbp], 0
  000c4	4c 8d 45 70	 lea	 r8, QWORD PTR $T5[rbp]
  000c8	48 8b 95 d8 00
	00 00		 mov	 rdx, QWORD PTR tv95[rbp]
  000cf	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000d6	e8 00 00 00 00	 call	 ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool,0>
  000db	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR $T10[rbp]
  000e1	83 c8 01	 or	 eax, 1
  000e4	89 85 c0 00 00
	00		 mov	 DWORD PTR $T10[rbp], eax
  000ea	48 8d 4d 78	 lea	 rcx, QWORD PTR $T6[rbp]
  000ee	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  000f3	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000fa	e9 37 01 00 00	 jmp	 $LN1@emplace
$LN2@emplace:

; 610  :             }
; 611  : 
; 612  :             _Check_max_size();

  000ff	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00106	e8 00 00 00 00	 call	 ?_Check_max_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_max_size

; 613  :             // invalidates _Keyval:
; 614  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

  0010b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00112	48 83 c0 08	 add	 rax, 8
  00116	48 8b c8	 mov	 rcx, rax
  00119	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  0011e	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR <_Vals_0>$[rbp]
  00125	48 8b d0	 mov	 rdx, rax
  00128	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  0012c	e8 00 00 00 00	 call	 ??$?0AEB_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@AEB_K@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64 const &>
  00131	90		 npad	 1

; 615  :             if (_Check_rehash_required_1()) {

  00132	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00139	e8 00 00 00 00	 call	 ?_Check_rehash_required_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_rehash_required_1
  0013e	0f b6 c0	 movzx	 eax, al
  00141	85 c0		 test	 eax, eax
  00143	74 47		 je	 SHORT $LN3@emplace

; 616  :                 _Rehash_for_1();

  00145	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0014c	e8 00 00 00 00	 call	 ?_Rehash_for_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Rehash_for_1

; 617  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

  00151	48 8b 45 28	 mov	 rax, QWORD PTR _Newnode$4[rbp+8]
  00155	48 83 c0 10	 add	 rax, 16
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 ?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
  00161	4c 8b 4d 08	 mov	 r9, QWORD PTR _Hashval$2[rbp]
  00165	4c 8b c0	 mov	 r8, rax
  00168	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR $T7[rbp]
  0016f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00176	e8 00 00 00 00	 call	 ??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Find_last<unsigned __int64>
  0017b	48 8d 4d 10	 lea	 rcx, QWORD PTR _Target$3[rbp]
  0017f	48 8b f9	 mov	 rdi, rcx
  00182	48 8b f0	 mov	 rsi, rax
  00185	b9 10 00 00 00	 mov	 ecx, 16
  0018a	f3 a4		 rep movsb
$LN3@emplace:

; 618  :             }
; 619  : 
; 620  :             return {

  0018c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00193	48 83 c0 08	 add	 rax, 8
  00197	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv177[rbp], rax
  0019e	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  001a2	e8 00 00 00 00	 call	 ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Release
  001a7	4c 8b c8	 mov	 r9, rax
  001aa	4c 8b 45 10	 mov	 r8, QWORD PTR _Target$3[rbp]
  001ae	48 8b 55 08	 mov	 rdx, QWORD PTR _Hashval$2[rbp]
  001b2	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001b9	e8 00 00 00 00	 call	 ?_Insert_new_node_before@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@_KPEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Insert_new_node_before
  001be	4c 8b c0	 mov	 r8, rax
  001c1	48 8d 95 a8 00
	00 00		 lea	 rdx, QWORD PTR $T9[rbp]
  001c8	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR tv177[rbp]
  001cf	e8 00 00 00 00	 call	 ?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter
  001d4	48 89 85 d0 00
	00 00		 mov	 QWORD PTR tv193[rbp], rax
  001db	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR tv193[rbp]
  001e2	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv182[rbp], rax
  001e9	c6 85 a0 00 00
	00 01		 mov	 BYTE PTR $T8[rbp], 1
  001f0	4c 8d 85 a0 00
	00 00		 lea	 r8, QWORD PTR $T8[rbp]
  001f7	48 8b 95 d8 00
	00 00		 mov	 rdx, QWORD PTR tv182[rbp]
  001fe	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00205	e8 00 00 00 00	 call	 ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool,0>
  0020a	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR $T10[rbp]
  00210	83 c8 01	 or	 eax, 1
  00213	89 85 c0 00 00
	00		 mov	 DWORD PTR $T10[rbp], eax
  00219	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00220	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00225	90		 npad	 1
  00226	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  0022a	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >
  0022f	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@emplace:

; 621  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 622  :         } else {
; 623  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 624  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 625  :             const auto _Hashval = _Traitsobj(_Keyval);
; 626  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 627  :             if (_Target._Duplicate) {
; 628  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 629  :             }
; 630  : 
; 631  :             _Check_max_size();
; 632  :             if (_Check_rehash_required_1()) {
; 633  :                 _Rehash_for_1();
; 634  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);
; 635  :             }
; 636  : 
; 637  :             return {
; 638  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 639  :         }
; 640  :     }

  00236	48 8d a5 e0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+224]
  0023d	5f		 pop	 rdi
  0023e	5e		 pop	 rsi
  0023f	5d		 pop	 rbp
  00240	c3		 ret	 0
??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64 const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Keyval$1 = 0
_Hashval$2 = 8
_Target$3 = 16
_Newnode$4 = 32
$T5 = 112
$T6 = 120
$T7 = 144
$T8 = 160
$T9 = 168
$T10 = 192
tv177 = 200
tv90 = 200
tv75 = 200
tv193 = 208
tv186 = 208
tv182 = 216
tv95 = 216
this$ = 256
__$ReturnUdt$ = 264
<_Vals_0>$ = 272
?dtor$2@?0???$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z@4HA PROC ; `std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64 const &>'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$2@?0???$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z@4HA ENDP ; `std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64 const &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z
_TEXT	SEGMENT
_Keyval$1 = 0
_Hashval$2 = 8
_Target$3 = 16
_Newnode$4 = 32
$T5 = 112
$T6 = 120
$T7 = 144
$T8 = 160
$T9 = 168
$T10 = 192
tv177 = 200
tv90 = 200
tv75 = 200
tv193 = 208
tv186 = 208
tv182 = 216
tv95 = 216
this$ = 256
__$ReturnUdt$ = 264
<_Vals_0>$ = 272
??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64>, COMDAT

; 590  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR $T10[rbp], 0
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 591  :         // try to insert value_type(_Vals...)
; 592  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 593  :         if constexpr (_Multi) {
; 594  :             _Check_max_size();
; 595  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 596  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 597  :             const auto _Hashval = _Traitsobj(_Keyval);
; 598  :             if (_Check_rehash_required_1()) {
; 599  :                 _Rehash_for_1();
; 600  :             }
; 601  : 
; 602  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 603  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 604  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 605  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

  00034	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR <_Vals_0>$[rbp]
  0003b	e8 00 00 00 00	 call	 ?_Extract@?$_In_place_key_extract_set@_K_K@std@@SAAEB_KAEB_K@Z ; std::_In_place_key_extract_set<unsigned __int64,unsigned __int64>::_Extract
  00040	48 89 45 00	 mov	 QWORD PTR _Keyval$1[rbp], rax

; 606  :             const auto _Hashval = _Traitsobj(_Keyval);

  00044	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv75[rbp], rax
  00052	48 8b 55 00	 mov	 rdx, QWORD PTR _Keyval$1[rbp]
  00056	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR tv75[rbp]
  0005d	e8 00 00 00 00	 call	 ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
  00062	48 89 45 08	 mov	 QWORD PTR _Hashval$2[rbp], rax

; 607  :             auto _Target        = _Find_last(_Keyval, _Hashval);

  00066	4c 8b 4d 08	 mov	 r9, QWORD PTR _Hashval$2[rbp]
  0006a	4c 8b 45 00	 mov	 r8, QWORD PTR _Keyval$1[rbp]
  0006e	48 8d 55 10	 lea	 rdx, QWORD PTR _Target$3[rbp]
  00072	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00079	e8 00 00 00 00	 call	 ??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Find_last<unsigned __int64>

; 608  :             if (_Target._Duplicate) {

  0007e	48 83 7d 18 00	 cmp	 QWORD PTR _Target$3[rbp+8], 0
  00083	74 7a		 je	 SHORT $LN2@emplace

; 609  :                 return {_List._Make_iter(_Target._Duplicate), false};

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 83 c0 08	 add	 rax, 8
  00090	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv90[rbp], rax
  00097	4c 8b 45 18	 mov	 r8, QWORD PTR _Target$3[rbp+8]
  0009b	48 8d 55 78	 lea	 rdx, QWORD PTR $T6[rbp]
  0009f	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR tv90[rbp]
  000a6	e8 00 00 00 00	 call	 ?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter
  000ab	48 89 85 d0 00
	00 00		 mov	 QWORD PTR tv186[rbp], rax
  000b2	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR tv186[rbp]
  000b9	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv95[rbp], rax
  000c0	c6 45 70 00	 mov	 BYTE PTR $T5[rbp], 0
  000c4	4c 8d 45 70	 lea	 r8, QWORD PTR $T5[rbp]
  000c8	48 8b 95 d8 00
	00 00		 mov	 rdx, QWORD PTR tv95[rbp]
  000cf	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000d6	e8 00 00 00 00	 call	 ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool,0>
  000db	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR $T10[rbp]
  000e1	83 c8 01	 or	 eax, 1
  000e4	89 85 c0 00 00
	00		 mov	 DWORD PTR $T10[rbp], eax
  000ea	48 8d 4d 78	 lea	 rcx, QWORD PTR $T6[rbp]
  000ee	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  000f3	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000fa	e9 37 01 00 00	 jmp	 $LN1@emplace
$LN2@emplace:

; 610  :             }
; 611  : 
; 612  :             _Check_max_size();

  000ff	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00106	e8 00 00 00 00	 call	 ?_Check_max_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_max_size

; 613  :             // invalidates _Keyval:
; 614  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

  0010b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00112	48 83 c0 08	 add	 rax, 8
  00116	48 8b c8	 mov	 rcx, rax
  00119	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  0011e	4c 8b 85 10 01
	00 00		 mov	 r8, QWORD PTR <_Vals_0>$[rbp]
  00125	48 8b d0	 mov	 rdx, rax
  00128	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  0012c	e8 00 00 00 00	 call	 ??$?0_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@$$QEA_K@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > ><unsigned __int64>
  00131	90		 npad	 1

; 615  :             if (_Check_rehash_required_1()) {

  00132	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00139	e8 00 00 00 00	 call	 ?_Check_rehash_required_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_rehash_required_1
  0013e	0f b6 c0	 movzx	 eax, al
  00141	85 c0		 test	 eax, eax
  00143	74 47		 je	 SHORT $LN3@emplace

; 616  :                 _Rehash_for_1();

  00145	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0014c	e8 00 00 00 00	 call	 ?_Rehash_for_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Rehash_for_1

; 617  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

  00151	48 8b 45 28	 mov	 rax, QWORD PTR _Newnode$4[rbp+8]
  00155	48 83 c0 10	 add	 rax, 16
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 ?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
  00161	4c 8b 4d 08	 mov	 r9, QWORD PTR _Hashval$2[rbp]
  00165	4c 8b c0	 mov	 r8, rax
  00168	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR $T7[rbp]
  0016f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00176	e8 00 00 00 00	 call	 ??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Find_last<unsigned __int64>
  0017b	48 8d 4d 10	 lea	 rcx, QWORD PTR _Target$3[rbp]
  0017f	48 8b f9	 mov	 rdi, rcx
  00182	48 8b f0	 mov	 rsi, rax
  00185	b9 10 00 00 00	 mov	 ecx, 16
  0018a	f3 a4		 rep movsb
$LN3@emplace:

; 618  :             }
; 619  : 
; 620  :             return {

  0018c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00193	48 83 c0 08	 add	 rax, 8
  00197	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv177[rbp], rax
  0019e	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  001a2	e8 00 00 00 00	 call	 ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned __int64,void *> > >::_Release
  001a7	4c 8b c8	 mov	 r9, rax
  001aa	4c 8b 45 10	 mov	 r8, QWORD PTR _Target$3[rbp]
  001ae	48 8b 55 08	 mov	 rdx, QWORD PTR _Hashval$2[rbp]
  001b2	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001b9	e8 00 00 00 00	 call	 ?_Insert_new_node_before@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@_KPEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Insert_new_node_before
  001be	4c 8b c0	 mov	 r8, rax
  001c1	48 8d 95 a8 00
	00 00		 lea	 rdx, QWORD PTR $T9[rbp]
  001c8	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR tv177[rbp]
  001cf	e8 00 00 00 00	 call	 ?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter
  001d4	48 89 85 d0 00
	00 00		 mov	 QWORD PTR tv193[rbp], rax
  001db	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR tv193[rbp]
  001e2	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv182[rbp], rax
  001e9	c6 85 a0 00 00
	00 01		 mov	 BYTE PTR $T8[rbp], 1
  001f0	4c 8d 85 a0 00
	00 00		 lea	 r8, QWORD PTR $T8[rbp]
  001f7	48 8b 95 d8 00
	00 00		 mov	 rdx, QWORD PTR tv182[rbp]
  001fe	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00205	e8 00 00 00 00	 call	 ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool,0>
  0020a	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR $T10[rbp]
  00210	83 c8 01	 or	 eax, 1
  00213	89 85 c0 00 00
	00		 mov	 DWORD PTR $T10[rbp], eax
  00219	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00220	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00225	90		 npad	 1
  00226	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  0022a	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >
  0022f	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@emplace:

; 621  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 622  :         } else {
; 623  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 624  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 625  :             const auto _Hashval = _Traitsobj(_Keyval);
; 626  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 627  :             if (_Target._Duplicate) {
; 628  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 629  :             }
; 630  : 
; 631  :             _Check_max_size();
; 632  :             if (_Check_rehash_required_1()) {
; 633  :                 _Rehash_for_1();
; 634  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);
; 635  :             }
; 636  : 
; 637  :             return {
; 638  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 639  :         }
; 640  :     }

  00236	48 8d a5 e0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+224]
  0023d	5f		 pop	 rdi
  0023e	5e		 pop	 rsi
  0023f	5d		 pop	 rbp
  00240	c3		 ret	 0
??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Keyval$1 = 0
_Hashval$2 = 8
_Target$3 = 16
_Newnode$4 = 32
$T5 = 112
$T6 = 120
$T7 = 144
$T8 = 160
$T9 = 168
$T10 = 192
tv177 = 200
tv90 = 200
tv75 = 200
tv193 = 208
tv186 = 208
tv182 = 216
tv95 = 216
this$ = 256
__$ReturnUdt$ = 264
<_Vals_0>$ = 272
?dtor$2@?0???$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z@4HA PROC ; `std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64>'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Newnode$4[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned __int64,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$2@?0???$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z@4HA ENDP ; `std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1135 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1136 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1137 :     using _Ty = typename _Alloc::value_type;
; 1138 :     _Ptr->~_Ty();
; 1139 :     _Deallocate_plain(_Al, _Ptr);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00028	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >

; 1140 : }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ; std::_Get_size_of_n<16>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bb	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@XZ PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>::~pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??1?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@XZ ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>::~pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >,bool>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QEAA@AEBU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8b 4d 58	 mov	 rcx, QWORD PTR __that$[rbp]
  00029	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QEAA@XZ ; std::_Iterator_base12::~_Iterator_base12
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Pnode$ = 88
_Plist$ = 96
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00029	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QEAA@XZ ; std::_Iterator_base12::_Iterator_base12
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 4d 58	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  00036	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 38   :         this->_Adopt(_Plist);

  0003a	48 8b 55 60	 mov	 rdx, QWORD PTR _Plist$[rbp]
  0003e	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00042	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 39   :     }

  00047	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\unordered_map
;	COMDAT ??$insert@U?$pair@_KUBucket@@@std@@$0A@@?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
__$ReturnUdt$ = 104
_Val$ = 112
??$insert@U?$pair@_KUBucket@@@std@@$0A@@?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z PROC ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::insert<std::pair<unsigned __int64,Bucket>,0>, COMDAT

; 274  :     pair<iterator, bool> insert(_Valty&& _Val) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	c7 45 40 00 00
	00 00		 mov	 DWORD PTR $T1[rbp], 0
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DA11C4D_unordered_map
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 275  :         return this->emplace(_STD forward<_Valty>(_Val));

  0002c	4c 8b 45 70	 mov	 r8, QWORD PTR _Val$[rbp]
  00030	48 8b 55 68	 mov	 rdx, QWORD PTR __$ReturnUdt$[rbp]
  00034	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ??$emplace@U?$pair@_KUBucket@@@std@@@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::emplace<std::pair<unsigned __int64,Bucket> >
  0003d	8b 45 40	 mov	 eax, DWORD PTR $T1[rbp]
  00040	83 c8 01	 or	 eax, 1
  00043	89 45 40	 mov	 DWORD PTR $T1[rbp], eax
  00046	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 276  :     }

  0004a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
??$insert@U?$pair@_KUBucket@@@std@@$0A@@?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z ENDP ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::insert<std::pair<unsigned __int64,Bucket>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$?0_KUBucket@@$0A@@?$pair@$$CB_KUBucket@@@std@@QEAA@$$QEAU?$pair@_KUBucket@@@1@@Z
_TEXT	SEGMENT
this$ = 96
_Right$ = 104
??$?0_KUBucket@@$0A@@?$pair@$$CB_KUBucket@@@std@@QEAA@$$QEAU?$pair@_KUBucket@@@1@@Z PROC ; std::pair<unsigned __int64 const ,Bucket>::pair<unsigned __int64 const ,Bucket><unsigned __int64,Bucket,0>, COMDAT

; 278  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00022	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00026	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  0002a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00038	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  0003c	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  00040	b9 18 00 00 00	 mov	 ecx, 24
  00045	f3 a4		 rep movsb
  00047	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004f	5f		 pop	 rdi
  00050	5e		 pop	 rsi
  00051	5d		 pop	 rbp
  00052	c3		 ret	 0
??$?0_KUBucket@@$0A@@?$pair@$$CB_KUBucket@@@std@@QEAA@$$QEAU?$pair@_KUBucket@@@1@@Z ENDP ; std::pair<unsigned __int64 const ,Bucket>::pair<unsigned __int64 const ,Bucket><unsigned __int64,Bucket,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$make_pair@AEA_KAEAUBucket@@@std@@YA?AU?$pair@_KUBucket@@@0@AEA_KAEAUBucket@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 80
_Val1$ = 88
_Val2$ = 96
??$make_pair@AEA_KAEAUBucket@@@std@@YA?AU?$pair@_KUBucket@@@0@AEA_KAEAUBucket@@@Z PROC ; std::make_pair<unsigned __int64 &,Bucket &>, COMDAT

; 567  :         is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>) /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 568  :     // return pair composed from arguments
; 569  :     using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 570  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

  00025	4c 8b 45 60	 mov	 r8, QWORD PTR _Val2$[rbp]
  00029	48 8b 55 58	 mov	 rdx, QWORD PTR _Val1$[rbp]
  0002d	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00031	e8 00 00 00 00	 call	 ??$?0AEA_KAEAUBucket@@$0A@@?$pair@_KUBucket@@@std@@QEAA@AEA_KAEAUBucket@@@Z ; std::pair<unsigned __int64,Bucket>::pair<unsigned __int64,Bucket><unsigned __int64 &,Bucket &,0>
  00036	48 8b 45 50	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 571  : }

  0003a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
??$make_pair@AEA_KAEAUBucket@@@std@@YA?AU?$pair@_KUBucket@@@0@AEA_KAEAUBucket@@@Z ENDP ; std::make_pair<unsigned __int64 &,Bucket &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z
_TEXT	SEGMENT
tv73 = 64
tv76 = 72
this$ = 96
_Keyval1$ = 104
_Keyval2$ = 112
??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>, COMDAT

; 154  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 155  :         // test if _Keyval1 NOT equal to _Keyval2
; 156  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
  00031	48 89 45 40	 mov	 QWORD PTR tv73[rbp], rax
  00035	4c 8b 45 70	 mov	 r8, QWORD PTR _Keyval2$[rbp]
  00039	48 8b 55 68	 mov	 rdx, QWORD PTR _Keyval1$[rbp]
  0003d	48 8b 4d 40	 mov	 rcx, QWORD PTR tv73[rbp]
  00041	e8 00 00 00 00	 call	 ??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z ; std::equal_to<unsigned __int64>::operator()
  00046	0f b6 c0	 movzx	 eax, al
  00049	85 c0		 test	 eax, eax
  0004b	75 09		 jne	 SHORT $LN3@operator
  0004d	c7 45 48 01 00
	00 00		 mov	 DWORD PTR tv76[rbp], 1
  00054	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00056	c7 45 48 00 00
	00 00		 mov	 DWORD PTR tv76[rbp], 0
$LN4@operator:
  0005d	0f b6 45 48	 movzx	 eax, BYTE PTR tv76[rbp]

; 157  :     }

  00061	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00065	5d		 pop	 rbp
  00066	c3		 ret	 0
??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
tv75 = 64
this$ = 96
_Keyval$ = 104
??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>, COMDAT

; 147  :     _NODISCARD size_t operator()(const _Keyty& _Keyval) const noexcept(_Nothrow_hash<_Hasher, _Keyty>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 148  :         // hash _Keyval to size_t value
; 149  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
  0002c	48 89 45 40	 mov	 QWORD PTR tv75[rbp], rax
  00030	48 8b 55 68	 mov	 rdx, QWORD PTR _Keyval$[rbp]
  00034	48 8b 4d 40	 mov	 rcx, QWORD PTR tv75[rbp]
  00038	e8 00 00 00 00	 call	 ??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()

; 150  :     }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z
_TEXT	SEGMENT
_Hashval$ = 0
_Target$1 = 8
$T2 = 80
tv91 = 96
tv73 = 96
this$ = 128
_Keyval$ = 136
??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Erase<unsigned __int64>, COMDAT

; 1106 :     size_type _Erase(const _Keytype& _Keyval) noexcept(_Noexcept_heterogeneous_erasure<_Keytype>()) /* strengthened */ {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1107 :         const size_t _Hashval = _Traitsobj(_Keyval);

  00023	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 89 45 60	 mov	 QWORD PTR tv73[rbp], rax
  0002e	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR _Keyval$[rbp]
  00035	48 8b 4d 60	 mov	 rcx, QWORD PTR tv73[rbp]
  00039	e8 00 00 00 00	 call	 ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
  0003e	48 89 45 00	 mov	 QWORD PTR _Hashval$[rbp], rax

; 1108 :         if constexpr (_Multi) {
; 1109 :             const auto _Where = _Equal_range(_Keyval, _Hashval);
; 1110 :             _Unchecked_erase(_Where._First._Ptr, _Where._Last._Ptr);
; 1111 :             return _Where._Distance;
; 1112 :         } else {
; 1113 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

  00042	4c 8b 4d 00	 mov	 r9, QWORD PTR _Hashval$[rbp]
  00046	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR _Keyval$[rbp]
  0004d	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  00051	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00058	e8 00 00 00 00	 call	 ??$_Find_last@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@_KPEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Find_last<unsigned __int64>
  0005d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00061	48 89 45 08	 mov	 QWORD PTR _Target$1[rbp], rax

; 1114 :             if (_Target) {

  00065	48 83 7d 08 00	 cmp	 QWORD PTR _Target$1[rbp], 0
  0006a	74 4b		 je	 SHORT $LN2@Erase

; 1115 :                 _Erase_bucket(_Target, _Hashval & _Mask);

  0006c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00073	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00077	48 8b 4d 00	 mov	 rcx, QWORD PTR _Hashval$[rbp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	4c 8b c0	 mov	 r8, rax
  00084	48 8b 55 08	 mov	 rdx, QWORD PTR _Target$1[rbp]
  00088	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0008f	e8 00 00 00 00	 call	 ?_Erase_bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@_KPEAX@2@_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Erase_bucket

; 1116 :                 _List._Unchecked_erase(_Target);

  00094	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0009b	48 83 c0 08	 add	 rax, 8
  0009f	48 89 45 60	 mov	 QWORD PTR tv91[rbp], rax
  000a3	48 8b 55 08	 mov	 rdx, QWORD PTR _Target$1[rbp]
  000a7	48 8b 4d 60	 mov	 rcx, QWORD PTR tv91[rbp]
  000ab	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@QEAU32@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_erase

; 1117 :                 return 1;

  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	eb 02		 jmp	 SHORT $LN1@Erase
$LN2@Erase:

; 1118 :             }
; 1119 : 
; 1120 :             return 0;

  000b7	33 c0		 xor	 eax, eax
$LN1@Erase:

; 1121 :         }
; 1122 :     }

  000b9	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000bd	5d		 pop	 rbp
  000be	c3		 ret	 0
??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Erase<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 96
$T4 = 104
$T5 = 128
$T6 = 136
$T7 = 137
$T8 = 140
tv135 = 144
tv94 = 152
tv137 = 160
tv83 = 168
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z PROC ; std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >, COMDAT

; 6860 : _NODISCARD constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { // find smallest element

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	c7 85 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR $T8[rbp], 0
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0002e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6861 :     return _STD min_element(_First, _Last, less<>{});

  00033	48 8d 45 40	 lea	 rax, QWORD PTR $T1[rbp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 01 00 00 00	 mov	 ecx, 1
  00041	f3 aa		 rep stosb
  00043	0f b6 45 40	 movzx	 eax, BYTE PTR $T1[rbp]
  00047	88 85 88 00 00
	00		 mov	 BYTE PTR $T6[rbp], al
  0004d	0f b6 85 88 00
	00 00		 movzx	 eax, BYTE PTR $T6[rbp]
  00054	88 85 89 00 00
	00		 mov	 BYTE PTR $T7[rbp], al
  0005a	48 8d 45 48	 lea	 rax, QWORD PTR $T2[rbp]
  0005e	48 89 45 60	 mov	 QWORD PTR $T3[rbp], rax
  00062	48 8b 95 e0 00
	00 00		 mov	 rdx, QWORD PTR _Last$[rbp]
  00069	48 8b 4d 60	 mov	 rcx, QWORD PTR $T3[rbp]
  0006d	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@AEBV01@@Z
  00072	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv135[rbp], rax
  00079	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR tv135[rbp]
  00080	48 89 85 98 00
	00 00		 mov	 QWORD PTR tv94[rbp], rax
  00087	48 8d 45 68	 lea	 rax, QWORD PTR $T4[rbp]
  0008b	48 89 85 80 00
	00 00		 mov	 QWORD PTR $T5[rbp], rax
  00092	48 8b 95 d8 00
	00 00		 mov	 rdx, QWORD PTR _First$[rbp]
  00099	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR $T5[rbp]
  000a0	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@AEBV01@@Z
  000a5	48 89 85 a0 00
	00 00		 mov	 QWORD PTR tv137[rbp], rax
  000ac	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR tv137[rbp]
  000b3	48 89 85 a8 00
	00 00		 mov	 QWORD PTR tv83[rbp], rax
  000ba	44 0f b6 8d 89
	00 00 00	 movzx	 r9d, BYTE PTR $T7[rbp]
  000c2	4c 8b 85 98 00
	00 00		 mov	 r8, QWORD PTR tv94[rbp]
  000c9	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR tv83[rbp]
  000d0	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000d7	e8 00 00 00 00	 call	 ??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@U?$less@X@2@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0U?$less@X@0@@Z ; std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,std::less<void> >
  000dc	8b 85 8c 00 00
	00		 mov	 eax, DWORD PTR $T8[rbp]
  000e2	83 c8 01	 or	 eax, 1
  000e5	89 85 8c 00 00
	00		 mov	 DWORD PTR $T8[rbp], eax
  000eb	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR _First$[rbp]
  000f2	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  000f7	90		 npad	 1
  000f8	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  000ff	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00104	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 6862 : }

  0010b	48 8d a5 b8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+184]
  00112	5f		 pop	 rdi
  00113	5d		 pop	 rbp
  00114	c3		 ret	 0
??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z ENDP ; std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 96
$T4 = 104
$T5 = 128
$T6 = 136
$T7 = 137
$T8 = 140
tv135 = 144
tv94 = 152
tv137 = 160
tv83 = 168
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA PROC ; `std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA ENDP ; `std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 96
$T4 = 104
$T5 = 128
$T6 = 136
$T7 = 137
$T8 = 140
tv135 = 144
tv94 = 152
tv137 = 160
tv83 = 168
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA PROC ; `std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR _First$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$1@?0???$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z@4HA ENDP ; `std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 80
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator++, COMDAT

; 106  :     _List_unchecked_iterator& operator++() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 107  :         _Mybase::operator++();

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator++

; 108  :         return *this;

  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 109  :     }

  00028	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUBucket@@@1@XZ
_TEXT	SEGMENT
this$ = 80
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUBucket@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator*, COMDAT

; 98   :     _NODISCARD reference operator*() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 99   :         return const_cast<reference>(_Mybase::operator*());

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator*

; 100  :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUBucket@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 64
this$ = 96
_Right$ = 104
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 72   :         return _Ptr == _Right._Ptr;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	75 09		 jne	 SHORT $LN3@operator
  00030	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv67[rbp], 1
  00037	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00039	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv67[rbp], 0
$LN4@operator:
  00040	0f b6 45 40	 movzx	 eax, BYTE PTR tv67[rbp]

; 73   :     }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 80
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator--, COMDAT

; 60   :     _List_unchecked_const_iterator& operator--() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 61   :         _Ptr = _Ptr->_Prev;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 62   :         return *this;

  0002d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 63   :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 80
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 50   :         _Ptr = _Ptr->_Next;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 01	 mov	 QWORD PTR [rcx], rax

; 51   :         return *this;

  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 52   :     }

  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ
_TEXT	SEGMENT
this$ = 80
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 42   :         return _Ptr->_Myval;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 83 c0 10	 add	 rax, 16

; 43   :     }

  00026	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Pnode$ = 88
_Plist$ = 96
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

  00030	48 8b 55 60	 mov	 rdx, QWORD PTR _Plist$[rbp]
  00034	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt

; 39   :     }

  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@XZ PROC ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::~pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??1?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@XZ ENDP ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>::~pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >,bool>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::~_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::~_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
this$ = 80
_It$ = 88
?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_Seek_to, COMDAT

; 218  :     void _Seek_to(const _List_unchecked_const_iterator<_Mylist> _It) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 219  :         this->_Ptr = _It._Ptr;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _It$[rbp]
  00028	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 220  :     }

  0002c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00030	5d		 pop	 rbp
  00031	c3		 ret	 0
?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
tv86 = 64
tv84 = 72
this$ = 96
__$ReturnUdt$ = 104
?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_Unwrapped, COMDAT

; 214  :     _NODISCARD _List_unchecked_const_iterator<_Mylist> _Unwrapped() const noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 215  :         return _List_unchecked_const_iterator<_Mylist>(this->_Ptr, static_cast<const _Mylist*>(this->_Getcont()));

  00020	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00024	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00029	48 89 45 40	 mov	 QWORD PTR tv86[rbp], rax
  0002d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00035	48 89 45 48	 mov	 QWORD PTR tv84[rbp], rax
  00039	4c 8b 45 40	 mov	 r8, QWORD PTR tv86[rbp]
  0003d	48 8b 55 48	 mov	 rdx, QWORD PTR tv84[rbp]
  00041	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00045	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>
  0004a	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 216  :     }

  0004e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Verify_range@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@0@Z
_TEXT	SEGMENT
tv69 = 64
_First$ = 96
_Last$ = 104
?_Verify_range@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@0@Z PROC ; std::_Verify_range, COMDAT

; 207  :     friend void _Verify_range(const _List_const_iterator& _First, const _List_const_iterator& _Last) noexcept {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@Verify_ran:

; 208  :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "list iterators in range are from different containers");

  00023	48 8b 4d 60	 mov	 rcx, QWORD PTR _First$[rbp]
  00027	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002c	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  00030	48 8b 4d 68	 mov	 rcx, QWORD PTR _Last$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00039	48 8b 4d 40	 mov	 rcx, QWORD PTR tv69[rbp]
  0003d	48 3b c8	 cmp	 rcx, rax
  00040	75 02		 jne	 SHORT $LN7@Verify_ran
  00042	eb 6b		 jmp	 SHORT $LN9@Verify_ran
$LN7@Verify_ran:
  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@GAGDEJEE@list?5iterators?5in?5range?5are?5fro@
  0004b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00057	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005c	45 33 c9	 xor	 r9d, r9d
  0005f	41 b8 d0 00 00
	00		 mov	 r8d, 208		; 000000d0H
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@
  0006c	b9 02 00 00 00	 mov	 ecx, 2
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00077	83 f8 01	 cmp	 eax, 1
  0007a	75 03		 jne	 SHORT $LN11@Verify_ran
  0007c	cc		 int	 3
  0007d	33 c0		 xor	 eax, eax
$LN11@Verify_ran:
  0007f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00088	41 b9 d0 00 00
	00		 mov	 r9d, 208		; 000000d0H
  0008e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@KAMKPLHN@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs@
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 95		 jne	 SHORT $LN7@Verify_ran
$LN9@Verify_ran:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	0f 85 6a ff ff
	ff		 jne	 $LN4@Verify_ran

; 209  :     }

  000b9	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000bd	5d		 pop	 rbp
  000be	c3		 ret	 0
?_Verify_range@std@@YAXAEBV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@1@0@Z ENDP ; std::_Verify_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBAAEB_KXZ
_TEXT	SEGMENT
_Mycont$ = 0
this$ = 96
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBAAEB_KXZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());

  0001e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00022	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00027	48 89 45 00	 mov	 QWORD PTR _Mycont$[rbp], rax
$LN4@operator:

; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");

  0002b	48 83 7d 00 00	 cmp	 QWORD PTR _Mycont$[rbp], 0
  00030	74 02		 je	 SHORT $LN7@operator
  00032	eb 6b		 jmp	 SHORT $LN15@operator
$LN7@operator:
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DD@MBIHGLJE@cannot?5dereference?5value?9initia@
  0003b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00047	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004c	45 33 c9	 xor	 r9d, r9d
  0004f	41 b8 92 00 00
	00		 mov	 r8d, 146		; 00000092H
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@
  0005c	b9 02 00 00 00	 mov	 ecx, 2
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00067	83 f8 01	 cmp	 eax, 1
  0006a	75 03		 jne	 SHORT $LN19@operator
  0006c	cc		 int	 3
  0006d	33 c0		 xor	 eax, eax
$LN19@operator:
  0006f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00078	41 b9 92 00 00
	00		 mov	 r9d, 146		; 00000092H
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GK@NKIMOCIG@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 95		 jne	 SHORT $LN7@operator
$LN15@operator:
  0009f	33 c0		 xor	 eax, eax
  000a1	85 c0		 test	 eax, eax
  000a3	75 86		 jne	 SHORT $LN4@operator
$LN10@operator:

; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");

  000a5	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000a9	48 8b 4d 00	 mov	 rcx, QWORD PTR _Mycont$[rbp]
  000ad	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b1	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000b5	74 02		 je	 SHORT $LN13@operator
  000b7	eb 6b		 jmp	 SHORT $LN17@operator
$LN13@operator:
  000b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@JCBFHMPL@cannot?5dereference?5end?5list?5ite@
  000c0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  000cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d1	45 33 c9	 xor	 r9d, r9d
  000d4	41 b8 93 00 00
	00		 mov	 r8d, 147		; 00000093H
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@
  000e1	b9 02 00 00 00	 mov	 ecx, 2
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  000ec	83 f8 01	 cmp	 eax, 1
  000ef	75 03		 jne	 SHORT $LN20@operator
  000f1	cc		 int	 3
  000f2	33 c0		 xor	 eax, eax
$LN20@operator:
  000f4	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000fd	41 b9 93 00 00
	00		 mov	 r9d, 147		; 00000093H
  00103	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@CNEFBDCF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 95		 jne	 SHORT $LN13@operator
$LN17@operator:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	0f 85 77 ff ff
	ff		 jne	 $LN10@operator

; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

  0012e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00132	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00136	48 83 c0 10	 add	 rax, 16

; 151  :     }

  0013a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0013e	5d		 pop	 rbp
  0013f	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBAAEB_KXZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QEAA@AEBU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8b 4d 58	 mov	 rcx, QWORD PTR __that$[rbp]
  00029	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QEAA@AEBU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8b 4d 58	 mov	 rcx, QWORD PTR __that$[rbp]
  00029	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QEAA@XZ ; std::_Iterator_base12::~_Iterator_base12
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Pnode$ = 88
_Plist$ = 96
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00029	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QEAA@XZ ; std::_Iterator_base12::_Iterator_base12
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 4d 58	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  00036	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 38   :         this->_Adopt(_Plist);

  0003a	48 8b 55 60	 mov	 rdx, QWORD PTR _Plist$[rbp]
  0003e	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00042	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 39   :     }

  00047	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.cpp
;	COMDAT ??1TMemory@@QEAA@XZ
_TEXT	SEGMENT
<range>$L0$1 = 0
<begin>$L0$2 = 8
<end>$L0$3 = 16
i$4 = 24
this$ = 112
??1TMemory@@QEAA@XZ PROC				; TMemory::~TMemory, COMDAT

; 9    : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__AA61B192_TMemory@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 10   :     for (auto& i : m_Buckets)

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 89 45 00	 mov	 QWORD PTR <range>$L0$1[rbp], rax
  00026	48 8d 55 08	 lea	 rdx, QWORD PTR <begin>$L0$2[rbp]
  0002a	48 8b 4d 00	 mov	 rcx, QWORD PTR <range>$L0$1[rbp]
  0002e	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_begin
  00033	48 8d 55 10	 lea	 rdx, QWORD PTR <end>$L0$3[rbp]
  00037	48 8b 4d 00	 mov	 rcx, QWORD PTR <range>$L0$1[rbp]
  0003b	e8 00 00 00 00	 call	 ?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_end
  00040	eb 09		 jmp	 SHORT $LN4@TMemory
$LN2@TMemory:
  00042	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  00046	e8 00 00 00 00	 call	 ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator++
$LN4@TMemory:
  0004b	48 8d 55 10	 lea	 rdx, QWORD PTR <end>$L0$3[rbp]
  0004f	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  00053	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator==
  00058	0f b6 c0	 movzx	 eax, al
  0005b	85 c0		 test	 eax, eax
  0005d	75 23		 jne	 SHORT $LN3@TMemory
  0005f	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  00063	e8 00 00 00 00	 call	 ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUBucket@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator*
  00068	48 89 45 18	 mov	 QWORD PTR i$4[rbp], rax

; 11   :     {
; 12   :         Delete(i.second);

  0006c	48 8b 45 18	 mov	 rax, QWORD PTR i$4[rbp]
  00070	48 83 c0 08	 add	 rax, 8
  00074	48 8b d0	 mov	 rdx, rax
  00077	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0007b	e8 00 00 00 00	 call	 ?Delete@TMemory@@QEAAXAEAUBucket@@@Z ; TMemory::Delete

; 13   :     }

  00080	eb c0		 jmp	 SHORT $LN2@TMemory
$LN3@TMemory:

; 14   : 
; 15   : }

  00082	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00086	48 83 c0 50	 add	 rax, 80			; 00000050H
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 ??1?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ
  00092	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00096	48 8b c8	 mov	 rcx, rax
  00099	e8 00 00 00 00	 call	 ??1?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ
  0009e	90		 npad	 1
  0009f	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a3	5d		 pop	 rbp
  000a4	c3		 ret	 0
??1TMemory@@QEAA@XZ ENDP				; TMemory::~TMemory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.cpp
;	COMDAT ?Delete@TMemory@@QEAAXAEAUBucket@@@Z
_TEXT	SEGMENT
$T1 = 64
tv80 = 96
this$ = 128
bucket$ = 136
?Delete@TMemory@@QEAAXAEAUBucket@@@Z PROC		; TMemory::Delete, COMDAT

; 49   : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__AA61B192_TMemory@cpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 50   :     if (bucket.ptr)

  00023	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR bucket$[rbp]
  0002a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0002e	74 51		 je	 SHORT $LN2@Delete

; 51   :     {
; 52   :         free(bucket.ptr);

  00030	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR bucket$[rbp]
  00037	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 53   :         bucket.ptr = nullptr;

  00040	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR bucket$[rbp]
  00047	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 54   :         m_FreeId.insert(bucket.id);

  0004e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00055	48 83 c0 50	 add	 rax, 80			; 00000050H
  00059	48 89 45 60	 mov	 QWORD PTR tv80[rbp], rax
  0005d	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR bucket$[rbp]
  00064	48 83 c0 10	 add	 rax, 16
  00068	4c 8b c0	 mov	 r8, rax
  0006b	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0006f	48 8b 4d 60	 mov	 rcx, QWORD PTR tv80[rbp]
  00073	e8 00 00 00 00	 call	 ?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@AEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::insert
  00078	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0007c	e8 00 00 00 00	 call	 ??1?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@XZ
$LN2@Delete:

; 55   :     }
; 56   : 
; 57   :     bucket.id = 0;

  00081	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR bucket$[rbp]
  00088	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 58   :     bucket.sizePointer = 0;

  00090	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR bucket$[rbp]
  00097	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 59   : }

  0009f	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000a3	5d		 pop	 rbp
  000a4	c3		 ret	 0
?Delete@TMemory@@QEAAXAEAUBucket@@@Z ENDP		; TMemory::Delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.cpp
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.h
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.cpp
;	COMDAT ?Allocate@TMemory@@QEAA?AUBucket@@_K@Z
_TEXT	SEGMENT
bucket$ = 0
m$ = 24
$T1 = 96
$T2 = 120
$T3 = 128
$T4 = 152
$T5 = 160
$T6 = 184
$T7 = 216
tv178 = 248
tv155 = 248
tv150 = 248
tv80 = 248
tv182 = 256
tv133 = 264
tv128 = 272
tv184 = 280
tv83 = 288
tv186 = 296
this$ = 336
__$ReturnUdt$ = 344
size$ = 352
?Allocate@TMemory@@QEAA?AUBucket@@_K@Z PROC		; TMemory::Allocate, COMDAT

; 20   : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__AA61B192_TMemory@cpp
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.h

; 10   : 	void* ptr = nullptr;

  0002a	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR bucket$[rbp], 0

; 11   : 	size_t sizePointer = 0;

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR bucket$[rbp+8], 0

; 12   : 	uint64_t id = UINT64_MAX;

  0003a	48 c7 45 10 ff
	ff ff ff	 mov	 QWORD PTR bucket$[rbp+16], -1
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.cpp

; 22   :     uint64_t m = *std::min_element(m_FreeId.begin(), m_FreeId.end());

  00042	48 8d 45 60	 lea	 rax, QWORD PTR $T1[rbp]
  00046	48 89 45 78	 mov	 QWORD PTR $T2[rbp], rax
  0004a	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00051	48 83 c0 50	 add	 rax, 80			; 00000050H
  00055	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv80[rbp], rax
  0005c	48 8b 55 78	 mov	 rdx, QWORD PTR $T2[rbp]
  00060	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR tv80[rbp]
  00067	e8 00 00 00 00	 call	 ?end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::end
  0006c	48 89 85 00 01
	00 00		 mov	 QWORD PTR tv182[rbp], rax
  00073	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR tv182[rbp]
  0007a	48 89 85 08 01
	00 00		 mov	 QWORD PTR tv133[rbp], rax
  00081	48 8d 85 80 00
	00 00		 lea	 rax, QWORD PTR $T3[rbp]
  00088	48 89 85 98 00
	00 00		 mov	 QWORD PTR $T4[rbp], rax
  0008f	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00096	48 83 c0 50	 add	 rax, 80			; 00000050H
  0009a	48 89 85 10 01
	00 00		 mov	 QWORD PTR tv128[rbp], rax
  000a1	48 8b 95 98 00
	00 00		 mov	 rdx, QWORD PTR $T4[rbp]
  000a8	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR tv128[rbp]
  000af	e8 00 00 00 00	 call	 ?begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::begin
  000b4	48 89 85 18 01
	00 00		 mov	 QWORD PTR tv184[rbp], rax
  000bb	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv184[rbp]
  000c2	48 89 85 20 01
	00 00		 mov	 QWORD PTR tv83[rbp], rax
  000c9	4c 8b 85 08 01
	00 00		 mov	 r8, QWORD PTR tv133[rbp]
  000d0	48 8b 95 20 01
	00 00		 mov	 rdx, QWORD PTR tv83[rbp]
  000d7	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  000de	e8 00 00 00 00	 call	 ??$min_element@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@@std@@YA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@0@V10@0@Z ; std::min_element<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > > >
  000e3	48 89 85 28 01
	00 00		 mov	 QWORD PTR tv186[rbp], rax
  000ea	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR tv186[rbp]
  000f1	e8 00 00 00 00	 call	 ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEBAAEB_KXZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> > >::operator*
  000f6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f9	48 89 45 18	 mov	 QWORD PTR m$[rbp], rax
  000fd	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  00104	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ

; 23   : 
; 24   : 
; 25   :     if (m < id_counter)

  00109	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00110	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00117	48 39 45 18	 cmp	 QWORD PTR m$[rbp], rax
  0011b	73 2c		 jae	 SHORT $LN2@Allocate

; 26   :     {
; 27   :         m_FreeId.erase(m);

  0011d	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00124	48 83 c0 50	 add	 rax, 80			; 00000050H
  00128	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv150[rbp], rax
  0012f	48 8d 55 18	 lea	 rdx, QWORD PTR m$[rbp]
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR tv150[rbp]
  0013a	e8 00 00 00 00	 call	 ?erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA_KAEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::erase

; 28   :         bucket.id = m;

  0013f	48 8b 45 18	 mov	 rax, QWORD PTR m$[rbp]
  00143	48 89 45 10	 mov	 QWORD PTR bucket$[rbp+16], rax

; 29   :     }

  00147	eb 3f		 jmp	 SHORT $LN3@Allocate
$LN2@Allocate:

; 30   :     else
; 31   :         bucket.id = id_counter++;

  00149	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00150	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00157	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv155[rbp], rax
  0015e	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00165	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0016c	48 ff c0	 inc	 rax
  0016f	48 8b 8d 50 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00176	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax
  0017d	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR tv155[rbp]
  00184	48 89 45 10	 mov	 QWORD PTR bucket$[rbp+16], rax
$LN3@Allocate:

; 32   : 
; 33   :     bucket.sizePointer = size;

  00188	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR size$[rbp]
  0018f	48 89 45 08	 mov	 QWORD PTR bucket$[rbp+8], rax

; 34   :     bucket.ptr = malloc(size);

  00193	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR size$[rbp]
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001a0	48 89 45 00	 mov	 QWORD PTR bucket$[rbp], rax

; 35   :     if (!bucket.ptr)

  001a4	48 83 7d 00 00	 cmp	 QWORD PTR bucket$[rbp], 0
  001a9	75 2f		 jne	 SHORT $LN4@Allocate

; 36   :     {
; 37   :         free(bucket.ptr);

  001ab	48 8b 4d 00	 mov	 rcx, QWORD PTR bucket$[rbp]
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 38   :         return Bucket();

  001b5	48 8b bd 58 01
	00 00		 mov	 rdi, QWORD PTR __$ReturnUdt$[rbp]
  001bc	33 c0		 xor	 eax, eax
  001be	b9 18 00 00 00	 mov	 ecx, 24
  001c3	f3 aa		 rep stosb
  001c5	48 8b 8d 58 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  001cc	e8 00 00 00 00	 call	 ??0Bucket@@QEAA@XZ
  001d1	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  001d8	eb 60		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 39   :     }
; 40   :    
; 41   :     m_Buckets.insert(std::make_pair(bucket.id, bucket));

  001da	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001e1	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv178[rbp], rax
  001e8	4c 8d 45 00	 lea	 r8, QWORD PTR bucket$[rbp]
  001ec	48 8d 55 10	 lea	 rdx, QWORD PTR bucket$[rbp+16]
  001f0	48 8d 8d b8 00
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  001f7	e8 00 00 00 00	 call	 ??$make_pair@AEA_KAEAUBucket@@@std@@YA?AU?$pair@_KUBucket@@@0@AEA_KAEAUBucket@@@Z ; std::make_pair<unsigned __int64 &,Bucket &>
  001fc	4c 8b c0	 mov	 r8, rax
  001ff	48 8d 95 d8 00
	00 00		 lea	 rdx, QWORD PTR $T7[rbp]
  00206	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR tv178[rbp]
  0020d	e8 00 00 00 00	 call	 ??$insert@U?$pair@_KUBucket@@@std@@$0A@@?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@_KUBucket@@@1@@Z ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::insert<std::pair<unsigned __int64,Bucket>,0>
  00212	48 8d 8d d8 00
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  00219	e8 00 00 00 00	 call	 ??1?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@_N@std@@QEAA@XZ

; 42   : 
; 43   : 
; 44   :     return bucket;

  0021e	48 8d 45 00	 lea	 rax, QWORD PTR bucket$[rbp]
  00222	48 8b bd 58 01
	00 00		 mov	 rdi, QWORD PTR __$ReturnUdt$[rbp]
  00229	48 8b f0	 mov	 rsi, rax
  0022c	b9 18 00 00 00	 mov	 ecx, 24
  00231	f3 a4		 rep movsb
  00233	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@Allocate:

; 45   : }

  0023a	48 8d a5 30 01
	00 00		 lea	 rsp, QWORD PTR [rbp+304]
  00241	5f		 pop	 rdi
  00242	5e		 pop	 rsi
  00243	5d		 pop	 rbp
  00244	c3		 ret	 0
?Allocate@TMemory@@QEAA?AUBucket@@_K@Z ENDP		; TMemory::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.cpp
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.h
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.cpp
;	COMDAT ??0TMemory@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
tv85 = 104
this$ = 128
??0TMemory@@QEAA@XZ PROC				; TMemory::TMemory, COMDAT

; 4    : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__AA61B192_TMemory@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 ??0?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
  0002d	90		 npad	 1
  0002e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	48 83 c0 50	 add	 rax, 80			; 00000050H
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??0?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ ; std::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >
  00041	90		 npad	 1
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.h

; 21   : 	uint64_t id_counter = 0;

  00042	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00049	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Memory\TMemory.cpp

; 5    :     m_FreeId.insert(UINT64_MAX);

  00054	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005b	48 83 c0 50	 add	 rax, 80			; 00000050H
  0005f	48 89 45 68	 mov	 QWORD PTR tv85[rbp], rax
  00063	48 c7 45 40 ff
	ff ff ff	 mov	 QWORD PTR $T1[rbp], -1
  0006b	4c 8d 45 40	 lea	 r8, QWORD PTR $T1[rbp]
  0006f	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  00073	48 8b 4d 68	 mov	 rcx, QWORD PTR tv85[rbp]
  00077	e8 00 00 00 00	 call	 ?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@$$QEA_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::insert
  0007c	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00080	e8 00 00 00 00	 call	 ??1?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@std@@QEAA@XZ
  00085	90		 npad	 1

; 6    : }

  00086	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008d	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00091	5d		 pop	 rbp
  00092	c3		 ret	 0
??0TMemory@@QEAA@XZ ENDP				; TMemory::TMemory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 72
tv85 = 104
this$ = 128
?dtor$0@?0???0TMemory@@QEAA@XZ@4HA PROC			; `TMemory::TMemory'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???0TMemory@@QEAA@XZ@4HA ENDP			; `TMemory::TMemory'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 72
tv85 = 104
this$ = 128
?dtor$1@?0???0TMemory@@QEAA@XZ@4HA PROC			; `TMemory::TMemory'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00011	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00015	e8 00 00 00 00	 call	 ??1?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ
  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5d		 pop	 rbp
  0001f	c3		 ret	 0
?dtor$1@?0???0TMemory@@QEAA@XZ@4HA ENDP			; `TMemory::TMemory'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ PROC ; std::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >::~unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ ENDP ; std::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >::~unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\unordered_set
;	COMDAT ??0?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 68
tv79 = 72
tv77 = 80
this$ = 112
??0?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ PROC ; std::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >, COMDAT

; 101  :     unordered_set() : _Mybase(_Key_compare(), allocator_type()) {}

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__4818932A_unordered_set
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001e	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00022	e8 00 00 00 00	 call	 ??0?$allocator@_K@std@@QEAA@XZ ; std::allocator<unsigned __int64>::allocator<unsigned __int64>
  00027	48 89 45 48	 mov	 QWORD PTR tv79[rbp], rax
  0002b	48 8d 4d 44	 lea	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
  00034	48 89 45 50	 mov	 QWORD PTR tv77[rbp], rax
  00038	4c 8b 45 48	 mov	 r8, QWORD PTR tv79[rbp]
  0003c	48 8b 55 50	 mov	 rdx, QWORD PTR tv77[rbp]
  00040	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00044	e8 00 00 00 00	 call	 ??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >
  00049	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0004d	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00051	5d		 pop	 rbp
  00052	c3		 ret	 0
??0?$unordered_set@_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@_K@2@@std@@QEAA@XZ ENDP ; std::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >::unordered_set<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::~_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 83 c0 20	 add	 rax, 32			; 00000020H
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::~_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >
  0001f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00023	48 83 c0 08	 add	 rax, 8
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 ??1?$list@_KV?$allocator@_K@std@@@std@@QEAA@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::~list<unsigned __int64,std::allocator<unsigned __int64> >
  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??1?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::~_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >, COMDAT

; 397  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QEAA@XZ ; std::_Container_base12::_Container_base12
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S1$ = 8
$T1 = 73
this$ = 112
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::~_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >, COMDAT

; 322  :     ~_Hash_vec() {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 323  :         _Tidy();

  0001e	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00022	e8 00 00 00 00	 call	 ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Tidy

; 324  : #if _ITERATOR_DEBUG_LEVEL != 0
; 325  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());

  00027	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first
  00033	48 8b d0	 mov	 rdx, rax
  00036	48 8d 4d 08	 lea	 rcx, QWORD PTR $S1$[rbp]
  0003a	e8 00 00 00 00	 call	 ??$?0V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
  0003f	48 8d 45 08	 lea	 rax, QWORD PTR $S1$[rbp]
  00043	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 326  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  00047	48 c7 45 49 00
	00 00 00	 mov	 QWORD PTR $T1[rbp], 0
  0004f	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00053	48 8d 55 49	 lea	 rdx, QWORD PTR $T1[rbp]
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  0005f	48 8b d0	 mov	 rdx, rax
  00062	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  00066	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 327  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 328  :     }

  0006b	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::~_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv92 = 64
tv90 = 72
tv88 = 80
this$ = 112
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Tidy, COMDAT

; 312  :     void _Tidy() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 313  :         if (_Mypair._Myval2._Myfirst != nullptr) {

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00027	74 73		 je	 SHORT $LN2@Tidy

; 314  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

  00029	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00031	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00039	e8 00 00 00 00	 call	 ??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>

; 315  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

  0003e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00042	48 8b c8	 mov	 rcx, rax
  00045	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first
  0004a	48 89 45 40	 mov	 QWORD PTR tv92[rbp], rax
  0004e	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00052	e8 00 00 00 00	 call	 ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::capacity
  00057	48 89 45 48	 mov	 QWORD PTR tv90[rbp], rax
  0005b	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0005f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00063	48 89 45 50	 mov	 QWORD PTR tv88[rbp], rax
  00067	4c 8b 45 48	 mov	 r8, QWORD PTR tv90[rbp]
  0006b	48 8b 55 50	 mov	 rdx, QWORD PTR tv88[rbp]
  0006f	48 8b 4d 40	 mov	 rcx, QWORD PTR tv92[rbp]
  00073	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::deallocate

; 316  :             _Mypair._Myval2._Myfirst = nullptr;

  00078	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0007c	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 317  :             _Mypair._Myval2._Mylast  = nullptr;

  00084	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00088	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 318  :             _Mypair._Myval2._Myend   = nullptr;

  00090	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00094	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN2@Tidy:

; 319  :         }
; 320  :     }

  0009c	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a0	5d		 pop	 rbp
  000a1	c3		 ret	 0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
_Oldsize$ = 0
_Alvec$ = 8
_Newvec$1 = 16
_Oldcapacity$2 = 24
_Newend$3 = 32
this$ = 128
_Cells$ = 136
_Val$ = 144
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Assign_grow, COMDAT

; 288  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 289  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 290  :         const auto _Oldsize = size();

  00028	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::size
  00034	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 291  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 292  :         auto& _Alvec = _Mypair._Get_first();

  00038	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first
  00047	48 89 45 08	 mov	 QWORD PTR _Alvec$[rbp], rax

; 293  :         if (_Oldsize < _Cells) {

  0004b	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR _Cells$[rbp]
  00052	48 39 45 00	 cmp	 QWORD PTR _Oldsize$[rbp], rax
  00056	0f 83 b4 00 00
	00		 jae	 $LN2@Assign_gro

; 294  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

  0005c	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR _Cells$[rbp]
  00063	48 8b 4d 08	 mov	 rcx, QWORD PTR _Alvec$[rbp]
  00067	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::allocate
  0006c	48 89 45 10	 mov	 QWORD PTR _Newvec$1[rbp], rax

; 295  :             // nothrow hereafter
; 296  :             const auto _Oldcapacity = capacity();

  00070	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00077	e8 00 00 00 00	 call	 ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::capacity
  0007c	48 89 45 18	 mov	 QWORD PTR _Oldcapacity$2[rbp], rax

; 297  :             if (_Oldcapacity != 0) {

  00080	48 83 7d 18 00	 cmp	 QWORD PTR _Oldcapacity$2[rbp], 0
  00085	74 33		 je	 SHORT $LN4@Assign_gro

; 298  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

  00087	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00092	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00099	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0009d	e8 00 00 00 00	 call	 ??$_Destroy_range@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *>

; 299  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

  000a2	4c 8b 45 18	 mov	 r8, QWORD PTR _Oldcapacity$2[rbp]
  000a6	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ad	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000b1	48 8b 4d 08	 mov	 rcx, QWORD PTR _Alvec$[rbp]
  000b5	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::deallocate
$LN4@Assign_gro:

; 300  :             }
; 301  : 
; 302  :             _Mypair._Myval2._Myfirst = _Newvec;

  000ba	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c1	48 8b 4d 10	 mov	 rcx, QWORD PTR _Newvec$1[rbp]
  000c5	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 303  :             const auto _Newend       = _Newvec + _Cells;

  000c9	48 8b 45 10	 mov	 rax, QWORD PTR _Newvec$1[rbp]
  000cd	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Cells$[rbp]
  000d4	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  000d8	48 89 45 20	 mov	 QWORD PTR _Newend$3[rbp], rax

; 304  :             _Mypair._Myval2._Mylast  = _Newend;

  000dc	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000e3	48 8b 4d 20	 mov	 rcx, QWORD PTR _Newend$3[rbp]
  000e7	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 305  :             _Mypair._Myval2._Myend   = _Newend;

  000eb	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000f2	48 8b 4d 20	 mov	 rcx, QWORD PTR _Newend$3[rbp]
  000f6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 306  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

  000fa	4c 8d 85 90 00
	00 00		 lea	 r8, QWORD PTR _Val$[rbp]
  00101	48 8b 55 20	 mov	 rdx, QWORD PTR _Newend$3[rbp]
  00105	48 8b 4d 10	 mov	 rcx, QWORD PTR _Newvec$1[rbp]
  00109	e8 00 00 00 00	 call	 ??$uninitialized_fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >

; 307  :         } else {

  0010e	eb 22		 jmp	 SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 308  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

  00110	4c 8d 85 90 00
	00 00		 lea	 r8, QWORD PTR _Val$[rbp]
  00117	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0011e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00122	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00129	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0012d	e8 00 00 00 00	 call	 ??$fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
$LN3@Assign_gro:

; 309  :         }
; 310  :     }

  00132	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00136	5d		 pop	 rbp
  00137	c3		 ret	 0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 80
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::capacity, COMDAT

; 282  :     _NODISCARD size_type capacity() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 283  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 284  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 285  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00027	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002b	48 2b c1	 sub	 rax, rcx
  0002e	48 c1 f8 03	 sar	 rax, 3

; 286  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
this$ = 96
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::max_size, COMDAT

; 277  :     _NODISCARD size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 278  :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >,1>::_Get_first
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::max_size
  0002f	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00033	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00038	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  0003c	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00040	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00044	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 279  :             _Aliter_traits::max_size(_Mypair._Get_first()));
; 280  :     }

  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 80
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::size, COMDAT

; 273  :     _NODISCARD size_type size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 274  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 2b c1	 sub	 rax, rcx
  0002e	48 c1 f8 03	 sar	 rax, 3

; 275  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 80
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001b	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 738  :     }

  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YA_K_K@Z ; std::_Get_size_of_n<8>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAPEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 8b 45 60	 mov	 rax, QWORD PTR _Count$[rbp]
  000ae	48 c1 e0 03	 shl	 rax, 3
  000b2	48 8b d0	 mov	 rdx, rax
  000b5	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b9	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000be	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000c2	5d		 pop	 rbp
  000c3	c3		 ret	 0
?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@QEAAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 80
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Max_bucket_size, COMDAT

; 1805 :     const float& _Max_bucket_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1806 :         return _Traitsobj._Get_max_bucket_size();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1807 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 80
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Max_bucket_size, COMDAT

; 1801 :     float& _Max_bucket_size() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1802 :         return _Traitsobj._Get_max_bucket_size();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1803 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
_Max_storage_buckets_log2$ = 0
_Max_storage_buckets$ = 8
_End$ = 16
_Guard$ = 24
_Inserted$ = 32
_Next_inserted$1 = 40
_Inserted_key$2 = 48
_Bucket$3 = 56
_Bucket_lo$4 = 64
_Bucket_hi$5 = 72
_Insert_before$6 = 80
tv255 = 152
tv251 = 152
tv210 = 152
tv174 = 152
tv84 = 152
this$ = 176
_Buckets$ = 184
?_Forced_rehash@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Forced_rehash, COMDAT

; 1709 :     void _Forced_rehash(size_type _Buckets) {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1710 :         // Force rehash of elements in _List, distrusting existing bucket assignments in _Vec.
; 1711 :         // Assumes _Buckets is greater than _Min_buckets, and that changing to that many buckets doesn't violate
; 1712 :         // load_factor() <= max_load_factor().
; 1713 : 
; 1714 :         // Don't violate power of 2, fits in half the bucket vector invariant:
; 1715 :         // (we assume because vector must use single allocations; as a result, its max_size fits in a size_t)
; 1716 :         const unsigned long _Max_storage_buckets_log2 = _Floor_of_log_2(static_cast<size_t>(_Vec.max_size() >> 1));

  00023	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::max_size
  00036	48 d1 e8	 shr	 rax, 1
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ?_Floor_of_log_2@std@@YAK_K@Z ; std::_Floor_of_log_2
  00041	89 45 00	 mov	 DWORD PTR _Max_storage_buckets_log2$[rbp], eax

; 1717 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

  00044	8b 45 00	 mov	 eax, DWORD PTR _Max_storage_buckets_log2$[rbp]
  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	48 89 8d 98 00
	00 00		 mov	 QWORD PTR tv251[rbp], rcx
  00053	0f b6 c8	 movzx	 ecx, al
  00056	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR tv251[rbp]
  0005d	48 d3 e0	 shl	 rax, cl
  00060	48 89 45 08	 mov	 QWORD PTR _Max_storage_buckets$[rbp], rax

; 1718 :         if (_Buckets > _Max_storage_buckets) {

  00064	48 8b 45 08	 mov	 rax, QWORD PTR _Max_storage_buckets$[rbp]
  00068	48 39 85 b8 00
	00 00		 cmp	 QWORD PTR _Buckets$[rbp], rax
  0006f	76 0c		 jbe	 SHORT $LN8@Forced_reh

; 1719 :             _Xlength_error("invalid hash bucket count");

  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
  00078	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN8@Forced_reh:

; 1720 :         }
; 1721 : 
; 1722 :         // The above test also means that we won't perform a forbidden full shift when restoring the power of
; 1723 :         // 2 invariant
; 1724 :         // this round up to power of 2 in addition to the _Buckets > _Maxidx above means
; 1725 :         // we'll at least double in size (the next power of 2 above _Maxidx)
; 1726 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

  0007d	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR _Buckets$[rbp]
  00084	e8 00 00 00 00	 call	 ?_Ceiling_of_log_2@std@@YAK_K@Z ; std::_Ceiling_of_log_2
  00089	b9 01 00 00 00	 mov	 ecx, 1
  0008e	48 89 8d 98 00
	00 00		 mov	 QWORD PTR tv255[rbp], rcx
  00095	0f b6 c8	 movzx	 ecx, al
  00098	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR tv255[rbp]
  0009f	48 d3 e0	 shl	 rax, cl
  000a2	48 89 85 b8 00
	00 00		 mov	 QWORD PTR _Buckets$[rbp], rax

; 1727 :         const _Unchecked_iterator _End = _Unchecked_end();

  000a9	48 8d 55 10	 lea	 rdx, QWORD PTR _End$[rbp]
  000ad	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b4	e8 00 00 00 00	 call	 ?_Unchecked_end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_end

; 1728 : 
; 1729 :         _Vec._Assign_grow(_Buckets << 1, _End);

  000b9	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c0	48 83 c0 20	 add	 rax, 32			; 00000020H
  000c4	48 89 85 98 00
	00 00		 mov	 QWORD PTR tv84[rbp], rax
  000cb	48 8b 85 b8 00
	00 00		 mov	 rax, QWORD PTR _Buckets$[rbp]
  000d2	48 d1 e0	 shl	 rax, 1
  000d5	4c 8b 45 10	 mov	 r8, QWORD PTR _End$[rbp]
  000d9	48 8b d0	 mov	 rdx, rax
  000dc	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR tv84[rbp]
  000e3	e8 00 00 00 00	 call	 ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Assign_grow

; 1730 :         _Mask   = _Buckets - 1;

  000e8	48 8b 85 b8 00
	00 00		 mov	 rax, QWORD PTR _Buckets$[rbp]
  000ef	48 ff c8	 dec	 rax
  000f2	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f9	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 1731 :         _Maxidx = _Buckets;

  000fd	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00104	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR _Buckets$[rbp]
  0010b	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 1732 : 
; 1733 :         _Clear_guard _Guard{this};

  0010f	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  00116	48 8d 4d 18	 lea	 rcx, QWORD PTR _Guard$[rbp]
  0011a	e8 00 00 00 00	 call	 ??0_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Clear_guard::_Clear_guard

; 1734 : 
; 1735 :         _Unchecked_iterator _Inserted = _Unchecked_begin();

  0011f	48 8d 55 20	 lea	 rdx, QWORD PTR _Inserted$[rbp]
  00123	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0012a	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_begin

; 1736 : 
; 1737 :         // Remember the next _Inserted value as splices will change _Inserted's position arbitrarily.
; 1738 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

  0012f	48 8b 45 20	 mov	 rax, QWORD PTR _Inserted$[rbp]
  00133	48 89 45 28	 mov	 QWORD PTR _Next_inserted$1[rbp], rax
  00137	eb 08		 jmp	 SHORT $LN4@Forced_reh
$LN2@Forced_reh:
  00139	48 8b 45 28	 mov	 rax, QWORD PTR _Next_inserted$1[rbp]
  0013d	48 89 45 20	 mov	 QWORD PTR _Inserted$[rbp], rax
$LN4@Forced_reh:
  00141	48 8d 55 10	 lea	 rdx, QWORD PTR _End$[rbp]
  00145	48 8d 4d 20	 lea	 rcx, QWORD PTR _Inserted$[rbp]
  00149	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator==
  0014e	0f b6 c0	 movzx	 eax, al
  00151	85 c0		 test	 eax, eax
  00153	0f 85 b1 01 00
	00		 jne	 $LN3@Forced_reh

; 1739 :             ++_Next_inserted;

  00159	48 8d 4d 28	 lea	 rcx, QWORD PTR _Next_inserted$1[rbp]
  0015d	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator++

; 1740 : 
; 1741 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);

  00162	48 8d 4d 20	 lea	 rcx, QWORD PTR _Inserted$[rbp]
  00166	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator*
  0016b	48 8b c8	 mov	 rcx, rax
  0016e	e8 00 00 00 00	 call	 ?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
  00173	48 89 45 30	 mov	 QWORD PTR _Inserted_key$2[rbp], rax

; 1742 :             const size_type _Bucket = bucket(_Inserted_key);

  00177	48 8b 55 30	 mov	 rdx, QWORD PTR _Inserted_key$2[rbp]
  0017b	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00182	e8 00 00 00 00	 call	 ?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket
  00187	48 89 45 38	 mov	 QWORD PTR _Bucket$3[rbp], rax

; 1743 : 
; 1744 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1745 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1746 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

  0018b	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket$3[rbp]
  0018f	48 d1 e0	 shl	 rax, 1
  00192	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0019d	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  001a1	48 89 45 40	 mov	 QWORD PTR _Bucket_lo$4[rbp], rax

; 1747 :             _Unchecked_iterator& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1];

  001a5	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket$3[rbp]
  001a9	48 d1 e0	 shl	 rax, 1
  001ac	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001b3	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001b7	48 8d 44 c1 08	 lea	 rax, QWORD PTR [rcx+rax*8+8]
  001bc	48 89 45 48	 mov	 QWORD PTR _Bucket_hi$5[rbp], rax

; 1748 : 
; 1749 :             if (_Bucket_lo == _End) {

  001c0	48 8d 55 10	 lea	 rdx, QWORD PTR _End$[rbp]
  001c4	48 8b 4d 40	 mov	 rcx, QWORD PTR _Bucket_lo$4[rbp]
  001c8	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator==
  001cd	0f b6 c0	 movzx	 eax, al
  001d0	85 c0		 test	 eax, eax
  001d2	74 1b		 je	 SHORT $LN9@Forced_reh

; 1750 :                 // The bucket was empty, set it to the inserted element.
; 1751 :                 _Bucket_lo = _Inserted;

  001d4	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_lo$4[rbp]
  001d8	48 8b 4d 20	 mov	 rcx, QWORD PTR _Inserted$[rbp]
  001dc	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1752 :                 _Bucket_hi = _Inserted;

  001df	48 8b 45 48	 mov	 rax, QWORD PTR _Bucket_hi$5[rbp]
  001e3	48 8b 4d 20	 mov	 rcx, QWORD PTR _Inserted$[rbp]
  001e7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1753 :                 continue;

  001ea	e9 4a ff ff ff	 jmp	 $LN2@Forced_reh
$LN9@Forced_reh:

; 1754 :             }
; 1755 : 
; 1756 :             // Search the bucket for the insertion location and move element if necessary.
; 1757 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

  001ef	48 8b 45 48	 mov	 rax, QWORD PTR _Bucket_hi$5[rbp]
  001f3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f6	48 89 45 50	 mov	 QWORD PTR _Insert_before$6[rbp], rax

; 1758 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

  001fa	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00201	48 89 85 98 00
	00 00		 mov	 QWORD PTR tv174[rbp], rax
  00208	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  0020c	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator*
  00211	48 8b c8	 mov	 rcx, rax
  00214	e8 00 00 00 00	 call	 ?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
  00219	4c 8b c0	 mov	 r8, rax
  0021c	48 8b 55 30	 mov	 rdx, QWORD PTR _Inserted_key$2[rbp]
  00220	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR tv174[rbp]
  00227	e8 00 00 00 00	 call	 ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
  0022c	0f b6 c0	 movzx	 eax, al
  0022f	85 c0		 test	 eax, eax
  00231	75 3e		 jne	 SHORT $LN5@Forced_reh

; 1759 :                 // The inserted element belongs at the end of the bucket; splice it there and set _Bucket_hi to the
; 1760 :                 // new bucket inclusive end.
; 1761 :                 ++_Insert_before;

  00233	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  00237	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator++

; 1762 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

  0023c	48 8d 55 20	 lea	 rdx, QWORD PTR _Inserted$[rbp]
  00240	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  00244	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator==
  00249	0f b6 c0	 movzx	 eax, al
  0024c	85 c0		 test	 eax, eax
  0024e	75 11		 jne	 SHORT $LN11@Forced_reh

; 1763 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

  00250	4c 8b 45 28	 mov	 r8, QWORD PTR _Next_inserted$1[rbp]
  00254	48 8b 55 20	 mov	 rdx, QWORD PTR _Inserted$[rbp]
  00258	48 8b 4d 50	 mov	 rcx, QWORD PTR _Insert_before$6[rbp]
  0025c	e8 00 00 00 00	 call	 ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Unchecked_splice
$LN11@Forced_reh:

; 1764 :                 }
; 1765 : 
; 1766 :                 _Bucket_hi = _Inserted;

  00261	48 8b 45 48	 mov	 rax, QWORD PTR _Bucket_hi$5[rbp]
  00265	48 8b 4d 20	 mov	 rcx, QWORD PTR _Inserted$[rbp]
  00269	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1767 :                 continue;

  0026c	e9 c8 fe ff ff	 jmp	 $LN2@Forced_reh
$LN5@Forced_reh:

; 1768 :             }
; 1769 : 
; 1770 :             // The insertion point isn't *_Bucket_hi, so search [_Bucket_lo, _Bucket_hi) for insertion point; we
; 1771 :             // go backwards to maintain sortedness when !_Standard.
; 1772 :             for (;;) {
; 1773 :                 if (_Bucket_lo == _Insert_before) {

  00271	48 8d 55 50	 lea	 rdx, QWORD PTR _Insert_before$6[rbp]
  00275	48 8b 4d 40	 mov	 rcx, QWORD PTR _Bucket_lo$4[rbp]
  00279	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator==
  0027e	0f b6 c0	 movzx	 eax, al
  00281	85 c0		 test	 eax, eax
  00283	74 1e		 je	 SHORT $LN12@Forced_reh

; 1774 :                     // There are no equivalent keys in the bucket, so insert it at the beginning.
; 1775 :                     // Element can't be already in position here because:
; 1776 :                     // * (for !_Standard) _Inserted_key < *_Insert_before or
; 1777 :                     // * (for _Standard) _Inserted_key != *_Insert_before
; 1778 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

  00285	4c 8b 45 28	 mov	 r8, QWORD PTR _Next_inserted$1[rbp]
  00289	48 8b 55 20	 mov	 rdx, QWORD PTR _Inserted$[rbp]
  0028d	48 8b 4d 50	 mov	 rcx, QWORD PTR _Insert_before$6[rbp]
  00291	e8 00 00 00 00	 call	 ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Unchecked_splice

; 1779 :                     _Bucket_lo = _Inserted;

  00296	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_lo$4[rbp]
  0029a	48 8b 4d 20	 mov	 rcx, QWORD PTR _Inserted$[rbp]
  0029e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1780 :                     break;

  002a1	eb 62		 jmp	 SHORT $LN6@Forced_reh
$LN12@Forced_reh:

; 1781 :                 }
; 1782 : 
; 1783 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

  002a3	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  002aa	48 89 85 98 00
	00 00		 mov	 QWORD PTR tv210[rbp], rax
  002b1	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  002b5	e8 00 00 00 00	 call	 ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator--
  002ba	48 8b c8	 mov	 rcx, rax
  002bd	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEB_KXZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator*
  002c2	48 8b c8	 mov	 rcx, rax
  002c5	e8 00 00 00 00	 call	 ?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
  002ca	4c 8b c0	 mov	 r8, rax
  002cd	48 8b 55 30	 mov	 rdx, QWORD PTR _Inserted_key$2[rbp]
  002d1	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR tv210[rbp]
  002d8	e8 00 00 00 00	 call	 ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
  002dd	0f b6 c0	 movzx	 eax, al
  002e0	85 c0		 test	 eax, eax
  002e2	75 1c		 jne	 SHORT $LN13@Forced_reh

; 1784 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1785 :                     ++_Insert_before;

  002e4	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  002e8	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0>::operator++

; 1786 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1787 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1788 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

  002ed	4c 8b 45 28	 mov	 r8, QWORD PTR _Next_inserted$1[rbp]
  002f1	48 8b 55 20	 mov	 rdx, QWORD PTR _Inserted$[rbp]
  002f5	48 8b 4d 50	 mov	 rcx, QWORD PTR _Insert_before$6[rbp]
  002f9	e8 00 00 00 00	 call	 ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Unchecked_splice

; 1789 :                     break;

  002fe	eb 05		 jmp	 SHORT $LN6@Forced_reh
$LN13@Forced_reh:

; 1790 :                 }
; 1791 :             }

  00300	e9 6c ff ff ff	 jmp	 $LN5@Forced_reh
$LN6@Forced_reh:

; 1792 :         }

  00305	e9 2f fe ff ff	 jmp	 $LN2@Forced_reh
$LN3@Forced_reh:

; 1793 : 
; 1794 :         _Guard._Target = nullptr;

  0030a	48 c7 45 18 00
	00 00 00	 mov	 QWORD PTR _Guard$[rbp], 0

; 1795 : 
; 1796 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1797 :         _Stl_internal_check_container_invariants();
; 1798 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1799 :     }

  00312	48 8d 4d 18	 lea	 rcx, QWORD PTR _Guard$[rbp]
  00316	e8 00 00 00 00	 call	 ??1_Clear_guard@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Clear_guard::~_Clear_guard
  0031b	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  00322	5d		 pop	 rbp
  00323	c3		 ret	 0
?_Forced_rehash@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
_Old_buckets$ = 0
_Req_buckets$ = 8
$T1 = 80
this$ = 112
_For_size$ = 120
?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Desired_grow_bucket_count, COMDAT

; 1688 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1689 :         const size_type _Old_buckets = bucket_count();

  00023	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00027	e8 00 00 00 00	 call	 ?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket_count
  0002c	48 89 45 00	 mov	 QWORD PTR _Old_buckets$[rbp], rax

; 1690 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

  00030	48 8b 55 78	 mov	 rdx, QWORD PTR _For_size$[rbp]
  00034	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Min_load_factor_buckets
  0003d	48 89 45 50	 mov	 QWORD PTR $T1[rbp], rax
  00041	48 8d 55 50	 lea	 rdx, QWORD PTR $T1[rbp]
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_Min_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@2_KB
  0004c	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  00051	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00054	48 89 45 08	 mov	 QWORD PTR _Req_buckets$[rbp], rax

; 1691 :         if (_Old_buckets >= _Req_buckets) {

  00058	48 8b 45 08	 mov	 rax, QWORD PTR _Req_buckets$[rbp]
  0005c	48 39 45 00	 cmp	 QWORD PTR _Old_buckets$[rbp], rax
  00060	72 06		 jb	 SHORT $LN2@Desired_gr

; 1692 :             // we already have enough buckets so there's no need to change the count
; 1693 :             return _Old_buckets;

  00062	48 8b 45 00	 mov	 rax, QWORD PTR _Old_buckets$[rbp]
  00066	eb 26		 jmp	 SHORT $LN1@Desired_gr
$LN2@Desired_gr:

; 1694 :         }
; 1695 : 
; 1696 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

  00068	48 81 7d 00 00
	02 00 00	 cmp	 QWORD PTR _Old_buckets$[rbp], 512 ; 00000200H
  00070	73 18		 jae	 SHORT $LN3@Desired_gr
  00072	48 8b 45 00	 mov	 rax, QWORD PTR _Old_buckets$[rbp]
  00076	48 c1 e0 03	 shl	 rax, 3
  0007a	48 3b 45 08	 cmp	 rax, QWORD PTR _Req_buckets$[rbp]
  0007e	72 0a		 jb	 SHORT $LN3@Desired_gr

; 1697 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1698 :             return _Old_buckets * 8;

  00080	48 8b 45 00	 mov	 rax, QWORD PTR _Old_buckets$[rbp]
  00084	48 c1 e0 03	 shl	 rax, 3
  00088	eb 04		 jmp	 SHORT $LN1@Desired_gr
$LN3@Desired_gr:

; 1699 :         }
; 1700 : 
; 1701 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1702 :         return _Req_buckets;

  0008a	48 8b 45 08	 mov	 rax, QWORD PTR _Req_buckets$[rbp]
$LN1@Desired_gr:

; 1703 :     }

  0008e	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00092	5d		 pop	 rbp
  00093	c3		 ret	 0
?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
tv65 = 64
this$ = 96
_For_size$ = 104
?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Min_load_factor_buckets, COMDAT

; 1683 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1684 :         // returns the minimum number of buckets necessary for the elements in _List
; 1685 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _For_size$[rbp]
  00024	48 85 c0	 test	 rax, rax
  00027	7c 0c		 jl	 SHORT $LN4@Min_load_f
  00029	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  0002e	f3 0f 11 45 40	 movss	 DWORD PTR tv65[rbp], xmm0
  00033	eb 1e		 jmp	 SHORT $LN5@Min_load_f
$LN4@Min_load_f:
  00035	48 8b c8	 mov	 rcx, rax
  00038	48 d1 e9	 shr	 rcx, 1
  0003b	48 83 e0 01	 and	 rax, 1
  0003f	48 0b c8	 or	 rcx, rax
  00042	f3 48 0f 2a c9	 cvtsi2ss xmm1, rcx
  00047	f3 0f 58 c9	 addss	 xmm1, xmm1
  0004b	0f 28 c1	 movaps	 xmm0, xmm1
  0004e	f3 0f 11 45 40	 movss	 DWORD PTR tv65[rbp], xmm0
$LN5@Min_load_f:
  00053	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00057	e8 00 00 00 00	 call	 ?max_load_factor@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::max_load_factor
  0005c	f3 0f 10 4d 40	 movss	 xmm1, DWORD PTR tv65[rbp]
  00061	f3 0f 5e c8	 divss	 xmm1, xmm0
  00065	0f 28 c1	 movaps	 xmm0, xmm1
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ceilf
  0006e	33 c0		 xor	 eax, eax
  00070	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@5f000000
  00077	72 1e		 jb	 SHORT $LN3@Min_load_f
  00079	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@5f000000
  00081	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@5f000000
  00088	73 0d		 jae	 SHORT $LN3@Min_load_f
  0008a	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00094	48 03 c1	 add	 rax, rcx
$LN3@Min_load_f:
  00097	f3 48 0f 2c c8	 cvttss2si rcx, xmm0
  0009c	48 03 c8	 add	 rcx, rax
  0009f	48 8b c1	 mov	 rax, rcx

; 1686 :     }

  000a2	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000a6	5d		 pop	 rbp
  000a7	c3		 ret	 0
?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@_KPEAX@2@_K@Z
_TEXT	SEGMENT
_Bucket_lo$ = 0
_Bucket_hi$ = 8
_End$1 = 16
this$ = 112
_Plist$ = 120
_Bucket$ = 128
?_Erase_bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@_KPEAX@2@_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Erase_bucket, COMDAT

; 1665 :     void _Erase_bucket(_Nodeptr _Plist, size_type _Bucket) noexcept {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1666 :         // remove the node _Plist from its bucket
; 1667 :         _Nodeptr& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

  00028	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Bucket$[rbp]
  0002f	48 d1 e0	 shl	 rax, 1
  00032	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00036	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0003a	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0003e	48 89 45 00	 mov	 QWORD PTR _Bucket_lo$[rbp], rax

; 1668 :         _Nodeptr& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

  00042	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Bucket$[rbp]
  00049	48 d1 e0	 shl	 rax, 1
  0004c	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00050	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00054	48 8d 44 c1 08	 lea	 rax, QWORD PTR [rcx+rax*8+8]
  00059	48 89 45 08	 mov	 QWORD PTR _Bucket_hi$[rbp], rax

; 1669 :         if (_Bucket_hi == _Plist) {

  0005d	48 8b 45 08	 mov	 rax, QWORD PTR _Bucket_hi$[rbp]
  00061	48 8b 4d 78	 mov	 rcx, QWORD PTR _Plist$[rbp]
  00065	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00068	75 42		 jne	 SHORT $LN2@Erase_buck

; 1670 :             if (_Bucket_lo == _Plist) { // make bucket empty

  0006a	48 8b 45 00	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  0006e	48 8b 4d 78	 mov	 rcx, QWORD PTR _Plist$[rbp]
  00072	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00075	75 24		 jne	 SHORT $LN4@Erase_buck

; 1671 :                 const auto _End = _List._Mypair._Myval2._Myhead;

  00077	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0007b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007f	48 89 45 10	 mov	 QWORD PTR _End$1[rbp], rax

; 1672 : 
; 1673 :                 _Bucket_lo = _End;

  00083	48 8b 45 00	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00087	48 8b 4d 10	 mov	 rcx, QWORD PTR _End$1[rbp]
  0008b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1674 :                 _Bucket_hi = _End;

  0008e	48 8b 45 08	 mov	 rax, QWORD PTR _Bucket_hi$[rbp]
  00092	48 8b 4d 10	 mov	 rcx, QWORD PTR _End$1[rbp]
  00096	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1675 :             } else {

  00099	eb 0f		 jmp	 SHORT $LN5@Erase_buck
$LN4@Erase_buck:

; 1676 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

  0009b	48 8b 45 08	 mov	 rax, QWORD PTR _Bucket_hi$[rbp]
  0009f	48 8b 4d 78	 mov	 rcx, QWORD PTR _Plist$[rbp]
  000a3	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a7	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Erase_buck:

; 1677 :             }

  000aa	eb 1b		 jmp	 SHORT $LN3@Erase_buck
$LN2@Erase_buck:

; 1678 :         } else if (_Bucket_lo == _Plist) {

  000ac	48 8b 45 00	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  000b0	48 8b 4d 78	 mov	 rcx, QWORD PTR _Plist$[rbp]
  000b4	48 39 08	 cmp	 QWORD PTR [rax], rcx
  000b7	75 0e		 jne	 SHORT $LN3@Erase_buck

; 1679 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

  000b9	48 8b 45 00	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  000bd	48 8b 4d 78	 mov	 rcx, QWORD PTR _Plist$[rbp]
  000c1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c4	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Erase_buck:

; 1680 :         }
; 1681 :     }

  000c7	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000cb	5d		 pop	 rbp
  000cc	c3		 ret	 0
?_Erase_bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@_KPEAX@2@_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Erase_bucket
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 0
_Newsize$ = 8
this$ = 96
?_Rehash_for_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Rehash_for_1, COMDAT

; 1659 :     void _Rehash_for_1() {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1660 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00023	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 1661 :         const auto _Newsize = _Oldsize + 1;

  00027	48 8b 45 00	 mov	 rax, QWORD PTR _Oldsize$[rbp]
  0002b	48 ff c0	 inc	 rax
  0002e	48 89 45 08	 mov	 QWORD PTR _Newsize$[rbp], rax

; 1662 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

  00032	48 8b 55 08	 mov	 rdx, QWORD PTR _Newsize$[rbp]
  00036	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003a	e8 00 00 00 00	 call	 ?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Desired_grow_bucket_count
  0003f	48 8b d0	 mov	 rdx, rax
  00042	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00046	e8 00 00 00 00	 call	 ?_Forced_rehash@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Forced_rehash

; 1663 :     }

  0004b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
?_Rehash_for_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
_Oldsize$ = 0
_Newsize$ = 8
tv70 = 80
tv71 = 84
tv77 = 88
this$ = 112
?_Check_rehash_required_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_rehash_required_1, COMDAT

; 1653 :     bool _Check_rehash_required_1() const noexcept {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1654 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00026	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 1655 :         const auto _Newsize      = _Oldsize + 1;

  0002a	48 8b 45 00	 mov	 rax, QWORD PTR _Oldsize$[rbp]
  0002e	48 ff c0	 inc	 rax
  00031	48 89 45 08	 mov	 QWORD PTR _Newsize$[rbp], rax

; 1656 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

  00035	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00039	e8 00 00 00 00	 call	 ?max_load_factor@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::max_load_factor
  0003e	f3 0f 11 45 50	 movss	 DWORD PTR tv70[rbp], xmm0
  00043	48 8b 45 08	 mov	 rax, QWORD PTR _Newsize$[rbp]
  00047	48 85 c0	 test	 rax, rax
  0004a	7c 0c		 jl	 SHORT $LN7@Check_reha
  0004c	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  00051	f3 0f 11 4d 54	 movss	 DWORD PTR tv71[rbp], xmm1
  00056	eb 1e		 jmp	 SHORT $LN8@Check_reha
$LN7@Check_reha:
  00058	48 8b c8	 mov	 rcx, rax
  0005b	48 d1 e9	 shr	 rcx, 1
  0005e	48 83 e0 01	 and	 rax, 1
  00062	48 0b c8	 or	 rcx, rax
  00065	f3 48 0f 2a d1	 cvtsi2ss xmm2, rcx
  0006a	f3 0f 58 d2	 addss	 xmm2, xmm2
  0006e	0f 28 ca	 movaps	 xmm1, xmm2
  00071	f3 0f 11 4d 54	 movss	 DWORD PTR tv71[rbp], xmm1
$LN8@Check_reha:
  00076	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0007a	e8 00 00 00 00	 call	 ?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket_count
  0007f	48 85 c0	 test	 rax, rax
  00082	7c 07		 jl	 SHORT $LN5@Check_reha
  00084	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00089	eb 19		 jmp	 SHORT $LN6@Check_reha
$LN5@Check_reha:
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	48 d1 e9	 shr	 rcx, 1
  00091	48 83 e0 01	 and	 rax, 1
  00095	48 0b c8	 or	 rcx, rax
  00098	f3 48 0f 2a c9	 cvtsi2ss xmm1, rcx
  0009d	f3 0f 58 c9	 addss	 xmm1, xmm1
  000a1	0f 28 c1	 movaps	 xmm0, xmm1
$LN6@Check_reha:
  000a4	f3 0f 10 4d 54	 movss	 xmm1, DWORD PTR tv71[rbp]
  000a9	f3 0f 5e c8	 divss	 xmm1, xmm0
  000ad	0f 28 c1	 movaps	 xmm0, xmm1
  000b0	f3 0f 10 4d 50	 movss	 xmm1, DWORD PTR tv70[rbp]
  000b5	0f 2f c1	 comiss	 xmm0, xmm1
  000b8	76 09		 jbe	 SHORT $LN3@Check_reha
  000ba	c7 45 58 01 00
	00 00		 mov	 DWORD PTR tv77[rbp], 1
  000c1	eb 07		 jmp	 SHORT $LN4@Check_reha
$LN3@Check_reha:
  000c3	c7 45 58 00 00
	00 00		 mov	 DWORD PTR tv77[rbp], 0
$LN4@Check_reha:
  000ca	0f b6 45 58	 movzx	 eax, BYTE PTR tv77[rbp]

; 1657 :     }

  000ce	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000d2	5d		 pop	 rbp
  000d3	c3		 ret	 0
?_Check_rehash_required_1@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
_Oldsize$ = 0
this$ = 96
?_Check_max_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_max_size, COMDAT

; 1646 :     void _Check_max_size() const {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1647 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00023	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 1648 :         if (_Oldsize == _List.max_size()) {

  00027	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 83 c0 08	 add	 rax, 8
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 ?max_size@?$list@_KV?$allocator@_K@std@@@std@@QEBA_KXZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::max_size
  00037	48 39 45 00	 cmp	 QWORD PTR _Oldsize$[rbp], rax
  0003b	75 0c		 jne	 SHORT $LN2@Check_max_

; 1649 :             _Xlength_error("unordered_map/set too long");

  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
  00044	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Check_max_:
$LN3@Check_max_:

; 1650 :         }
; 1651 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?_Check_max_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@_KPEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
_Insert_after$ = 0
_Head$ = 8
_Bucket_array$ = 16
_Bucket$ = 24
_Bucket_lo$ = 32
_Bucket_hi$ = 40
this$ = 128
_Hashval$ = 136
_Insert_before$ = 144
_Newnode$ = 152
?_Insert_new_node_before@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@_KPEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Insert_new_node_before, COMDAT

; 1615 :         const size_t _Hashval, const _Nodeptr _Insert_before, const _Nodeptr _Newnode) noexcept {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1616 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

  0002d	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Insert_before$[rbp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 89 45 00	 mov	 QWORD PTR _Insert_after$[rbp], rax

; 1617 :         ++_List._Mypair._Myval2._Mysize;

  0003c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00043	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00047	48 ff c0	 inc	 rax
  0004a	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00051	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1618 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

  00055	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Newnode$[rbp]
  0005c	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR _Insert_before$[rbp]
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * const &>

; 1619 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

  0006b	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Newnode$[rbp]
  00072	48 83 c0 08	 add	 rax, 8
  00076	48 8d 55 00	 lea	 rdx, QWORD PTR _Insert_after$[rbp]
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * const &>

; 1620 :         _Insert_after->_Next  = _Newnode;

  00082	48 8b 45 00	 mov	 rax, QWORD PTR _Insert_after$[rbp]
  00086	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  0008d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1621 :         _Insert_before->_Prev = _Newnode;

  00090	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Insert_before$[rbp]
  00097	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  0009e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1622 : 
; 1623 :         const auto _Head                = _List._Mypair._Myval2._Myhead;

  000a2	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ad	48 89 45 08	 mov	 QWORD PTR _Head$[rbp], rax

; 1624 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

  000b1	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000bc	48 89 45 10	 mov	 QWORD PTR _Bucket_array$[rbp], rax

; 1625 :         const size_type _Bucket         = _Hashval & _Mask;

  000c0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c7	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000cb	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Hashval$[rbp]
  000d2	48 23 c8	 and	 rcx, rax
  000d5	48 8b c1	 mov	 rax, rcx
  000d8	48 89 45 18	 mov	 QWORD PTR _Bucket$[rbp], rax

; 1626 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

  000dc	48 8b 45 18	 mov	 rax, QWORD PTR _Bucket$[rbp]
  000e0	48 d1 e0	 shl	 rax, 1
  000e3	48 8b 4d 10	 mov	 rcx, QWORD PTR _Bucket_array$[rbp]
  000e7	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000eb	48 89 45 20	 mov	 QWORD PTR _Bucket_lo$[rbp], rax

; 1627 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];

  000ef	48 8b 45 18	 mov	 rax, QWORD PTR _Bucket$[rbp]
  000f3	48 d1 e0	 shl	 rax, 1
  000f6	48 8b 4d 10	 mov	 rcx, QWORD PTR _Bucket_array$[rbp]
  000fa	48 8d 44 c1 08	 lea	 rax, QWORD PTR [rcx+rax*8+8]
  000ff	48 89 45 28	 mov	 QWORD PTR _Bucket_hi$[rbp], rax

; 1628 :         if (_Bucket_lo._Ptr == _Head) {

  00103	48 8b 45 20	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00107	48 8b 4d 08	 mov	 rcx, QWORD PTR _Head$[rbp]
  0010b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0010e	75 1e		 jne	 SHORT $LN2@Insert_new

; 1629 :             // bucket is empty, set both
; 1630 :             _Bucket_lo._Ptr = _Newnode;

  00110	48 8b 45 20	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00114	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  0011b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1631 :             _Bucket_hi._Ptr = _Newnode;

  0011e	48 8b 45 28	 mov	 rax, QWORD PTR _Bucket_hi$[rbp]
  00122	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  00129	48 89 08	 mov	 QWORD PTR [rax], rcx
  0012c	eb 3b		 jmp	 SHORT $LN3@Insert_new
$LN2@Insert_new:

; 1632 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

  0012e	48 8b 45 20	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00132	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Insert_before$[rbp]
  00139	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0013c	75 10		 jne	 SHORT $LN4@Insert_new

; 1633 :             // new node is the lowest element in the bucket
; 1634 :             _Bucket_lo._Ptr = _Newnode;

  0013e	48 8b 45 20	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00142	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  00149	48 89 08	 mov	 QWORD PTR [rax], rcx
  0014c	eb 1b		 jmp	 SHORT $LN3@Insert_new
$LN4@Insert_new:

; 1635 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

  0014e	48 8b 45 28	 mov	 rax, QWORD PTR _Bucket_hi$[rbp]
  00152	48 8b 4d 00	 mov	 rcx, QWORD PTR _Insert_after$[rbp]
  00156	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00159	75 0e		 jne	 SHORT $LN3@Insert_new

; 1636 :             // new node is the highest element in the bucket
; 1637 :             _Bucket_hi._Ptr = _Newnode;

  0015b	48 8b 45 28	 mov	 rax, QWORD PTR _Bucket_hi$[rbp]
  0015f	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  00166	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Insert_new:

; 1638 :         }
; 1639 : 
; 1640 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1641 :         _Stl_internal_check_container_invariants();
; 1642 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1643 :         return _Newnode;

  00169	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Newnode$[rbp]

; 1644 :     }

  00170	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00174	5d		 pop	 rbp
  00175	c3		 ret	 0
?_Insert_new_node_before@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@_KPEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 0
_Head$1 = 8
$T2 = 80
tv132 = 88
tv134 = 96
tv130 = 104
this$ = 128
?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::clear, COMDAT

; 1151 :     void clear() noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1152 :         // TRANSITION, ABI:
; 1153 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1154 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1155 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1156 :         //   (2) The hash function operator() may throw exceptions, and
; 1157 :         //   (3) clear() is a noexcept function.
; 1158 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1159 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

  0001e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00029	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 1160 :         if (_Oldsize == 0) {

  0002d	48 83 7d 00 00	 cmp	 QWORD PTR _Oldsize$[rbp], 0
  00032	75 05		 jne	 SHORT $LN2@clear

; 1161 :             return;

  00034	e9 9b 00 00 00	 jmp	 $LN1@clear
$LN2@clear:

; 1162 :         }
; 1163 : 
; 1164 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1165 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1166 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1167 :             // as many buckets as elements, remove element-by-element.
; 1168 :             if (bucket_count() / 8 > _Oldsize) {

  00039	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00040	e8 00 00 00 00	 call	 ?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket_count
  00045	33 d2		 xor	 edx, edx
  00047	b9 08 00 00 00	 mov	 ecx, 8
  0004c	48 f7 f1	 div	 rcx
  0004f	48 3b 45 00	 cmp	 rax, QWORD PTR _Oldsize$[rbp]
  00053	76 28		 jbe	 SHORT $LN3@clear

; 1169 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

  00055	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00060	48 89 45 08	 mov	 QWORD PTR _Head$1[rbp], rax

; 1170 :                 _Unchecked_erase(_Head->_Next, _Head);

  00064	4c 8b 45 08	 mov	 r8, QWORD PTR _Head$1[rbp]
  00068	48 8b 45 08	 mov	 rax, QWORD PTR _Head$1[rbp]
  0006c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0006f	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00076	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_erase

; 1171 :                 return;

  0007b	eb 57		 jmp	 SHORT $LN1@clear
$LN3@clear:

; 1172 :             }
; 1173 :         }
; 1174 : 
; 1175 :         // Bulk destroy items and reset buckets
; 1176 :         _List.clear();

  0007d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00084	48 83 c0 08	 add	 rax, 8
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 ?clear@?$list@_KV?$allocator@_K@std@@@std@@QEAAXXZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::clear

; 1177 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

  00090	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  00094	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009b	e8 00 00 00 00	 call	 ?_Unchecked_end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_end
  000a0	48 89 45 58	 mov	 QWORD PTR tv132[rbp], rax
  000a4	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ab	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000af	48 89 45 60	 mov	 QWORD PTR tv134[rbp], rax
  000b3	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ba	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000be	48 89 45 68	 mov	 QWORD PTR tv130[rbp], rax
  000c2	4c 8b 45 58	 mov	 r8, QWORD PTR tv132[rbp]
  000c6	48 8b 55 60	 mov	 rdx, QWORD PTR tv134[rbp]
  000ca	48 8b 4d 68	 mov	 rcx, QWORD PTR tv130[rbp]
  000ce	e8 00 00 00 00	 call	 ??$fill@PEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXQEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> >
  000d3	90		 npad	 1
$LN1@clear:

; 1178 :     }

  000d4	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000d8	5d		 pop	 rbp
  000d9	c3		 ret	 0
?clear@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA_KAEB_K@Z
_TEXT	SEGMENT
this$ = 80
_Keyval$ = 88
?erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA_KAEB_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::erase, COMDAT

; 1139 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Erase(_Keyval))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1140 :         return _Erase(_Keyval);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Keyval$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ??$_Erase@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAA_KAEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Erase<unsigned __int64>

; 1141 :     }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA_KAEB_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
_End$ = 0
_Bucket_bounds$ = 8
_Eraser$ = 16
_Predecessor$1 = 40
_Bucket$2 = 48
_Bucket_lo$3 = 56
_Bucket_hi$4 = 64
_Update_lo$5 = 72
_Old_hi$6 = 80
_At_bucket_back$7 = 88
_Bucket$8 = 96
_Bucket_lo$9 = 104
_Bucket_hi$10 = 112
_Old_hi$11 = 120
_At_bucket_back$12 = 128
$T13 = 200
$T14 = 208
$T15 = 216
tv156 = 224
tv130 = 224
tv128 = 224
this$ = 256
_First$ = 264
_Last$ = 272
?_Unchecked_erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_erase, COMDAT

; 1027 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN25:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1028 :         if (_First == _Last) {

  00028	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0002f	48 39 85 08 01
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  00036	75 0c		 jne	 SHORT $LN10@Unchecked_

; 1029 :             return _Last;

  00038	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0003f	e9 84 02 00 00	 jmp	 $LN1@Unchecked_
$LN10@Unchecked_:

; 1030 :         }
; 1031 : 
; 1032 :         const auto _End           = _List._Mypair._Myval2._Myhead;

  00044	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004f	48 89 45 00	 mov	 QWORD PTR _End$[rbp], rax

; 1033 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

  00053	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005e	48 89 45 08	 mov	 QWORD PTR _Bucket_bounds$[rbp], rax

; 1034 :         _Range_eraser _Eraser{_List, _First};

  00062	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00069	48 83 c0 08	 add	 rax, 8
  0006d	4c 8b 85 08 01
	00 00		 mov	 r8, QWORD PTR _First$[rbp]
  00074	48 8b d0	 mov	 rdx, rax
  00077	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  0007b	e8 00 00 00 00	 call	 ??0_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@AEAV?$list@_KV?$allocator@_K@std@@@2@QEAU?$_List_node@_KPEAX@2@@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::_Range_eraser

; 1035 :         {
; 1036 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1037 :             const auto _Predecessor = _First->_Prev;

  00080	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  00087	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008b	48 89 45 28	 mov	 QWORD PTR _Predecessor$1[rbp], rax

; 1038 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

  0008f	48 8b 45 20	 mov	 rax, QWORD PTR _Eraser$[rbp+16]
  00093	48 83 c0 10	 add	 rax, 16
  00097	48 8b c8	 mov	 rcx, rax
  0009a	e8 00 00 00 00	 call	 ?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
  0009f	48 8b d0	 mov	 rdx, rax
  000a2	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	e8 00 00 00 00	 call	 ?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket
  000ae	48 89 45 30	 mov	 QWORD PTR _Bucket$2[rbp], rax

; 1039 :             // nothrow hereafter this block
; 1040 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

  000b2	48 8b 45 30	 mov	 rax, QWORD PTR _Bucket$2[rbp]
  000b6	48 d1 e0	 shl	 rax, 1
  000b9	48 8b 4d 08	 mov	 rcx, QWORD PTR _Bucket_bounds$[rbp]
  000bd	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000c1	48 89 45 38	 mov	 QWORD PTR _Bucket_lo$3[rbp], rax

; 1041 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

  000c5	48 8b 45 30	 mov	 rax, QWORD PTR _Bucket$2[rbp]
  000c9	48 d1 e0	 shl	 rax, 1
  000cc	48 8b 4d 08	 mov	 rcx, QWORD PTR _Bucket_bounds$[rbp]
  000d0	48 8d 44 c1 08	 lea	 rax, QWORD PTR [rcx+rax*8+8]
  000d5	48 89 45 40	 mov	 QWORD PTR _Bucket_hi$4[rbp], rax

; 1042 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

  000d9	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket_lo$3[rbp]
  000dd	48 8b 4d 20	 mov	 rcx, QWORD PTR _Eraser$[rbp+16]
  000e1	48 39 08	 cmp	 QWORD PTR [rax], rcx
  000e4	75 09		 jne	 SHORT $LN19@Unchecked_
  000e6	c6 85 e0 00 00
	00 01		 mov	 BYTE PTR tv128[rbp], 1
  000ed	eb 07		 jmp	 SHORT $LN20@Unchecked_
$LN19@Unchecked_:
  000ef	c6 85 e0 00 00
	00 00		 mov	 BYTE PTR tv128[rbp], 0
$LN20@Unchecked_:
  000f6	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR tv128[rbp]
  000fd	88 45 48	 mov	 BYTE PTR _Update_lo$5[rbp], al

; 1043 :             const _Nodeptr _Old_hi = _Bucket_hi;

  00100	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_hi$4[rbp]
  00104	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00107	48 89 45 50	 mov	 QWORD PTR _Old_hi$6[rbp], rax
$LN2@Unchecked_:

; 1044 :             for (;;) { // remove elements until we hit the end of the bucket
; 1045 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

  0010b	48 8b 45 50	 mov	 rax, QWORD PTR _Old_hi$6[rbp]
  0010f	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  00113	75 09		 jne	 SHORT $LN21@Unchecked_
  00115	c6 85 e0 00 00
	00 01		 mov	 BYTE PTR tv130[rbp], 1
  0011c	eb 07		 jmp	 SHORT $LN22@Unchecked_
$LN21@Unchecked_:
  0011e	c6 85 e0 00 00
	00 00		 mov	 BYTE PTR tv130[rbp], 0
$LN22@Unchecked_:
  00125	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR tv130[rbp]
  0012c	88 45 58	 mov	 BYTE PTR _At_bucket_back$7[rbp], al

; 1046 :                 _Eraser._Bump_erased();

  0012f	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  00133	e8 00 00 00 00	 call	 ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::_Bump_erased

; 1047 :                 if (_At_bucket_back) {

  00138	0f b6 45 58	 movzx	 eax, BYTE PTR _At_bucket_back$7[rbp]
  0013c	85 c0		 test	 eax, eax
  0013e	74 02		 je	 SHORT $LN11@Unchecked_

; 1048 :                     break;

  00140	eb 45		 jmp	 SHORT $LN3@Unchecked_
$LN11@Unchecked_:

; 1049 :                 }
; 1050 : 
; 1051 :                 if (_Eraser._Next == _Last) {

  00142	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00149	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  0014d	75 36		 jne	 SHORT $LN12@Unchecked_

; 1052 :                     if (_Update_lo) {

  0014f	0f b6 45 48	 movzx	 eax, BYTE PTR _Update_lo$5[rbp]
  00153	85 c0		 test	 eax, eax
  00155	74 0b		 je	 SHORT $LN13@Unchecked_

; 1053 :                         // erased the bucket's prefix
; 1054 :                         _Bucket_lo = _Eraser._Next;

  00157	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket_lo$3[rbp]
  0015b	48 8b 4d 20	 mov	 rcx, QWORD PTR _Eraser$[rbp+16]
  0015f	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN13@Unchecked_:

; 1055 :                     }
; 1056 : 
; 1057 :                     return _Last;

  00162	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00169	48 89 85 c8 00
	00 00		 mov	 QWORD PTR $T13[rbp], rax
  00170	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  00174	e8 00 00 00 00	 call	 ??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::~_Range_eraser
  00179	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR $T13[rbp]
  00180	e9 43 01 00 00	 jmp	 $LN1@Unchecked_
$LN12@Unchecked_:

; 1058 :                 }
; 1059 :             }

  00185	eb 84		 jmp	 SHORT $LN2@Unchecked_
$LN3@Unchecked_:

; 1060 : 
; 1061 :             if (_Update_lo) {

  00187	0f b6 45 48	 movzx	 eax, BYTE PTR _Update_lo$5[rbp]
  0018b	85 c0		 test	 eax, eax
  0018d	74 18		 je	 SHORT $LN14@Unchecked_

; 1062 :                 // emptied the bucket
; 1063 :                 _Bucket_lo = _End;

  0018f	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket_lo$3[rbp]
  00193	48 8b 4d 00	 mov	 rcx, QWORD PTR _End$[rbp]
  00197	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1064 :                 _Bucket_hi = _End;

  0019a	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_hi$4[rbp]
  0019e	48 8b 4d 00	 mov	 rcx, QWORD PTR _End$[rbp]
  001a2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1065 :             } else {

  001a5	eb 0b		 jmp	 SHORT $LN5@Unchecked_
$LN14@Unchecked_:

; 1066 :                 _Bucket_hi = _Predecessor;

  001a7	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_hi$4[rbp]
  001ab	48 8b 4d 28	 mov	 rcx, QWORD PTR _Predecessor$1[rbp]
  001af	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Unchecked_:

; 1067 :             }
; 1068 :         }
; 1069 : 
; 1070 :         // hereafter we are always erasing buckets' prefixes
; 1071 :         while (_Eraser._Next != _Last) {

  001b2	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  001b9	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  001bd	0f 84 e7 00 00
	00		 je	 $LN6@Unchecked_

; 1072 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

  001c3	48 8b 45 20	 mov	 rax, QWORD PTR _Eraser$[rbp+16]
  001c7	48 83 c0 10	 add	 rax, 16
  001cb	48 8b c8	 mov	 rcx, rax
  001ce	e8 00 00 00 00	 call	 ?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
  001d3	48 8b d0	 mov	 rdx, rax
  001d6	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001dd	e8 00 00 00 00	 call	 ?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket
  001e2	48 89 45 60	 mov	 QWORD PTR _Bucket$8[rbp], rax

; 1073 :             // nothrow hereafter this block
; 1074 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

  001e6	48 8b 45 60	 mov	 rax, QWORD PTR _Bucket$8[rbp]
  001ea	48 d1 e0	 shl	 rax, 1
  001ed	48 8b 4d 08	 mov	 rcx, QWORD PTR _Bucket_bounds$[rbp]
  001f1	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  001f5	48 89 45 68	 mov	 QWORD PTR _Bucket_lo$9[rbp], rax

; 1075 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

  001f9	48 8b 45 60	 mov	 rax, QWORD PTR _Bucket$8[rbp]
  001fd	48 d1 e0	 shl	 rax, 1
  00200	48 8b 4d 08	 mov	 rcx, QWORD PTR _Bucket_bounds$[rbp]
  00204	48 8d 44 c1 08	 lea	 rax, QWORD PTR [rcx+rax*8+8]
  00209	48 89 45 70	 mov	 QWORD PTR _Bucket_hi$10[rbp], rax

; 1076 :             const _Nodeptr _Old_hi = _Bucket_hi;

  0020d	48 8b 45 70	 mov	 rax, QWORD PTR _Bucket_hi$10[rbp]
  00211	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00214	48 89 45 78	 mov	 QWORD PTR _Old_hi$11[rbp], rax
$LN7@Unchecked_:

; 1077 :             for (;;) { // remove elements until we hit the end of the bucket
; 1078 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

  00218	48 8b 45 78	 mov	 rax, QWORD PTR _Old_hi$11[rbp]
  0021c	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  00220	75 09		 jne	 SHORT $LN23@Unchecked_
  00222	c6 85 e0 00 00
	00 01		 mov	 BYTE PTR tv156[rbp], 1
  00229	eb 07		 jmp	 SHORT $LN24@Unchecked_
$LN23@Unchecked_:
  0022b	c6 85 e0 00 00
	00 00		 mov	 BYTE PTR tv156[rbp], 0
$LN24@Unchecked_:
  00232	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR tv156[rbp]
  00239	88 85 80 00 00
	00		 mov	 BYTE PTR _At_bucket_back$12[rbp], al

; 1079 :                 _Eraser._Bump_erased();

  0023f	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  00243	e8 00 00 00 00	 call	 ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::_Bump_erased

; 1080 :                 if (_At_bucket_back) {

  00248	0f b6 85 80 00
	00 00		 movzx	 eax, BYTE PTR _At_bucket_back$12[rbp]
  0024f	85 c0		 test	 eax, eax
  00251	74 02		 je	 SHORT $LN16@Unchecked_

; 1081 :                     break;

  00253	eb 3a		 jmp	 SHORT $LN8@Unchecked_
$LN16@Unchecked_:

; 1082 :                 }
; 1083 : 
; 1084 :                 if (_Eraser._Next == _Last) {

  00255	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0025c	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  00260	75 2b		 jne	 SHORT $LN17@Unchecked_

; 1085 :                     // erased the bucket's prefix
; 1086 :                     _Bucket_lo = _Eraser._Next;

  00262	48 8b 45 68	 mov	 rax, QWORD PTR _Bucket_lo$9[rbp]
  00266	48 8b 4d 20	 mov	 rcx, QWORD PTR _Eraser$[rbp+16]
  0026a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1087 :                     return _Last;

  0026d	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00274	48 89 85 d0 00
	00 00		 mov	 QWORD PTR $T14[rbp], rax
  0027b	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  0027f	e8 00 00 00 00	 call	 ??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::~_Range_eraser
  00284	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR $T14[rbp]
  0028b	eb 3b		 jmp	 SHORT $LN1@Unchecked_
$LN17@Unchecked_:

; 1088 :                 }
; 1089 :             }

  0028d	eb 89		 jmp	 SHORT $LN7@Unchecked_
$LN8@Unchecked_:

; 1090 : 
; 1091 :             // emptied the bucket
; 1092 :             _Bucket_lo = _End;

  0028f	48 8b 45 68	 mov	 rax, QWORD PTR _Bucket_lo$9[rbp]
  00293	48 8b 4d 00	 mov	 rcx, QWORD PTR _End$[rbp]
  00297	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1093 :             _Bucket_hi = _End;

  0029a	48 8b 45 70	 mov	 rax, QWORD PTR _Bucket_hi$10[rbp]
  0029e	48 8b 4d 00	 mov	 rcx, QWORD PTR _End$[rbp]
  002a2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1094 :         }

  002a5	e9 08 ff ff ff	 jmp	 $LN5@Unchecked_
$LN6@Unchecked_:

; 1095 : 
; 1096 :         return _Last;

  002aa	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  002b1	48 89 85 d8 00
	00 00		 mov	 QWORD PTR $T15[rbp], rax
  002b8	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  002bc	e8 00 00 00 00	 call	 ??1_Range_eraser@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Range_eraser::~_Range_eraser
  002c1	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR $T15[rbp]
$LN1@Unchecked_:

; 1097 :     }

  002c8	48 8d a5 f0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+240]
  002cf	5d		 pop	 rbp
  002d0	c3		 ret	 0
?_Unchecked_erase@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@$$QEA_K@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
__$ReturnUdt$ = 104
_Val$ = 112
?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@$$QEA_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::insert, COMDAT

; 938  :     conditional_t<_Multi, iterator, pair<iterator, bool>> insert(value_type&& _Val) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	c7 45 40 00 00
	00 00		 mov	 DWORD PTR $T1[rbp], 0
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 939  :         return emplace(_STD move(_Val));

  0002c	4c 8b 45 70	 mov	 r8, QWORD PTR _Val$[rbp]
  00030	48 8b 55 68	 mov	 rdx, QWORD PTR __$ReturnUdt$[rbp]
  00034	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ??$emplace@_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@$$QEA_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64>
  0003d	8b 45 40	 mov	 eax, DWORD PTR $T1[rbp]
  00040	83 c8 01	 or	 eax, 1
  00043	89 45 40	 mov	 DWORD PTR $T1[rbp], eax
  00046	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 940  :     }

  0004a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@$$QEA_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@AEB_K@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
__$ReturnUdt$ = 104
_Val$ = 112
?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@AEB_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::insert, COMDAT

; 934  :     conditional_t<_Multi, iterator, pair<iterator, bool>> insert(const value_type& _Val) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	c7 45 40 00 00
	00 00		 mov	 DWORD PTR $T1[rbp], 0
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 935  :         return emplace(_Val);

  0002c	4c 8b 45 70	 mov	 r8, QWORD PTR _Val$[rbp]
  00030	48 8b 55 68	 mov	 rdx, QWORD PTR __$ReturnUdt$[rbp]
  00034	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ??$emplace@AEB_K@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@1@AEB_K@Z ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::emplace<unsigned __int64 const &>
  0003d	8b 45 40	 mov	 eax, DWORD PTR $T1[rbp]
  00040	83 c8 01	 or	 eax, 1
  00043	89 45 40	 mov	 DWORD PTR $T1[rbp], eax
  00046	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 936  :     }

  0004a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
?insert@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@_N@2@AEB_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 80
?max_load_factor@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::max_load_factor, COMDAT

; 911  :     _NODISCARD float max_load_factor() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 912  :         return _Max_bucket_size();

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Max_bucket_size
  00024	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]

; 913  :     }

  00028	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?max_load_factor@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
tv73 = 64
this$ = 96
_Keyval$ = 104
?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket, COMDAT

; 855  :         noexcept(_Nothrow_hash<_Traits, key_type>) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 856  :         return _Traitsobj(_Keyval) & _Mask;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 40	 mov	 QWORD PTR tv73[rbp], rax
  00028	48 8b 55 68	 mov	 rdx, QWORD PTR _Keyval$[rbp]
  0002c	48 8b 4d 40	 mov	 rcx, QWORD PTR tv73[rbp]
  00030	e8 00 00 00 00	 call	 ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
  00035	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00039	48 23 41 40	 and	 rax, QWORD PTR [rcx+64]

; 857  :     }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?bucket@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 80
?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket_count, COMDAT

; 846  :     _NODISCARD size_type bucket_count() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 847  :         return _Maxidx;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]

; 848  :     }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?bucket_count@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
$T1 = 64
tv72 = 72
this$ = 96
__$ReturnUdt$ = 104
?_Unchecked_end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_end, COMDAT

; 811  :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 812  :         return _List._Unchecked_end();

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 45 48	 mov	 QWORD PTR tv72[rbp], rax
  0002c	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00030	48 8b 4d 48	 mov	 rcx, QWORD PTR tv72[rbp]
  00034	e8 00 00 00 00	 call	 ?_Unchecked_end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_end
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00040	48 89 01	 mov	 QWORD PTR [rcx], rax
  00043	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 813  :     }

  00047	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
?_Unchecked_end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
$T1 = 64
tv72 = 72
this$ = 96
__$ReturnUdt$ = 104
?_Unchecked_begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_begin, COMDAT

; 803  :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 804  :         return _List._Unchecked_begin();

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 45 48	 mov	 QWORD PTR tv72[rbp], rax
  0002c	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00030	48 8b 4d 48	 mov	 rcx, QWORD PTR tv72[rbp]
  00034	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_begin
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00040	48 89 01	 mov	 QWORD PTR [rcx], rax
  00043	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 805  :     }

  00047	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
?_Unchecked_begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = 64
tv74 = 88
this$ = 112
__$ReturnUdt$ = 120
?end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::end, COMDAT

; 795  :     _NODISCARD iterator end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 796  :         return _List.end();

  00023	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 83 c0 08	 add	 rax, 8
  0002b	48 89 45 58	 mov	 QWORD PTR tv74[rbp], rax
  0002f	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00033	48 8b 4d 58	 mov	 rcx, QWORD PTR tv74[rbp]
  00037	e8 00 00 00 00	 call	 ?end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::end
  0003c	48 8b d0	 mov	 rdx, rax
  0003f	48 8b 4d 78	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00043	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z
  00048	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0004c	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00051	48 8b 45 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 797  :     }

  00055	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?end@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = 64
tv74 = 88
this$ = 112
__$ReturnUdt$ = 120
?begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::begin, COMDAT

; 787  :     _NODISCARD iterator begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 788  :         return _List.begin();

  00023	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 83 c0 08	 add	 rax, 8
  0002b	48 89 45 58	 mov	 QWORD PTR tv74[rbp], rax
  0002f	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00033	48 8b 4d 58	 mov	 rcx, QWORD PTR tv74[rbp]
  00037	e8 00 00 00 00	 call	 ?begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::begin
  0003c	48 8b d0	 mov	 rdx, rax
  0003f	48 8b 4d 78	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00043	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@$$QEAV01@@Z
  00048	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0004c	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@XZ
  00051	48 8b 45 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 789  :     }

  00055	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?begin@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@QEAA?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
tv137 = 80
tv82 = 80
tv74 = 80
tv69 = 80
tv131 = 88
this$ = 112
_Parg$ = 120
_Al$ = 128
??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >, COMDAT

; 377  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00028	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 89 45 50	 mov	 QWORD PTR tv69[rbp], rax
  00030	48 8b 55 78	 mov	 rdx, QWORD PTR _Parg$[rbp]
  00034	48 8b 4d 50	 mov	 rcx, QWORD PTR tv69[rbp]
  00038	e8 00 00 00 00	 call	 ??0?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>
  0003d	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 83 c0 08	 add	 rax, 8
  00045	48 89 45 50	 mov	 QWORD PTR tv74[rbp], rax
  00049	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Al$[rbp]
  00050	48 8b 4d 50	 mov	 rcx, QWORD PTR tv74[rbp]
  00054	e8 00 00 00 00	 call	 ??0?$list@_KV?$allocator@_K@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::list<unsigned __int64,std::allocator<unsigned __int64> >
  00059	90		 npad	 1
  0005a	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0005e	48 83 c0 20	 add	 rax, 32			; 00000020H
  00062	48 89 45 50	 mov	 QWORD PTR tv82[rbp], rax
  00066	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Al$[rbp]
  0006d	48 8b 4d 50	 mov	 rcx, QWORD PTR tv82[rbp]
  00071	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@_K@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > ><std::allocator<unsigned __int64> const &,0>
  00076	90		 npad	 1
  00077	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0007b	48 c7 40 40 07
	00 00 00	 mov	 QWORD PTR [rax+64], 7
  00083	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00087	48 c7 40 48 08
	00 00 00	 mov	 QWORD PTR [rax+72], 8

; 378  :         // construct empty hash table
; 379  :         _Max_bucket_size() = _Bucket_size;

  0008f	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00093	e8 00 00 00 00	 call	 ?_Max_bucket_size@?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Max_bucket_size
  00098	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000a0	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 380  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

  000a4	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000a8	48 83 c0 20	 add	 rax, 32			; 00000020H
  000ac	48 89 45 50	 mov	 QWORD PTR tv137[rbp], rax
  000b0	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000b4	48 83 c0 08	 add	 rax, 8
  000b8	48 89 45 58	 mov	 QWORD PTR tv131[rbp], rax
  000bc	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  000c0	48 8b 4d 58	 mov	 rcx, QWORD PTR tv131[rbp]
  000c4	e8 00 00 00 00	 call	 ?_Unchecked_end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_end
  000c9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cc	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  000d0	4c 8b 45 40	 mov	 r8, QWORD PTR $T1[rbp]
  000d4	ba 10 00 00 00	 mov	 edx, 16
  000d9	48 8b 4d 50	 mov	 rcx, QWORD PTR tv137[rbp]
  000dd	e8 00 00 00 00	 call	 ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::_Assign_grow
  000e2	90		 npad	 1

; 381  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 382  :         _Stl_internal_check_container_invariants();
; 383  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 384  :     }

  000e3	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000e7	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000eb	5d		 pop	 rbp
  000ec	c3		 ret	 0
??0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 72
tv137 = 80
tv82 = 80
tv74 = 80
tv69 = 80
tv131 = 88
this$ = 112
_Parg$ = 120
_Al$ = 128
?dtor$0@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA PROC ; `std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	48 83 c1 08	 add	 rcx, 8
  00012	e8 00 00 00 00	 call	 ??1?$list@_KV?$allocator@_K@std@@@std@@QEAA@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::~list<unsigned __int64,std::allocator<unsigned __int64> >
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA ENDP ; `std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 72
tv137 = 80
tv82 = 80
tv74 = 80
tv69 = 80
tv131 = 88
this$ = 112
_Parg$ = 120
_Al$ = 128
?dtor$1@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA PROC ; `std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00012	e8 00 00 00 00	 call	 ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >::~_Hash_vec<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned __int64> >,std::_Iterator_base0> > >
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$1@?0???0?$_Hash@V?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@_K@1@@Z@4HA ENDP ; `std::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >::_Hash<std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_First_prev$ = 0
_Last_prev$ = 8
_Before_prev$ = 16
_Before$ = 112
_First$ = 120
_Last$ = 128
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Unchecked_splice, COMDAT

; 468  :     static _Nodeptr _Unchecked_splice(const _Nodeptr _Before, const _Nodeptr _First, const _Nodeptr _Last) noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 469  :         // splice [_First, _Last) before _Before; returns _Last
; 470  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 471  :         // 3 reads and 6 writes
; 472  : 
; 473  :         // fixup the _Next values
; 474  :         const auto _First_prev  = _First->_Prev;

  00028	48 8b 45 78	 mov	 rax, QWORD PTR _First$[rbp]
  0002c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00030	48 89 45 00	 mov	 QWORD PTR _First_prev$[rbp], rax

; 475  :         _First_prev->_Next      = _Last;

  00034	48 8b 45 00	 mov	 rax, QWORD PTR _First_prev$[rbp]
  00038	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  0003f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

  00042	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	48 89 45 08	 mov	 QWORD PTR _Last_prev$[rbp], rax

; 477  :         _Last_prev->_Next       = _Before;

  00051	48 8b 45 08	 mov	 rax, QWORD PTR _Last_prev$[rbp]
  00055	48 8b 4d 70	 mov	 rcx, QWORD PTR _Before$[rbp]
  00059	48 89 08	 mov	 QWORD PTR [rax], rcx

; 478  :         const auto _Before_prev = _Before->_Prev;

  0005c	48 8b 45 70	 mov	 rax, QWORD PTR _Before$[rbp]
  00060	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00064	48 89 45 10	 mov	 QWORD PTR _Before_prev$[rbp], rax

; 479  :         _Before_prev->_Next     = _First;

  00068	48 8b 45 10	 mov	 rax, QWORD PTR _Before_prev$[rbp]
  0006c	48 8b 4d 78	 mov	 rcx, QWORD PTR _First$[rbp]
  00070	48 89 08	 mov	 QWORD PTR [rax], rcx

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

  00073	48 8b 45 70	 mov	 rax, QWORD PTR _Before$[rbp]
  00077	48 8b 4d 08	 mov	 rcx, QWORD PTR _Last_prev$[rbp]
  0007b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

  0007f	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00086	48 8b 4d 00	 mov	 rcx, QWORD PTR _First_prev$[rbp]
  0008a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 484  :         _First->_Prev  = _Before_prev;

  0008e	48 8b 45 78	 mov	 rax, QWORD PTR _First$[rbp]
  00092	48 8b 4d 10	 mov	 rcx, QWORD PTR _Before_prev$[rbp]
  00096	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 485  : 
; 486  :         return _Last;

  0009a	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]

; 487  :     }

  000a1	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a5	5d		 pop	 rbp
  000a6	c3		 ret	 0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@_K@std@@@std@@SAPEAU?$_List_node@_KPEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
_Pnext$ = 8
_Head$ = 16
_Pnextnext$1 = 24
this$ = 112
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);

  0001e	ba 03 00 00 00	 mov	 edx, 3
  00023	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;

  0002d	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 83 c0 08	 add	 rax, 8
  00038	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 380  :         const auto _Head          = _Myhead;

  0003c	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 89 45 10	 mov	 QWORD PTR _Head$[rbp], rax
$LN2@Orphan_non:

; 381  :         while (*_Pnext) {

  00048	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0004c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00050	74 48		 je	 SHORT $LN3@Orphan_non

; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

  00052	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 83 c0 08	 add	 rax, 8
  0005d	48 89 45 18	 mov	 QWORD PTR _Pnextnext$1[rbp], rax

; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on

  00061	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 8b 4d 10	 mov	 rcx, QWORD PTR _Head$[rbp]
  0006c	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00070	75 0a		 jne	 SHORT $LN4@Orphan_non

; 384  :                 _Pnext = _Pnextnext;

  00072	48 8b 45 18	 mov	 rax, QWORD PTR _Pnextnext$1[rbp]
  00076	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 385  :             } else { // orphan the iterator

  0007a	eb 1c		 jmp	 SHORT $LN5@Orphan_non
$LN4@Orphan_non:

; 386  :                 (*_Pnext)->_Myproxy = nullptr;

  0007c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00080	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00083	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 387  :                 *_Pnext             = *_Pnextnext;

  0008a	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0008e	48 8b 4d 18	 mov	 rcx, QWORD PTR _Pnextnext$1[rbp]
  00092	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00095	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Orphan_non:

; 388  :             }
; 389  :         }

  00098	eb ae		 jmp	 SHORT $LN2@Orphan_non
$LN3@Orphan_non:

; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

  0009a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000a4	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a8	5d		 pop	 rbp
  000a9	c3		 ret	 0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXPEAU?$_List_node@_KPEAX@2@@Z
_TEXT	SEGMENT
_Lock$ = 0
_Pnext$ = 8
_Head$ = 16
_Pnextnext$1 = 24
_Pnextptr$2 = 32
this$ = 128
_Ptr$ = 136
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXPEAU?$_List_node@_KPEAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Orphan_ptr2, COMDAT

; 355  :     void _Orphan_ptr2(_Nodeptr _Ptr) noexcept { // orphan iterators with specified node pointers

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 356  : #if _ITERATOR_DEBUG_LEVEL == 2
; 357  :         _Lockit _Lock(_LOCK_DEBUG);

  00023	ba 03 00 00 00	 mov	 edx, 3
  00028	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 358  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;

  00032	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 83 c0 08	 add	 rax, 8
  00040	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 359  :         const auto _Head          = _Myhead;

  00044	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004f	48 89 45 10	 mov	 QWORD PTR _Head$[rbp], rax
$LN2@Orphan_ptr:

; 360  :         while (*_Pnext) {

  00053	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00057	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0005b	74 5d		 je	 SHORT $LN3@Orphan_ptr

; 361  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

  0005d	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00061	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00064	48 83 c0 08	 add	 rax, 8
  00068	48 89 45 18	 mov	 QWORD PTR _Pnextnext$1[rbp], rax

; 362  :             const auto _Pnextptr          = static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr;

  0006c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00070	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00073	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00077	48 89 45 20	 mov	 QWORD PTR _Pnextptr$2[rbp], rax

; 363  :             if (_Pnextptr == _Head || _Pnextptr != _Ptr) {

  0007b	48 8b 45 10	 mov	 rax, QWORD PTR _Head$[rbp]
  0007f	48 39 45 20	 cmp	 QWORD PTR _Pnextptr$2[rbp], rax
  00083	74 0d		 je	 SHORT $LN6@Orphan_ptr
  00085	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR _Ptr$[rbp]
  0008c	48 39 45 20	 cmp	 QWORD PTR _Pnextptr$2[rbp], rax
  00090	74 0a		 je	 SHORT $LN4@Orphan_ptr
$LN6@Orphan_ptr:

; 364  :                 // iterator is end() or doesn't point at the one we are orphaning, move on
; 365  :                 _Pnext = _Pnextnext;

  00092	48 8b 45 18	 mov	 rax, QWORD PTR _Pnextnext$1[rbp]
  00096	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 366  :             } else { // orphan the iterator

  0009a	eb 1c		 jmp	 SHORT $LN5@Orphan_ptr
$LN4@Orphan_ptr:

; 367  :                 (*_Pnext)->_Myproxy = nullptr;

  0009c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  000a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a3	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 368  :                 *_Pnext             = *_Pnextnext;

  000aa	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  000ae	48 8b 4d 18	 mov	 rcx, QWORD PTR _Pnextnext$1[rbp]
  000b2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b5	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Orphan_ptr:

; 369  :             }
; 370  :         }

  000b8	eb 99		 jmp	 SHORT $LN2@Orphan_ptr
$LN3@Orphan_ptr:

; 371  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 372  :         (void) _Ptr;
; 373  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 374  :     }

  000ba	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000c4	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000c8	5d		 pop	 rbp
  000c9	c3		 ret	 0
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXPEAU?$_List_node@_KPEAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Orphan_ptr2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_List_val<std::_List_simple_types<unsigned __int64> >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QEAA@XZ ; std::_Container_base12::_Container_base12
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_List_val<std::_List_simple_types<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal, COMDAT

; 1850 :     const _Alnode& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1851 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Get_first

; 1852 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal, COMDAT

; 1846 :     _Alnode& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1847 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Get_first

; 1848 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S5$ = 8
_Proxy$ = 16
_Al$ = 32
_Newhead$ = 40
this$ = 128
?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Alloc_sentinel_and_proxy, COMDAT

; 1831 :     void _Alloc_sentinel_and_proxy() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1832 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  0001e	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  0002a	48 8b d0	 mov	 rdx, rax
  0002d	48 8d 4d 08	 lea	 rcx, QWORD PTR $S5$[rbp]
  00031	e8 00 00 00 00	 call	 ??$?0U?$_List_node@_KPEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<unsigned __int64,void *> >
  00036	48 8d 45 08	 lea	 rax, QWORD PTR $S5$[rbp]
  0003a	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 1833 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  0003e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00045	4c 8b c0	 mov	 r8, rax
  00048	48 8b 55 00	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  0004c	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00050	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00055	90		 npad	 1

; 1834 :         auto& _Al     = _Getal();

  00056	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005d	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  00062	48 89 45 20	 mov	 QWORD PTR _Al$[rbp], rax

; 1835 :         auto _Newhead = _Al.allocate(1);

  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	48 8b 4d 20	 mov	 rcx, QWORD PTR _Al$[rbp]
  0006f	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@_K@Z ; std::allocator<std::_List_node<unsigned __int64,void *> >::allocate
  00074	48 89 45 28	 mov	 QWORD PTR _Newhead$[rbp], rax

; 1836 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00078	48 8b 45 28	 mov	 rax, QWORD PTR _Newhead$[rbp]
  0007c	48 8d 55 28	 lea	 rdx, QWORD PTR _Newhead$[rbp]
  00080	48 8b c8	 mov	 rcx, rax
  00083	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * &>

; 1837 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  00088	48 8b 45 28	 mov	 rax, QWORD PTR _Newhead$[rbp]
  0008c	48 83 c0 08	 add	 rax, 8
  00090	48 8d 55 28	 lea	 rdx, QWORD PTR _Newhead$[rbp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@_KPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@_KPEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<unsigned __int64,void *> *,std::_List_node<unsigned __int64,void *> * &>

; 1838 :         _Mypair._Myval2._Myhead = _Newhead;

  0009c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	48 8b 4d 28	 mov	 rcx, QWORD PTR _Newhead$[rbp]
  000a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1839 :         _Proxy._Release();

  000ab	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000af	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  000b4	90		 npad	 1

; 1840 :     }

  000b5	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000b9	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000be	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000c2	5d		 pop	 rbp
  000c3	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Alproxy$ = 0
$S5$ = 8
_Proxy$ = 16
_Al$ = 32
_Newhead$ = 40
this$ = 128
?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ@4HA PROC ; `std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Alloc_sentinel_and_proxy'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ@4HA ENDP ; `std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Alloc_sentinel_and_proxy'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Tidy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Al$ = 0
_My_data$ = 8
this$ = 96
?_Tidy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ PROC	; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy, COMDAT

; 1496 :     void _Tidy() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1497 :         auto& _Al      = _Getal();

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  00024	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00028	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax

; 1499 :         _My_data._Orphan_all();

  00030	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 1500 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00039	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0003d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00041	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00045	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned __int64,void *> > >

; 1501 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0004a	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0004e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00052	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00056	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Freenode0<std::allocator<std::_List_node<unsigned __int64,void *> > >

; 1502 :     }

  0005b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?_Tidy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ ENDP	; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?clear@?$list@_KV?$allocator@_K@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 0
tv75 = 72
tv73 = 80
this$ = 112
?clear@?$list@_KV?$allocator@_K@std@@@std@@QEAAXXZ PROC	; std::list<unsigned __int64,std::allocator<unsigned __int64> >::clear, COMDAT

; 1486 :     void clear() noexcept { // erase all

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1487 :         auto& _My_data = _Mypair._Myval2;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 1488 :         _My_data._Orphan_non_end();

  00026	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Orphan_non_end

; 1489 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0002f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  0003b	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0003f	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  00044	48 89 45 50	 mov	 QWORD PTR tv73[rbp], rax
  00048	48 8b 55 48	 mov	 rdx, QWORD PTR tv75[rbp]
  0004c	48 8b 4d 50	 mov	 rcx, QWORD PTR tv73[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned __int64,void *> > >

; 1490 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00055	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00059	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005d	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00061	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00065	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1491 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00068	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0006c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00070	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00074	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00078	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1492 :         _My_data._Mysize        = 0;

  0007c	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00080	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1493 :     }

  00088	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0008c	5d		 pop	 rbp
  0008d	c3		 ret	 0
?clear@?$list@_KV?$allocator@_K@std@@@std@@QEAAXXZ ENDP	; std::list<unsigned __int64,std::allocator<unsigned __int64> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
_Predecessor$ = 0
_Head$ = 8
_Lock$1 = 16
_Marked$2 = 24
_Pnext$3 = 32
_Pnextnext$4 = 40
_Al$ = 48
_Erasures$ = 56
_Next$5 = 64
this$ = 160
_First$ = 168
_Last$ = 176
?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_erase, COMDAT

; 1436 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept { // erase [_First, _Last)

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1437 :         if (_First == _Last) {

  00028	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0002f	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  00036	75 0c		 jne	 SHORT $LN10@Unchecked_

; 1438 :             return _Last;

  00038	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0003f	e9 9d 01 00 00	 jmp	 $LN1@Unchecked_
$LN10@Unchecked_:

; 1439 :         }
; 1440 : 
; 1441 :         const auto _Predecessor = _First->_Prev;

  00044	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  0004b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004f	48 89 45 00	 mov	 QWORD PTR _Predecessor$[rbp], rax

; 1442 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1443 :         const auto _Head = _Mypair._Myval2._Myhead;

  00053	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005e	48 89 45 08	 mov	 QWORD PTR _Head$[rbp], rax

; 1444 :         if (_First == _Head->_Next && _Last == _Head) { // orphan all non-end iterators

  00062	48 8b 45 08	 mov	 rax, QWORD PTR _Head$[rbp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  00070	75 21		 jne	 SHORT $LN11@Unchecked_
  00072	48 8b 45 08	 mov	 rax, QWORD PTR _Head$[rbp]
  00076	48 39 85 b0 00
	00 00		 cmp	 QWORD PTR _Last$[rbp], rax
  0007d	75 14		 jne	 SHORT $LN11@Unchecked_

; 1445 :             _Mypair._Myval2._Orphan_non_end();

  0007f	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00086	48 8b c8	 mov	 rcx, rax
  00089	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Orphan_non_end

; 1446 :         } else { // orphan erased iterators

  0008e	e9 b1 00 00 00	 jmp	 $LN12@Unchecked_
$LN11@Unchecked_:

; 1447 :             _Lockit _Lock(_LOCK_DEBUG);

  00093	ba 03 00 00 00	 mov	 edx, 3
  00098	48 8d 4d 10	 lea	 rcx, QWORD PTR _Lock$1[rbp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1448 :             for (auto _Marked = _First; _Marked != _Last; _Marked = _Marked->_Next) { // mark erased nodes

  000a2	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  000a9	48 89 45 18	 mov	 QWORD PTR _Marked$2[rbp], rax
  000ad	eb 0b		 jmp	 SHORT $LN4@Unchecked_
$LN2@Unchecked_:
  000af	48 8b 45 18	 mov	 rax, QWORD PTR _Marked$2[rbp]
  000b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b6	48 89 45 18	 mov	 QWORD PTR _Marked$2[rbp], rax
$LN4@Unchecked_:
  000ba	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  000c1	48 39 45 18	 cmp	 QWORD PTR _Marked$2[rbp], rax
  000c5	74 0e		 je	 SHORT $LN3@Unchecked_

; 1449 :                 _Marked->_Prev = nullptr;

  000c7	48 8b 45 18	 mov	 rax, QWORD PTR _Marked$2[rbp]
  000cb	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1450 :             }

  000d3	eb da		 jmp	 SHORT $LN2@Unchecked_
$LN3@Unchecked_:

; 1451 : 
; 1452 :             _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

  000d5	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000df	48 83 c0 08	 add	 rax, 8
  000e3	48 89 45 20	 mov	 QWORD PTR _Pnext$3[rbp], rax
$LN5@Unchecked_:

; 1453 :             while (*_Pnext) {

  000e7	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  000eb	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000ef	74 49		 je	 SHORT $LN6@Unchecked_

; 1454 :                 _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

  000f1	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  000f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f8	48 83 c0 08	 add	 rax, 8
  000fc	48 89 45 28	 mov	 QWORD PTR _Pnextnext$4[rbp], rax

; 1455 :                 if (static_cast<const_iterator&>(**_Pnext)._Ptr->_Prev) { // node still has a _Prev, skip

  00100	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  00104	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00107	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00110	74 0a		 je	 SHORT $LN13@Unchecked_

; 1456 :                     _Pnext = _Pnextnext;

  00112	48 8b 45 28	 mov	 rax, QWORD PTR _Pnextnext$4[rbp]
  00116	48 89 45 20	 mov	 QWORD PTR _Pnext$3[rbp], rax

; 1457 :                 } else { // orphan the iterator

  0011a	eb 1c		 jmp	 SHORT $LN14@Unchecked_
$LN13@Unchecked_:

; 1458 :                     (*_Pnext)->_Myproxy = nullptr;

  0011c	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  00120	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00123	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1459 :                     *_Pnext             = *_Pnextnext;

  0012a	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  0012e	48 8b 4d 28	 mov	 rcx, QWORD PTR _Pnextnext$4[rbp]
  00132	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00135	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN14@Unchecked_:

; 1460 :                 }
; 1461 :             }

  00138	eb ad		 jmp	 SHORT $LN5@Unchecked_
$LN6@Unchecked_:

; 1462 : 
; 1463 :             // _Prev pointers not restored because we're about to delete the nodes of which they are a member anyway
; 1464 :         }

  0013a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Lock$1[rbp]
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
$LN12@Unchecked_:

; 1465 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1466 : 
; 1467 :         // snip out the removed range
; 1468 :         _Predecessor->_Next = _Last;

  00144	48 8b 45 00	 mov	 rax, QWORD PTR _Predecessor$[rbp]
  00148	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  0014f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1469 :         _Last->_Prev        = _Predecessor;

  00152	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00159	48 8b 4d 00	 mov	 rcx, QWORD PTR _Predecessor$[rbp]
  0015d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1470 : 
; 1471 :         // count and deallocate the removed nodes
; 1472 :         auto& _Al           = _Getal();

  00161	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00168	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  0016d	48 89 45 30	 mov	 QWORD PTR _Al$[rbp], rax

; 1473 :         size_type _Erasures = 0;

  00171	48 c7 45 38 00
	00 00 00	 mov	 QWORD PTR _Erasures$[rbp], 0
$LN9@Unchecked_:

; 1474 :         do {
; 1475 :             const auto _Next = _First->_Next;

  00179	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  00180	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00183	48 89 45 40	 mov	 QWORD PTR _Next$5[rbp], rax

; 1476 :             _Node::_Freenode(_Al, _First);

  00187	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _First$[rbp]
  0018e	48 8b 4d 30	 mov	 rcx, QWORD PTR _Al$[rbp]
  00192	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Freenode<std::allocator<std::_List_node<unsigned __int64,void *> > >

; 1477 :             _First = _Next;

  00197	48 8b 45 40	 mov	 rax, QWORD PTR _Next$5[rbp]
  0019b	48 89 85 a8 00
	00 00		 mov	 QWORD PTR _First$[rbp], rax

; 1478 :             ++_Erasures;

  001a2	48 8b 45 38	 mov	 rax, QWORD PTR _Erasures$[rbp]
  001a6	48 ff c0	 inc	 rax
  001a9	48 89 45 38	 mov	 QWORD PTR _Erasures$[rbp], rax

; 1479 :         } while (_First != _Last);

  001ad	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  001b4	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  001bb	75 bc		 jne	 SHORT $LN9@Unchecked_

; 1480 : 
; 1481 :         _Mypair._Myval2._Mysize -= _Erasures;

  001bd	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001c4	48 8b 4d 38	 mov	 rcx, QWORD PTR _Erasures$[rbp]
  001c8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001cc	48 2b c1	 sub	 rax, rcx
  001cf	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001d6	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1482 :         return _Last;

  001da	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
$LN1@Unchecked_:

; 1483 :     }

  001e1	48 8d a5 90 00
	00 00		 lea	 rsp, QWORD PTR [rbp+144]
  001e8	5d		 pop	 rbp
  001e9	c3		 ret	 0
?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@PEAU32@QEAU32@@Z ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@QEAU32@@Z
_TEXT	SEGMENT
_Result$ = 0
tv70 = 72
this$ = 96
_Pnode$ = 104
?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@QEAU32@@Z PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_erase, COMDAT

; 1419 :     _Nodeptr _Unchecked_erase(const _Nodeptr _Pnode) noexcept { // erase element at _Pnode

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1420 :         const auto _Result = _Pnode->_Next;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Pnode$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax

; 1421 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 89 45 48	 mov	 QWORD PTR tv70[rbp], rax
  00033	48 8b 55 68	 mov	 rdx, QWORD PTR _Pnode$[rbp]
  00037	48 8b 4d 48	 mov	 rcx, QWORD PTR tv70[rbp]
  0003b	e8 00 00 00 00	 call	 ?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@_K@std@@@std@@QEAAXPEAU?$_List_node@_KPEAX@2@@Z ; std::_List_val<std::_List_simple_types<unsigned __int64> >::_Orphan_ptr2

; 1422 :         --_Mypair._Myval2._Mysize;

  00040	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00044	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00048	48 ff c8	 dec	 rax
  0004b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0004f	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1423 :         _Pnode->_Prev->_Next = _Result;

  00053	48 8b 45 68	 mov	 rax, QWORD PTR _Pnode$[rbp]
  00057	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005b	48 8b 4d 00	 mov	 rcx, QWORD PTR _Result$[rbp]
  0005f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1424 :         _Result->_Prev       = _Pnode->_Prev;

  00062	48 8b 45 00	 mov	 rax, QWORD PTR _Result$[rbp]
  00066	48 8b 4d 68	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  0006a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0006e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1425 :         _Node::_Freenode(_Getal(), _Pnode);

  00072	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  0007b	48 8b 55 68	 mov	 rdx, QWORD PTR _Pnode$[rbp]
  0007f	48 8b c8	 mov	 rcx, rax
  00082	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@?$_List_node@_KPEAX@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@1@PEAU01@@Z ; std::_List_node<unsigned __int64,void *>::_Freenode<std::allocator<std::_List_node<unsigned __int64,void *> > >

; 1426 :         return _Result;

  00087	48 8b 45 00	 mov	 rax, QWORD PTR _Result$[rbp]

; 1427 :     }

  0008b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0008f	5d		 pop	 rbp
  00090	c3		 ret	 0
?_Unchecked_erase@?$list@_KV?$allocator@_K@std@@@std@@AEAAPEAU?$_List_node@_KPEAX@2@QEAU32@@Z ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?max_size@?$list@_KV?$allocator@_K@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
this$ = 96
?max_size@?$list@_KV?$allocator@_K@std@@@std@@QEBA_KXZ PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::max_size, COMDAT

; 1191 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1192 :         return (_STD min)(

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::max_size
  0002c	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00030	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00035	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00039	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0003d	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00041	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1193 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1194 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?max_size@?$list@_KV?$allocator@_K@std@@@std@@QEBA_KXZ ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
_Where$ = 96
?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter, COMDAT

; 1120 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1121 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<unsigned __int64> > const >
  00031	4c 8b c0	 mov	 r8, rax
  00034	48 8b 55 60	 mov	 rdx, QWORD PTR _Where$[rbp]
  00038	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0003c	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
  00041	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1122 :     }

  00045	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
?_Make_iter@?$list@_KV?$allocator@_K@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@PEAU?$_List_node@_KPEAX@2@@Z ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?_Unchecked_end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_end, COMDAT

; 1112 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1113 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

  00020	45 33 c0	 xor	 r8d, r8d
  00023	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0002b	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0002f	e8 00 00 00 00	 call	 ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
  00034	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1114 :     }

  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?_Unchecked_end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?_Unchecked_begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_begin, COMDAT

; 1104 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1105 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	45 33 c0	 xor	 r8d, r8d
  0002b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002e	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00032	e8 00 00 00 00	 call	 ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
  00037	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1106 :     }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
?_Unchecked_begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 64
tv76 = 72
this$ = 96
__$ReturnUdt$ = 104
?end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::end, COMDAT

; 1096 :     _NODISCARD iterator end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1097 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<unsigned __int64> > >
  0002c	48 89 45 40	 mov	 QWORD PTR tv78[rbp], rax
  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 89 45 48	 mov	 QWORD PTR tv76[rbp], rax
  0003c	4c 8b 45 40	 mov	 r8, QWORD PTR tv78[rbp]
  00040	48 8b 55 48	 mov	 rdx, QWORD PTR tv76[rbp]
  00044	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00048	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
  0004d	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1098 :     }

  00051	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
?end@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv79 = 64
tv77 = 72
this$ = 96
__$ReturnUdt$ = 104
?begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::begin, COMDAT

; 1088 :     _NODISCARD iterator begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1089 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@_K@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<unsigned __int64> > >
  0002c	48 89 45 40	 mov	 QWORD PTR tv79[rbp], rax
  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003b	48 89 45 48	 mov	 QWORD PTR tv77[rbp], rax
  0003f	4c 8b 45 40	 mov	 r8, QWORD PTR tv79[rbp]
  00043	48 8b 55 48	 mov	 rdx, QWORD PTR tv77[rbp]
  00047	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0004b	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@std@@QEAA@PEAU?$_List_node@_KPEAX@1@PEBV?$_List_val@U?$_List_simple_types@_K@std@@@1@@Z
  00050	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1090 :     }

  00054	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00058	5d		 pop	 rbp
  00059	c3		 ret	 0
?begin@?$list@_KV?$allocator@_K@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@_K@std@@@std@@@2@XZ ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??1?$list@_KV?$allocator@_K@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S2$ = 8
this$ = 96
??1?$list@_KV?$allocator@_K@std@@@std@@QEAA@XZ PROC	; std::list<unsigned __int64,std::allocator<unsigned __int64> >::~list<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT

; 1044 :     ~list() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1045 :         _Tidy();

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Tidy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy

; 1046 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1047 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00024	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ?_Getal@?$list@_KV?$allocator@_K@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@XZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Getal
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8d 4d 08	 lea	 rcx, QWORD PTR $S2$[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0U?$_List_node@_KPEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@_KPEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<unsigned __int64,void *> >
  00039	48 8d 45 08	 lea	 rax, QWORD PTR $S2$[rbp]
  0003d	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 1048 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);

  00041	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00048	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  0004c	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 1049 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1050 :     }

  00051	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
??1?$list@_KV?$allocator@_K@std@@@std@@QEAA@XZ ENDP	; std::list<unsigned __int64,std::allocator<unsigned __int64> >::~list<unsigned __int64,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$list@_KV?$allocator@_K@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z
_TEXT	SEGMENT
$T1 = 64
tv70 = 72
this$ = 96
_Al$ = 104
??0?$list@_KV?$allocator@_K@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z PROC ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::list<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT

; 802  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 48	 mov	 QWORD PTR tv70[rbp], rax
  00028	4c 8b 45 68	 mov	 r8, QWORD PTR _Al$[rbp]
  0002c	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00030	48 8b 4d 48	 mov	 rcx, QWORD PTR tv70[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@_K@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@_K@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_K@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1>::_Compressed_pair<std::allocator<std::_List_node<unsigned __int64,void *> >,std::_List_val<std::_List_simple_types<unsigned __int64> >,1><std::allocator<unsigned __int64> const &>

; 803  :         _Alloc_sentinel_and_proxy();

  00039	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003d	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@_KV?$allocator@_K@std@@@std@@AEAAXXZ ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::_Alloc_sentinel_and_proxy

; 804  :     }

  00042	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00046	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
??0?$list@_KV?$allocator@_K@std@@@std@@QEAA@AEBV?$allocator@_K@1@@Z ENDP ; std::list<unsigned __int64,std::allocator<unsigned __int64> >::list<unsigned __int64,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 80
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001b	48 b8 aa aa aa
	aa aa aa aa 0a	 mov	 rax, 768614336404564650	; 0aaaaaaaaaaaaaaaH

; 738  :     }

  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@_KPEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@QEAU?$_List_node@_KPEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@QEAU?$_List_node@_KPEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@deallocate

; 709  :             _Al.deallocate(_Ptr, _Count);

  00031	4c 8b 45 60	 mov	 r8, QWORD PTR _Count$[rbp]
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00039	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAXQEAU?$_List_node@_KPEAX@2@_K@Z ; std::allocator<std::_List_node<unsigned __int64,void *> >::deallocate

; 710  :         } else

  00042	eb 11		 jmp	 SHORT $LN3@deallocate
$LN2@deallocate:

; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00044	48 6b 45 60 18	 imul	 rax, QWORD PTR _Count$[rbp], 24
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>
$LN3@deallocate:

; 715  :         }
; 716  :     }

  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@_KPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@_KPEAX@std@@@2@QEAU?$_List_node@_KPEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<unsigned __int64,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@_K@Z PROC ; std::allocator<std::_List_node<unsigned __int64,void *> >::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z ; std::_Get_size_of_n<24>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAPEAU?$_List_node@_KPEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<unsigned __int64,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAXQEAU?$_List_node@_KPEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAXQEAU?$_List_node@_KPEAX@2@_K@Z PROC ; std::allocator<std::_List_node<unsigned __int64,void *> >::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 6b 45 60 18	 imul	 rax, QWORD PTR _Count$[rbp], 24
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bb	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?deallocate@?$allocator@U?$_List_node@_KPEAX@std@@@std@@QEAAXQEAU?$_List_node@_KPEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<unsigned __int64,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\unordered_set
;	COMDAT ?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z
_TEXT	SEGMENT
_Val$ = 80
?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z PROC ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn, COMDAT

; 52   :     static const _Kty& _Kfn(const value_type& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__4818932A_unordered_set
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 53   :         return _Val;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 54   :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Kfn@?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@SAAEB_KAEB_K@Z ENDP ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Kfn
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\unordered_set
;	COMDAT ??0?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Traits$ = 88
??0?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z PROC ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>, COMDAT

; 48   :     explicit _Uset_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__4818932A_unordered_set
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Traits$[rbp]
  00024	8b 00		 mov	 eax, DWORD PTR [rax]
  00026	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002a	89 01		 mov	 DWORD PTR [rcx], eax
  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??0?$_Uset_traits@_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@_K@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ENDP ; std::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>::_Uset_traits<unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<unsigned __int64>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$allocator@_K@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$allocator@_K@std@@QEAA@XZ PROC			; std::allocator<unsigned __int64>::allocator<unsigned __int64>, COMDAT

; 962  :     constexpr allocator() noexcept {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??0?$allocator@_K@std@@QEAA@XZ ENDP			; std::allocator<unsigned __int64>::allocator<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::~unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::~unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\unordered_map
;	COMDAT ??0?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 68
tv79 = 72
tv77 = 80
this$ = 112
??0?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >, COMDAT

; 106  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DA11C4D_unordered_map
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001e	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00022	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,Bucket> >::allocator<std::pair<unsigned __int64 const ,Bucket> >
  00027	48 89 45 48	 mov	 QWORD PTR tv79[rbp], rax
  0002b	48 8d 4d 44	 lea	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
  00034	48 89 45 50	 mov	 QWORD PTR tv77[rbp], rax
  00038	4c 8b 45 48	 mov	 r8, QWORD PTR tv79[rbp]
  0003c	48 8b 55 50	 mov	 rdx, QWORD PTR tv77[rbp]
  00040	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00044	e8 00 00 00 00	 call	 ??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >
  00049	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0004d	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00051	5d		 pop	 rbp
  00052	c3		 ret	 0
??0?$unordered_map@_KUBucket@@U?$hash@_K@std@@U?$equal_to@_K@3@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::unordered_map<unsigned __int64,Bucket,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 83 c0 20	 add	 rax, 32			; 00000020H
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >
  0001f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00023	48 83 c0 08	 add	 rax, 8
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 ??1?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::~list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??1?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >, COMDAT

; 397  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QEAA@XZ ; std::_Container_base12::_Container_base12
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S3$ = 8
$T1 = 73
this$ = 112
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >, COMDAT

; 322  :     ~_Hash_vec() {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 323  :         _Tidy();

  0001e	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00022	e8 00 00 00 00	 call	 ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Tidy

; 324  : #if _ITERATOR_DEBUG_LEVEL != 0
; 325  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());

  00027	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first
  00033	48 8b d0	 mov	 rdx, rax
  00036	48 8d 4d 08	 lea	 rcx, QWORD PTR $S3$[rbp]
  0003a	e8 00 00 00 00	 call	 ??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
  0003f	48 8d 45 08	 lea	 rax, QWORD PTR $S3$[rbp]
  00043	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 326  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  00047	48 c7 45 49 00
	00 00 00	 mov	 QWORD PTR $T1[rbp], 0
  0004f	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00053	48 8d 55 49	 lea	 rdx, QWORD PTR $T1[rbp]
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  0005f	48 8b d0	 mov	 rdx, rax
  00062	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  00066	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 327  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 328  :     }

  0006b	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv92 = 64
tv90 = 72
tv88 = 80
this$ = 112
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Tidy, COMDAT

; 312  :     void _Tidy() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 313  :         if (_Mypair._Myval2._Myfirst != nullptr) {

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00027	74 73		 je	 SHORT $LN2@Tidy

; 314  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

  00029	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00031	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00039	e8 00 00 00 00	 call	 ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>

; 315  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

  0003e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00042	48 8b c8	 mov	 rcx, rax
  00045	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first
  0004a	48 89 45 40	 mov	 QWORD PTR tv92[rbp], rax
  0004e	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00052	e8 00 00 00 00	 call	 ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::capacity
  00057	48 89 45 48	 mov	 QWORD PTR tv90[rbp], rax
  0005b	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0005f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00063	48 89 45 50	 mov	 QWORD PTR tv88[rbp], rax
  00067	4c 8b 45 48	 mov	 r8, QWORD PTR tv90[rbp]
  0006b	48 8b 55 50	 mov	 rdx, QWORD PTR tv88[rbp]
  0006f	48 8b 4d 40	 mov	 rcx, QWORD PTR tv92[rbp]
  00073	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::deallocate

; 316  :             _Mypair._Myval2._Myfirst = nullptr;

  00078	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0007c	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 317  :             _Mypair._Myval2._Mylast  = nullptr;

  00084	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00088	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 318  :             _Mypair._Myval2._Myend   = nullptr;

  00090	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00094	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN2@Tidy:

; 319  :         }
; 320  :     }

  0009c	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a0	5d		 pop	 rbp
  000a1	c3		 ret	 0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Oldsize$ = 0
_Alvec$ = 8
_Newvec$1 = 16
_Oldcapacity$2 = 24
_Newend$3 = 32
this$ = 128
_Cells$ = 136
_Val$ = 144
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Assign_grow, COMDAT

; 288  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 289  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 290  :         const auto _Oldsize = size();

  00028	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::size
  00034	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 291  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 292  :         auto& _Alvec = _Mypair._Get_first();

  00038	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first
  00047	48 89 45 08	 mov	 QWORD PTR _Alvec$[rbp], rax

; 293  :         if (_Oldsize < _Cells) {

  0004b	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR _Cells$[rbp]
  00052	48 39 45 00	 cmp	 QWORD PTR _Oldsize$[rbp], rax
  00056	0f 83 b4 00 00
	00		 jae	 $LN2@Assign_gro

; 294  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

  0005c	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR _Cells$[rbp]
  00063	48 8b 4d 08	 mov	 rcx, QWORD PTR _Alvec$[rbp]
  00067	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::allocate
  0006c	48 89 45 10	 mov	 QWORD PTR _Newvec$1[rbp], rax

; 295  :             // nothrow hereafter
; 296  :             const auto _Oldcapacity = capacity();

  00070	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00077	e8 00 00 00 00	 call	 ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::capacity
  0007c	48 89 45 18	 mov	 QWORD PTR _Oldcapacity$2[rbp], rax

; 297  :             if (_Oldcapacity != 0) {

  00080	48 83 7d 18 00	 cmp	 QWORD PTR _Oldcapacity$2[rbp], 0
  00085	74 33		 je	 SHORT $LN4@Assign_gro

; 298  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

  00087	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00092	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00099	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0009d	e8 00 00 00 00	 call	 ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *>

; 299  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

  000a2	4c 8b 45 18	 mov	 r8, QWORD PTR _Oldcapacity$2[rbp]
  000a6	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ad	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000b1	48 8b 4d 08	 mov	 rcx, QWORD PTR _Alvec$[rbp]
  000b5	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::deallocate
$LN4@Assign_gro:

; 300  :             }
; 301  : 
; 302  :             _Mypair._Myval2._Myfirst = _Newvec;

  000ba	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c1	48 8b 4d 10	 mov	 rcx, QWORD PTR _Newvec$1[rbp]
  000c5	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 303  :             const auto _Newend       = _Newvec + _Cells;

  000c9	48 8b 45 10	 mov	 rax, QWORD PTR _Newvec$1[rbp]
  000cd	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Cells$[rbp]
  000d4	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  000d8	48 89 45 20	 mov	 QWORD PTR _Newend$3[rbp], rax

; 304  :             _Mypair._Myval2._Mylast  = _Newend;

  000dc	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000e3	48 8b 4d 20	 mov	 rcx, QWORD PTR _Newend$3[rbp]
  000e7	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 305  :             _Mypair._Myval2._Myend   = _Newend;

  000eb	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000f2	48 8b 4d 20	 mov	 rcx, QWORD PTR _Newend$3[rbp]
  000f6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 306  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

  000fa	4c 8d 85 90 00
	00 00		 lea	 r8, QWORD PTR _Val$[rbp]
  00101	48 8b 55 20	 mov	 rdx, QWORD PTR _Newend$3[rbp]
  00105	48 8b 4d 10	 mov	 rcx, QWORD PTR _Newvec$1[rbp]
  00109	e8 00 00 00 00	 call	 ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >

; 307  :         } else {

  0010e	eb 22		 jmp	 SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 308  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

  00110	4c 8d 85 90 00
	00 00		 lea	 r8, QWORD PTR _Val$[rbp]
  00117	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0011e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00122	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00129	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0012d	e8 00 00 00 00	 call	 ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
$LN3@Assign_gro:

; 309  :         }
; 310  :     }

  00132	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00136	5d		 pop	 rbp
  00137	c3		 ret	 0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 80
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::capacity, COMDAT

; 282  :     _NODISCARD size_type capacity() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 283  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 284  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 285  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00027	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002b	48 2b c1	 sub	 rax, rcx
  0002e	48 c1 f8 03	 sar	 rax, 3

; 286  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
this$ = 96
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::max_size, COMDAT

; 277  :     _NODISCARD size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 278  :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >,1>::_Get_first
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::max_size
  0002f	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00033	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00038	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  0003c	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00040	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00044	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 279  :             _Aliter_traits::max_size(_Mypair._Get_first()));
; 280  :     }

  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 80
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::size, COMDAT

; 273  :     _NODISCARD size_type size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 274  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 2b c1	 sub	 rax, rcx
  0002e	48 c1 f8 03	 sar	 rax, 3

; 275  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 80
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001b	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 738  :     }

  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YA_K_K@Z ; std::_Get_size_of_n<8>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 8b 45 60	 mov	 rax, QWORD PTR _Count$[rbp]
  000ae	48 c1 e0 03	 shl	 rax, 3
  000b2	48 8b d0	 mov	 rdx, rax
  000b5	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b9	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000be	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000c2	5d		 pop	 rbp
  000c3	c3		 ret	 0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 80
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Max_bucket_size, COMDAT

; 1805 :     const float& _Max_bucket_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1806 :         return _Traitsobj._Get_max_bucket_size();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1807 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 80
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Max_bucket_size, COMDAT

; 1801 :     float& _Max_bucket_size() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1802 :         return _Traitsobj._Get_max_bucket_size();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1803 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
_Max_storage_buckets_log2$ = 0
_Max_storage_buckets$ = 8
_End$ = 16
_Guard$ = 24
_Inserted$ = 32
_Next_inserted$1 = 40
_Inserted_key$2 = 48
_Bucket$3 = 56
_Bucket_lo$4 = 64
_Bucket_hi$5 = 72
_Insert_before$6 = 80
tv313 = 152
tv309 = 152
tv258 = 152
tv194 = 152
tv84 = 152
this$ = 176
_Buckets$ = 184
?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Forced_rehash, COMDAT

; 1709 :     void _Forced_rehash(size_type _Buckets) {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1710 :         // Force rehash of elements in _List, distrusting existing bucket assignments in _Vec.
; 1711 :         // Assumes _Buckets is greater than _Min_buckets, and that changing to that many buckets doesn't violate
; 1712 :         // load_factor() <= max_load_factor().
; 1713 : 
; 1714 :         // Don't violate power of 2, fits in half the bucket vector invariant:
; 1715 :         // (we assume because vector must use single allocations; as a result, its max_size fits in a size_t)
; 1716 :         const unsigned long _Max_storage_buckets_log2 = _Floor_of_log_2(static_cast<size_t>(_Vec.max_size() >> 1));

  00023	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::max_size
  00036	48 d1 e8	 shr	 rax, 1
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ?_Floor_of_log_2@std@@YAK_K@Z ; std::_Floor_of_log_2
  00041	89 45 00	 mov	 DWORD PTR _Max_storage_buckets_log2$[rbp], eax

; 1717 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

  00044	8b 45 00	 mov	 eax, DWORD PTR _Max_storage_buckets_log2$[rbp]
  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	48 89 8d 98 00
	00 00		 mov	 QWORD PTR tv309[rbp], rcx
  00053	0f b6 c8	 movzx	 ecx, al
  00056	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR tv309[rbp]
  0005d	48 d3 e0	 shl	 rax, cl
  00060	48 89 45 08	 mov	 QWORD PTR _Max_storage_buckets$[rbp], rax

; 1718 :         if (_Buckets > _Max_storage_buckets) {

  00064	48 8b 45 08	 mov	 rax, QWORD PTR _Max_storage_buckets$[rbp]
  00068	48 39 85 b8 00
	00 00		 cmp	 QWORD PTR _Buckets$[rbp], rax
  0006f	76 0c		 jbe	 SHORT $LN8@Forced_reh

; 1719 :             _Xlength_error("invalid hash bucket count");

  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
  00078	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN8@Forced_reh:

; 1720 :         }
; 1721 : 
; 1722 :         // The above test also means that we won't perform a forbidden full shift when restoring the power of
; 1723 :         // 2 invariant
; 1724 :         // this round up to power of 2 in addition to the _Buckets > _Maxidx above means
; 1725 :         // we'll at least double in size (the next power of 2 above _Maxidx)
; 1726 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

  0007d	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR _Buckets$[rbp]
  00084	e8 00 00 00 00	 call	 ?_Ceiling_of_log_2@std@@YAK_K@Z ; std::_Ceiling_of_log_2
  00089	b9 01 00 00 00	 mov	 ecx, 1
  0008e	48 89 8d 98 00
	00 00		 mov	 QWORD PTR tv313[rbp], rcx
  00095	0f b6 c8	 movzx	 ecx, al
  00098	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR tv313[rbp]
  0009f	48 d3 e0	 shl	 rax, cl
  000a2	48 89 85 b8 00
	00 00		 mov	 QWORD PTR _Buckets$[rbp], rax

; 1727 :         const _Unchecked_iterator _End = _Unchecked_end();

  000a9	48 8d 55 10	 lea	 rdx, QWORD PTR _End$[rbp]
  000ad	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b4	e8 00 00 00 00	 call	 ?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_end

; 1728 : 
; 1729 :         _Vec._Assign_grow(_Buckets << 1, _End);

  000b9	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c0	48 83 c0 20	 add	 rax, 32			; 00000020H
  000c4	48 89 85 98 00
	00 00		 mov	 QWORD PTR tv84[rbp], rax
  000cb	48 8b 85 b8 00
	00 00		 mov	 rax, QWORD PTR _Buckets$[rbp]
  000d2	48 d1 e0	 shl	 rax, 1
  000d5	4c 8b 45 10	 mov	 r8, QWORD PTR _End$[rbp]
  000d9	48 8b d0	 mov	 rdx, rax
  000dc	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR tv84[rbp]
  000e3	e8 00 00 00 00	 call	 ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Assign_grow

; 1730 :         _Mask   = _Buckets - 1;

  000e8	48 8b 85 b8 00
	00 00		 mov	 rax, QWORD PTR _Buckets$[rbp]
  000ef	48 ff c8	 dec	 rax
  000f2	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f9	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 1731 :         _Maxidx = _Buckets;

  000fd	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00104	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR _Buckets$[rbp]
  0010b	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 1732 : 
; 1733 :         _Clear_guard _Guard{this};

  0010f	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  00116	48 8d 4d 18	 lea	 rcx, QWORD PTR _Guard$[rbp]
  0011a	e8 00 00 00 00	 call	 ??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Clear_guard::_Clear_guard

; 1734 : 
; 1735 :         _Unchecked_iterator _Inserted = _Unchecked_begin();

  0011f	48 8d 55 20	 lea	 rdx, QWORD PTR _Inserted$[rbp]
  00123	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0012a	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_begin

; 1736 : 
; 1737 :         // Remember the next _Inserted value as splices will change _Inserted's position arbitrarily.
; 1738 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

  0012f	48 8b 45 20	 mov	 rax, QWORD PTR _Inserted$[rbp]
  00133	48 89 45 28	 mov	 QWORD PTR _Next_inserted$1[rbp], rax
  00137	eb 08		 jmp	 SHORT $LN4@Forced_reh
$LN2@Forced_reh:
  00139	48 8b 45 28	 mov	 rax, QWORD PTR _Next_inserted$1[rbp]
  0013d	48 89 45 20	 mov	 QWORD PTR _Inserted$[rbp], rax
$LN4@Forced_reh:
  00141	48 8d 55 10	 lea	 rdx, QWORD PTR _End$[rbp]
  00145	48 8d 4d 20	 lea	 rcx, QWORD PTR _Inserted$[rbp]
  00149	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator==
  0014e	0f b6 c0	 movzx	 eax, al
  00151	85 c0		 test	 eax, eax
  00153	0f 85 b1 01 00
	00		 jne	 $LN3@Forced_reh

; 1739 :             ++_Next_inserted;

  00159	48 8d 4d 28	 lea	 rcx, QWORD PTR _Next_inserted$1[rbp]
  0015d	e8 00 00 00 00	 call	 ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator++

; 1740 : 
; 1741 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);

  00162	48 8d 4d 20	 lea	 rcx, QWORD PTR _Inserted$[rbp]
  00166	e8 00 00 00 00	 call	 ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUBucket@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > >::operator*
  0016b	48 8b c8	 mov	 rcx, rax
  0016e	e8 00 00 00 00	 call	 ??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>
  00173	48 89 45 30	 mov	 QWORD PTR _Inserted_key$2[rbp], rax

; 1742 :             const size_type _Bucket = bucket(_Inserted_key);

  00177	48 8b 55 30	 mov	 rdx, QWORD PTR _Inserted_key$2[rbp]
  0017b	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00182	e8 00 00 00 00	 call	 ?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket
  00187	48 89 45 38	 mov	 QWORD PTR _Bucket$3[rbp], rax

; 1743 : 
; 1744 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1745 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1746 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

  0018b	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket$3[rbp]
  0018f	48 d1 e0	 shl	 rax, 1
  00192	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0019d	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  001a1	48 89 45 40	 mov	 QWORD PTR _Bucket_lo$4[rbp], rax

; 1747 :             _Unchecked_iterator& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1];

  001a5	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket$3[rbp]
  001a9	48 d1 e0	 shl	 rax, 1
  001ac	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001b3	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001b7	48 8d 44 c1 08	 lea	 rax, QWORD PTR [rcx+rax*8+8]
  001bc	48 89 45 48	 mov	 QWORD PTR _Bucket_hi$5[rbp], rax

; 1748 : 
; 1749 :             if (_Bucket_lo == _End) {

  001c0	48 8d 55 10	 lea	 rdx, QWORD PTR _End$[rbp]
  001c4	48 8b 4d 40	 mov	 rcx, QWORD PTR _Bucket_lo$4[rbp]
  001c8	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator==
  001cd	0f b6 c0	 movzx	 eax, al
  001d0	85 c0		 test	 eax, eax
  001d2	74 1b		 je	 SHORT $LN9@Forced_reh

; 1750 :                 // The bucket was empty, set it to the inserted element.
; 1751 :                 _Bucket_lo = _Inserted;

  001d4	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_lo$4[rbp]
  001d8	48 8b 4d 20	 mov	 rcx, QWORD PTR _Inserted$[rbp]
  001dc	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1752 :                 _Bucket_hi = _Inserted;

  001df	48 8b 45 48	 mov	 rax, QWORD PTR _Bucket_hi$5[rbp]
  001e3	48 8b 4d 20	 mov	 rcx, QWORD PTR _Inserted$[rbp]
  001e7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1753 :                 continue;

  001ea	e9 4a ff ff ff	 jmp	 $LN2@Forced_reh
$LN9@Forced_reh:

; 1754 :             }
; 1755 : 
; 1756 :             // Search the bucket for the insertion location and move element if necessary.
; 1757 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

  001ef	48 8b 45 48	 mov	 rax, QWORD PTR _Bucket_hi$5[rbp]
  001f3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f6	48 89 45 50	 mov	 QWORD PTR _Insert_before$6[rbp], rax

; 1758 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

  001fa	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00201	48 89 85 98 00
	00 00		 mov	 QWORD PTR tv194[rbp], rax
  00208	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  0020c	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator*
  00211	48 8b c8	 mov	 rcx, rax
  00214	e8 00 00 00 00	 call	 ??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>
  00219	4c 8b c0	 mov	 r8, rax
  0021c	48 8b 55 30	 mov	 rdx, QWORD PTR _Inserted_key$2[rbp]
  00220	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR tv194[rbp]
  00227	e8 00 00 00 00	 call	 ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
  0022c	0f b6 c0	 movzx	 eax, al
  0022f	85 c0		 test	 eax, eax
  00231	75 3e		 jne	 SHORT $LN5@Forced_reh

; 1759 :                 // The inserted element belongs at the end of the bucket; splice it there and set _Bucket_hi to the
; 1760 :                 // new bucket inclusive end.
; 1761 :                 ++_Insert_before;

  00233	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  00237	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator++

; 1762 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

  0023c	48 8d 55 20	 lea	 rdx, QWORD PTR _Inserted$[rbp]
  00240	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  00244	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator==
  00249	0f b6 c0	 movzx	 eax, al
  0024c	85 c0		 test	 eax, eax
  0024e	75 11		 jne	 SHORT $LN11@Forced_reh

; 1763 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

  00250	4c 8b 45 28	 mov	 r8, QWORD PTR _Next_inserted$1[rbp]
  00254	48 8b 55 20	 mov	 rdx, QWORD PTR _Inserted$[rbp]
  00258	48 8b 4d 50	 mov	 rcx, QWORD PTR _Insert_before$6[rbp]
  0025c	e8 00 00 00 00	 call	 ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_splice
$LN11@Forced_reh:

; 1764 :                 }
; 1765 : 
; 1766 :                 _Bucket_hi = _Inserted;

  00261	48 8b 45 48	 mov	 rax, QWORD PTR _Bucket_hi$5[rbp]
  00265	48 8b 4d 20	 mov	 rcx, QWORD PTR _Inserted$[rbp]
  00269	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1767 :                 continue;

  0026c	e9 c8 fe ff ff	 jmp	 $LN2@Forced_reh
$LN5@Forced_reh:

; 1768 :             }
; 1769 : 
; 1770 :             // The insertion point isn't *_Bucket_hi, so search [_Bucket_lo, _Bucket_hi) for insertion point; we
; 1771 :             // go backwards to maintain sortedness when !_Standard.
; 1772 :             for (;;) {
; 1773 :                 if (_Bucket_lo == _Insert_before) {

  00271	48 8d 55 50	 lea	 rdx, QWORD PTR _Insert_before$6[rbp]
  00275	48 8b 4d 40	 mov	 rcx, QWORD PTR _Bucket_lo$4[rbp]
  00279	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator==
  0027e	0f b6 c0	 movzx	 eax, al
  00281	85 c0		 test	 eax, eax
  00283	74 1e		 je	 SHORT $LN12@Forced_reh

; 1774 :                     // There are no equivalent keys in the bucket, so insert it at the beginning.
; 1775 :                     // Element can't be already in position here because:
; 1776 :                     // * (for !_Standard) _Inserted_key < *_Insert_before or
; 1777 :                     // * (for _Standard) _Inserted_key != *_Insert_before
; 1778 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

  00285	4c 8b 45 28	 mov	 r8, QWORD PTR _Next_inserted$1[rbp]
  00289	48 8b 55 20	 mov	 rdx, QWORD PTR _Inserted$[rbp]
  0028d	48 8b 4d 50	 mov	 rcx, QWORD PTR _Insert_before$6[rbp]
  00291	e8 00 00 00 00	 call	 ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_splice

; 1779 :                     _Bucket_lo = _Inserted;

  00296	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_lo$4[rbp]
  0029a	48 8b 4d 20	 mov	 rcx, QWORD PTR _Inserted$[rbp]
  0029e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1780 :                     break;

  002a1	eb 62		 jmp	 SHORT $LN6@Forced_reh
$LN12@Forced_reh:

; 1781 :                 }
; 1782 : 
; 1783 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

  002a3	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  002aa	48 89 85 98 00
	00 00		 mov	 QWORD PTR tv258[rbp], rax
  002b1	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  002b5	e8 00 00 00 00	 call	 ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator--
  002ba	48 8b c8	 mov	 rcx, rax
  002bd	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KUBucket@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator*
  002c2	48 8b c8	 mov	 rcx, rax
  002c5	e8 00 00 00 00	 call	 ??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>
  002ca	4c 8b c0	 mov	 r8, rax
  002cd	48 8b 55 30	 mov	 rdx, QWORD PTR _Inserted_key$2[rbp]
  002d1	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR tv258[rbp]
  002d8	e8 00 00 00 00	 call	 ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
  002dd	0f b6 c0	 movzx	 eax, al
  002e0	85 c0		 test	 eax, eax
  002e2	75 1c		 jne	 SHORT $LN13@Forced_reh

; 1784 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1785 :                     ++_Insert_before;

  002e4	48 8d 4d 50	 lea	 rcx, QWORD PTR _Insert_before$6[rbp]
  002e8	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,std::_Iterator_base0>::operator++

; 1786 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1787 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1788 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

  002ed	4c 8b 45 28	 mov	 r8, QWORD PTR _Next_inserted$1[rbp]
  002f1	48 8b 55 20	 mov	 rdx, QWORD PTR _Inserted$[rbp]
  002f5	48 8b 4d 50	 mov	 rcx, QWORD PTR _Insert_before$6[rbp]
  002f9	e8 00 00 00 00	 call	 ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_splice

; 1789 :                     break;

  002fe	eb 05		 jmp	 SHORT $LN6@Forced_reh
$LN13@Forced_reh:

; 1790 :                 }
; 1791 :             }

  00300	e9 6c ff ff ff	 jmp	 $LN5@Forced_reh
$LN6@Forced_reh:

; 1792 :         }

  00305	e9 2f fe ff ff	 jmp	 $LN2@Forced_reh
$LN3@Forced_reh:

; 1793 : 
; 1794 :         _Guard._Target = nullptr;

  0030a	48 c7 45 18 00
	00 00 00	 mov	 QWORD PTR _Guard$[rbp], 0

; 1795 : 
; 1796 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1797 :         _Stl_internal_check_container_invariants();
; 1798 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1799 :     }

  00312	48 8d 4d 18	 lea	 rcx, QWORD PTR _Guard$[rbp]
  00316	e8 00 00 00 00	 call	 ??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Clear_guard::~_Clear_guard
  0031b	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  00322	5d		 pop	 rbp
  00323	c3		 ret	 0
?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
_Old_buckets$ = 0
_Req_buckets$ = 8
$T1 = 80
this$ = 112
_For_size$ = 120
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Desired_grow_bucket_count, COMDAT

; 1688 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1689 :         const size_type _Old_buckets = bucket_count();

  00023	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00027	e8 00 00 00 00	 call	 ?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket_count
  0002c	48 89 45 00	 mov	 QWORD PTR _Old_buckets$[rbp], rax

; 1690 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

  00030	48 8b 55 78	 mov	 rdx, QWORD PTR _For_size$[rbp]
  00034	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Min_load_factor_buckets
  0003d	48 89 45 50	 mov	 QWORD PTR $T1[rbp], rax
  00041	48 8d 55 50	 lea	 rdx, QWORD PTR $T1[rbp]
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_Min_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@2_KB
  0004c	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  00051	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00054	48 89 45 08	 mov	 QWORD PTR _Req_buckets$[rbp], rax

; 1691 :         if (_Old_buckets >= _Req_buckets) {

  00058	48 8b 45 08	 mov	 rax, QWORD PTR _Req_buckets$[rbp]
  0005c	48 39 45 00	 cmp	 QWORD PTR _Old_buckets$[rbp], rax
  00060	72 06		 jb	 SHORT $LN2@Desired_gr

; 1692 :             // we already have enough buckets so there's no need to change the count
; 1693 :             return _Old_buckets;

  00062	48 8b 45 00	 mov	 rax, QWORD PTR _Old_buckets$[rbp]
  00066	eb 26		 jmp	 SHORT $LN1@Desired_gr
$LN2@Desired_gr:

; 1694 :         }
; 1695 : 
; 1696 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

  00068	48 81 7d 00 00
	02 00 00	 cmp	 QWORD PTR _Old_buckets$[rbp], 512 ; 00000200H
  00070	73 18		 jae	 SHORT $LN3@Desired_gr
  00072	48 8b 45 00	 mov	 rax, QWORD PTR _Old_buckets$[rbp]
  00076	48 c1 e0 03	 shl	 rax, 3
  0007a	48 3b 45 08	 cmp	 rax, QWORD PTR _Req_buckets$[rbp]
  0007e	72 0a		 jb	 SHORT $LN3@Desired_gr

; 1697 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1698 :             return _Old_buckets * 8;

  00080	48 8b 45 00	 mov	 rax, QWORD PTR _Old_buckets$[rbp]
  00084	48 c1 e0 03	 shl	 rax, 3
  00088	eb 04		 jmp	 SHORT $LN1@Desired_gr
$LN3@Desired_gr:

; 1699 :         }
; 1700 : 
; 1701 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1702 :         return _Req_buckets;

  0008a	48 8b 45 08	 mov	 rax, QWORD PTR _Req_buckets$[rbp]
$LN1@Desired_gr:

; 1703 :     }

  0008e	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00092	5d		 pop	 rbp
  00093	c3		 ret	 0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
tv65 = 64
this$ = 96
_For_size$ = 104
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Min_load_factor_buckets, COMDAT

; 1683 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1684 :         // returns the minimum number of buckets necessary for the elements in _List
; 1685 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _For_size$[rbp]
  00024	48 85 c0	 test	 rax, rax
  00027	7c 0c		 jl	 SHORT $LN4@Min_load_f
  00029	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  0002e	f3 0f 11 45 40	 movss	 DWORD PTR tv65[rbp], xmm0
  00033	eb 1e		 jmp	 SHORT $LN5@Min_load_f
$LN4@Min_load_f:
  00035	48 8b c8	 mov	 rcx, rax
  00038	48 d1 e9	 shr	 rcx, 1
  0003b	48 83 e0 01	 and	 rax, 1
  0003f	48 0b c8	 or	 rcx, rax
  00042	f3 48 0f 2a c9	 cvtsi2ss xmm1, rcx
  00047	f3 0f 58 c9	 addss	 xmm1, xmm1
  0004b	0f 28 c1	 movaps	 xmm0, xmm1
  0004e	f3 0f 11 45 40	 movss	 DWORD PTR tv65[rbp], xmm0
$LN5@Min_load_f:
  00053	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00057	e8 00 00 00 00	 call	 ?max_load_factor@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::max_load_factor
  0005c	f3 0f 10 4d 40	 movss	 xmm1, DWORD PTR tv65[rbp]
  00061	f3 0f 5e c8	 divss	 xmm1, xmm0
  00065	0f 28 c1	 movaps	 xmm0, xmm1
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ceilf
  0006e	33 c0		 xor	 eax, eax
  00070	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@5f000000
  00077	72 1e		 jb	 SHORT $LN3@Min_load_f
  00079	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@5f000000
  00081	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@5f000000
  00088	73 0d		 jae	 SHORT $LN3@Min_load_f
  0008a	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00094	48 03 c1	 add	 rax, rcx
$LN3@Min_load_f:
  00097	f3 48 0f 2c c8	 cvttss2si rcx, xmm0
  0009c	48 03 c8	 add	 rcx, rax
  0009f	48 8b c1	 mov	 rax, rcx

; 1686 :     }

  000a2	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000a6	5d		 pop	 rbp
  000a7	c3		 ret	 0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 0
_Newsize$ = 8
this$ = 96
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Rehash_for_1, COMDAT

; 1659 :     void _Rehash_for_1() {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1660 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00023	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 1661 :         const auto _Newsize = _Oldsize + 1;

  00027	48 8b 45 00	 mov	 rax, QWORD PTR _Oldsize$[rbp]
  0002b	48 ff c0	 inc	 rax
  0002e	48 89 45 08	 mov	 QWORD PTR _Newsize$[rbp], rax

; 1662 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

  00032	48 8b 55 08	 mov	 rdx, QWORD PTR _Newsize$[rbp]
  00036	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003a	e8 00 00 00 00	 call	 ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Desired_grow_bucket_count
  0003f	48 8b d0	 mov	 rdx, rax
  00042	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00046	e8 00 00 00 00	 call	 ?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Forced_rehash

; 1663 :     }

  0004b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
_Oldsize$ = 0
_Newsize$ = 8
tv70 = 80
tv71 = 84
tv77 = 88
this$ = 112
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Check_rehash_required_1, COMDAT

; 1653 :     bool _Check_rehash_required_1() const noexcept {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1654 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00026	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 1655 :         const auto _Newsize      = _Oldsize + 1;

  0002a	48 8b 45 00	 mov	 rax, QWORD PTR _Oldsize$[rbp]
  0002e	48 ff c0	 inc	 rax
  00031	48 89 45 08	 mov	 QWORD PTR _Newsize$[rbp], rax

; 1656 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

  00035	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00039	e8 00 00 00 00	 call	 ?max_load_factor@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::max_load_factor
  0003e	f3 0f 11 45 50	 movss	 DWORD PTR tv70[rbp], xmm0
  00043	48 8b 45 08	 mov	 rax, QWORD PTR _Newsize$[rbp]
  00047	48 85 c0	 test	 rax, rax
  0004a	7c 0c		 jl	 SHORT $LN7@Check_reha
  0004c	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  00051	f3 0f 11 4d 54	 movss	 DWORD PTR tv71[rbp], xmm1
  00056	eb 1e		 jmp	 SHORT $LN8@Check_reha
$LN7@Check_reha:
  00058	48 8b c8	 mov	 rcx, rax
  0005b	48 d1 e9	 shr	 rcx, 1
  0005e	48 83 e0 01	 and	 rax, 1
  00062	48 0b c8	 or	 rcx, rax
  00065	f3 48 0f 2a d1	 cvtsi2ss xmm2, rcx
  0006a	f3 0f 58 d2	 addss	 xmm2, xmm2
  0006e	0f 28 ca	 movaps	 xmm1, xmm2
  00071	f3 0f 11 4d 54	 movss	 DWORD PTR tv71[rbp], xmm1
$LN8@Check_reha:
  00076	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0007a	e8 00 00 00 00	 call	 ?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket_count
  0007f	48 85 c0	 test	 rax, rax
  00082	7c 07		 jl	 SHORT $LN5@Check_reha
  00084	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00089	eb 19		 jmp	 SHORT $LN6@Check_reha
$LN5@Check_reha:
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	48 d1 e9	 shr	 rcx, 1
  00091	48 83 e0 01	 and	 rax, 1
  00095	48 0b c8	 or	 rcx, rax
  00098	f3 48 0f 2a c9	 cvtsi2ss xmm1, rcx
  0009d	f3 0f 58 c9	 addss	 xmm1, xmm1
  000a1	0f 28 c1	 movaps	 xmm0, xmm1
$LN6@Check_reha:
  000a4	f3 0f 10 4d 54	 movss	 xmm1, DWORD PTR tv71[rbp]
  000a9	f3 0f 5e c8	 divss	 xmm1, xmm0
  000ad	0f 28 c1	 movaps	 xmm0, xmm1
  000b0	f3 0f 10 4d 50	 movss	 xmm1, DWORD PTR tv70[rbp]
  000b5	0f 2f c1	 comiss	 xmm0, xmm1
  000b8	76 09		 jbe	 SHORT $LN3@Check_reha
  000ba	c7 45 58 01 00
	00 00		 mov	 DWORD PTR tv77[rbp], 1
  000c1	eb 07		 jmp	 SHORT $LN4@Check_reha
$LN3@Check_reha:
  000c3	c7 45 58 00 00
	00 00		 mov	 DWORD PTR tv77[rbp], 0
$LN4@Check_reha:
  000ca	0f b6 45 58	 movzx	 eax, BYTE PTR tv77[rbp]

; 1657 :     }

  000ce	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000d2	5d		 pop	 rbp
  000d3	c3		 ret	 0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
_Oldsize$ = 0
this$ = 96
?_Check_max_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Check_max_size, COMDAT

; 1646 :     void _Check_max_size() const {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1647 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00023	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 1648 :         if (_Oldsize == _List.max_size()) {

  00027	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 83 c0 08	 add	 rax, 8
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 ?max_size@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::max_size
  00037	48 39 45 00	 cmp	 QWORD PTR _Oldsize$[rbp], rax
  0003b	75 0c		 jne	 SHORT $LN2@Check_max_

; 1649 :             _Xlength_error("unordered_map/set too long");

  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
  00044	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Check_max_:
$LN3@Check_max_:

; 1650 :         }
; 1651 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?_Check_max_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
_Insert_after$ = 0
_Head$ = 8
_Bucket_array$ = 16
_Bucket$ = 24
_Bucket_lo$ = 32
_Bucket_hi$ = 40
this$ = 128
_Hashval$ = 136
_Insert_before$ = 144
_Newnode$ = 152
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Insert_new_node_before, COMDAT

; 1615 :         const size_t _Hashval, const _Nodeptr _Insert_before, const _Nodeptr _Newnode) noexcept {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1616 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

  0002d	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Insert_before$[rbp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 89 45 00	 mov	 QWORD PTR _Insert_after$[rbp], rax

; 1617 :         ++_List._Mypair._Myval2._Mysize;

  0003c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00043	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00047	48 ff c0	 inc	 rax
  0004a	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00051	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1618 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

  00055	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Newnode$[rbp]
  0005c	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR _Insert_before$[rbp]
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * const &>

; 1619 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

  0006b	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Newnode$[rbp]
  00072	48 83 c0 08	 add	 rax, 8
  00076	48 8d 55 00	 lea	 rdx, QWORD PTR _Insert_after$[rbp]
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * const &>

; 1620 :         _Insert_after->_Next  = _Newnode;

  00082	48 8b 45 00	 mov	 rax, QWORD PTR _Insert_after$[rbp]
  00086	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  0008d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1621 :         _Insert_before->_Prev = _Newnode;

  00090	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Insert_before$[rbp]
  00097	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  0009e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1622 : 
; 1623 :         const auto _Head                = _List._Mypair._Myval2._Myhead;

  000a2	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ad	48 89 45 08	 mov	 QWORD PTR _Head$[rbp], rax

; 1624 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

  000b1	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000bc	48 89 45 10	 mov	 QWORD PTR _Bucket_array$[rbp], rax

; 1625 :         const size_type _Bucket         = _Hashval & _Mask;

  000c0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c7	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000cb	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Hashval$[rbp]
  000d2	48 23 c8	 and	 rcx, rax
  000d5	48 8b c1	 mov	 rax, rcx
  000d8	48 89 45 18	 mov	 QWORD PTR _Bucket$[rbp], rax

; 1626 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

  000dc	48 8b 45 18	 mov	 rax, QWORD PTR _Bucket$[rbp]
  000e0	48 d1 e0	 shl	 rax, 1
  000e3	48 8b 4d 10	 mov	 rcx, QWORD PTR _Bucket_array$[rbp]
  000e7	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000eb	48 89 45 20	 mov	 QWORD PTR _Bucket_lo$[rbp], rax

; 1627 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];

  000ef	48 8b 45 18	 mov	 rax, QWORD PTR _Bucket$[rbp]
  000f3	48 d1 e0	 shl	 rax, 1
  000f6	48 8b 4d 10	 mov	 rcx, QWORD PTR _Bucket_array$[rbp]
  000fa	48 8d 44 c1 08	 lea	 rax, QWORD PTR [rcx+rax*8+8]
  000ff	48 89 45 28	 mov	 QWORD PTR _Bucket_hi$[rbp], rax

; 1628 :         if (_Bucket_lo._Ptr == _Head) {

  00103	48 8b 45 20	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00107	48 8b 4d 08	 mov	 rcx, QWORD PTR _Head$[rbp]
  0010b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0010e	75 1e		 jne	 SHORT $LN2@Insert_new

; 1629 :             // bucket is empty, set both
; 1630 :             _Bucket_lo._Ptr = _Newnode;

  00110	48 8b 45 20	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00114	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  0011b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1631 :             _Bucket_hi._Ptr = _Newnode;

  0011e	48 8b 45 28	 mov	 rax, QWORD PTR _Bucket_hi$[rbp]
  00122	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  00129	48 89 08	 mov	 QWORD PTR [rax], rcx
  0012c	eb 3b		 jmp	 SHORT $LN3@Insert_new
$LN2@Insert_new:

; 1632 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

  0012e	48 8b 45 20	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00132	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Insert_before$[rbp]
  00139	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0013c	75 10		 jne	 SHORT $LN4@Insert_new

; 1633 :             // new node is the lowest element in the bucket
; 1634 :             _Bucket_lo._Ptr = _Newnode;

  0013e	48 8b 45 20	 mov	 rax, QWORD PTR _Bucket_lo$[rbp]
  00142	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  00149	48 89 08	 mov	 QWORD PTR [rax], rcx
  0014c	eb 1b		 jmp	 SHORT $LN3@Insert_new
$LN4@Insert_new:

; 1635 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

  0014e	48 8b 45 28	 mov	 rax, QWORD PTR _Bucket_hi$[rbp]
  00152	48 8b 4d 00	 mov	 rcx, QWORD PTR _Insert_after$[rbp]
  00156	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00159	75 0e		 jne	 SHORT $LN3@Insert_new

; 1636 :             // new node is the highest element in the bucket
; 1637 :             _Bucket_hi._Ptr = _Newnode;

  0015b	48 8b 45 28	 mov	 rax, QWORD PTR _Bucket_hi$[rbp]
  0015f	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Newnode$[rbp]
  00166	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Insert_new:

; 1638 :         }
; 1639 : 
; 1640 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1641 :         _Stl_internal_check_container_invariants();
; 1642 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1643 :         return _Newnode;

  00169	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Newnode$[rbp]

; 1644 :     }

  00170	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00174	5d		 pop	 rbp
  00175	c3		 ret	 0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 0
_Head$1 = 8
$T2 = 80
tv132 = 88
tv134 = 96
tv130 = 104
this$ = 128
?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::clear, COMDAT

; 1151 :     void clear() noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1152 :         // TRANSITION, ABI:
; 1153 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1154 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1155 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1156 :         //   (2) The hash function operator() may throw exceptions, and
; 1157 :         //   (3) clear() is a noexcept function.
; 1158 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1159 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

  0001e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00029	48 89 45 00	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 1160 :         if (_Oldsize == 0) {

  0002d	48 83 7d 00 00	 cmp	 QWORD PTR _Oldsize$[rbp], 0
  00032	75 05		 jne	 SHORT $LN2@clear

; 1161 :             return;

  00034	e9 9b 00 00 00	 jmp	 $LN1@clear
$LN2@clear:

; 1162 :         }
; 1163 : 
; 1164 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1165 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1166 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1167 :             // as many buckets as elements, remove element-by-element.
; 1168 :             if (bucket_count() / 8 > _Oldsize) {

  00039	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00040	e8 00 00 00 00	 call	 ?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket_count
  00045	33 d2		 xor	 edx, edx
  00047	b9 08 00 00 00	 mov	 ecx, 8
  0004c	48 f7 f1	 div	 rcx
  0004f	48 3b 45 00	 cmp	 rax, QWORD PTR _Oldsize$[rbp]
  00053	76 28		 jbe	 SHORT $LN3@clear

; 1169 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

  00055	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00060	48 89 45 08	 mov	 QWORD PTR _Head$1[rbp], rax

; 1170 :                 _Unchecked_erase(_Head->_Next, _Head);

  00064	4c 8b 45 08	 mov	 r8, QWORD PTR _Head$1[rbp]
  00068	48 8b 45 08	 mov	 rax, QWORD PTR _Head$1[rbp]
  0006c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0006f	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00076	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_erase

; 1171 :                 return;

  0007b	eb 57		 jmp	 SHORT $LN1@clear
$LN3@clear:

; 1172 :             }
; 1173 :         }
; 1174 : 
; 1175 :         // Bulk destroy items and reset buckets
; 1176 :         _List.clear();

  0007d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00084	48 83 c0 08	 add	 rax, 8
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 ?clear@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::clear

; 1177 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

  00090	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  00094	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009b	e8 00 00 00 00	 call	 ?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_end
  000a0	48 89 45 58	 mov	 QWORD PTR tv132[rbp], rax
  000a4	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ab	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000af	48 89 45 60	 mov	 QWORD PTR tv134[rbp], rax
  000b3	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ba	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000be	48 89 45 68	 mov	 QWORD PTR tv130[rbp], rax
  000c2	4c 8b 45 58	 mov	 r8, QWORD PTR tv132[rbp]
  000c6	48 8b 55 60	 mov	 rdx, QWORD PTR tv134[rbp]
  000ca	48 8b 4d 68	 mov	 rcx, QWORD PTR tv130[rbp]
  000ce	e8 00 00 00 00	 call	 ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > >
  000d3	90		 npad	 1
$LN1@clear:

; 1178 :     }

  000d4	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000d8	5d		 pop	 rbp
  000d9	c3		 ret	 0
?clear@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
_End$ = 0
_Bucket_bounds$ = 8
_Eraser$ = 16
_Predecessor$1 = 40
_Bucket$2 = 48
_Bucket_lo$3 = 56
_Bucket_hi$4 = 64
_Update_lo$5 = 72
_Old_hi$6 = 80
_At_bucket_back$7 = 88
_Bucket$8 = 96
_Bucket_lo$9 = 104
_Bucket_hi$10 = 112
_Old_hi$11 = 120
_At_bucket_back$12 = 128
$T13 = 200
$T14 = 208
$T15 = 216
tv172 = 224
tv138 = 224
tv136 = 224
this$ = 256
_First$ = 264
_Last$ = 272
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_erase, COMDAT

; 1027 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN25:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1028 :         if (_First == _Last) {

  00028	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0002f	48 39 85 08 01
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  00036	75 0c		 jne	 SHORT $LN10@Unchecked_

; 1029 :             return _Last;

  00038	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0003f	e9 84 02 00 00	 jmp	 $LN1@Unchecked_
$LN10@Unchecked_:

; 1030 :         }
; 1031 : 
; 1032 :         const auto _End           = _List._Mypair._Myval2._Myhead;

  00044	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004f	48 89 45 00	 mov	 QWORD PTR _End$[rbp], rax

; 1033 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

  00053	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005e	48 89 45 08	 mov	 QWORD PTR _Bucket_bounds$[rbp], rax

; 1034 :         _Range_eraser _Eraser{_List, _First};

  00062	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00069	48 83 c0 08	 add	 rax, 8
  0006d	4c 8b 85 08 01
	00 00		 mov	 r8, QWORD PTR _First$[rbp]
  00074	48 8b d0	 mov	 rdx, rax
  00077	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  0007b	e8 00 00 00 00	 call	 ??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::_Range_eraser

; 1035 :         {
; 1036 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1037 :             const auto _Predecessor = _First->_Prev;

  00080	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  00087	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008b	48 89 45 28	 mov	 QWORD PTR _Predecessor$1[rbp], rax

; 1038 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

  0008f	48 8b 45 20	 mov	 rax, QWORD PTR _Eraser$[rbp+16]
  00093	48 83 c0 10	 add	 rax, 16
  00097	48 8b c8	 mov	 rcx, rax
  0009a	e8 00 00 00 00	 call	 ??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>
  0009f	48 8b d0	 mov	 rdx, rax
  000a2	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	e8 00 00 00 00	 call	 ?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket
  000ae	48 89 45 30	 mov	 QWORD PTR _Bucket$2[rbp], rax

; 1039 :             // nothrow hereafter this block
; 1040 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

  000b2	48 8b 45 30	 mov	 rax, QWORD PTR _Bucket$2[rbp]
  000b6	48 d1 e0	 shl	 rax, 1
  000b9	48 8b 4d 08	 mov	 rcx, QWORD PTR _Bucket_bounds$[rbp]
  000bd	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000c1	48 89 45 38	 mov	 QWORD PTR _Bucket_lo$3[rbp], rax

; 1041 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

  000c5	48 8b 45 30	 mov	 rax, QWORD PTR _Bucket$2[rbp]
  000c9	48 d1 e0	 shl	 rax, 1
  000cc	48 8b 4d 08	 mov	 rcx, QWORD PTR _Bucket_bounds$[rbp]
  000d0	48 8d 44 c1 08	 lea	 rax, QWORD PTR [rcx+rax*8+8]
  000d5	48 89 45 40	 mov	 QWORD PTR _Bucket_hi$4[rbp], rax

; 1042 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

  000d9	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket_lo$3[rbp]
  000dd	48 8b 4d 20	 mov	 rcx, QWORD PTR _Eraser$[rbp+16]
  000e1	48 39 08	 cmp	 QWORD PTR [rax], rcx
  000e4	75 09		 jne	 SHORT $LN19@Unchecked_
  000e6	c6 85 e0 00 00
	00 01		 mov	 BYTE PTR tv136[rbp], 1
  000ed	eb 07		 jmp	 SHORT $LN20@Unchecked_
$LN19@Unchecked_:
  000ef	c6 85 e0 00 00
	00 00		 mov	 BYTE PTR tv136[rbp], 0
$LN20@Unchecked_:
  000f6	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR tv136[rbp]
  000fd	88 45 48	 mov	 BYTE PTR _Update_lo$5[rbp], al

; 1043 :             const _Nodeptr _Old_hi = _Bucket_hi;

  00100	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_hi$4[rbp]
  00104	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00107	48 89 45 50	 mov	 QWORD PTR _Old_hi$6[rbp], rax
$LN2@Unchecked_:

; 1044 :             for (;;) { // remove elements until we hit the end of the bucket
; 1045 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

  0010b	48 8b 45 50	 mov	 rax, QWORD PTR _Old_hi$6[rbp]
  0010f	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  00113	75 09		 jne	 SHORT $LN21@Unchecked_
  00115	c6 85 e0 00 00
	00 01		 mov	 BYTE PTR tv138[rbp], 1
  0011c	eb 07		 jmp	 SHORT $LN22@Unchecked_
$LN21@Unchecked_:
  0011e	c6 85 e0 00 00
	00 00		 mov	 BYTE PTR tv138[rbp], 0
$LN22@Unchecked_:
  00125	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR tv138[rbp]
  0012c	88 45 58	 mov	 BYTE PTR _At_bucket_back$7[rbp], al

; 1046 :                 _Eraser._Bump_erased();

  0012f	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  00133	e8 00 00 00 00	 call	 ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::_Bump_erased

; 1047 :                 if (_At_bucket_back) {

  00138	0f b6 45 58	 movzx	 eax, BYTE PTR _At_bucket_back$7[rbp]
  0013c	85 c0		 test	 eax, eax
  0013e	74 02		 je	 SHORT $LN11@Unchecked_

; 1048 :                     break;

  00140	eb 45		 jmp	 SHORT $LN3@Unchecked_
$LN11@Unchecked_:

; 1049 :                 }
; 1050 : 
; 1051 :                 if (_Eraser._Next == _Last) {

  00142	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00149	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  0014d	75 36		 jne	 SHORT $LN12@Unchecked_

; 1052 :                     if (_Update_lo) {

  0014f	0f b6 45 48	 movzx	 eax, BYTE PTR _Update_lo$5[rbp]
  00153	85 c0		 test	 eax, eax
  00155	74 0b		 je	 SHORT $LN13@Unchecked_

; 1053 :                         // erased the bucket's prefix
; 1054 :                         _Bucket_lo = _Eraser._Next;

  00157	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket_lo$3[rbp]
  0015b	48 8b 4d 20	 mov	 rcx, QWORD PTR _Eraser$[rbp+16]
  0015f	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN13@Unchecked_:

; 1055 :                     }
; 1056 : 
; 1057 :                     return _Last;

  00162	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00169	48 89 85 c8 00
	00 00		 mov	 QWORD PTR $T13[rbp], rax
  00170	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  00174	e8 00 00 00 00	 call	 ??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::~_Range_eraser
  00179	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR $T13[rbp]
  00180	e9 43 01 00 00	 jmp	 $LN1@Unchecked_
$LN12@Unchecked_:

; 1058 :                 }
; 1059 :             }

  00185	eb 84		 jmp	 SHORT $LN2@Unchecked_
$LN3@Unchecked_:

; 1060 : 
; 1061 :             if (_Update_lo) {

  00187	0f b6 45 48	 movzx	 eax, BYTE PTR _Update_lo$5[rbp]
  0018b	85 c0		 test	 eax, eax
  0018d	74 18		 je	 SHORT $LN14@Unchecked_

; 1062 :                 // emptied the bucket
; 1063 :                 _Bucket_lo = _End;

  0018f	48 8b 45 38	 mov	 rax, QWORD PTR _Bucket_lo$3[rbp]
  00193	48 8b 4d 00	 mov	 rcx, QWORD PTR _End$[rbp]
  00197	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1064 :                 _Bucket_hi = _End;

  0019a	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_hi$4[rbp]
  0019e	48 8b 4d 00	 mov	 rcx, QWORD PTR _End$[rbp]
  001a2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1065 :             } else {

  001a5	eb 0b		 jmp	 SHORT $LN5@Unchecked_
$LN14@Unchecked_:

; 1066 :                 _Bucket_hi = _Predecessor;

  001a7	48 8b 45 40	 mov	 rax, QWORD PTR _Bucket_hi$4[rbp]
  001ab	48 8b 4d 28	 mov	 rcx, QWORD PTR _Predecessor$1[rbp]
  001af	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Unchecked_:

; 1067 :             }
; 1068 :         }
; 1069 : 
; 1070 :         // hereafter we are always erasing buckets' prefixes
; 1071 :         while (_Eraser._Next != _Last) {

  001b2	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  001b9	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  001bd	0f 84 e7 00 00
	00		 je	 $LN6@Unchecked_

; 1072 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

  001c3	48 8b 45 20	 mov	 rax, QWORD PTR _Eraser$[rbp+16]
  001c7	48 83 c0 10	 add	 rax, 16
  001cb	48 8b c8	 mov	 rcx, rax
  001ce	e8 00 00 00 00	 call	 ??$_Kfn@$$CB_KUBucket@@@?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUBucket@@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Kfn<unsigned __int64 const ,Bucket>
  001d3	48 8b d0	 mov	 rdx, rax
  001d6	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001dd	e8 00 00 00 00	 call	 ?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket
  001e2	48 89 45 60	 mov	 QWORD PTR _Bucket$8[rbp], rax

; 1073 :             // nothrow hereafter this block
; 1074 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

  001e6	48 8b 45 60	 mov	 rax, QWORD PTR _Bucket$8[rbp]
  001ea	48 d1 e0	 shl	 rax, 1
  001ed	48 8b 4d 08	 mov	 rcx, QWORD PTR _Bucket_bounds$[rbp]
  001f1	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  001f5	48 89 45 68	 mov	 QWORD PTR _Bucket_lo$9[rbp], rax

; 1075 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

  001f9	48 8b 45 60	 mov	 rax, QWORD PTR _Bucket$8[rbp]
  001fd	48 d1 e0	 shl	 rax, 1
  00200	48 8b 4d 08	 mov	 rcx, QWORD PTR _Bucket_bounds$[rbp]
  00204	48 8d 44 c1 08	 lea	 rax, QWORD PTR [rcx+rax*8+8]
  00209	48 89 45 70	 mov	 QWORD PTR _Bucket_hi$10[rbp], rax

; 1076 :             const _Nodeptr _Old_hi = _Bucket_hi;

  0020d	48 8b 45 70	 mov	 rax, QWORD PTR _Bucket_hi$10[rbp]
  00211	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00214	48 89 45 78	 mov	 QWORD PTR _Old_hi$11[rbp], rax
$LN7@Unchecked_:

; 1077 :             for (;;) { // remove elements until we hit the end of the bucket
; 1078 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

  00218	48 8b 45 78	 mov	 rax, QWORD PTR _Old_hi$11[rbp]
  0021c	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  00220	75 09		 jne	 SHORT $LN23@Unchecked_
  00222	c6 85 e0 00 00
	00 01		 mov	 BYTE PTR tv172[rbp], 1
  00229	eb 07		 jmp	 SHORT $LN24@Unchecked_
$LN23@Unchecked_:
  0022b	c6 85 e0 00 00
	00 00		 mov	 BYTE PTR tv172[rbp], 0
$LN24@Unchecked_:
  00232	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR tv172[rbp]
  00239	88 85 80 00 00
	00		 mov	 BYTE PTR _At_bucket_back$12[rbp], al

; 1079 :                 _Eraser._Bump_erased();

  0023f	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  00243	e8 00 00 00 00	 call	 ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::_Bump_erased

; 1080 :                 if (_At_bucket_back) {

  00248	0f b6 85 80 00
	00 00		 movzx	 eax, BYTE PTR _At_bucket_back$12[rbp]
  0024f	85 c0		 test	 eax, eax
  00251	74 02		 je	 SHORT $LN16@Unchecked_

; 1081 :                     break;

  00253	eb 3a		 jmp	 SHORT $LN8@Unchecked_
$LN16@Unchecked_:

; 1082 :                 }
; 1083 : 
; 1084 :                 if (_Eraser._Next == _Last) {

  00255	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0025c	48 39 45 20	 cmp	 QWORD PTR _Eraser$[rbp+16], rax
  00260	75 2b		 jne	 SHORT $LN17@Unchecked_

; 1085 :                     // erased the bucket's prefix
; 1086 :                     _Bucket_lo = _Eraser._Next;

  00262	48 8b 45 68	 mov	 rax, QWORD PTR _Bucket_lo$9[rbp]
  00266	48 8b 4d 20	 mov	 rcx, QWORD PTR _Eraser$[rbp+16]
  0026a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1087 :                     return _Last;

  0026d	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00274	48 89 85 d0 00
	00 00		 mov	 QWORD PTR $T14[rbp], rax
  0027b	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  0027f	e8 00 00 00 00	 call	 ??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::~_Range_eraser
  00284	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR $T14[rbp]
  0028b	eb 3b		 jmp	 SHORT $LN1@Unchecked_
$LN17@Unchecked_:

; 1088 :                 }
; 1089 :             }

  0028d	eb 89		 jmp	 SHORT $LN7@Unchecked_
$LN8@Unchecked_:

; 1090 : 
; 1091 :             // emptied the bucket
; 1092 :             _Bucket_lo = _End;

  0028f	48 8b 45 68	 mov	 rax, QWORD PTR _Bucket_lo$9[rbp]
  00293	48 8b 4d 00	 mov	 rcx, QWORD PTR _End$[rbp]
  00297	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1093 :             _Bucket_hi = _End;

  0029a	48 8b 45 70	 mov	 rax, QWORD PTR _Bucket_hi$10[rbp]
  0029e	48 8b 4d 00	 mov	 rcx, QWORD PTR _End$[rbp]
  002a2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1094 :         }

  002a5	e9 08 ff ff ff	 jmp	 $LN5@Unchecked_
$LN6@Unchecked_:

; 1095 : 
; 1096 :         return _Last;

  002aa	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  002b1	48 89 85 d8 00
	00 00		 mov	 QWORD PTR $T15[rbp], rax
  002b8	48 8d 4d 10	 lea	 rcx, QWORD PTR _Eraser$[rbp]
  002bc	e8 00 00 00 00	 call	 ??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Range_eraser::~_Range_eraser
  002c1	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR $T15[rbp]
$LN1@Unchecked_:

; 1097 :     }

  002c8	48 8d a5 f0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+240]
  002cf	5d		 pop	 rbp
  002d0	c3		 ret	 0
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 80
?max_load_factor@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::max_load_factor, COMDAT

; 911  :     _NODISCARD float max_load_factor() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 912  :         return _Max_bucket_size();

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Max_bucket_size
  00024	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]

; 913  :     }

  00028	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?max_load_factor@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
tv73 = 64
this$ = 96
_Keyval$ = 104
?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket, COMDAT

; 855  :         noexcept(_Nothrow_hash<_Traits, key_type>) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 856  :         return _Traitsobj(_Keyval) & _Mask;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 40	 mov	 QWORD PTR tv73[rbp], rax
  00028	48 8b 55 68	 mov	 rdx, QWORD PTR _Keyval$[rbp]
  0002c	48 8b 4d 40	 mov	 rcx, QWORD PTR tv73[rbp]
  00030	e8 00 00 00 00	 call	 ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
  00035	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00039	48 23 41 40	 and	 rax, QWORD PTR [rcx+64]

; 857  :     }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?bucket@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KAEB_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 80
?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket_count, COMDAT

; 846  :     _NODISCARD size_type bucket_count() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 847  :         return _Maxidx;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]

; 848  :     }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?bucket_count@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 64
this$ = 96
__$ReturnUdt$ = 104
?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_end, COMDAT

; 811  :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 812  :         return _List._Unchecked_end();

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  0002c	48 8b 55 68	 mov	 rdx, QWORD PTR __$ReturnUdt$[rbp]
  00030	48 8b 4d 40	 mov	 rcx, QWORD PTR tv69[rbp]
  00034	e8 00 00 00 00	 call	 ?_Unchecked_end@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_end
  00039	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 813  :     }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 64
this$ = 96
__$ReturnUdt$ = 104
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_begin, COMDAT

; 803  :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 804  :         return _List._Unchecked_begin();

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  0002c	48 8b 55 68	 mov	 rdx, QWORD PTR __$ReturnUdt$[rbp]
  00030	48 8b 4d 40	 mov	 rcx, QWORD PTR tv69[rbp]
  00034	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_begin
  00039	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 805  :     }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 64
tv132 = 72
tv82 = 72
tv74 = 72
tv69 = 72
tv128 = 80
this$ = 112
_Parg$ = 120
_Al$ = 128
??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >, COMDAT

; 377  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00028	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 89 45 48	 mov	 QWORD PTR tv69[rbp], rax
  00030	48 8b 55 78	 mov	 rdx, QWORD PTR _Parg$[rbp]
  00034	48 8b 4d 48	 mov	 rcx, QWORD PTR tv69[rbp]
  00038	e8 00 00 00 00	 call	 ??0?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>
  0003d	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 83 c0 08	 add	 rax, 8
  00045	48 89 45 48	 mov	 QWORD PTR tv74[rbp], rax
  00049	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Al$[rbp]
  00050	48 8b 4d 48	 mov	 rcx, QWORD PTR tv74[rbp]
  00054	e8 00 00 00 00	 call	 ??0?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
  00059	90		 npad	 1
  0005a	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0005e	48 83 c0 20	 add	 rax, 32			; 00000020H
  00062	48 89 45 48	 mov	 QWORD PTR tv82[rbp], rax
  00066	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Al$[rbp]
  0006d	48 8b 4d 48	 mov	 rcx, QWORD PTR tv82[rbp]
  00071	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > ><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &,0>
  00076	90		 npad	 1
  00077	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0007b	48 c7 40 40 07
	00 00 00	 mov	 QWORD PTR [rax+64], 7
  00083	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00087	48 c7 40 48 08
	00 00 00	 mov	 QWORD PTR [rax+72], 8

; 378  :         // construct empty hash table
; 379  :         _Max_bucket_size() = _Bucket_size;

  0008f	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00093	e8 00 00 00 00	 call	 ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Max_bucket_size
  00098	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000a0	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 380  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

  000a4	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000a8	48 83 c0 20	 add	 rax, 32			; 00000020H
  000ac	48 89 45 48	 mov	 QWORD PTR tv132[rbp], rax
  000b0	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000b4	48 83 c0 08	 add	 rax, 8
  000b8	48 89 45 50	 mov	 QWORD PTR tv128[rbp], rax
  000bc	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  000c0	48 8b 4d 50	 mov	 rcx, QWORD PTR tv128[rbp]
  000c4	e8 00 00 00 00	 call	 ?_Unchecked_end@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_end
  000c9	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  000cc	ba 10 00 00 00	 mov	 edx, 16
  000d1	48 8b 4d 48	 mov	 rcx, QWORD PTR tv132[rbp]
  000d5	e8 00 00 00 00	 call	 ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::_Assign_grow
  000da	90		 npad	 1

; 381  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 382  :         _Stl_internal_check_container_invariants();
; 383  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 384  :     }

  000db	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000df	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000e3	5d		 pop	 rbp
  000e4	c3		 ret	 0
??0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
tv132 = 72
tv82 = 72
tv74 = 72
tv69 = 72
tv128 = 80
this$ = 112
_Parg$ = 120
_Al$ = 128
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	48 83 c1 08	 add	 rcx, 8
  00012	e8 00 00 00 00	 call	 ??1?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::~list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
tv132 = 72
tv82 = 72
tv74 = 72
tv69 = 72
tv128 = 80
this$ = 112
_Parg$ = 120
_Al$ = 128
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00012	e8 00 00 00 00	 call	 ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > > > >
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_First_prev$ = 0
_Last_prev$ = 8
_Before_prev$ = 16
_Before$ = 112
_First$ = 120
_Last$ = 128
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_splice, COMDAT

; 468  :     static _Nodeptr _Unchecked_splice(const _Nodeptr _Before, const _Nodeptr _First, const _Nodeptr _Last) noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 469  :         // splice [_First, _Last) before _Before; returns _Last
; 470  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 471  :         // 3 reads and 6 writes
; 472  : 
; 473  :         // fixup the _Next values
; 474  :         const auto _First_prev  = _First->_Prev;

  00028	48 8b 45 78	 mov	 rax, QWORD PTR _First$[rbp]
  0002c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00030	48 89 45 00	 mov	 QWORD PTR _First_prev$[rbp], rax

; 475  :         _First_prev->_Next      = _Last;

  00034	48 8b 45 00	 mov	 rax, QWORD PTR _First_prev$[rbp]
  00038	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  0003f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

  00042	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	48 89 45 08	 mov	 QWORD PTR _Last_prev$[rbp], rax

; 477  :         _Last_prev->_Next       = _Before;

  00051	48 8b 45 08	 mov	 rax, QWORD PTR _Last_prev$[rbp]
  00055	48 8b 4d 70	 mov	 rcx, QWORD PTR _Before$[rbp]
  00059	48 89 08	 mov	 QWORD PTR [rax], rcx

; 478  :         const auto _Before_prev = _Before->_Prev;

  0005c	48 8b 45 70	 mov	 rax, QWORD PTR _Before$[rbp]
  00060	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00064	48 89 45 10	 mov	 QWORD PTR _Before_prev$[rbp], rax

; 479  :         _Before_prev->_Next     = _First;

  00068	48 8b 45 10	 mov	 rax, QWORD PTR _Before_prev$[rbp]
  0006c	48 8b 4d 78	 mov	 rcx, QWORD PTR _First$[rbp]
  00070	48 89 08	 mov	 QWORD PTR [rax], rcx

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

  00073	48 8b 45 70	 mov	 rax, QWORD PTR _Before$[rbp]
  00077	48 8b 4d 08	 mov	 rcx, QWORD PTR _Last_prev$[rbp]
  0007b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

  0007f	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00086	48 8b 4d 00	 mov	 rcx, QWORD PTR _First_prev$[rbp]
  0008a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 484  :         _First->_Prev  = _Before_prev;

  0008e	48 8b 45 78	 mov	 rax, QWORD PTR _First$[rbp]
  00092	48 8b 4d 10	 mov	 rcx, QWORD PTR _Before_prev$[rbp]
  00096	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 485  : 
; 486  :         return _Last;

  0009a	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]

; 487  :     }

  000a1	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a5	5d		 pop	 rbp
  000a6	c3		 ret	 0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
_Pnext$ = 8
_Head$ = 16
_Pnextnext$1 = 24
this$ = 112
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);

  0001e	ba 03 00 00 00	 mov	 edx, 3
  00023	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;

  0002d	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 83 c0 08	 add	 rax, 8
  00038	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 380  :         const auto _Head          = _Myhead;

  0003c	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 89 45 10	 mov	 QWORD PTR _Head$[rbp], rax
$LN2@Orphan_non:

; 381  :         while (*_Pnext) {

  00048	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0004c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00050	74 48		 je	 SHORT $LN3@Orphan_non

; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

  00052	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 83 c0 08	 add	 rax, 8
  0005d	48 89 45 18	 mov	 QWORD PTR _Pnextnext$1[rbp], rax

; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on

  00061	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 8b 4d 10	 mov	 rcx, QWORD PTR _Head$[rbp]
  0006c	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00070	75 0a		 jne	 SHORT $LN4@Orphan_non

; 384  :                 _Pnext = _Pnextnext;

  00072	48 8b 45 18	 mov	 rax, QWORD PTR _Pnextnext$1[rbp]
  00076	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 385  :             } else { // orphan the iterator

  0007a	eb 1c		 jmp	 SHORT $LN5@Orphan_non
$LN4@Orphan_non:

; 386  :                 (*_Pnext)->_Myproxy = nullptr;

  0007c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00080	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00083	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 387  :                 *_Pnext             = *_Pnextnext;

  0008a	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0008e	48 8b 4d 18	 mov	 rcx, QWORD PTR _Pnextnext$1[rbp]
  00092	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00095	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Orphan_non:

; 388  :             }
; 389  :         }

  00098	eb ae		 jmp	 SHORT $LN2@Orphan_non
$LN3@Orphan_non:

; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

  0009a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000a4	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a8	5d		 pop	 rbp
  000a9	c3		 ret	 0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QEAA@XZ ; std::_Container_base12::_Container_base12
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal, COMDAT

; 1850 :     const _Alnode& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1851 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Get_first

; 1852 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal, COMDAT

; 1846 :     _Alnode& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1847 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Get_first

; 1848 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S6$ = 8
_Proxy$ = 16
_Al$ = 32
_Newhead$ = 40
this$ = 128
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1831 :     void _Alloc_sentinel_and_proxy() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1832 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  0001e	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
  0002a	48 8b d0	 mov	 rdx, rax
  0002d	48 8d 4d 08	 lea	 rcx, QWORD PTR $S6$[rbp]
  00031	e8 00 00 00 00	 call	 ??$?0U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >
  00036	48 8d 45 08	 lea	 rax, QWORD PTR $S6$[rbp]
  0003a	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 1833 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  0003e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00045	4c 8b c0	 mov	 r8, rax
  00048	48 8b 55 00	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  0004c	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00050	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00055	90		 npad	 1

; 1834 :         auto& _Al     = _Getal();

  00056	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005d	e8 00 00 00 00	 call	 ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
  00062	48 89 45 20	 mov	 QWORD PTR _Al$[rbp], rax

; 1835 :         auto _Newhead = _Al.allocate(1);

  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	48 8b 4d 20	 mov	 rcx, QWORD PTR _Al$[rbp]
  0006f	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::allocate
  00074	48 89 45 28	 mov	 QWORD PTR _Newhead$[rbp], rax

; 1836 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00078	48 8b 45 28	 mov	 rax, QWORD PTR _Newhead$[rbp]
  0007c	48 8d 55 28	 lea	 rdx, QWORD PTR _Newhead$[rbp]
  00080	48 8b c8	 mov	 rcx, rax
  00083	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * &>

; 1837 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  00088	48 8b 45 28	 mov	 rax, QWORD PTR _Newhead$[rbp]
  0008c	48 83 c0 08	 add	 rax, 8
  00090	48 8d 55 28	 lea	 rdx, QWORD PTR _Newhead$[rbp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> * &>

; 1838 :         _Mypair._Myval2._Myhead = _Newhead;

  0009c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	48 8b 4d 28	 mov	 rcx, QWORD PTR _Newhead$[rbp]
  000a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1839 :         _Proxy._Release();

  000ab	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000af	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  000b4	90		 npad	 1

; 1840 :     }

  000b5	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000b9	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000be	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000c2	5d		 pop	 rbp
  000c3	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Alproxy$ = 0
$S6$ = 8
_Proxy$ = 16
_Al$ = 32
_Newhead$ = 40
this$ = 128
?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ@4HA PROC ; `std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Alloc_sentinel_and_proxy'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ@4HA ENDP ; `std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Alloc_sentinel_and_proxy'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Al$ = 0
_My_data$ = 8
this$ = 96
?_Tidy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Tidy, COMDAT

; 1496 :     void _Tidy() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1497 :         auto& _Al      = _Getal();

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
  00024	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00028	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax

; 1499 :         _My_data._Orphan_all();

  00030	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 1500 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00039	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0003d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00041	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00045	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >

; 1501 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0004a	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0004e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00052	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00056	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >

; 1502 :     }

  0005b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?_Tidy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 0
tv75 = 72
tv73 = 80
this$ = 112
?clear@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::clear, COMDAT

; 1486 :     void clear() noexcept { // erase all

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1487 :         auto& _My_data = _Mypair._Myval2;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 1488 :         _My_data._Orphan_non_end();

  00026	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Orphan_non_end

; 1489 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0002f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  0003b	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0003f	e8 00 00 00 00	 call	 ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
  00044	48 89 45 50	 mov	 QWORD PTR tv73[rbp], rax
  00048	48 8b 55 48	 mov	 rdx, QWORD PTR tv75[rbp]
  0004c	48 8b 4d 50	 mov	 rcx, QWORD PTR tv73[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >

; 1490 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00055	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00059	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005d	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00061	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00065	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1491 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00068	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0006c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00070	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00074	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00078	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1492 :         _My_data._Mysize        = 0;

  0007c	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00080	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1493 :     }

  00088	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0008c	5d		 pop	 rbp
  0008d	c3		 ret	 0
?clear@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_erase@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
_Predecessor$ = 0
_Head$ = 8
_Lock$1 = 16
_Marked$2 = 24
_Pnext$3 = 32
_Pnextnext$4 = 40
_Al$ = 48
_Erasures$ = 56
_Next$5 = 64
this$ = 160
_First$ = 168
_Last$ = 176
?_Unchecked_erase@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_erase, COMDAT

; 1436 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept { // erase [_First, _Last)

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1437 :         if (_First == _Last) {

  00028	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0002f	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  00036	75 0c		 jne	 SHORT $LN10@Unchecked_

; 1438 :             return _Last;

  00038	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0003f	e9 9d 01 00 00	 jmp	 $LN1@Unchecked_
$LN10@Unchecked_:

; 1439 :         }
; 1440 : 
; 1441 :         const auto _Predecessor = _First->_Prev;

  00044	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  0004b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004f	48 89 45 00	 mov	 QWORD PTR _Predecessor$[rbp], rax

; 1442 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1443 :         const auto _Head = _Mypair._Myval2._Myhead;

  00053	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005e	48 89 45 08	 mov	 QWORD PTR _Head$[rbp], rax

; 1444 :         if (_First == _Head->_Next && _Last == _Head) { // orphan all non-end iterators

  00062	48 8b 45 08	 mov	 rax, QWORD PTR _Head$[rbp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  00070	75 21		 jne	 SHORT $LN11@Unchecked_
  00072	48 8b 45 08	 mov	 rax, QWORD PTR _Head$[rbp]
  00076	48 39 85 b0 00
	00 00		 cmp	 QWORD PTR _Last$[rbp], rax
  0007d	75 14		 jne	 SHORT $LN11@Unchecked_

; 1445 :             _Mypair._Myval2._Orphan_non_end();

  0007f	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00086	48 8b c8	 mov	 rcx, rax
  00089	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >::_Orphan_non_end

; 1446 :         } else { // orphan erased iterators

  0008e	e9 b1 00 00 00	 jmp	 $LN12@Unchecked_
$LN11@Unchecked_:

; 1447 :             _Lockit _Lock(_LOCK_DEBUG);

  00093	ba 03 00 00 00	 mov	 edx, 3
  00098	48 8d 4d 10	 lea	 rcx, QWORD PTR _Lock$1[rbp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1448 :             for (auto _Marked = _First; _Marked != _Last; _Marked = _Marked->_Next) { // mark erased nodes

  000a2	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  000a9	48 89 45 18	 mov	 QWORD PTR _Marked$2[rbp], rax
  000ad	eb 0b		 jmp	 SHORT $LN4@Unchecked_
$LN2@Unchecked_:
  000af	48 8b 45 18	 mov	 rax, QWORD PTR _Marked$2[rbp]
  000b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b6	48 89 45 18	 mov	 QWORD PTR _Marked$2[rbp], rax
$LN4@Unchecked_:
  000ba	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  000c1	48 39 45 18	 cmp	 QWORD PTR _Marked$2[rbp], rax
  000c5	74 0e		 je	 SHORT $LN3@Unchecked_

; 1449 :                 _Marked->_Prev = nullptr;

  000c7	48 8b 45 18	 mov	 rax, QWORD PTR _Marked$2[rbp]
  000cb	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1450 :             }

  000d3	eb da		 jmp	 SHORT $LN2@Unchecked_
$LN3@Unchecked_:

; 1451 : 
; 1452 :             _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

  000d5	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000df	48 83 c0 08	 add	 rax, 8
  000e3	48 89 45 20	 mov	 QWORD PTR _Pnext$3[rbp], rax
$LN5@Unchecked_:

; 1453 :             while (*_Pnext) {

  000e7	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  000eb	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000ef	74 49		 je	 SHORT $LN6@Unchecked_

; 1454 :                 _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

  000f1	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  000f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f8	48 83 c0 08	 add	 rax, 8
  000fc	48 89 45 28	 mov	 QWORD PTR _Pnextnext$4[rbp], rax

; 1455 :                 if (static_cast<const_iterator&>(**_Pnext)._Ptr->_Prev) { // node still has a _Prev, skip

  00100	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  00104	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00107	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00110	74 0a		 je	 SHORT $LN13@Unchecked_

; 1456 :                     _Pnext = _Pnextnext;

  00112	48 8b 45 28	 mov	 rax, QWORD PTR _Pnextnext$4[rbp]
  00116	48 89 45 20	 mov	 QWORD PTR _Pnext$3[rbp], rax

; 1457 :                 } else { // orphan the iterator

  0011a	eb 1c		 jmp	 SHORT $LN14@Unchecked_
$LN13@Unchecked_:

; 1458 :                     (*_Pnext)->_Myproxy = nullptr;

  0011c	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  00120	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00123	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1459 :                     *_Pnext             = *_Pnextnext;

  0012a	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  0012e	48 8b 4d 28	 mov	 rcx, QWORD PTR _Pnextnext$4[rbp]
  00132	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00135	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN14@Unchecked_:

; 1460 :                 }
; 1461 :             }

  00138	eb ad		 jmp	 SHORT $LN5@Unchecked_
$LN6@Unchecked_:

; 1462 : 
; 1463 :             // _Prev pointers not restored because we're about to delete the nodes of which they are a member anyway
; 1464 :         }

  0013a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Lock$1[rbp]
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
$LN12@Unchecked_:

; 1465 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1466 : 
; 1467 :         // snip out the removed range
; 1468 :         _Predecessor->_Next = _Last;

  00144	48 8b 45 00	 mov	 rax, QWORD PTR _Predecessor$[rbp]
  00148	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  0014f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1469 :         _Last->_Prev        = _Predecessor;

  00152	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00159	48 8b 4d 00	 mov	 rcx, QWORD PTR _Predecessor$[rbp]
  0015d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1470 : 
; 1471 :         // count and deallocate the removed nodes
; 1472 :         auto& _Al           = _Getal();

  00161	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00168	e8 00 00 00 00	 call	 ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
  0016d	48 89 45 30	 mov	 QWORD PTR _Al$[rbp], rax

; 1473 :         size_type _Erasures = 0;

  00171	48 c7 45 38 00
	00 00 00	 mov	 QWORD PTR _Erasures$[rbp], 0
$LN9@Unchecked_:

; 1474 :         do {
; 1475 :             const auto _Next = _First->_Next;

  00179	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  00180	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00183	48 89 45 40	 mov	 QWORD PTR _Next$5[rbp], rax

; 1476 :             _Node::_Freenode(_Al, _First);

  00187	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _First$[rbp]
  0018e	48 8b 4d 30	 mov	 rcx, QWORD PTR _Al$[rbp]
  00192	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >

; 1477 :             _First = _Next;

  00197	48 8b 45 40	 mov	 rax, QWORD PTR _Next$5[rbp]
  0019b	48 89 85 a8 00
	00 00		 mov	 QWORD PTR _First$[rbp], rax

; 1478 :             ++_Erasures;

  001a2	48 8b 45 38	 mov	 rax, QWORD PTR _Erasures$[rbp]
  001a6	48 ff c0	 inc	 rax
  001a9	48 89 45 38	 mov	 QWORD PTR _Erasures$[rbp], rax

; 1479 :         } while (_First != _Last);

  001ad	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  001b4	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  001bb	75 bc		 jne	 SHORT $LN9@Unchecked_

; 1480 : 
; 1481 :         _Mypair._Myval2._Mysize -= _Erasures;

  001bd	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001c4	48 8b 4d 38	 mov	 rcx, QWORD PTR _Erasures$[rbp]
  001c8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001cc	48 2b c1	 sub	 rax, rcx
  001cf	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001d6	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1482 :         return _Last;

  001da	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
$LN1@Unchecked_:

; 1483 :     }

  001e1	48 8d a5 90 00
	00 00		 lea	 rsp, QWORD PTR [rbp+144]
  001e8	5d		 pop	 rbp
  001e9	c3		 ret	 0
?_Unchecked_erase@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
this$ = 96
?max_size@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::max_size, COMDAT

; 1191 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1192 :         return (_STD min)(

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::max_size
  0002c	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00030	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00035	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00039	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0003d	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00041	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1193 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1194 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?max_size@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
_Where$ = 96
?_Make_iter@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Make_iter, COMDAT

; 1120 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1121 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > > const >
  00031	4c 8b c0	 mov	 r8, rax
  00034	48 8b 55 60	 mov	 rdx, QWORD PTR _Where$[rbp]
  00038	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0003c	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
  00041	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1122 :     }

  00045	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
?_Make_iter@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?_Unchecked_end@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_end, COMDAT

; 1112 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1113 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

  00020	45 33 c0	 xor	 r8d, r8d
  00023	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0002b	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0002f	e8 00 00 00 00	 call	 ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
  00034	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1114 :     }

  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?_Unchecked_end@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?_Unchecked_begin@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_begin, COMDAT

; 1104 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1105 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	45 33 c0	 xor	 r8d, r8d
  0002b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002e	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00032	e8 00 00 00 00	 call	 ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@1@@Z
  00037	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1106 :     }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
?_Unchecked_begin@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??1?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S4$ = 8
this$ = 96
??1?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::~list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >, COMDAT

; 1044 :     ~list() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1045 :         _Tidy();

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Tidy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Tidy

; 1046 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1047 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00024	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ?_Getal@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Getal
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8d 4d 08	 lea	 rcx, QWORD PTR $S4$[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >
  00039	48 8d 45 08	 lea	 rax, QWORD PTR $S4$[rbp]
  0003d	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 1048 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);

  00041	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00048	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  0004c	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 1049 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1050 :     }

  00051	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
??1?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::~list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 64
tv70 = 72
this$ = 96
_Al$ = 104
??0?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z PROC ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >, COMDAT

; 802  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 48	 mov	 QWORD PTR tv70[rbp], rax
  00028	4c 8b 45 68	 mov	 r8, QWORD PTR _Al$[rbp]
  0002c	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00030	48 8b 4d 48	 mov	 rcx, QWORD PTR tv70[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUBucket@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,Bucket> > >,1><std::allocator<std::pair<unsigned __int64 const ,Bucket> > const &>

; 803  :         _Alloc_sentinel_and_proxy();

  00039	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003d	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::_Alloc_sentinel_and_proxy

; 804  :     }

  00042	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00046	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
??0?$list@U?$pair@$$CB_KUBucket@@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUBucket@@@std@@@1@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >::list<std::pair<unsigned __int64 const ,Bucket>,std::allocator<std::pair<unsigned __int64 const ,Bucket> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 80
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001b	48 b8 55 55 55
	55 55 55 55 05	 mov	 rax, 384307168202282325	; 0555555555555555H

; 738  :     }

  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@deallocate

; 709  :             _Al.deallocate(_Ptr, _Count);

  00031	4c 8b 45 60	 mov	 r8, QWORD PTR _Count$[rbp]
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00039	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::deallocate

; 710  :         } else

  00042	eb 11		 jmp	 SHORT $LN3@deallocate
$LN2@deallocate:

; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00044	48 6b 45 60 30	 imul	 rax, QWORD PTR _Count$[rbp], 48 ; 00000030H
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>
$LN3@deallocate:

; 715  :         }
; 716  :     }

  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0DA@@std@@YA_K_K@Z ; std::_Get_size_of_n<48>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 6b 45 60 30	 imul	 rax, QWORD PTR _Count$[rbp], 48 ; 00000030H
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bb	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KUBucket@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,Bucket>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\unordered_map
;	COMDAT ??0?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Traits$ = 88
??0?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DA11C4D_unordered_map
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Traits$[rbp]
  00024	8b 00		 mov	 eax, DWORD PTR [rax]
  00026	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002a	89 01		 mov	 DWORD PTR [rcx], eax
  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??0?$_Umap_traits@_KUBucket@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUBucket@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>::_Umap_traits<unsigned __int64,Bucket,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,Bucket> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<unsigned __int64 const ,Bucket> >::allocator<std::pair<unsigned __int64 const ,Bucket> >, COMDAT

; 962  :     constexpr allocator() noexcept {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??0?$allocator@U?$pair@$$CB_KUBucket@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,Bucket> >::allocator<std::pair<unsigned __int64 const ,Bucket> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ PROC ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ENDP ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ PROC ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z
_TEXT	SEGMENT
tv65 = 64
this$ = 96
_Left$ = 104
_Right$ = 112
??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z PROC		; std::equal_to<unsigned __int64>::operator(), COMDAT

; 392  :         noexcept(noexcept(_Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 393  :         return _Left == _Right;

  00025	48 8b 45 68	 mov	 rax, QWORD PTR _Left$[rbp]
  00029	48 8b 4d 70	 mov	 rcx, QWORD PTR _Right$[rbp]
  0002d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00030	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00033	75 09		 jne	 SHORT $LN3@operator
  00035	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv65[rbp], 1
  0003c	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0003e	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv65[rbp], 0
$LN4@operator:
  00045	0f b6 45 40	 movzx	 eax, BYTE PTR tv65[rbp]

; 394  :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z ENDP		; std::equal_to<unsigned __int64>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ
_TEXT	SEGMENT
this$ = 80
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size, COMDAT

; 163  :     _NODISCARD const float& _Get_max_bucket_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 164  :         return _Mypair._Myval2._Myval2;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 165  :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ
_TEXT	SEGMENT
this$ = 80
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size, COMDAT

; 159  :     _NODISCARD float& _Get_max_bucket_size() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 160  :         return _Mypair._Myval2._Myval2;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 161  :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xhash
;	COMDAT ??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 68
$T3 = 69
tv75 = 72
this$ = 96
??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >, COMDAT

; 136  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__696C8ED8_xhash
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  00023	0f 57 c0	 xorps	 xmm0, xmm0
  00026	f3 0f 11 45 40	 movss	 DWORD PTR $T1[rbp], xmm0
  0002b	4c 8d 4d 40	 lea	 r9, QWORD PTR $T1[rbp]
  0002f	4c 8d 45 44	 lea	 r8, QWORD PTR $T2[rbp]
  00033	0f b6 55 45	 movzx	 edx, BYTE PTR $T3[rbp]
  00037	48 8b 4d 48	 mov	 rcx, QWORD PTR tv75[rbp]
  0003b	e8 00 00 00 00	 call	 ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
  00040	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z
_TEXT	SEGMENT
_Keyval$ = 80
?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z PROC		; std::hash<unsigned __int64>::_Do_hash, COMDAT

; 2389 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2390 :         return _Hash_representation(_Keyval);

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR _Keyval$[rbp]
  0001f	e8 00 00 00 00	 call	 ??$_Hash_representation@_K@std@@YA_KAEB_K@Z ; std::_Hash_representation<unsigned __int64>

; 2391 :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z ENDP		; std::hash<unsigned __int64>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
this$ = 80
_Keyval$ = 88
??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z PROC ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator(), COMDAT

; 2371 :         noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2372 :         return hash<_Kty>::_Do_hash(_Keyval);

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Keyval$[rbp]
  00024	e8 00 00 00 00	 call	 ?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z ; std::hash<unsigned __int64>::_Do_hash

; 2373 :     }

  00029	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ENDP ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Bucket@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0Bucket@@QEAA@XZ PROC					; Bucket::Bucket, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00011	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00018	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001c	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 c7 40 10 ff
	ff ff ff	 mov	 QWORD PTR [rax+16], -1
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??0Bucket@@QEAA@XZ ENDP					; Bucket::Bucket
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xbit_ops.h
;	COMDAT ?_Ceiling_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Value$ = 80
?_Ceiling_of_log_2@std@@YAK_K@Z PROC			; std::_Ceiling_of_log_2, COMDAT

; 50   : _NODISCARD inline unsigned long _Ceiling_of_log_2(const size_t _Value) noexcept { // returns ceil(log_2(_Value))

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B566F9C5_xbit_ops@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 51   :                                                                                   // pre: _Value > 1
; 52   :     return 1 + _Floor_of_log_2(_Value - 1);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Value$[rbp]
  0001f	48 ff c8	 dec	 rax
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 ?_Floor_of_log_2@std@@YAK_K@Z ; std::_Floor_of_log_2
  0002a	ff c0		 inc	 eax

; 53   : }

  0002c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00030	5d		 pop	 rbp
  00031	c3		 ret	 0
?_Ceiling_of_log_2@std@@YAK_K@Z ENDP			; std::_Ceiling_of_log_2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xbit_ops.h
;	COMDAT ?_Floor_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Result$ = 0
_Value$ = 96
?_Floor_of_log_2@std@@YAK_K@Z PROC			; std::_Floor_of_log_2, COMDAT

; 24   : _NODISCARD inline unsigned long _Floor_of_log_2(size_t _Value) noexcept { // returns floor(log_2(_Value))

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B566F9C5_xbit_ops@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR _Value$[rbp]
  0001f	48 83 c8 01	 or	 rax, 1
  00023	48 89 45 60	 mov	 QWORD PTR _Value$[rbp], rax

; 26   :     unsigned long _Result;
; 27   : 
; 28   : #ifdef _M_CEE_PURE
; 29   : #ifdef _WIN64
; 30   :     _Result = 63;
; 31   : #else // ^^^ 64-bit / 32-bit vvv
; 32   :     _Result = 31;
; 33   : #endif // 64 vs. 32-bit
; 34   : 
; 35   :     while ((size_t{1} << _Result) > _Value) {
; 36   :         --_Result;
; 37   :     }
; 38   : 
; 39   : #else // ^^^ _M_CEE_PURE / !_M_CEE_PURE vvv
; 40   : #ifdef _WIN64
; 41   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

  00027	48 8b 45 60	 mov	 rax, QWORD PTR _Value$[rbp]
  0002b	48 0f bd c0	 bsr	 rax, rax
  0002f	89 45 00	 mov	 DWORD PTR _Result$[rbp], eax

; 42   : #else // ^^^ 64-bit / 32-bit vvv
; 43   :     _BitScanReverse(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]
; 44   : #endif // 64 vs. 32-bit
; 45   : #endif // _M_CEE_PURE
; 46   : 
; 47   :     return _Result;

  00032	8b 45 00	 mov	 eax, DWORD PTR _Result$[rbp]

; 48   : }

  00035	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
?_Floor_of_log_2@std@@YAK_K@Z ENDP			; std::_Floor_of_log_2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>

; 252  :     } else

  00041	eb 2a		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 10 00 00 00	 mov	 ecx, 16
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00061	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00064	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00068	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00071	5d		 pop	 rbp
  00072	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0_Basic_container_proxy_ptr12@std@@IEAA@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT

; 1453 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1446 :     _Container_proxy* _Ptr = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1453 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
??0_Basic_container_proxy_ptr12@std@@IEAA@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ PROC ; std::_Basic_container_proxy_ptr12::_Release, COMDAT

; 1448 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1449 :         _Ptr = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1450 :     }

  00026	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ENDP ; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ PROC ; std::_Iterator_base12::_Orphan_me_locked_v3, COMDAT

; 1362 :     void _Orphan_me_locked_v3() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1363 :         _Lockit _Lock(_LOCK_DEBUG);

  0001b	ba 03 00 00 00	 mov	 edx, 3
  00020	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1364 :         _Orphan_me_unlocked_v3();

  0002a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1365 :     }

  00033	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ ENDP ; std::_Iterator_base12::_Orphan_me_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$ = 0
this$ = 96
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ PROC ; std::_Iterator_base12::_Orphan_me_unlocked_v3, COMDAT

; 1346 :     _CONSTEXPR20 void _Orphan_me_unlocked_v3() noexcept {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1347 :         if (!_Myproxy) { // already orphaned

  0001e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00026	75 05		 jne	 SHORT $LN10@Orphan_me_

; 1348 :             return;

  00028	e9 ce 00 00 00	 jmp	 $LN1@Orphan_me_
$LN10@Orphan_me_:

; 1349 :         }
; 1350 : 
; 1351 :         // adopted, remove self from list
; 1352 :         _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;

  0002d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 83 c0 08	 add	 rax, 8
  00038	48 89 45 00	 mov	 QWORD PTR _Pnext$[rbp], rax
$LN2@Orphan_me_:

; 1353 :         while (*_Pnext && *_Pnext != this) {

  0003c	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00040	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00044	74 1e		 je	 SHORT $LN6@Orphan_me_
  00046	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0004a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0004e	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00051	74 11		 je	 SHORT $LN6@Orphan_me_

; 1354 :             _Pnext = &(*_Pnext)->_Mynextiter;

  00053	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00057	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005a	48 83 c0 08	 add	 rax, 8
  0005e	48 89 45 00	 mov	 QWORD PTR _Pnext$[rbp], rax

; 1355 :         }

  00062	eb d8		 jmp	 SHORT $LN2@Orphan_me_
$LN6@Orphan_me_:

; 1356 : 
; 1357 :         _STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");

  00064	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00068	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006c	74 02		 je	 SHORT $LN9@Orphan_me_
  0006e	eb 6b		 jmp	 SHORT $LN12@Orphan_me_
$LN9@Orphan_me_:
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
  00077	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	45 33 c9	 xor	 r9d, r9d
  0008b	41 b8 4d 05 00
	00		 mov	 r8d, 1357		; 0000054dH
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  00098	b9 02 00 00 00	 mov	 ecx, 2
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  000a3	83 f8 01	 cmp	 eax, 1
  000a6	75 03		 jne	 SHORT $LN14@Orphan_me_
  000a8	cc		 int	 3
  000a9	33 c0		 xor	 eax, eax
$LN14@Orphan_me_:
  000ab	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000b4	41 b9 4d 05 00
	00		 mov	 r9d, 1357		; 0000054dH
  000ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000d5	33 c0		 xor	 eax, eax
  000d7	85 c0		 test	 eax, eax
  000d9	75 95		 jne	 SHORT $LN9@Orphan_me_
$LN12@Orphan_me_:
  000db	33 c0		 xor	 eax, eax
  000dd	85 c0		 test	 eax, eax
  000df	75 83		 jne	 SHORT $LN6@Orphan_me_

; 1358 :         *_Pnext  = _Mynextiter;

  000e1	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  000e5	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  000e9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ed	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1359 :         _Myproxy = nullptr;

  000f0	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000f4	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN1@Orphan_me_:

; 1360 :     }

  000fb	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000ff	5d		 pop	 rbp
  00100	c3		 ret	 0
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ENDP ; std::_Iterator_base12::_Orphan_me_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
_Parent$ = 104
?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_locked, COMDAT

; 1341 :     void _Adopt_locked(const _Container_base12* _Parent) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1342 :         _Lockit _Lock(_LOCK_DEBUG);

  00020	ba 03 00 00 00	 mov	 edx, 3
  00025	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1343 :         _Adopt_unlocked(_Parent);

  0002f	48 8b 55 68	 mov	 rdx, QWORD PTR _Parent$[rbp]
  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1344 :     }

  0003c	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00046	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_locked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
_Parent_proxy$ = 0
this$ = 96
_Parent$ = 104
?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_unlocked, COMDAT

; 1324 :     _CONSTEXPR20 void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1325 :         if (!_Parent) {

  00020	48 83 7d 68 00	 cmp	 QWORD PTR _Parent$[rbp], 0
  00025	75 0b		 jne	 SHORT $LN2@Adopt_unlo

; 1326 :             _Orphan_me_unlocked_v3();

  00027	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1327 :             return;

  00030	eb 52		 jmp	 SHORT $LN1@Adopt_unlo
$LN2@Adopt_unlo:

; 1328 :         }
; 1329 : 
; 1330 :         _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  00032	48 8b 45 68	 mov	 rax, QWORD PTR _Parent$[rbp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 89 45 00	 mov	 QWORD PTR _Parent_proxy$[rbp], rax

; 1331 :         if (_Myproxy != _Parent_proxy) { // change parentage

  0003d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8b 4d 00	 mov	 rcx, QWORD PTR _Parent_proxy$[rbp]
  00045	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00048	74 3a		 je	 SHORT $LN1@Adopt_unlo

; 1332 :             if (_Myproxy) { // adopted, remove self from list

  0004a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00052	74 09		 je	 SHORT $LN4@Adopt_unlo

; 1333 :                 _Orphan_me_unlocked_v3();

  00054	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00058	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN4@Adopt_unlo:

; 1334 :             }
; 1335 :             _Mynextiter                 = _Parent_proxy->_Myfirstiter;

  0005d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00061	48 8b 4d 00	 mov	 rcx, QWORD PTR _Parent_proxy$[rbp]
  00065	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00069	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1336 :             _Parent_proxy->_Myfirstiter = this;

  0006d	48 8b 45 00	 mov	 rax, QWORD PTR _Parent_proxy$[rbp]
  00071	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00075	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1337 :             _Myproxy                    = _Parent_proxy;

  00079	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0007d	48 8b 4d 00	 mov	 rcx, QWORD PTR _Parent_proxy$[rbp]
  00081	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@Adopt_unlo:

; 1338 :         }
; 1339 :     }

  00084	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00088	5d		 pop	 rbp
  00089	c3		 ret	 0
?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
_Right$ = 104
?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z PROC ; std::_Iterator_base12::_Assign_locked, COMDAT

; 1319 :     void _Assign_locked(const _Iterator_base12& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1320 :         _Lockit _Lock(_LOCK_DEBUG);

  00020	ba 03 00 00 00	 mov	 edx, 3
  00025	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1321 :         _Assign_unlocked(_Right);

  0002f	48 8b 55 68	 mov	 rdx, QWORD PTR _Right$[rbp]
  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_unlocked

; 1322 :     }

  0003c	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00046	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z ENDP ; std::_Iterator_base12::_Assign_locked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z PROC ; std::_Iterator_base12::_Assign_unlocked, COMDAT

; 1307 :     _CONSTEXPR20 void _Assign_unlocked(const _Iterator_base12& _Right) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1308 :         if (_Myproxy == _Right._Myproxy) {

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	75 02		 jne	 SHORT $LN2@Assign_unl

; 1309 :             return;

  00030	eb 28		 jmp	 SHORT $LN1@Assign_unl
$LN2@Assign_unl:

; 1310 :         }
; 1311 : 
; 1312 :         if (_Right._Myproxy) {

  00032	48 8b 45 58	 mov	 rax, QWORD PTR _Right$[rbp]
  00036	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003a	74 15		 je	 SHORT $LN3@Assign_unl

; 1313 :             _Adopt_unlocked(_Right._Myproxy->_Mycont);

  0003c	48 8b 45 58	 mov	 rax, QWORD PTR _Right$[rbp]
  00040	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00043	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00046	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0004a	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1314 :         } else { // becoming invalid, disown current parent

  0004f	eb 09		 jmp	 SHORT $LN1@Assign_unl
$LN3@Assign_unl:

; 1315 :             _Orphan_me_unlocked_v3();

  00051	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00055	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN1@Assign_unl:

; 1316 :         }
; 1317 :     }

  0005a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z ENDP ; std::_Iterator_base12::_Assign_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = 64
this$ = 96
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT

; 1296 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1297 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 10		 je	 SHORT $LN3@Getcont
  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 89 45 40	 mov	 QWORD PTR tv68[rbp], rax
  00033	eb 08		 jmp	 SHORT $LN4@Getcont
$LN3@Getcont:
  00035	48 c7 45 40 00
	00 00 00	 mov	 QWORD PTR tv68[rbp], 0
$LN4@Getcont:
  0003d	48 8b 45 40	 mov	 rax, QWORD PTR tv68[rbp]

; 1298 :     }

  00041	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
this$ = 80
_Parent$ = 88
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT

; 1276 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1277 : #if _HAS_CXX20
; 1278 :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0f		 je	 SHORT $LN2@Adopt

; 1279 :             _Adopt_unlocked(_Parent);

  0002c	48 8b 55 58	 mov	 rdx, QWORD PTR _Parent$[rbp]
  00030	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1280 :         } else

  00039	eb 0d		 jmp	 SHORT $LN3@Adopt
$LN2@Adopt:

; 1281 : #endif // _HAS_CXX20
; 1282 :         {
; 1283 :             _Adopt_locked(_Parent);

  0003b	48 8b 55 58	 mov	 rdx, QWORD PTR _Parent$[rbp]
  0003f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00043	e8 00 00 00 00	 call	 ?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
$LN3@Adopt:

; 1284 :         }
; 1285 :     }

  00048	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT

; 1265 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1266 : #if _HAS_CXX20
; 1267 :         if (_STD is_constant_evaluated()) {

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 0b		 je	 SHORT $LN2@Iterator_b

; 1268 :             _Orphan_me_unlocked_v3();

  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1269 :         } else

  00030	eb 09		 jmp	 SHORT $LN3@Iterator_b
$LN2@Iterator_b:

; 1270 : #endif // _HAS_CXX20
; 1271 :         {
; 1272 :             _Orphan_me_locked_v3();

  00032	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00036	e8 00 00 00 00	 call	 ?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
$LN3@Iterator_b:

; 1273 :         }
; 1274 :     }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??1_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z PROC	; std::_Iterator_base12::operator=, COMDAT

; 1248 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1249 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1250 : #if _HAS_CXX20
; 1251 :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0f		 je	 SHORT $LN2@operator

; 1252 :             _Assign_unlocked(_Right);

  0002c	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00030	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_unlocked

; 1253 :         } else

  00039	eb 0d		 jmp	 SHORT $LN3@operator
$LN2@operator:

; 1254 : #endif // _HAS_CXX20
; 1255 :         {
; 1256 :             _Assign_locked(_Right);

  0003b	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  0003f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00043	e8 00 00 00 00	 call	 ?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_locked
$LN3@operator:

; 1257 :         }
; 1258 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1259 :         _Myproxy = _Right._Myproxy;
; 1260 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1261 :         return *this;

  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1262 :     }

  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z ENDP	; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
??0_Iterator_base12@std@@QEAA@AEBU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT

; 1244 :     _CONSTEXPR20 _Iterator_base12(const _Iterator_base12& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1247 : 
; 1248 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1249 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1250 : #if _HAS_CXX20
; 1251 :         if (_STD is_constant_evaluated()) {
; 1252 :             _Assign_unlocked(_Right);
; 1253 :         } else
; 1254 : #endif // _HAS_CXX20
; 1255 :         {
; 1256 :             _Assign_locked(_Right);
; 1257 :         }
; 1258 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1259 :         _Myproxy = _Right._Myproxy;
; 1260 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1261 :         return *this;
; 1262 :     }
; 1263 : 
; 1264 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1265 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {
; 1266 : #if _HAS_CXX20
; 1267 :         if (_STD is_constant_evaluated()) {
; 1268 :             _Orphan_me_unlocked_v3();
; 1269 :         } else
; 1270 : #endif // _HAS_CXX20
; 1271 :         {
; 1272 :             _Orphan_me_locked_v3();
; 1273 :         }
; 1274 :     }
; 1275 : 
; 1276 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1277 : #if _HAS_CXX20
; 1278 :         if (_STD is_constant_evaluated()) {
; 1279 :             _Adopt_unlocked(_Parent);
; 1280 :         } else
; 1281 : #endif // _HAS_CXX20
; 1282 :         {
; 1283 :             _Adopt_locked(_Parent);
; 1284 :         }
; 1285 :     }
; 1286 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1287 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1288 :         if (_Parent) { // have a parent, do adoption
; 1289 :             _Myproxy = _Parent->_Myproxy;
; 1290 :         } else { // no future parent, just disown current parent
; 1291 :             _Myproxy = nullptr;
; 1292 :         }
; 1293 :     }
; 1294 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1295 : 
; 1296 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {
; 1297 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1298 :     }
; 1299 : 
; 1300 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1301 : 
; 1302 :     mutable _Container_proxy* _Myproxy    = nullptr;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1303 :     mutable _Iterator_base12* _Mynextiter = nullptr;

  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1245 :         *this = _Right;

  00037	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  0003b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0003f	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z ; std::_Iterator_base12::operator=

; 1246 :     }

  00044	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00048	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
??0_Iterator_base12@std@@QEAA@AEBU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT

; 1242 :     _CONSTEXPR20 _Iterator_base12() noexcept = default; // construct orphaned iterator

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1243 : 
; 1244 :     _CONSTEXPR20 _Iterator_base12(const _Iterator_base12& _Right) noexcept {
; 1245 :         *this = _Right;
; 1246 :     }
; 1247 : 
; 1248 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1249 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1250 : #if _HAS_CXX20
; 1251 :         if (_STD is_constant_evaluated()) {
; 1252 :             _Assign_unlocked(_Right);
; 1253 :         } else
; 1254 : #endif // _HAS_CXX20
; 1255 :         {
; 1256 :             _Assign_locked(_Right);
; 1257 :         }
; 1258 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1259 :         _Myproxy = _Right._Myproxy;
; 1260 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1261 :         return *this;
; 1262 :     }
; 1263 : 
; 1264 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1265 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {
; 1266 : #if _HAS_CXX20
; 1267 :         if (_STD is_constant_evaluated()) {
; 1268 :             _Orphan_me_unlocked_v3();
; 1269 :         } else
; 1270 : #endif // _HAS_CXX20
; 1271 :         {
; 1272 :             _Orphan_me_locked_v3();
; 1273 :         }
; 1274 :     }
; 1275 : 
; 1276 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1277 : #if _HAS_CXX20
; 1278 :         if (_STD is_constant_evaluated()) {
; 1279 :             _Adopt_unlocked(_Parent);
; 1280 :         } else
; 1281 : #endif // _HAS_CXX20
; 1282 :         {
; 1283 :             _Adopt_locked(_Parent);
; 1284 :         }
; 1285 :     }
; 1286 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1287 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1288 :         if (_Parent) { // have a parent, do adoption
; 1289 :             _Myproxy = _Parent->_Myproxy;
; 1290 :         } else { // no future parent, just disown current parent
; 1291 :             _Myproxy = nullptr;
; 1292 :         }
; 1293 :     }
; 1294 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1295 : 
; 1296 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {
; 1297 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1298 :     }
; 1299 : 
; 1300 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1301 : 
; 1302 :     mutable _Container_proxy* _Myproxy    = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1303 :     mutable _Iterator_base12* _Mynextiter = nullptr;

  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1242 :     _CONSTEXPR20 _Iterator_base12() noexcept = default; // construct orphaned iterator

  00032	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
??0_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT

; 1229 :     void _Orphan_all_locked_v3() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1230 :         _Lockit _Lock(_LOCK_DEBUG);

  0001b	ba 03 00 00 00	 mov	 edx, 3
  00020	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1231 :         _Orphan_all_unlocked_v3();

  0002a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1232 :     }

  00033	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$1 = 0
$T2 = 72
this$ = 96
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT

; 1369 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1370 :     if (!_Myproxy) { // no proxy, already done

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	75 02		 jne	 SHORT $LN5@Orphan_all

; 1371 :         return;

  00025	eb 45		 jmp	 SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1372 :     }
; 1373 : 
; 1374 :     // proxy allocated, drain it
; 1375 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

  00027	48 c7 45 48 00
	00 00 00	 mov	 QWORD PTR $T2[rbp], 0
  0002f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 83 c0 08	 add	 rax, 8
  0003a	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
  00046	48 89 45 00	 mov	 QWORD PTR _Pnext$1[rbp], rax
  0004a	eb 0c		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0004c	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00050	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00054	48 89 45 00	 mov	 QWORD PTR _Pnext$1[rbp], rax
$LN4@Orphan_all:
  00058	48 83 7d 00 00	 cmp	 QWORD PTR _Pnext$1[rbp], 0
  0005d	74 0d		 je	 SHORT $LN1@Orphan_all

; 1376 :         _Pnext->_Myproxy = nullptr;

  0005f	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00063	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1377 :     }

  0006a	eb e0		 jmp	 SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 1378 : }

  0006c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 1380 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1381 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1382 : #if _HAS_CXX20
; 1383 :     if (_STD is_constant_evaluated()) {

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 0b		 je	 SHORT $LN2@Orphan_all

; 1384 :         _Orphan_all_unlocked_v3();

  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1385 :     } else

  00030	eb 09		 jmp	 SHORT $LN3@Orphan_all
$LN2@Orphan_all:

; 1386 : #endif // _HAS_CXX20
; 1387 :     {
; 1388 :         _Orphan_all_locked_v3();

  00032	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00036	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN3@Orphan_all:

; 1389 :     }
; 1390 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1391 : }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT

; 1198 :     _CONSTEXPR20 _Container_base12() noexcept = default;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1199 : 
; 1200 :     _Container_base12(const _Container_base12&)            = delete;
; 1201 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1202 : 
; 1203 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1204 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1205 : 
; 1206 :     template <class _Alloc>
; 1207 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1208 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1209 :         _Construct_in_place(*_New_proxy, this);
; 1210 :         _Myproxy            = _New_proxy;
; 1211 :         _New_proxy->_Mycont = this;
; 1212 :     }
; 1213 : 
; 1214 :     template <class _Alloc>
; 1215 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1216 :         // pre: no iterators refer to the existing proxy
; 1217 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1218 :         _Construct_in_place(*_New_proxy, this);
; 1219 :         _New_proxy->_Mycont = this;
; 1220 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1221 :     }
; 1222 : 
; 1223 :     _Container_proxy* _Myproxy = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1198 :     _CONSTEXPR20 _Container_base12() noexcept = default;

  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
??0_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 80
_Mycont_$ = 88
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT

; 1190 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Mycont_$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1191 : 
; 1192 :     const _Container_base12* _Mycont       = nullptr;
; 1193 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1190 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1179 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr_user$ = 0
_Ptr_container$ = 8
_Min_back_shift$ = 16
_Back_shift$ = 24
_Ptr$ = 112
_Bytes$ = 120
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 154  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 155  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 156  :     _Bytes += _Non_user_size;

  00023	48 8b 45 78	 mov	 rax, QWORD PTR _Bytes$[rbp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  0002e	48 8b 4d 78	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00032	48 89 01	 mov	 QWORD PTR [rcx], rax

; 157  : 
; 158  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00035	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 45 00	 mov	 QWORD PTR _Ptr_user$[rbp], rax

; 159  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00040	b8 08 00 00 00	 mov	 eax, 8
  00045	48 6b c0 ff	 imul	 rax, rax, -1
  00049	48 8b 4d 00	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  0004d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00051	48 89 45 08	 mov	 QWORD PTR _Ptr_container$[rbp], rax
$LN4@Adjust_man:

; 160  : 
; 161  :     // If the following asserts, it likely means that we are performing
; 162  :     // an aligned delete on memory coming from an unaligned allocation.
; 163  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00055	b8 08 00 00 00	 mov	 eax, 8
  0005a	48 6b c0 fe	 imul	 rax, rax, -2
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  00062	48 ba fa fa fa
	fa fa fa fa fa	 mov	 rdx, -361700864190383366 ; fafafafafafafafaH
  0006c	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00070	75 02		 jne	 SHORT $LN14@Adjust_man
  00072	eb 77		 jmp	 SHORT $LN15@Adjust_man
$LN14@Adjust_man:
$LN7@Adjust_man:
  00074	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  0007a	83 c0 09	 add	 eax, 9
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  00084	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00090	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00095	45 33 c9	 xor	 r9d, r9d
  00098	44 8b c0	 mov	 r8d, eax
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  000a2	b9 02 00 00 00	 mov	 ecx, 2
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 03		 jne	 SHORT $LN19@Adjust_man
  000b2	cc		 int	 3
  000b3	33 c0		 xor	 eax, eax
$LN19@Adjust_man:
  000b5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  000bb	83 c0 09	 add	 eax, 9
  000be	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000c7	44 8b c8	 mov	 r9d, eax
  000ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000e5	33 c0		 xor	 eax, eax
  000e7	85 c0		 test	 eax, eax
  000e9	75 89		 jne	 SHORT $LN7@Adjust_man
$LN15@Adjust_man:
  000eb	33 c0		 xor	 eax, eax
  000ed	85 c0		 test	 eax, eax
  000ef	0f 85 60 ff ff
	ff		 jne	 $LN4@Adjust_man

; 164  : 
; 165  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 166  :     // in range [_Min_back_shift, _Non_user_size]
; 167  : #ifdef _DEBUG
; 168  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000f5	48 c7 45 10 10
	00 00 00	 mov	 QWORD PTR _Min_back_shift$[rbp], 16

; 169  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 170  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 171  : #endif // _DEBUG
; 172  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fd	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00101	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  00105	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00108	48 2b c1	 sub	 rax, rcx
  0010b	48 89 45 18	 mov	 QWORD PTR _Back_shift$[rbp], rax
$LN10@Adjust_man:

; 173  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010f	48 83 7d 18 10	 cmp	 QWORD PTR _Back_shift$[rbp], 16
  00114	72 09		 jb	 SHORT $LN16@Adjust_man
  00116	48 83 7d 18 2f	 cmp	 QWORD PTR _Back_shift$[rbp], 47 ; 0000002fH
  0011b	77 02		 ja	 SHORT $LN16@Adjust_man
  0011d	eb 77		 jmp	 SHORT $LN17@Adjust_man
$LN16@Adjust_man:
$LN13@Adjust_man:
  0011f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00125	83 c0 13	 add	 eax, 19
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  0012f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0013b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00140	45 33 c9	 xor	 r9d, r9d
  00143	44 8b c0	 mov	 r8d, eax
  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0014d	b9 02 00 00 00	 mov	 ecx, 2
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00158	83 f8 01	 cmp	 eax, 1
  0015b	75 03		 jne	 SHORT $LN20@Adjust_man
  0015d	cc		 int	 3
  0015e	33 c0		 xor	 eax, eax
$LN20@Adjust_man:
  00160	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00166	83 c0 13	 add	 eax, 19
  00169	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00172	44 8b c8	 mov	 r9d, eax
  00175	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00190	33 c0		 xor	 eax, eax
  00192	85 c0		 test	 eax, eax
  00194	75 89		 jne	 SHORT $LN13@Adjust_man
$LN17@Adjust_man:
  00196	33 c0		 xor	 eax, eax
  00198	85 c0		 test	 eax, eax
  0019a	0f 85 6f ff ff
	ff		 jne	 $LN10@Adjust_man

; 174  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001a0	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  001a4	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  001a8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 175  : }

  001ab	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  001af	5d		 pop	 rbp
  001b0	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 80
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 85   :         void* _Allocate(const size_t _Bytes) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 86   :         return ::operator new(_Bytes);

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 87   :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 64
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 330  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00009	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2DED1E19_exception
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 331  :     _THROW(bad_array_new_length{});

  0001a	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0001e	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QEAA@XZ ; std::bad_array_new_length::bad_array_new_length
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
  0002a	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0002e	e8 00 00 00 00	 call	 _CxxThrowException
$LN2@Throw_bad_:

; 332  : }

  00033	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UEAA@XZ
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QEAA@AEBV01@@Z
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 141  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 140  :         : bad_alloc("bad array new length")

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AEAA@QEBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 142  :     }

  00039	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@AEBV01@@Z ; std::exception::exception
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 80
_Message$ = 88
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 129  :         : exception(_Message, 1)

  00020	41 b8 01 00 00
	00		 mov	 r8d, 1
  00026	48 8b 55 58	 mov	 rdx, QWORD PTR _Message$[rbp]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@QEBDH@Z ; std::exception::exception

; 130  :     {

  00033	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  0003e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 131  :     }

  00041	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 64
this$ = 96
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 94   :     {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00024	74 0e		 je	 SHORT $LN3@what
  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002e	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  00032	eb 0b		 jmp	 SHORT $LN4@what
$LN3@what:
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
  0003b	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
$LN4@what:
  0003f	48 8b 45 40	 mov	 rax, QWORD PTR tv69[rbp]

; 96   :     }

  00043	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00026	48 89 08	 mov	 QWORD PTR [rax], rcx

; 90   :         __std_exception_destroy(&_Data);

  00029	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 83 c0 08	 add	 rax, 8
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 __std_exception_destroy

; 91   :     }

  00039	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 96
_Other$ = 104
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  0001c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00021	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   :         : _Data()

  0002f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 83 c0 08	 add	 rax, 8
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 10 00 00 00	 mov	 ecx, 16
  00041	f3 aa		 rep stosb

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00043	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00047	48 83 c0 08	 add	 rax, 8
  0004b	48 8b 4d 68	 mov	 rcx, QWORD PTR _Other$[rbp]
  0004f	48 83 c1 08	 add	 rcx, 8
  00053	48 8b d0	 mov	 rdx, rax
  00056	e8 00 00 00 00	 call	 __std_exception_copy

; 74   :     }

  0005b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0005f	48 8d 65 48	 lea	 rsp, QWORD PTR [rbp+72]
  00063	5f		 pop	 rdi
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 96
_Message$ = 104
__formal$ = 112
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00015	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00021	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00031	48 89 08	 mov	 QWORD PTR [rax], rcx

; 65   :         : _Data()

  00034	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 83 c0 08	 add	 rax, 8
  0003c	48 8b f8	 mov	 rdi, rax
  0003f	33 c0		 xor	 eax, eax
  00041	b9 10 00 00 00	 mov	 ecx, 16
  00046	f3 aa		 rep stosb

; 67   :         _Data._What = _Message;

  00048	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8b 4d 68	 mov	 rcx, QWORD PTR _Message$[rbp]
  00050	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 68   :     }

  00054	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8d 65 48	 lea	 rsp, QWORD PTR [rbp+72]
  0005c	5f		 pop	 rdi
  0005d	5d		 pop	 rbp
  0005e	c3		 ret	 0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
_TEXT	SEGMENT
_Idx$1 = 0
_Val$ = 96
_First$ = 104
_Count$ = 112
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 2324 :     const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2325 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  00025	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Idx$1[rbp], 0
  0002d	eb 0b		 jmp	 SHORT $LN4@Fnv1a_appe
$LN2@Fnv1a_appe:
  0002f	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  00033	48 ff c0	 inc	 rax
  00036	48 89 45 00	 mov	 QWORD PTR _Idx$1[rbp], rax
$LN4@Fnv1a_appe:
  0003a	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  0003e	48 39 45 00	 cmp	 QWORD PTR _Idx$1[rbp], rax
  00042	73 3a		 jae	 SHORT $LN3@Fnv1a_appe

; 2326 :         _Val ^= static_cast<size_t>(_First[_Idx]);

  00044	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  00048	48 8b 4d 68	 mov	 rcx, QWORD PTR _First$[rbp]
  0004c	48 03 c8	 add	 rcx, rax
  0004f	48 8b c1	 mov	 rax, rcx
  00052	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00055	48 8b 4d 60	 mov	 rcx, QWORD PTR _Val$[rbp]
  00059	48 33 c8	 xor	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	48 89 45 60	 mov	 QWORD PTR _Val$[rbp], rax

; 2327 :         _Val *= _FNV_prime;

  00063	48 b8 b3 01 00
	00 00 01 00 00	 mov	 rax, 1099511628211	; 00000100000001b3H
  0006d	48 8b 4d 60	 mov	 rcx, QWORD PTR _Val$[rbp]
  00071	48 0f af c8	 imul	 rcx, rax
  00075	48 8b c1	 mov	 rax, rcx
  00078	48 89 45 60	 mov	 QWORD PTR _Val$[rbp], rax

; 2328 :     }

  0007c	eb b1		 jmp	 SHORT $LN2@Fnv1a_appe
$LN3@Fnv1a_appe:

; 2329 : 
; 2330 :     return _Val;

  0007e	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]

; 2331 : }

  00082	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00086	5d		 pop	 rbp
  00087	c3		 ret	 0
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ENDP		; std::_Fnv1a_append_bytes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 80
_Where$ = 88
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 168  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__84C50014_vcruntime_new@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 169  :         (void)_Size;
; 170  :         return _Where;

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Where$[rbp]

; 171  :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 635  :     _NODISCARD static constexpr long long(max)() noexcept {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__595ABB90_limits
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 636  :         return LLONG_MAX;

  00017	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH

; 637  :     }

  00021	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 178  : _EXPORT_STD _NODISCARD constexpr bool is_constant_evaluated() noexcept {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9A2CA802_xtr1common
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 179  :     return __builtin_is_constant_evaluated();

  00017	32 c0		 xor	 al, al

; 180  : }

  00019	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
END
