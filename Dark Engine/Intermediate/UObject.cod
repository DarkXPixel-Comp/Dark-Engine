; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33030.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__B51A3A23_Core@h DB 01H
__4A250794_concurrencysal@h DB 01H
__64794009_sal@h DB 01H
__A3E7195B_vadefs@h DB 01H
__978626E5_vcruntime@h DB 01H
__735B63F8_xkeycheck@h DB 01H
__142C9C9C_yvals_core@h DB 01H
__1B0272D9_corecrt@h DB 01H
__84C50014_vcruntime_new@h DB 01H
__7A6EC116_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__E5B2708F_crtdefs@h DB 01H
__61229A4B_use_ansi@h DB 01H
__8C2D0B1D_yvals@h DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__4CF83D73_cstdio DB 01H
__61CC25A1_errno@h DB 01H
__4CB5F942_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__76FF1542_cstring DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__8ECB7138_corecrt_share@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__D673EB20_cwchar DB 01H
__9A2CA802_xtr1common DB 01H
__95B36E16_iosfwd DB 01H
__DBEA773D_stdint@h DB 01H
__87335CDF_cstdint DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__659C5902_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__3A6DBDA2_cstdlib DB 01H
__B9985323_float@h DB 01H
__3FBCF6F4_cfloat DB 01H
__BE829F50_climits DB 01H
__51ADDFC3_intrin0@inl@h DB 01H
__FC9FC984_intrin0@h DB 01H
__595ABB90_limits DB 01H
__9FA6670F_cstddef DB 01H
__3DF2A533_type_traits DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__35BB339F_eh@h DB 01H
__7280C444_vcruntime_exception@h DB 01H
__2DED1E19_exception DB 01H
__A5D71DBC_new DB 01H
__27E192CF_xatomic@h DB 01H
__50E371A7_initializer_list DB 01H
__339AE60A_concepts DB 01H
__C3788713_compare DB 01H
__0D603829_utility DB 01H
__874288EA___msvc_iter_core@hpp DB 01H
__B7320FC0_xutility DB 01H
__A0E057FF_tuple DB 01H
__67F55BEA_xmemory DB 01H
__A0A2F5C0_xpolymorphic_allocator@h DB 01H
__C671E263___msvc_sanitizer_annotate_container@hpp DB 01H
__1326DD76_xstring DB 01H
__1EC467ED_ctype@h DB 01H
__4333DAD4_cctype DB 01H
__91273182_string DB 01H
__F3EA4CCC___msvc_bit_utils@hpp DB 01H
__14F7CB70_vector DB 01H
__FBEF5BAE_Array@h DB 01H
__9024636E_DarkString@h DB 01H
__52656974_list DB 01H
__B9FFAD7A_UObject@h DB 01H
__0ED810FD_UObject@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	??1UObject@@QEAA@XZ				; UObject::~UObject
PUBLIC	?BeginPlay@UObject@@UEAAXXZ			; UObject::BeginPlay
PUBLIC	?Update@UObject@@UEAAXM@Z			; UObject::Update
PUBLIC	?Destroy@UObject@@UEAAXXZ			; UObject::Destroy
PUBLIC	?SetOwner@UObject@@UEAAXPEAV1@@Z		; UObject::SetOwner
PUBLIC	?GetOwner@UObject@@UEAAPEAV1@XZ			; UObject::GetOwner
PUBLIC	?deallocate@?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z ; std::allocator<std::_List_node<UObject *,void *> >::deallocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@QEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<UObject *,void *> > >::deallocate
PUBLIC	??1?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA@XZ ; std::list<UObject *,std::allocator<UObject *> >::~list<UObject *,std::allocator<UObject *> >
PUBLIC	?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_end
PUBLIC	?clear@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAAXXZ ; std::list<UObject *,std::allocator<UObject *> >::clear
PUBLIC	?_Tidy@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAXXZ ; std::list<UObject *,std::allocator<UObject *> >::_Tidy
PUBLIC	?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Getal
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<UObject *> >::_Orphan_non_end
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<UObject *,void *> >,std::_List_val<std::_List_simple_types<UObject *> >,1>::_Get_first
PUBLIC	??_GUObject@@QEAAPEAXI@Z			; UObject::`scalar deleting destructor'
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBQEAVUObject@@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator++
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator==
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator++
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<UObject *,void *>::_Free_non_head<std::allocator<std::_List_node<UObject *,void *> > >
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	??$?0U?$_List_node@PEAVUObject@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<UObject *,void *> >
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<UObject *,void *>::_Freenode0<std::allocator<std::_List_node<UObject *,void *> > >
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<UObject *,void *>::_Freenode<std::allocator<std::_List_node<UObject *,void *> > >
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@PEAVUObject@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@PEAVUObject@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<UObject *,void *> *>
PUBLIC	??$addressof@PEAVUObject@@@std@@YAPEAPEAVUObject@@AEAPEAV1@@Z ; std::addressof<UObject *>
PUBLIC	??$destroy@PEAVUObject@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@QEAPEAVUObject@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<UObject *,void *> > >::destroy<UObject *>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$destroy_at@PEAVUObject@@@std@@YAXQEAPEAVUObject@@@Z ; std::destroy_at<UObject *>
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_7UObject@@6B@				; UObject::`vftable'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_R4UObject@@6B@				; UObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVUObject@@@8				; UObject `RTTI Type Descriptor'
PUBLIC	??_R3UObject@@8					; UObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UObject@@8					; UObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UObject@@8			; UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__imp__invalid_parameter:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_constant_evaluated@std@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?is_constant_evaluated@std@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN21
	DD	imagerel $LN21+433
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+114
	DD	imagerel $unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1UObject@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??1UObject@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginPlay@UObject@@UEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+139
	DD	imagerel $unwind$?BeginPlay@UObject@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Update@UObject@@UEAAXM@Z DD imagerel $LN6
	DD	imagerel $LN6+173
	DD	imagerel $unwind$?Update@UObject@@UEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Destroy@UObject@@UEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+218
	DD	imagerel $unwind$?Destroy@UObject@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetOwner@UObject@@UEAAXPEAV1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?SetOwner@UObject@@UEAAXPEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetOwner@UObject@@UEAAPEAV1@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?GetOwner@UObject@@UEAAPEAV1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+193
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@QEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@QEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$??1?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+142
	DD	imagerel $unwind$?clear@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?_Tidy@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+170
	DD	imagerel $unwind$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GUObject@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_GUObject@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBQEAVUObject@@XZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBQEAVUObject@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+193
	DD	imagerel $unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$_List_node@PEAVUObject@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0U?$_List_node@PEAVUObject@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAU?$_List_node@PEAVUObject@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@PEAVUObject@@PEAX@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$_Destroy_in_place@PEAU?$_List_node@PEAVUObject@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@PEAVUObject@@PEAX@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@PEAVUObject@@@std@@YAPEAPEAVUObject@@AEAPEAV1@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@PEAVUObject@@@std@@YAPEAPEAVUObject@@AEAPEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@PEAVUObject@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@QEAPEAVUObject@@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$destroy@PEAVUObject@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@QEAPEAVUObject@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@PEAVUObject@@@std@@YAXQEAPEAVUObject@@@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$destroy_at@PEAVUObject@@@std@@YAXQEAPEAVUObject@@@Z
pdata	ENDS
;	COMDAT ??_R1A@?0A@EA@UObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UObject@@8 DD imagerel ??_R0?AVUObject@@@8 ; UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UObject@@8
rdata$r	ENDS
;	COMDAT ??_R2UObject@@8
rdata$r	SEGMENT
??_R2UObject@@8 DD imagerel ??_R1A@?0A@EA@UObject@@8	; UObject::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3UObject@@8
rdata$r	SEGMENT
??_R3UObject@@8 DD 00H					; UObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2UObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUObject@@@8
data$rs	SEGMENT
??_R0?AVUObject@@@8 DQ FLAT:??_7type_info@@6B@		; UObject `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R4UObject@@6B@
rdata$r	SEGMENT
??_R4UObject@@6B@ DD 01H				; UObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUObject@@@8
	DD	imagerel ??_R3UObject@@8
	DD	imagerel ??_R4UObject@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7UObject@@6B@
CONST	SEGMENT
??_7UObject@@6B@ DQ FLAT:??_R4UObject@@6B@		; UObject::`vftable'
	DQ	FLAT:?BeginPlay@UObject@@UEAAXXZ
	DQ	FLAT:?Update@UObject@@UEAAXM@Z
	DQ	FLAT:?Destroy@UObject@@UEAAXXZ
	DQ	FLAT:?SetOwner@UObject@@UEAAXPEAV1@@Z
	DQ	FLAT:?GetOwner@UObject@@UEAAPEAV1@XZ
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e', 00H, 'm'
	DB	00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program Fi'
	DB	'les\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.'
	DB	'33030\include\xmemory', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA DD 09aH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@PEAVUObject@@@std@@YAXQEAPEAVUObject@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@PEAVUObject@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@QEAPEAVUObject@@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@PEAVUObject@@@std@@YAPEAPEAVUObject@@AEAPEAV1@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAU?$_List_node@PEAVUObject@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@PEAVUObject@@PEAX@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DB 060H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DB 060H
	DD	imagerel $ip2state$??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$_List_node@PEAVUObject@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBQEAVUObject@@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GUObject@@QEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@QEAAXXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAAXXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@QEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetOwner@UObject@@UEAAPEAV1@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetOwner@UObject@@UEAAXPEAV1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Destroy@UObject@@UEAAXXZ DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Update@UObject@@UEAAXM@Z DD 025041801H
	DD	01132318H
	DD	0500c0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginPlay@UObject@@UEAAXXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1UObject@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1UObject@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1UObject@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1UObject@@QEAA@XZ DD 025030f19H
	DD	0b20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1UObject@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 035041701H
	DD	01123317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_constant_evaluated@std@@YA_NXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy_at@PEAVUObject@@@std@@YAXQEAPEAVUObject@@@Z
_TEXT	SEGMENT
_Location$ = 80
??$destroy_at@PEAVUObject@@@std@@YAXQEAPEAVUObject@@@Z PROC ; std::destroy_at<UObject *>, COMDAT

; 313  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 314  : #if _HAS_CXX20
; 315  :     if constexpr (is_array_v<_Ty>) {
; 316  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 317  :     } else
; 318  : #endif // _HAS_CXX20
; 319  :     {
; 320  :         _Location->~_Ty();
; 321  :     }
; 322  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$destroy_at@PEAVUObject@@@std@@YAXQEAPEAVUObject@@@Z ENDP ; std::destroy_at<UObject *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@deallocate

; 709  :             _Al.deallocate(_Ptr, _Count);

  00031	4c 8b 45 60	 mov	 r8, QWORD PTR _Count$[rbp]
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00039	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate

; 710  :         } else

  00042	eb 11		 jmp	 SHORT $LN3@deallocate
$LN2@deallocate:

; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00044	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>
$LN3@deallocate:

; 715  :         }
; 716  :     }

  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy@PEAVUObject@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@QEAPEAVUObject@@@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
??$destroy@PEAVUObject@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@QEAPEAVUObject@@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<UObject *,void *> > >::destroy<UObject *>, COMDAT

; 728  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 729  : #if _HAS_CXX20
; 730  :         _STD destroy_at(_Ptr);

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00024	e8 00 00 00 00	 call	 ??$destroy_at@PEAVUObject@@@std@@YAXQEAPEAVUObject@@@Z ; std::destroy_at<UObject *>

; 731  : #else // _HAS_CXX20
; 732  :         _Ptr->~_Uty();
; 733  : #endif // _HAS_CXX20
; 734  :     }

  00029	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
??$destroy@PEAVUObject@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@QEAPEAVUObject@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<UObject *,void *> > >::destroy<UObject *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@PEAVUObject@@@std@@YAPEAPEAVUObject@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@PEAVUObject@@@std@@YAPEAPEAVUObject@@AEAPEAV1@@Z PROC ; std::addressof<UObject *>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@PEAVUObject@@@std@@YAPEAPEAVUObject@@AEAPEAV1@@Z ENDP ; std::addressof<UObject *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@PEAVUObject@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@PEAVUObject@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 80
??$_Destroy_in_place@PEAU?$_List_node@PEAVUObject@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@PEAVUObject@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<UObject *,void *> *>, COMDAT

; 303  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 304  :     if constexpr (is_array_v<_Ty>) {
; 305  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 306  :     } else {
; 307  :         _Obj.~_Ty();
; 308  :     }
; 309  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$_Destroy_in_place@PEAU?$_List_node@PEAVUObject@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@PEAVUObject@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<UObject *,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1123 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1124 :     // deallocate a plain pointer using an allocator
; 1125 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1126 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1127 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00020	41 b8 01 00 00
	00		 mov	 r8d, 1
  00026	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  00033	90		 npad	 1

; 1128 :     } else {
; 1129 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1130 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1131 :     }
; 1132 : }

  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<UObject *,void *>::_Freenode<std::allocator<std::_List_node<UObject *,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00024	48 83 c0 10	 add	 rax, 16
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??$addressof@PEAVUObject@@@std@@YAPEAPEAVUObject@@AEAPEAV1@@Z ; std::addressof<UObject *>
  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00037	e8 00 00 00 00	 call	 ??$destroy@PEAVUObject@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@QEAPEAVUObject@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<UObject *,void *> > >::destroy<UObject *>

; 318  :         _Freenode0(_Al, _Ptr);

  0003c	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00040	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00044	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<UObject *,void *>::_Freenode0<std::allocator<std::_List_node<UObject *,void *> > >
  00049	90		 npad	 1

; 319  :     }

  0004a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<UObject *,void *>::_Freenode<std::allocator<std::_List_node<UObject *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 80
_Bytes$ = 88
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 251  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0b		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 256  :     } else

  00035	eb 25		 jmp	 SHORT $LN3@Deallocate
$LN2@Deallocate:

; 257  : #endif // _HAS_CXX20
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00037	48 81 7d 58 00
	10 00 00	 cmp	 QWORD PTR _Bytes$[rbp], 4096 ; 00001000H
  0003f	72 0d		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00041	48 8d 55 58	 lea	 rdx, QWORD PTR _Bytes$[rbp]
  00045	48 8d 4d 50	 lea	 rcx, QWORD PTR _Ptr$[rbp]
  00049	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0004e	48 8b 55 58	 mov	 rdx, QWORD PTR _Bytes$[rbp]
  00052	48 8b 4d 50	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00056	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0005b	90		 npad	 1
$LN3@Deallocate:

; 265  :     }
; 266  : }

  0005c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<UObject *,void *>::_Freenode0<std::allocator<std::_List_node<UObject *,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAU?$_List_node@PEAVUObject@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@PEAVUObject@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<UObject *,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0002c	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00030	48 83 c0 08	 add	 rax, 8
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAU?$_List_node@PEAVUObject@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@PEAVUObject@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<UObject *,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

  0003c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00042	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00046	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0004a	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@QEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<UObject *,void *> > >::deallocate
  0004f	90		 npad	 1

; 313  :     }

  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<UObject *,void *>::_Freenode0<std::allocator<std::_List_node<UObject *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1135 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1136 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1137 :     using _Ty = typename _Alloc::value_type;
; 1138 :     _Ptr->~_Ty();
; 1139 :     _Deallocate_plain(_Al, _Ptr);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00028	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >

; 1140 : }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0U?$_List_node@PEAVUObject@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0U?$_List_node@PEAVUObject@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<UObject *,void *> >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0U?$_List_node@PEAVUObject@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<UObject *,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bb	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 0
_Pnext$1 = 8
_Al$ = 96
_Head$ = 104
??$_Free_non_head@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<UObject *,void *>::_Free_non_head<std::allocator<std::_List_node<UObject *,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 324  :         _Head->_Prev->_Next = nullptr;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Head$[rbp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0002f	48 8b 45 68	 mov	 rax, QWORD PTR _Head$[rbp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 89 45 00	 mov	 QWORD PTR _Pnode$[rbp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0003a	eb 08		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00040	48 89 45 00	 mov	 QWORD PTR _Pnode$[rbp], rax
$LN4@Free_non_h:
  00044	48 83 7d 00 00	 cmp	 QWORD PTR _Pnode$[rbp], 0
  00049	74 1a		 je	 SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  0004b	48 8b 45 00	 mov	 rax, QWORD PTR _Pnode$[rbp]
  0004f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00052	48 89 45 08	 mov	 QWORD PTR _Pnext$1[rbp], rax

; 329  :             _Freenode(_Al, _Pnode);

  00056	48 8b 55 00	 mov	 rdx, QWORD PTR _Pnode$[rbp]
  0005a	48 8b 4d 60	 mov	 rcx, QWORD PTR _Al$[rbp]
  0005e	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<UObject *,void *>::_Freenode<std::allocator<std::_List_node<UObject *,void *> > >

; 330  :         }

  00063	eb d7		 jmp	 SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

  00065	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<UObject *,void *>::_Free_non_head<std::allocator<std::_List_node<UObject *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 80
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator++, COMDAT

; 106  :     _List_unchecked_iterator& operator++() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 107  :         _Mybase::operator++();

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator++

; 108  :         return *this;

  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 109  :     }

  00028	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ
_TEXT	SEGMENT
this$ = 80
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator*, COMDAT

; 98   :     _NODISCARD reference operator*() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 99   :         return const_cast<reference>(_Mybase::operator*());

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBQEAVUObject@@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator*

; 100  :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 64
this$ = 96
_Right$ = 104
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 72   :         return _Ptr == _Right._Ptr;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	75 09		 jne	 SHORT $LN3@operator
  00030	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv67[rbp], 1
  00037	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00039	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv67[rbp], 0
$LN4@operator:
  00040	0f b6 45 40	 movzx	 eax, BYTE PTR tv67[rbp]

; 73   :     }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 80
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 50   :         _Ptr = _Ptr->_Next;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 01	 mov	 QWORD PTR [rcx], rax

; 51   :         return *this;

  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 52   :     }

  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBQEAVUObject@@XZ
_TEXT	SEGMENT
this$ = 80
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBQEAVUObject@@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 42   :         return _Ptr->_Myval;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 83 c0 10	 add	 rax, 16

; 43   :     }

  00026	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBQEAVUObject@@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Pnode$ = 88
_Plist$ = 96
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

  00030	48 8b 55 60	 mov	 rdx, QWORD PTR _Plist$[rbp]
  00034	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt

; 39   :     }

  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GUObject@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_GUObject@@QEAAPEAXI@Z PROC				; UObject::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1UObject@@QEAA@XZ	; UObject::~UObject
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_GUObject@@QEAAPEAXI@Z ENDP				; UObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<UObject *,void *> >,std::_List_val<std::_List_simple_types<UObject *> >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<UObject *,void *> >,std::_List_val<std::_List_simple_types<UObject *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
_Pnext$ = 8
_Head$ = 16
_Pnextnext$1 = 24
this$ = 112
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<UObject *> >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);

  0001e	ba 03 00 00 00	 mov	 edx, 3
  00023	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;

  0002d	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 83 c0 08	 add	 rax, 8
  00038	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 380  :         const auto _Head          = _Myhead;

  0003c	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 89 45 10	 mov	 QWORD PTR _Head$[rbp], rax
$LN2@Orphan_non:

; 381  :         while (*_Pnext) {

  00048	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0004c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00050	74 48		 je	 SHORT $LN3@Orphan_non

; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

  00052	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 83 c0 08	 add	 rax, 8
  0005d	48 89 45 18	 mov	 QWORD PTR _Pnextnext$1[rbp], rax

; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on

  00061	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 8b 4d 10	 mov	 rcx, QWORD PTR _Head$[rbp]
  0006c	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00070	75 0a		 jne	 SHORT $LN4@Orphan_non

; 384  :                 _Pnext = _Pnextnext;

  00072	48 8b 45 18	 mov	 rax, QWORD PTR _Pnextnext$1[rbp]
  00076	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 385  :             } else { // orphan the iterator

  0007a	eb 1c		 jmp	 SHORT $LN5@Orphan_non
$LN4@Orphan_non:

; 386  :                 (*_Pnext)->_Myproxy = nullptr;

  0007c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00080	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00083	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 387  :                 *_Pnext             = *_Pnextnext;

  0008a	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0008e	48 8b 4d 18	 mov	 rcx, QWORD PTR _Pnextnext$1[rbp]
  00092	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00095	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Orphan_non:

; 388  :             }
; 389  :         }

  00098	eb ae		 jmp	 SHORT $LN2@Orphan_non
$LN3@Orphan_non:

; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

  0009a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000a4	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a8	5d		 pop	 rbp
  000a9	c3		 ret	 0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<UObject *> >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ PROC ; std::list<UObject *,std::allocator<UObject *> >::_Getal, COMDAT

; 1846 :     _Alnode& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1847 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<UObject *,void *> >,std::_List_val<std::_List_simple_types<UObject *> >,1>::_Get_first

; 1848 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ ENDP ; std::list<UObject *,std::allocator<UObject *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Tidy@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Al$ = 0
_My_data$ = 8
this$ = 96
?_Tidy@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAXXZ PROC ; std::list<UObject *,std::allocator<UObject *> >::_Tidy, COMDAT

; 1496 :     void _Tidy() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1497 :         auto& _Al      = _Getal();

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Getal
  00024	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00028	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax

; 1499 :         _My_data._Orphan_all();

  00030	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 1500 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00039	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0003d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00041	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00045	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<UObject *,void *>::_Free_non_head<std::allocator<std::_List_node<UObject *,void *> > >

; 1501 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0004a	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0004e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00052	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00056	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<UObject *,void *>::_Freenode0<std::allocator<std::_List_node<UObject *,void *> > >

; 1502 :     }

  0005b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?_Tidy@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAXXZ ENDP ; std::list<UObject *,std::allocator<UObject *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?clear@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 0
tv75 = 72
tv73 = 80
this$ = 112
?clear@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAAXXZ PROC ; std::list<UObject *,std::allocator<UObject *> >::clear, COMDAT

; 1486 :     void clear() noexcept { // erase all

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1487 :         auto& _My_data = _Mypair._Myval2;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 1488 :         _My_data._Orphan_non_end();

  00026	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<UObject *> >::_Orphan_non_end

; 1489 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0002f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  0003b	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0003f	e8 00 00 00 00	 call	 ?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Getal
  00044	48 89 45 50	 mov	 QWORD PTR tv73[rbp], rax
  00048	48 8b 55 48	 mov	 rdx, QWORD PTR tv75[rbp]
  0004c	48 8b 4d 50	 mov	 rcx, QWORD PTR tv73[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@?$_List_node@PEAVUObject@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<UObject *,void *>::_Free_non_head<std::allocator<std::_List_node<UObject *,void *> > >

; 1490 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00055	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00059	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005d	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00061	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00065	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1491 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00068	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0006c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00070	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00074	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00078	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1492 :         _My_data._Mysize        = 0;

  0007c	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00080	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1493 :     }

  00088	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0008c	5d		 pop	 rbp
  0008d	c3		 ret	 0
?clear@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAAXXZ ENDP ; std::list<UObject *,std::allocator<UObject *> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ PROC ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_end, COMDAT

; 1112 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1113 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

  00020	45 33 c0	 xor	 r8d, r8d
  00023	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0002b	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0002f	e8 00 00 00 00	 call	 ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z
  00034	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1114 :     }

  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ENDP ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ PROC ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_begin, COMDAT

; 1104 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1105 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	45 33 c0	 xor	 r8d, r8d
  0002b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002e	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00032	e8 00 00 00 00	 call	 ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@PEAVUObject@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@1@@Z
  00037	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1106 :     }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ENDP ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??1?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S1$ = 8
this$ = 96
??1?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA@XZ PROC ; std::list<UObject *,std::allocator<UObject *> >::~list<UObject *,std::allocator<UObject *> >, COMDAT

; 1044 :     ~list() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1045 :         _Tidy();

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Tidy@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAXXZ ; std::list<UObject *,std::allocator<UObject *> >::_Tidy

; 1046 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1047 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00024	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ?_Getal@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Getal
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8d 4d 08	 lea	 rcx, QWORD PTR $S1$[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0U?$_List_node@PEAVUObject@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<UObject *,void *> >
  00039	48 8d 45 08	 lea	 rax, QWORD PTR $S1$[rbp]
  0003d	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 1048 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);

  00041	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00048	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  0004c	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 1049 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1050 :     }

  00051	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
??1?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA@XZ ENDP ; std::list<UObject *,std::allocator<UObject *> >::~list<UObject *,std::allocator<UObject *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@QEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@QEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<UObject *,void *> > >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@deallocate

; 709  :             _Al.deallocate(_Ptr, _Count);

  00031	4c 8b 45 60	 mov	 r8, QWORD PTR _Count$[rbp]
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00039	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z ; std::allocator<std::_List_node<UObject *,void *> >::deallocate

; 710  :         } else

  00042	eb 11		 jmp	 SHORT $LN3@deallocate
$LN2@deallocate:

; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00044	48 6b 45 60 18	 imul	 rax, QWORD PTR _Count$[rbp], 24
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>
$LN3@deallocate:

; 715  :         }
; 716  :     }

  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@2@QEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<UObject *,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<UObject *,void *> >::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 6b 45 60 18	 imul	 rax, QWORD PTR _Count$[rbp], 24
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bb	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?deallocate@?$allocator@U?$_List_node@PEAVUObject@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@PEAVUObject@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<UObject *,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Engine\Classes\UObject\UObject.cpp
;	COMDAT ?GetOwner@UObject@@UEAAPEAV1@XZ
_TEXT	SEGMENT
this$ = 80
?GetOwner@UObject@@UEAAPEAV1@XZ PROC			; UObject::GetOwner, COMDAT

; 38   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0ED810FD_UObject@cpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 39   : 	return m_owner;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 40   : }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?GetOwner@UObject@@UEAAPEAV1@XZ ENDP			; UObject::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Engine\Classes\UObject\UObject.cpp
;	COMDAT ?SetOwner@UObject@@UEAAXPEAV1@@Z
_TEXT	SEGMENT
this$ = 80
owner$ = 88
?SetOwner@UObject@@UEAAXPEAV1@@Z PROC			; UObject::SetOwner, COMDAT

; 33   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0ED810FD_UObject@cpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 34   : 	m_owner = owner;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR owner$[rbp]
  00028	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 35   : }

  0002c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00030	5d		 pop	 rbp
  00031	c3		 ret	 0
?SetOwner@UObject@@UEAAXPEAV1@@Z ENDP			; UObject::SetOwner
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Engine\Classes\UObject\UObject.cpp
;	COMDAT ?Destroy@UObject@@UEAAXXZ
_TEXT	SEGMENT
<range>$L0$1 = 0
<begin>$L0$2 = 8
<end>$L0$3 = 16
i$4 = 24
$T5 = 96
tv95 = 104
this$ = 128
?Destroy@UObject@@UEAAXXZ PROC				; UObject::Destroy, COMDAT

; 20   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0ED810FD_UObject@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 21   : 	for (auto& i : m_objects)

  0001e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00025	48 83 c0 10	 add	 rax, 16
  00029	48 89 45 00	 mov	 QWORD PTR <range>$L0$1[rbp], rax
  0002d	48 8d 55 08	 lea	 rdx, QWORD PTR <begin>$L0$2[rbp]
  00031	48 8b 4d 00	 mov	 rcx, QWORD PTR <range>$L0$1[rbp]
  00035	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_begin
  0003a	48 8d 55 10	 lea	 rdx, QWORD PTR <end>$L0$3[rbp]
  0003e	48 8b 4d 00	 mov	 rcx, QWORD PTR <range>$L0$1[rbp]
  00042	e8 00 00 00 00	 call	 ?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_end
  00047	eb 09		 jmp	 SHORT $LN4@Destroy
$LN2@Destroy:
  00049	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  0004d	e8 00 00 00 00	 call	 ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator++
$LN4@Destroy:
  00052	48 8d 55 10	 lea	 rdx, QWORD PTR <end>$L0$3[rbp]
  00056	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  0005a	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator==
  0005f	0f b6 c0	 movzx	 eax, al
  00062	85 c0		 test	 eax, eax
  00064	75 5b		 jne	 SHORT $LN3@Destroy
  00066	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  0006a	e8 00 00 00 00	 call	 ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator*
  0006f	48 89 45 18	 mov	 QWORD PTR i$4[rbp], rax

; 22   : 	{
; 23   : 		if (i)

  00073	48 8b 45 18	 mov	 rax, QWORD PTR i$4[rbp]
  00077	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0007b	74 42		 je	 SHORT $LN5@Destroy

; 24   : 		{
; 25   : 			i->Destroy();

  0007d	48 8b 45 18	 mov	 rax, QWORD PTR i$4[rbp]
  00081	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00084	48 8b 4d 18	 mov	 rcx, QWORD PTR i$4[rbp]
  00088	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	ff 50 10	 call	 QWORD PTR [rax+16]

; 26   : 			delete i;

  00091	48 8b 45 18	 mov	 rax, QWORD PTR i$4[rbp]
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	48 89 45 60	 mov	 QWORD PTR $T5[rbp], rax
  0009c	48 83 7d 60 00	 cmp	 QWORD PTR $T5[rbp], 0
  000a1	74 14		 je	 SHORT $LN7@Destroy
  000a3	ba 01 00 00 00	 mov	 edx, 1
  000a8	48 8b 4d 60	 mov	 rcx, QWORD PTR $T5[rbp]
  000ac	e8 00 00 00 00	 call	 ??_GUObject@@QEAAPEAXI@Z
  000b1	48 89 45 68	 mov	 QWORD PTR tv95[rbp], rax
  000b5	eb 08		 jmp	 SHORT $LN8@Destroy
$LN7@Destroy:
  000b7	48 c7 45 68 00
	00 00 00	 mov	 QWORD PTR tv95[rbp], 0
$LN8@Destroy:
$LN5@Destroy:

; 27   : 		}
; 28   : 	}

  000bf	eb 88		 jmp	 SHORT $LN2@Destroy
$LN3@Destroy:

; 29   : 	m_objects.clear();

  000c1	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c8	48 83 c0 10	 add	 rax, 16
  000cc	48 8b c8	 mov	 rcx, rax
  000cf	e8 00 00 00 00	 call	 ?clear@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAAXXZ ; std::list<UObject *,std::allocator<UObject *> >::clear

; 30   : }

  000d4	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000d8	5d		 pop	 rbp
  000d9	c3		 ret	 0
?Destroy@UObject@@UEAAXXZ ENDP				; UObject::Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Engine\Classes\UObject\UObject.cpp
;	COMDAT ?Update@UObject@@UEAAXM@Z
_TEXT	SEGMENT
<range>$L0$1 = 0
<begin>$L0$2 = 8
<end>$L0$3 = 16
i$4 = 24
tv92 = 96
tv94 = 104
this$ = 128
DeltaTime$ = 136
?Update@UObject@@UEAAXM@Z PROC				; UObject::Update, COMDAT

; 12   : {

$LN6:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	55		 push	 rbp
  0000c	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0ED810FD_UObject@cpp
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 13   : 	for (auto& i : m_objects)

  00024	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 83 c0 10	 add	 rax, 16
  0002f	48 89 45 00	 mov	 QWORD PTR <range>$L0$1[rbp], rax
  00033	48 8d 55 08	 lea	 rdx, QWORD PTR <begin>$L0$2[rbp]
  00037	48 8b 4d 00	 mov	 rcx, QWORD PTR <range>$L0$1[rbp]
  0003b	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_begin
  00040	48 8d 55 10	 lea	 rdx, QWORD PTR <end>$L0$3[rbp]
  00044	48 8b 4d 00	 mov	 rcx, QWORD PTR <range>$L0$1[rbp]
  00048	e8 00 00 00 00	 call	 ?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_end
  0004d	eb 09		 jmp	 SHORT $LN4@Update
$LN2@Update:
  0004f	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  00053	e8 00 00 00 00	 call	 ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator++
$LN4@Update:
  00058	48 8d 55 10	 lea	 rdx, QWORD PTR <end>$L0$3[rbp]
  0005c	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  00060	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator==
  00065	0f b6 c0	 movzx	 eax, al
  00068	85 c0		 test	 eax, eax
  0006a	75 3b		 jne	 SHORT $LN3@Update
  0006c	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  00070	e8 00 00 00 00	 call	 ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator*
  00075	48 89 45 18	 mov	 QWORD PTR i$4[rbp], rax

; 14   : 	{
; 15   : 		i->Update(DeltaTime);

  00079	48 8b 45 18	 mov	 rax, QWORD PTR i$4[rbp]
  0007d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00080	48 89 45 60	 mov	 QWORD PTR tv92[rbp], rax
  00084	48 8b 45 18	 mov	 rax, QWORD PTR i$4[rbp]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00092	48 89 45 68	 mov	 QWORD PTR tv94[rbp], rax
  00096	f3 0f 10 8d 88
	00 00 00	 movss	 xmm1, DWORD PTR DeltaTime$[rbp]
  0009e	48 8b 4d 60	 mov	 rcx, QWORD PTR tv92[rbp]
  000a2	ff 55 68	 call	 QWORD PTR tv94[rbp]

; 16   : 	}

  000a5	eb a8		 jmp	 SHORT $LN2@Update
$LN3@Update:

; 17   : }

  000a7	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000ab	5d		 pop	 rbp
  000ac	c3		 ret	 0
?Update@UObject@@UEAAXM@Z ENDP				; UObject::Update
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Engine\Classes\UObject\UObject.cpp
;	COMDAT ?BeginPlay@UObject@@UEAAXXZ
_TEXT	SEGMENT
<range>$L0$1 = 0
<begin>$L0$2 = 8
<end>$L0$3 = 16
i$4 = 24
this$ = 112
?BeginPlay@UObject@@UEAAXXZ PROC			; UObject::BeginPlay, COMDAT

; 4    : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0ED810FD_UObject@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5    : 	for (auto& i : m_objects)

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 83 c0 10	 add	 rax, 16
  00026	48 89 45 00	 mov	 QWORD PTR <range>$L0$1[rbp], rax
  0002a	48 8d 55 08	 lea	 rdx, QWORD PTR <begin>$L0$2[rbp]
  0002e	48 8b 4d 00	 mov	 rcx, QWORD PTR <range>$L0$1[rbp]
  00032	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_begin
  00037	48 8d 55 10	 lea	 rdx, QWORD PTR <end>$L0$3[rbp]
  0003b	48 8b 4d 00	 mov	 rcx, QWORD PTR <range>$L0$1[rbp]
  0003f	e8 00 00 00 00	 call	 ?_Unchecked_end@?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@2@XZ ; std::list<UObject *,std::allocator<UObject *> >::_Unchecked_end
  00044	eb 09		 jmp	 SHORT $LN4@BeginPlay
$LN2@BeginPlay:
  00046	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  0004a	e8 00 00 00 00	 call	 ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator++
$LN4@BeginPlay:
  0004f	48 8d 55 10	 lea	 rdx, QWORD PTR <end>$L0$3[rbp]
  00053	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  00057	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<UObject *> >,std::_Iterator_base0>::operator==
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	85 c0		 test	 eax, eax
  00061	75 22		 jne	 SHORT $LN3@BeginPlay
  00063	48 8d 4d 08	 lea	 rcx, QWORD PTR <begin>$L0$2[rbp]
  00067	e8 00 00 00 00	 call	 ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PEAVUObject@@@std@@@std@@@std@@QEBAAEAPEAVUObject@@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UObject *> > >::operator*
  0006c	48 89 45 18	 mov	 QWORD PTR i$4[rbp], rax

; 6    : 	{
; 7    : 		i->BeginPlay();

  00070	48 8b 45 18	 mov	 rax, QWORD PTR i$4[rbp]
  00074	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00077	48 8b 4d 18	 mov	 rcx, QWORD PTR i$4[rbp]
  0007b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00081	ff 10		 call	 QWORD PTR [rax]

; 8    : 	}

  00083	eb c1		 jmp	 SHORT $LN2@BeginPlay
$LN3@BeginPlay:

; 9    : }

  00085	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00089	5d		 pop	 rbp
  0008a	c3		 ret	 0
?BeginPlay@UObject@@UEAAXXZ ENDP			; UObject::BeginPlay
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Engine\Classes\UObject\UObject.h
;	COMDAT ??1UObject@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1UObject@@QEAA@XZ PROC				; UObject::~UObject, COMDAT

; 23   : 	~UObject() { Destroy(); };

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B9FFAD7A_UObject@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7UObject@@6B@
  00026	48 89 08	 mov	 QWORD PTR [rax], rcx
  00029	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002d	e8 00 00 00 00	 call	 ?Destroy@UObject@@UEAAXXZ ; UObject::Destroy
  00032	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00036	48 83 c0 10	 add	 rax, 16
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ??1?$list@PEAVUObject@@V?$allocator@PEAVUObject@@@std@@@std@@QEAA@XZ ; std::list<UObject *,std::allocator<UObject *> >::~list<UObject *,std::allocator<UObject *> >
  00042	90		 npad	 1
  00043	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
??1UObject@@QEAA@XZ ENDP				; UObject::~UObject
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT

; 1229 :     void _Orphan_all_locked_v3() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1230 :         _Lockit _Lock(_LOCK_DEBUG);

  0001b	ba 03 00 00 00	 mov	 edx, 3
  00020	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1231 :         _Orphan_all_unlocked_v3();

  0002a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1232 :     }

  00033	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$1 = 0
$T2 = 72
this$ = 96
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT

; 1369 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1370 :     if (!_Myproxy) { // no proxy, already done

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	75 02		 jne	 SHORT $LN5@Orphan_all

; 1371 :         return;

  00025	eb 45		 jmp	 SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1372 :     }
; 1373 : 
; 1374 :     // proxy allocated, drain it
; 1375 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

  00027	48 c7 45 48 00
	00 00 00	 mov	 QWORD PTR $T2[rbp], 0
  0002f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 83 c0 08	 add	 rax, 8
  0003a	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
  00046	48 89 45 00	 mov	 QWORD PTR _Pnext$1[rbp], rax
  0004a	eb 0c		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0004c	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00050	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00054	48 89 45 00	 mov	 QWORD PTR _Pnext$1[rbp], rax
$LN4@Orphan_all:
  00058	48 83 7d 00 00	 cmp	 QWORD PTR _Pnext$1[rbp], 0
  0005d	74 0d		 je	 SHORT $LN1@Orphan_all

; 1376 :         _Pnext->_Myproxy = nullptr;

  0005f	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00063	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1377 :     }

  0006a	eb e0		 jmp	 SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 1378 : }

  0006c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 1380 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1381 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1382 : #if _HAS_CXX20
; 1383 :     if (_STD is_constant_evaluated()) {

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 0b		 je	 SHORT $LN2@Orphan_all

; 1384 :         _Orphan_all_unlocked_v3();

  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1385 :     } else

  00030	eb 09		 jmp	 SHORT $LN3@Orphan_all
$LN2@Orphan_all:

; 1386 : #endif // _HAS_CXX20
; 1387 :     {
; 1388 :         _Orphan_all_locked_v3();

  00032	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00036	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN3@Orphan_all:

; 1389 :     }
; 1390 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1391 : }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1179 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr_user$ = 0
_Ptr_container$ = 8
_Min_back_shift$ = 16
_Back_shift$ = 24
_Ptr$ = 112
_Bytes$ = 120
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 154  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 155  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 156  :     _Bytes += _Non_user_size;

  00023	48 8b 45 78	 mov	 rax, QWORD PTR _Bytes$[rbp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  0002e	48 8b 4d 78	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00032	48 89 01	 mov	 QWORD PTR [rcx], rax

; 157  : 
; 158  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00035	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 45 00	 mov	 QWORD PTR _Ptr_user$[rbp], rax

; 159  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00040	b8 08 00 00 00	 mov	 eax, 8
  00045	48 6b c0 ff	 imul	 rax, rax, -1
  00049	48 8b 4d 00	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  0004d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00051	48 89 45 08	 mov	 QWORD PTR _Ptr_container$[rbp], rax
$LN4@Adjust_man:

; 160  : 
; 161  :     // If the following asserts, it likely means that we are performing
; 162  :     // an aligned delete on memory coming from an unaligned allocation.
; 163  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00055	b8 08 00 00 00	 mov	 eax, 8
  0005a	48 6b c0 fe	 imul	 rax, rax, -2
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  00062	48 ba fa fa fa
	fa fa fa fa fa	 mov	 rdx, -361700864190383366 ; fafafafafafafafaH
  0006c	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00070	75 02		 jne	 SHORT $LN14@Adjust_man
  00072	eb 77		 jmp	 SHORT $LN15@Adjust_man
$LN14@Adjust_man:
$LN7@Adjust_man:
  00074	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  0007a	83 c0 09	 add	 eax, 9
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  00084	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00090	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00095	45 33 c9	 xor	 r9d, r9d
  00098	44 8b c0	 mov	 r8d, eax
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  000a2	b9 02 00 00 00	 mov	 ecx, 2
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 03		 jne	 SHORT $LN19@Adjust_man
  000b2	cc		 int	 3
  000b3	33 c0		 xor	 eax, eax
$LN19@Adjust_man:
  000b5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  000bb	83 c0 09	 add	 eax, 9
  000be	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000c7	44 8b c8	 mov	 r9d, eax
  000ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000e5	33 c0		 xor	 eax, eax
  000e7	85 c0		 test	 eax, eax
  000e9	75 89		 jne	 SHORT $LN7@Adjust_man
$LN15@Adjust_man:
  000eb	33 c0		 xor	 eax, eax
  000ed	85 c0		 test	 eax, eax
  000ef	0f 85 60 ff ff
	ff		 jne	 $LN4@Adjust_man

; 164  : 
; 165  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 166  :     // in range [_Min_back_shift, _Non_user_size]
; 167  : #ifdef _DEBUG
; 168  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000f5	48 c7 45 10 10
	00 00 00	 mov	 QWORD PTR _Min_back_shift$[rbp], 16

; 169  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 170  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 171  : #endif // _DEBUG
; 172  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fd	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00101	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  00105	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00108	48 2b c1	 sub	 rax, rcx
  0010b	48 89 45 18	 mov	 QWORD PTR _Back_shift$[rbp], rax
$LN10@Adjust_man:

; 173  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010f	48 83 7d 18 10	 cmp	 QWORD PTR _Back_shift$[rbp], 16
  00114	72 09		 jb	 SHORT $LN16@Adjust_man
  00116	48 83 7d 18 2f	 cmp	 QWORD PTR _Back_shift$[rbp], 47 ; 0000002fH
  0011b	77 02		 ja	 SHORT $LN16@Adjust_man
  0011d	eb 77		 jmp	 SHORT $LN17@Adjust_man
$LN16@Adjust_man:
$LN13@Adjust_man:
  0011f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00125	83 c0 13	 add	 eax, 19
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  0012f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0013b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00140	45 33 c9	 xor	 r9d, r9d
  00143	44 8b c0	 mov	 r8d, eax
  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0014d	b9 02 00 00 00	 mov	 ecx, 2
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00158	83 f8 01	 cmp	 eax, 1
  0015b	75 03		 jne	 SHORT $LN20@Adjust_man
  0015d	cc		 int	 3
  0015e	33 c0		 xor	 eax, eax
$LN20@Adjust_man:
  00160	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00166	83 c0 13	 add	 eax, 19
  00169	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00172	44 8b c8	 mov	 r9d, eax
  00175	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00190	33 c0		 xor	 eax, eax
  00192	85 c0		 test	 eax, eax
  00194	75 89		 jne	 SHORT $LN13@Adjust_man
$LN17@Adjust_man:
  00196	33 c0		 xor	 eax, eax
  00198	85 c0		 test	 eax, eax
  0019a	0f 85 6f ff ff
	ff		 jne	 $LN10@Adjust_man

; 174  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001a0	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  001a4	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  001a8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 175  : }

  001ab	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  001af	5d		 pop	 rbp
  001b0	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 178  : _EXPORT_STD _NODISCARD constexpr bool is_constant_evaluated() noexcept {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9A2CA802_xtr1common
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 179  :     return __builtin_is_constant_evaluated();

  00017	32 c0		 xor	 al, al

; 180  : }

  00019	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
END
