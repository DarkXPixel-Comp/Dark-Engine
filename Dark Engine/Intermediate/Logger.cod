; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33030.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?inst@Logger@@0PEAV1@EA				; Logger::inst
_BSS	SEGMENT
?inst@Logger@@0PEAV1@EA DQ 01H DUP (?)			; Logger::inst
_BSS	ENDS
msvcjmc	SEGMENT
__B51A3A23_Core@h DB 01H
__4A250794_concurrencysal@h DB 01H
__64794009_sal@h DB 01H
__A3E7195B_vadefs@h DB 01H
__978626E5_vcruntime@h DB 01H
__735B63F8_xkeycheck@h DB 01H
__142C9C9C_yvals_core@h DB 01H
__1B0272D9_corecrt@h DB 01H
__84C50014_vcruntime_new@h DB 01H
__7A6EC116_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__E5B2708F_crtdefs@h DB 01H
__61229A4B_use_ansi@h DB 01H
__8C2D0B1D_yvals@h DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__4CF83D73_cstdio DB 01H
__61CC25A1_errno@h DB 01H
__4CB5F942_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__76FF1542_cstring DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__8ECB7138_corecrt_share@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__D673EB20_cwchar DB 01H
__9A2CA802_xtr1common DB 01H
__95B36E16_iosfwd DB 01H
__DBEA773D_stdint@h DB 01H
__87335CDF_cstdint DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__659C5902_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__3A6DBDA2_cstdlib DB 01H
__B9985323_float@h DB 01H
__3FBCF6F4_cfloat DB 01H
__BE829F50_climits DB 01H
__51ADDFC3_intrin0@inl@h DB 01H
__FC9FC984_intrin0@h DB 01H
__595ABB90_limits DB 01H
__9FA6670F_cstddef DB 01H
__3DF2A533_type_traits DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__35BB339F_eh@h DB 01H
__7280C444_vcruntime_exception@h DB 01H
__2DED1E19_exception DB 01H
__A5D71DBC_new DB 01H
__27E192CF_xatomic@h DB 01H
__50E371A7_initializer_list DB 01H
__339AE60A_concepts DB 01H
__C3788713_compare DB 01H
__0D603829_utility DB 01H
__874288EA___msvc_iter_core@hpp DB 01H
__B7320FC0_xutility DB 01H
__A0E057FF_tuple DB 01H
__67F55BEA_xmemory DB 01H
__A0A2F5C0_xpolymorphic_allocator@h DB 01H
__C671E263___msvc_sanitizer_annotate_container@hpp DB 01H
__1326DD76_xstring DB 01H
__1EC467ED_ctype@h DB 01H
__4333DAD4_cctype DB 01H
__91273182_string DB 01H
__F3EA4CCC___msvc_bit_utils@hpp DB 01H
__14F7CB70_vector DB 01H
__FBEF5BAE_Array@h DB 01H
__9024636E_DarkString@h DB 01H
__0A9237D2_time@h DB 01H
__C070D2B6_ctime DB 01H
__52656974_list DB 01H
__F7972D0B_share@h DB 01H
__E9739B8C___msvc_system_error_abi@hpp DB 01H
__D1D94988_cerrno DB 01H
__A4A32444_stdexcept DB 01H
__57B442CC_xcall_once@h DB 01H
__24B81E12_xerrc@h DB 01H
__4F9CF3B8_xatomic_wait@h DB 01H
__01F6EC81_xtimec@h DB 01H
__006CADF8_xthreads@h DB 01H
__326FE752_atomic DB 01H
__E8E950EC_system_error DB 01H
__93AC6E75_vcruntime_typeinfo@h DB 01H
__C7EDFCD9_typeinfo DB 01H
__E5F4B71E_memory DB 01H
__C9B1E011_xfacet DB 01H
__24FAA3FC___msvc_xlocinfo_types@hpp DB 01H
__791C33B7_locale@h DB 01H
__A9C16173_clocale DB 01H
__D8641F11_xlocinfo DB 01H
__CC18A947_xlocale DB 01H
__E1816802_xiosbase DB 01H
__A6039CF8_streambuf DB 01H
__C0945C43___msvc_filebuf@hpp DB 01H
__06C34EBE_cmath DB 01H
__A69EB880_iterator DB 01H
__529FCF50_xlocnum DB 01H
__5D1A27AA_ios DB 01H
__DF087383_ostream DB 01H
__BCD846B9_istream DB 01H
__4A903650_fstream DB 01H
__6A70D710_ratio DB 01H
__E71D1BFE___msvc_chrono@hpp DB 01H
__F491F32A_vcruntime_startup@h DB 01H
__005E73E1_corecrt_startup@h DB 01H
__8B12B2C4_process@h DB 01H
__57ED3434_stop_token DB 01H
__3EB9CFA8_thread DB 01H
__78DDDD40_mutex DB 01H
__0ED14FEE_winpackagefamily@h DB 01H
__F92EF742_winapifamily@h DB 01H
__22E515EB_sdkddkver@h DB 01H
__73193115_excpt@h DB 01H
__EF35C9F2_stdarg@h DB 01H
__29F49F40_specstrings_undef@h DB 01H
__D0F42932_specstrings_strict@h DB 01H
__F00405FD_sdv_driverspecs@h DB 01H
__173E09CA_driverspecs@h DB 01H
__9A452361_specstrings@h DB 01H
__98517906_kernelspecs@h DB 01H
__D3497022_basetsd@h DB 01H
__7FCB5136_guiddef@h DB 01H
__FF8A9E11_pshpack4@h DB 01H
__D5438902_poppack@h DB 01H
__FB07E2A3_pshpack2@h DB 01H
__F6906775_pshpack8@h DB 01H
__F9415CFA_pshpack1@h DB 01H
__E58C6F1C_apiset@h DB 01H
__A5C52262_ktmtypes@h DB 01H
__FBBA8F9D_winnt@h DB 01H
__A32D3D2C_minwindef@h DB 01H
__7D798299_windef@h DB 01H
__9AE108E9_apisetcconv@h DB 01H
__9CE53D2C_minwinbase@h DB 01H
__5D0AA210_apiquery2@h DB 01H
__4DD4E726_processenv@h DB 01H
__3575CC96_fileapi@h DB 01H
__8EA220E6_fileapifromapp@h DB 01H
__BF9B31FE_debugapi@h DB 01H
__C3AFE134_utilapiset@h DB 01H
__76F69E51_handleapi@h DB 01H
__7E63D784_errhandlingapi@h DB 01H
__FFA7003C_fibersapi@h DB 01H
__8971CECF_namedpipeapi@h DB 01H
__46C9D8A6_profileapi@h DB 01H
__98D4F0A3_heapapi@h DB 01H
__50EF2A88_ioapiset@h DB 01H
__92EA1464_synchapi@h DB 01H
__A53D8AED_interlockedapi@h DB 01H
__B506CAAF_processthreadsapi@h DB 01H
__FF735694_sysinfoapi@h DB 01H
__29589789_memoryapi@h DB 01H
__E9C7A663_enclaveapi@h DB 01H
__D035F9F7_threadpoollegacyapiset@h DB 01H
__C899130C_threadpoolapiset@h DB 01H
__E0441EE7_jobapi@h DB 01H
__CEF86838_jobapi2@h DB 01H
__35AC6B9A_wow64apiset@h DB 01H
__C8AE41A5_libloaderapi@h DB 01H
__CC9E232D_securitybaseapi@h DB 01H
__C9D0C9B8_namespaceapi@h DB 01H
__30FF9CAD_systemtopologyapi@h DB 01H
__4D358795_processtopologyapi@h DB 01H
__40446D10_securityappcontainer@h DB 01H
__3A952EDF_realtimeapiset@h DB 01H
__F4865F4B_winerror@h DB 01H
__53C1BD93_timezoneapi@h DB 01H
__1FFBEDBF_winbase@h DB 01H
__43D3FA34_wingdi@h DB 01H
__D24A7391_tvout@h DB 01H
__7713A6C8_winuser@h DB 01H
__0B345F71_datetimeapi@h DB 01H
__9AC6960C_winnls@h DB 01H
__973A40A8_stringapiset@h DB 01H
__CC46FEE2_wincontypes@h DB 01H
__97D70BE1_consoleapi@h DB 01H
__27EC5E18_consoleapi2@h DB 01H
__262E342F_consoleapi3@h DB 01H
__641DCD70_wincon@h DB 01H
__5A96C7A7_verrsrc@h DB 01H
__B69C6FF2_winver@h DB 01H
__7AEB8C37_reason@h DB 01H
__59F1A8A9_winreg@h DB 01H
__EE0E2B7F_wnnc@h DB 01H
__DCDB7054_winnetwk@h DB 01H
__EDC72EEB_cderr@h DB 01H
__95F9199D_dde@h DB 01H
__66427627_ddeml@h DB 01H
__957C29A0_dlgs@h DB 01H
__12EA15AF_lzexpand@h DB 01H
__62131F15_mmsyscom@h DB 01H
__47E68D49_mciapi@h DB 01H
__5D7DD356_mmiscapi@h DB 01H
__7223D2EF_mmiscapi2@h DB 01H
__A330DBB3_playsoundapi@h DB 01H
__601B366F_mmeapi@h DB 01H
__1134ADD5_timeapi@h DB 01H
__93F2265A_joystickapi@h DB 01H
__DF6EB4E3_mmsystem@h DB 01H
__BD641FCB_nb30@h DB 01H
__DF8704F0_rpcdcep@h DB 01H
__5C6CA7BB_rpcdce@h DB 01H
__853533C4_rpcnsi@h DB 01H
__2D2406C3_rpcnterr@h DB 01H
__64521D71_rpcasync@h DB 01H
__AADCBA08_rpc@h DB 01H
__19E26CFF_shellapi@h DB 01H
__1E9F31D3_winperf@h DB 01H
__832A4112_inaddr@h DB 01H
__32C6F875_winsock@h DB 01H
__7953A3F8_bcrypt@h DB 01H
__E4169492_ncrypt@h DB 01H
__AF3DDDC3_dpapi@h DB 01H
__D1E23BF2_wincrypt@h DB 01H
__82AB4779_winefs@h DB 01H
__1FE431C9_rpcnsip@h DB 01H
__2B741F2D_rpcsal@h DB 01H
__92623256_rpcndr@h DB 01H
__9C18532E_wtypesbase@h DB 01H
__EA2E1D6D_wtypes@h DB 01H
__7DDD9F45_winioctl@h DB 01H
__E550A843_winsmcrd@h DB 01H
__9809C1BA_winscard@h DB 01H
__EA174FA4_prsht@h DB 01H
__0E1BD114_winspool@h DB 01H
__30B1AFDA_unknwnbase@h DB 01H
__328C1996_objidlbase@h DB 01H
__C4E06B6A_cguid@h DB 01H
__434718C5_combaseapi@h DB 01H
__DE6FDEF1_unknwn@h DB 01H
__CCE0BACC_objidl@h DB 01H
__8C7011E5_oaidl@h DB 01H
__2E0B7863_propidlbase@h DB 01H
__BF4CF2EC_coml2api@h DB 01H
__6D897344_oleidl@h DB 01H
__1129FC2C_servprov@h DB 01H
__757952E4_msxml@h DB 01H
__B1191D53_urlmon@h DB 01H
__404D1A47_propidl@h DB 01H
__A1C63593_objbase@h DB 01H
__C1B0A9CB_oleauto@h DB 01H
__24EAF61F_ole2@h DB 01H
__2B1843DA_commdlg@h DB 01H
__81DDEDE3_stralign@h DB 01H
__2134D1B4_winsvc@h DB 01H
__11C07376_mcx@h DB 01H
__577CE3E7_ime_cmodes@h DB 01H
__1E72C31E_imm@h DB 01H
__63AA7AF5_Windows@h DB 01H
__92B9F28F_CommandLine@h DB 01H
__CE362511_Logger@hpp DB 01H
__C7215CCD_algorithm DB 01H
__103905FF_Application@h DB 01H
__C263CAF0_Logger@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??Mstd@@YA_NUpartial_ordering@0@U_Literal_zero@0@@Z ; std::operator<
PUBLIC	??Mstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ; std::operator<
PUBLIC	??Ostd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ; std::operator>
PUBLIC	??Nstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ; std::operator<=
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QEAA@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
PUBLIC	??0_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QEAA@AEBU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_unlocked
PUBLIC	?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_locked
PUBLIC	?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked
PUBLIC	?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
PUBLIC	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
PUBLIC	?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
PUBLIC	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IEAA@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z	; std::_Char_traits<wchar_t,unsigned short>::assign
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z	; std::_Narrow_char_traits<char,int>::not_eof
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
PUBLIC	?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
PUBLIC	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
PUBLIC	??0bad_cast@std@@QEAA@XZ			; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UEAA@XZ			; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QEAA@AEBV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UEAAPEAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1locale@std@@QEAA@XZ				; std::locale::~locale
PUBLIC	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z	; std::locale::_Getfacet
PUBLIC	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
PUBLIC	??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z	; std::_Ungetc<char>
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
PUBLIC	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,0>
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
PUBLIC	??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??Y?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAAAEAV012@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::operator+=
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
PUBLIC	?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,0>
PUBLIC	??$?0_JU?$ratio@$00$00@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,0>
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
PUBLIC	?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
PUBLIC	??1thread@std@@QEAA@XZ				; std::thread::~thread
PUBLIC	?joinable@thread@std@@QEBA_NXZ			; std::thread::joinable
PUBLIC	?detach@thread@std@@QEAAXXZ			; std::thread::detach
PUBLIC	??0log_@@QEAA@XZ				; log_::log_
PUBLIC	??1log_@@QEAA@XZ				; log_::~log_
PUBLIC	??0log_@@QEAA@AEBU0@@Z				; log_::log_
PUBLIC	??4log_@@QEAAAEAU0@AEBU0@@Z			; log_::operator=
PUBLIC	??_Glog_@@QEAAPEAXI@Z				; log_::`scalar deleting destructor'
PUBLIC	?logging@@YAXPEAVLogger@@@Z			; logging
PUBLIC	?record@@YAXAEAUlog_@@@Z			; record
PUBLIC	??0Logger@@QEAA@XZ				; Logger::Logger
PUBLIC	?Initialize@Logger@@SAX_K@Z			; Logger::Initialize
PUBLIC	?Exit@Logger@@SAXXZ				; Logger::Exit
PUBLIC	?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z ; Logger::log
PUBLIC	?logF@Logger@@SAXPEBDZZ				; Logger::logF
PUBLIC	?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ ; Logger::logF
PUBLIC	?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z ; Logger::exLog
PUBLIC	?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z ; Logger::urgLog
PUBLIC	?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z ; Logger::log
PUBLIC	?wait@Logger@@SAXXZ				; Logger::wait
PUBLIC	??0?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_List_node<log_,void *> >::allocator<std::_List_node<log_,void *> >
PUBLIC	?deallocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ; std::allocator<std::_List_node<log_,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ; std::allocator<std::_List_node<log_,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@QEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::select_on_container_copy_construction
PUBLIC	??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ ; std::list<log_,std::allocator<log_> >::list<log_,std::allocator<log_> >
PUBLIC	??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@AEBV01@@Z ; std::list<log_,std::allocator<log_> >::list<log_,std::allocator<log_> >
PUBLIC	??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ ; std::list<log_,std::allocator<log_> >::~list<log_,std::allocator<log_> >
PUBLIC	??4?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::list<log_,std::allocator<log_> >::operator=
PUBLIC	?begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::begin
PUBLIC	?end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::end
PUBLIC	?_Unchecked_begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<log_,std::allocator<log_> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<log_,std::allocator<log_> >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@PEAU?$_List_node@Ulog_@@PEAX@2@@Z ; std::list<log_,std::allocator<log_> >::_Make_iter
PUBLIC	?max_size@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_KXZ ; std::list<log_,std::allocator<log_> >::max_size
PUBLIC	?empty@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_NXZ ; std::list<log_,std::allocator<log_> >::empty
PUBLIC	?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z ; std::list<log_,std::allocator<log_> >::push_back
PUBLIC	?erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@@Z ; std::list<log_,std::allocator<log_> >::erase
PUBLIC	?_Unchecked_erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@QEAU32@@Z ; std::list<log_,std::allocator<log_> >::_Unchecked_erase
PUBLIC	?clear@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXXZ ; std::list<log_,std::allocator<log_> >::clear
PUBLIC	?_Tidy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ ; std::list<log_,std::allocator<log_> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ ; std::list<log_,std::allocator<log_> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
PUBLIC	?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<log_> >::_List_val<std::_List_simple_types<log_> >
PUBLIC	?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXPEAU?$_List_node@Ulog_@@PEAX@2@@Z ; std::_List_val<std::_List_simple_types<log_> >::_Orphan_ptr2
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<log_> >::_Orphan_non_end
PUBLIC	?_Unlinknode@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@@Z ; std::_List_val<std::_List_simple_types<log_> >::_Unlinknode
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Get_first
PUBLIC	??1Logger@@QEAA@XZ				; Logger::~Logger
PUBLIC	??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@thread@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z ; std::thread::thread<void (__cdecl&)(Logger *),Logger * &,0>
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>
PUBLIC	??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEBUlog_@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator*
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator==
PUBLIC	??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::~_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@AEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEAUlog_@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator*
PUBLIC	??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::~_List_iterator<std::_List_val<std::_List_simple_types<log_> > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >
PUBLIC	??$?0H$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEBH@Z ; std::chrono::duration<__int64,std::ratio<1,1000000> >::duration<__int64,std::ratio<1,1000000> ><int,0>
PUBLIC	??$sleep_for@_JU?$ratio@$00$0PECEA@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000000> >
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	?_Verify_range@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; std::_Verify_range
PUBLIC	??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped
PUBLIC	??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>
PUBLIC	??$?0H$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEBH@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,0>
PUBLIC	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Free_non_head<std::allocator<std::_List_node<log_,void *> > >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<log_> > >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Freenode<std::allocator<std::_List_node<log_,void *> > >
PUBLIC	??$_Emplace@AEBUlog_@@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@QEAU21@AEBUlog_@@@Z ; std::list<log_,std::allocator<log_> >::_Emplace<log_ const &>
PUBLIC	??$addressof@$$CBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@@std@@YAPEBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@0@AEBV10@@Z ; std::addressof<std::list<log_,std::allocator<log_> > const >
PUBLIC	??$_Pocca@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<std::_List_node<log_,void *> > >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator++
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator==
PUBLIC	??$assign@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@$0A@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@0@Z ; std::list<log_,std::allocator<log_> >::assign<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,0>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<log_,void *> >
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1><std::allocator<std::_List_node<log_,void *> > >
PUBLIC	??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::list<log_,std::allocator<log_> >::_Construct_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1><>
PUBLIC	??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z	; std::_Refancy<wchar_t *,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$?0_W@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><wchar_t>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
PUBLIC	??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Freenode0<std::allocator<std::_List_node<log_,void *> > >
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<log_> > const >
PUBLIC	??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
PUBLIC	??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z		; std::_Get_size_of_n<80>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z		; std::_Get_size_of_n<16>
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z	; std::construct_at<char,char const &,0>
PUBLIC	??$addressof@_W@std@@YAPEA_WAEA_W@Z		; std::addressof<wchar_t>
PUBLIC	??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z ; std::construct_at<wchar_t,wchar_t const &,0>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
PUBLIC	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z		; std::end<char,21>
PUBLIC	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z	; std::_UIntegral_to_buff<char,unsigned int>
PUBLIC	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
PUBLIC	??$_Verify_range@D@std@@YAXQEBD0@Z		; std::_Verify_range<char>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z ; std::thread::_Start<void (__cdecl&)(Logger *),Logger * &>
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$_To_absolute_time@_JU?$ratio@$00$0PECEA@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@0@@Z ; std::_To_absolute_time<__int64,std::ratio<1,1000000> >
PUBLIC	??$?__M_JU?$ratio@$00$0PECEA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@0@Z ; std::chrono::operator<=><__int64,std::ratio<1,1000000>,__int64,std::ratio<1,1000000> >
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0PECEA@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000> >
PUBLIC	??$?__M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ; std::chrono::operator<=><__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<=><std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?0_JU?$ratio@$00$0PECEA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000>,0>
PUBLIC	??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
PUBLIC	??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &>
PUBLIC	??$distance@PEA_W@std@@YA_JPEA_W0@Z		; std::distance<wchar_t *>
PUBLIC	??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<wchar_t *,wchar_t *,unsigned __int64>
PUBLIC	??$_To_absolute_time@_JU?$ratio@$00$0DOI@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z ; std::_To_absolute_time<__int64,std::ratio<1,1000> >
PUBLIC	??$?__M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z ; std::chrono::operator<=><__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
PUBLIC	??$?0_JU?$ratio@$00$0DOI@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,0>
PUBLIC	??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z	; std::addressof<log_>
PUBLIC	??$destroy@Ulog_@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::destroy<log_>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@QEAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_Transfer_before
PUBLIC	??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > ><log_ const &>
PUBLIC	??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >
PUBLIC	??$_Get_unwrapped@AEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> &>
PUBLIC	??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::list<log_,std::allocator<log_> >::_Assign_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??0?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
PUBLIC	??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
PUBLIC	??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >
PUBLIC	??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_head<std::_List_simple_types<log_> >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<log_,void *> *>
PUBLIC	??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &,0>
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<log_,void *> *>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@$$QEAPEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>
PUBLIC	??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &>
PUBLIC	??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
PUBLIC	??$_Unfancy@$$CB_W@std@@YAPEB_WPEB_W@Z		; std::_Unfancy<wchar_t const >
PUBLIC	??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
PUBLIC	??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z ; std::_Allocators_equal<std::allocator<char> >
PUBLIC	??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z	; std::construct_at<char,0>
PUBLIC	??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>
PUBLIC	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z	; std::_Get_unwrapped<char * &>
PUBLIC	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
PUBLIC	??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$make_unique@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@A6AXPEAVLogger@@@ZAEAPEAV3@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@0@A6AXPEAVLogger@@@ZAEAPEAV2@@Z ; std::make_unique<std::tuple<void (__cdecl*)(Logger *),Logger *>,void (__cdecl&)(Logger *),Logger * &,0>
PUBLIC	??R?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@QEBAXPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ; std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >::operator()
PUBLIC	??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::~unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >
PUBLIC	?get@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEBAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::get
PUBLIC	?release@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1>::_Get_first
PUBLIC	??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(Logger *),Logger *>,0,1>
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0PECEA@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0PECEA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000>,0>
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$_To_timespec64_sys_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAEAU_timespec64@@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ; std::_To_timespec64_sys_10_day_clamped<__int64,std::ratio<1,1000000000> >
PUBLIC	??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,0>
PUBLIC	??$destroy_at@Ulog_@@@std@@YAXQEAUlog_@@@Z	; std::destroy_at<log_>
PUBLIC	??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::construct<log_,log_ const &>
PUBLIC	??$_Attach_at_end@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_at_end<std::_List_simple_types<log_> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEAPEAU10@@Z ; std::exchange<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>
PUBLIC	??$exchange@_K_K@std@@YA_KAEA_K$$QEA_K@Z	; std::exchange<unsigned __int64,unsigned __int64>
PUBLIC	??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &,0>
PUBLIC	??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@$$QEAPEAU10@@Z ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *,0>
PUBLIC	??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &,0>
PUBLIC	??$exchange@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$$T@std@@YAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::tuple<void (__cdecl*)(Logger *),Logger *> *,std::nullptr_t>
PUBLIC	??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<log_,void *> *,std::nullptr_t>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z ; std::tuple<void (__cdecl*)(Logger *),Logger *>::tuple<void (__cdecl*)(Logger *),Logger *><void (__cdecl&)(Logger *),Logger * &,0>
PUBLIC	??$?0U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > ><std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,0>
PUBLIC	??$get@$0A@P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAP6AXPEAVLogger@@@ZAEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z ; std::get<0,void (__cdecl*)(Logger *),Logger *>
PUBLIC	??$get@$00P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAPEAVLogger@@AEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z ; std::get<1,void (__cdecl*)(Logger *),Logger *>
PUBLIC	??$invoke@P6AXPEAVLogger@@@ZPEAV1@$$V@std@@YAX$$QEAP6AXPEAVLogger@@@Z$$QEAPEAV1@@Z ; std::invoke<void (__cdecl*)(Logger *),Logger *>
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?0_JU?$ratio@$00$0JIJGIA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,0>
PUBLIC	??$?__MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA?A_PAEBV?$duration@NU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::operator<=><double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?0NU?$ratio@$00$00@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@NU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,0>
PUBLIC	??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,0>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
PUBLIC	??$construct_at@Ulog_@@AEBU1@$0A@@std@@YAPEAUlog_@@QEAU1@AEBU1@@Z ; std::construct_at<log_,log_ const &,0>
PUBLIC	??$_Attach_before@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@AEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@QEAU21@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_before<std::_List_simple_types<log_> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,0>
PUBLIC	??$?0U_Exact_args_t@std@@A6AXPEAVLogger@@@ZAEAPEAV2@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@U_Exact_args_t@1@A6AXPEAVLogger@@@ZAEAPEAV3@@Z ; std::tuple<void (__cdecl*)(Logger *),Logger *>::tuple<void (__cdecl*)(Logger *),Logger *><std::_Exact_args_t,void (__cdecl&)(Logger *),Logger * &,0>
PUBLIC	??$?0AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1><std::tuple<void (__cdecl*)(Logger *),Logger *> * &>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,0>
PUBLIC	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@NU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,0>
PUBLIC	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
PUBLIC	??$?0U_Exact_args_t@std@@AEAPEAVLogger@@$$V$0A@@?$tuple@PEAVLogger@@@std@@QEAA@U_Exact_args_t@1@AEAPEAVLogger@@@Z ; std::tuple<Logger *>::tuple<Logger *><std::_Exact_args_t,Logger * &,0>
PUBLIC	??$?0A6AXPEAVLogger@@@Z@?$_Tuple_val@P6AXPEAVLogger@@@Z@std@@QEAA@A6AXPEAVLogger@@@Z@Z ; std::_Tuple_val<void (__cdecl*)(Logger *)>::_Tuple_val<void (__cdecl*)(Logger *)><void (__cdecl&)(Logger *)>
PUBLIC	??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0AEAPEAVLogger@@@?$_Tuple_val@PEAVLogger@@@std@@QEAA@AEAPEAVLogger@@@Z ; std::_Tuple_val<Logger *>::_Tuple_val<Logger *><Logger * &>
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	?less@partial_ordering@std@@2U12@B		; std::partial_ordering::less
PUBLIC	?equivalent@partial_ordering@std@@2U12@B	; std::partial_ordering::equivalent
PUBLIC	?greater@partial_ordering@std@@2U12@B		; std::partial_ordering::greater
PUBLIC	?unordered@partial_ordering@std@@2U12@B		; std::partial_ordering::unordered
PUBLIC	?less@strong_ordering@std@@2U12@B		; std::strong_ordering::less
PUBLIC	?equal@strong_ordering@std@@2U12@B		; std::strong_ordering::equal
PUBLIC	?greater@strong_ordering@std@@2U12@B		; std::strong_ordering::greater
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ ; `string'
PUBLIC	??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	_TI2?AVbad_cast@std@@
PUBLIC	_CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
PUBLIC	?l@@3VLogger@@A					; l
PUBLIC	??_C@_0CA@CAEGLMPG@The?5system?5started?5successfully@ ; `string'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_C@_05MIDDFADP@logs?1@			; `string'
PUBLIC	??_C@_04FPOLKAEB@?4log@				; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_02PBFOLPKM@?$FN?5@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL@				; `string'
PUBLIC	??_C@_06EOPONJBP@ERROR?5@			; `string'
PUBLIC	??_C@_08LHCGJDCA@WARNIMG?5@			; `string'
PUBLIC	??_C@_05NBJEAKGO@INFO?5@			; `string'
PUBLIC	??_C@_05LGFKMCHI@NULL?5@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_03NLJIHOMM@?5?9?5@			; `string'
PUBLIC	??_C@_0BM@BALDKKHE@list?5iterators?5incompatible@ ; `string'
PUBLIC	??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1DM@KDLJAKOP@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs@ ; `string'
PUBLIC	??_C@_0CC@KEJJOMBH@list?5erase?5iterator?5outside?5ran@ ; `string'
PUBLIC	??_C@_1EI@FHIDKIBN@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe@ ; `string'
PUBLIC	??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_0DD@MBIHGLJE@cannot?5dereference?5value?9initia@ ; `string'
PUBLIC	??_C@_1GK@NKIMOCIG@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CF@JCBFHMPL@cannot?5dereference?5end?5list?5ite@ ; `string'
PUBLIC	??_C@_1EO@CNEFBDCF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	??_C@_0BP@PFIPNLNI@front?$CI?$CJ?5called?5on?5empty?5string@ ; `string'
PUBLIC	??_C@_1EC@DINNLDHA@?$AA?$CC?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd@ ; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@ ; `string'
PUBLIC	??_C@_1COI@GKKHJOON@?$AA?$CC?$AAY?$AAo?$AAu?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn@ ; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ ; `string'
PUBLIC	??_C@_0DI@FIGNHEDK@string?5iterators?5in?5range?5are?5f@ ; `string'
PUBLIC	??_C@_1HE@MFNJODIC@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_C@_0CB@KDGGCAAF@string?5iterator?5range?5transpose@ ; `string'
PUBLIC	??_C@_1EG@NKDFABAL@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@412a5e0000000000
PUBLIC	__real@41cdcd6500000000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	__imp__invalid_parameter:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__imp__get_stream_buffer_pointers:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	__imp_fgetpos:PROC
EXTRN	__imp_fputc:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_fsetpos:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp__lock_file:PROC
EXTRN	__imp__unlock_file:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	?uncaught_exceptions@std@@YAHXZ:PROC		; std::uncaught_exceptions
EXTRN	__imp_terminate:PROC
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	__imp__localtime64_s:PROC
EXTRN	__imp__time64:PROC
EXTRN	_Xtime_get_ticks:PROC
EXTRN	_Query_perf_counter:PROC
EXTRN	_Query_perf_frequency:PROC
EXTRN	_Thrd_detach:PROC
EXTRN	_Thrd_sleep:PROC
EXTRN	_Cnd_do_broadcast_at_thread_exit:PROC
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
EXTRN	??_Ebad_cast@std@@UEAAPEAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_??Bid@locale@std@@QEAA_KXZ:PROC
EXTRN	?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	__imp_?always_noconv@codecvt_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAPEAD0PEAH001@Z:PROC
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC
EXTRN	?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z:PROC	; std::_Fiopen
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp__beginthreadex:PROC
EXTRN	?Prints@CommandConsole@@SAXPEBDZZ:PROC		; CommandConsole::Prints
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	_CxxThrowException:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?l@@3VLogger@@A DB 028H DUP (?)				; l
_BSS	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??2@YAPEAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??2@YAPEAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_constant_evaluated@std@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?is_constant_evaluated@std@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max@?$numeric_limits@_J@std@@SA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?max@?$numeric_limits@_J@std@@SA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Mstd@@YA_NUpartial_ordering@0@U_Literal_zero@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$??Mstd@@YA_NUpartial_ordering@0@U_Literal_zero@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Mstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??Mstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Ostd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??Ostd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Nstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??Nstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN21
	DD	imagerel $LN21+433
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_base12@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0_Container_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+114
	DD	imagerel $unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z DD imagerel $LN5
	DD	imagerel $LN5+122
	DD	imagerel $unwind$?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Iterator_base12@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??0_Iterator_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Iterator_base12@std@@QEAA@AEBU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$??0_Iterator_base12@std@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Iterator_base12@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$??1_Iterator_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z DD imagerel $LN6
	DD	imagerel $LN6+96
	DD	imagerel $unwind$?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+257
	DD	imagerel $unwind$?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+115
	DD	imagerel $unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z DD imagerel $LN5
	DD	imagerel $LN5+87
	DD	imagerel $unwind$?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+148
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN16
	DD	imagerel $LN16+305
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+86
	DD	imagerel $unwind$?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+71
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+84
	DD	imagerel $unwind$?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$allocator@D@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??0?$allocator@D@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN13
	DD	imagerel $LN13+189
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+93
	DD	imagerel $unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+149
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+105
	DD	imagerel $unwind$?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+144
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DD imagerel $LN13
	DD	imagerel $LN13+1140
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD imagerel ?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+134
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN8
	DD	imagerel $LN8+311
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+150
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+242
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+160
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN11
	DD	imagerel $LN11+548
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+237
	DD	imagerel $unwind$?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z DD imagerel $LN4
	DD	imagerel $LN4+178
	DD	imagerel $unwind$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ DD imagerel $LN12
	DD	imagerel $LN12+183
	DD	imagerel $unwind$?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+151
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+205
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD imagerel $LN13
	DD	imagerel $LN13+195
	DD	imagerel $unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+90
	DD	imagerel $unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+207
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN5
	DD	imagerel $LN5+69
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD imagerel $LN7
	DD	imagerel $LN7+193
	DD	imagerel $unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+43
	DD	imagerel $unwind$time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$localtime_s DD imagerel localtime_s
	DD	imagerel localtime_s+52
	DD	imagerel $unwind$localtime_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_cast@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1bad_cast@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_cast@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gbad_cast@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_cast@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Throw_bad_cast@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1locale@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+120
	DD	imagerel $unwind$??1locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD imagerel $LN8
	DD	imagerel $LN8+173
	DD	imagerel $unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD imagerel $LN7
	DD	imagerel $LN7+410
	DD	imagerel $unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAAAEAV012@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??Y?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAAAEAV012@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z DD imagerel $LN9
	DD	imagerel $LN9+260
	DD	imagerel $unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_JU?$ratio@$00$00@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$00@std@@@12@@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$??$?0_JU?$ratio@$00$00@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$00@std@@@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1thread@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??1thread@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?joinable@thread@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?joinable@thread@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?detach@thread@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+150
	DD	imagerel $unwind$?detach@thread@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0log_@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??0log_@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1log_@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1log_@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0log_@@QEAA@AEBU0@@Z DD imagerel $LN4
	DD	imagerel $LN4+107
	DD	imagerel $unwind$??0log_@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4log_@@QEAAAEAU0@AEBU0@@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??4log_@@QEAAAEAU0@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Glog_@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Glog_@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?logging@@YAXPEAVLogger@@@Z DD imagerel $LN13
	DD	imagerel $LN13+378
	DD	imagerel $unwind$?logging@@YAXPEAVLogger@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??logging@@YAXPEAVLogger@@@Z@4HA DD imagerel ?dtor$0@?0??logging@@YAXPEAVLogger@@@Z@4HA
	DD	imagerel ?dtor$0@?0??logging@@YAXPEAVLogger@@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??logging@@YAXPEAVLogger@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?record@@YAXAEAUlog_@@@Z DD imagerel $LN30
	DD	imagerel $LN30+1558
	DD	imagerel $unwind$?record@@YAXAEAUlog_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$0@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$0@?0??record@@YAXAEAUlog_@@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$1@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$1@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$2@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$2@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$2@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$3@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$3@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$3@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$4@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$4@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$4@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$5@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$5@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$5@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$6@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$6@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$6@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$7@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$7@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$7@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$8@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$8@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$8@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$8@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$9@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$9@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$9@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$9@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA+25
	DD	imagerel $unwind$?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$11@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$11@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$11@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$11@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$12@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$12@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$12@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$12@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$13@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$13@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$13@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$14@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$14@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$14@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$14@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$15@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$15@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$15@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$15@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$16@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$16@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$16@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$16@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$17@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$17@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$17@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$17@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$18@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$18@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$18@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$18@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA DD imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Logger@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$??0Logger@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@Logger@@SAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$?Initialize@Logger@@SAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??Initialize@Logger@@SAX_K@Z@4HA DD imagerel ?dtor$0@?0??Initialize@Logger@@SAX_K@Z@4HA
	DD	imagerel ?dtor$0@?0??Initialize@Logger@@SAX_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??Initialize@Logger@@SAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Exit@Logger@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?Exit@Logger@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DD imagerel $LN6
	DD	imagerel $LN6+201
	DD	imagerel $unwind$?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD imagerel ?dtor$0@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DD	imagerel ?dtor$0@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD imagerel ?dtor$1@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DD	imagerel ?dtor$1@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA+25
	DD	imagerel $unwind$?dtor$1@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?logF@Logger@@SAXPEBDZZ DD imagerel $LN10
	DD	imagerel $LN10+252
	DD	imagerel $unwind$?logF@Logger@@SAXPEBDZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??logF@Logger@@SAXPEBDZZ@4HA DD imagerel ?dtor$0@?0??logF@Logger@@SAXPEBDZZ@4HA
	DD	imagerel ?dtor$0@?0??logF@Logger@@SAXPEBDZZ@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??logF@Logger@@SAXPEBDZZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ DD imagerel $LN10
	DD	imagerel $LN10+252
	DD	imagerel $unwind$?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ@4HA DD imagerel ?dtor$0@?0??logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ@4HA
	DD	imagerel ?dtor$0@?0??logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DD imagerel $LN5
	DD	imagerel $LN5+152
	DD	imagerel $unwind$?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD imagerel ?dtor$0@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DD	imagerel ?dtor$0@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD imagerel ?dtor$1@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DD	imagerel ?dtor$1@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA+25
	DD	imagerel $unwind$?dtor$1@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DD imagerel $LN7
	DD	imagerel $LN7+291
	DD	imagerel $unwind$?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD imagerel ?dtor$0@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DD	imagerel ?dtor$0@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD imagerel ?dtor$1@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DD	imagerel ?dtor$1@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA+25
	DD	imagerel $unwind$?dtor$1@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD imagerel ?dtor$2@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DD	imagerel ?dtor$2@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA+25
	DD	imagerel $unwind$?dtor$2@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z DD imagerel $LN9
	DD	imagerel $LN9+383
	DD	imagerel $unwind$?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD imagerel ?dtor$0@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DD	imagerel ?dtor$0@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD imagerel ?dtor$1@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DD	imagerel ?dtor$1@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA+25
	DD	imagerel $unwind$?dtor$1@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?wait@Logger@@SAXXZ DD imagerel $LN5
	DD	imagerel $LN5+85
	DD	imagerel $unwind$?wait@Logger@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??0?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@Ulog_@@PEAX@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+193
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@Ulog_@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@QEAU?$_List_node@Ulog_@@PEAX@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@QEAU?$_List_node@Ulog_@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@AEBV32@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@AEBV32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+180
	DD	imagerel $unwind$??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+189
	DD	imagerel $unwind$??4?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$?end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?_Unchecked_begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Unchecked_end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@PEAU?$_List_node@Ulog_@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?_Make_iter@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@PEAU?$_List_node@Ulog_@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?max_size@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?empty@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@@Z DD imagerel $LN12
	DD	imagerel $LN12+308
	DD	imagerel $unwind$?erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN16
	DD	imagerel $LN16+490
	DD	imagerel $unwind$?_Unchecked_erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+142
	DD	imagerel $unwind$?clear@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?_Tidy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+196
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$??0?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXPEAU?$_List_node@Ulog_@@PEAX@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+202
	DD	imagerel $unwind$?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXPEAU?$_List_node@Ulog_@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+170
	DD	imagerel $unwind$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unlinknode@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$?_Unlinknode@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Logger@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1Logger@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__El@@YAXXZ DD imagerel ??__El@@YAXXZ
	DD	imagerel ??__El@@YAXXZ+53
	DD	imagerel $unwind$??__El@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fl@@YAXXZ DD imagerel ??__Fl@@YAXXZ
	DD	imagerel ??__Fl@@YAXXZ+29
	DD	imagerel $unwind$??__Fl@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@thread@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@thread@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD imagerel $LN9
	DD	imagerel $LN9+313
	DD	imagerel $unwind$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA+47
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD imagerel ?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA+30
	DD	imagerel $unwind$?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD imagerel ?dtor$2@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	imagerel ?dtor$2@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$2@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD imagerel $LN4
	DD	imagerel $LN4+150
	DD	imagerel $unwind$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+207
	DD	imagerel $unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA DD imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
	DD	imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN7
	DD	imagerel $LN7+148
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN19
	DD	imagerel $LN19+674
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN13
	DD	imagerel $LN13+352
	DD	imagerel $unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN7
	DD	imagerel $LN7+187
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN22
	DD	imagerel $LN22+795
	DD	imagerel $unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA DD imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN11
	DD	imagerel $LN11+518
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD imagerel $LN7
	DD	imagerel $LN7+285
	DD	imagerel $unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN8
	DD	imagerel $LN8+252
	DD	imagerel $unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN5
	DD	imagerel $LN5+196
	DD	imagerel $unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN7
	DD	imagerel $LN7+162
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN5
	DD	imagerel $LN5+142
	DD	imagerel $unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD imagerel $LN6
	DD	imagerel $LN6+289
	DD	imagerel $unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN15
	DD	imagerel $LN15+431
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD imagerel $LN5
	DD	imagerel $LN5+96
	DD	imagerel $unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+99
	DD	imagerel $unwind$?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+138
	DD	imagerel $unwind$?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD imagerel $LN14
	DD	imagerel $LN14+237
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+88
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN25
	DD	imagerel $LN25+886
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+78
	DD	imagerel $unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEBUlog_@@XZ DD imagerel $LN21
	DD	imagerel $LN21+320
	DD	imagerel $unwind$??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEBUlog_@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN14
	DD	imagerel $LN14+229
	DD	imagerel $unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEAUlog_@@XZ DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEAUlog_@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0H$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$?0H$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sleep_for@_JU?$ratio@$00$0PECEA@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$sleep_for@_JU?$ratio@$00$0PECEA@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Verify_range@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z DD imagerel $LN21
	DD	imagerel $LN21+328
	DD	imagerel $unwind$?_Verify_range@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z DD imagerel $LN8
	DD	imagerel $LN8+292
	DD	imagerel $unwind$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$1@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$2@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$2@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0H$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$?0H$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel $LN11
	DD	imagerel $LN11+264
	DD	imagerel $unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA+26
	DD	imagerel $unwind$?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA+25
	DD	imagerel $unwind$?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace@AEBUlog_@@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@QEAU21@AEBUlog_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+163
	DD	imagerel $unwind$??$_Emplace@AEBUlog_@@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@QEAU21@AEBUlog_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@$$CBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@@std@@YAPEBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@$$CBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@@std@@YAPEBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocca@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$_Pocca@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$assign@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@$0A@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@0@Z DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$??$assign@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@$0A@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+193
	DD	imagerel $unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$?0V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD imagerel $LN5
	DD	imagerel $LN5+201
	DD	imagerel $unwind$??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA DD imagerel ?dtor$0@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA DD imagerel ?dtor$1@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
	DD	imagerel ?dtor$1@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA+25
	DD	imagerel $unwind$?dtor$1@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_W@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0_W@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_size@_K_K@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Convert_size@_K_K@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+528
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+471
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@$$CBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@$$CBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD imagerel $LN3
	DD	imagerel $LN3+123
	DD	imagerel $unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN6
	DD	imagerel $LN6+478
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+377
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z DD imagerel $LN3
	DD	imagerel $LN3+144
	DD	imagerel $unwind$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+504
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@D@std@@YAPEADPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Unfancy@D@std@@YAPEADPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+86
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@D@std@@YAPEADAEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@D@std@@YAPEADAEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@_W@std@@YAPEA_WAEA_W@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@_W@std@@YAPEA_WAEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+230
	DD	imagerel $unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Verify_range@D@std@@YAXQEBD0@Z DD imagerel $LN12
	DD	imagerel $LN12+163
	DD	imagerel $unwind$??$_Verify_range@D@std@@YAXQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+96
	DD	imagerel $unwind$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z DD imagerel $LN7
	DD	imagerel $LN7+192
	DD	imagerel $unwind$??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z@4HA DD imagerel ?dtor$0@?0???$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel $LN26
	DD	imagerel $LN26+850
	DD	imagerel $unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+78
	DD	imagerel $unwind$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+119
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+100
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN7
	DD	imagerel $LN7+211
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+89
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_To_absolute_time@_JU?$ratio@$00$0PECEA@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+321
	DD	imagerel $unwind$??$_To_absolute_time@_JU?$ratio@$00$0PECEA@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?__M_JU?$ratio@$00$0PECEA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@0@Z DD imagerel $LN7
	DD	imagerel $LN7+204
	DD	imagerel $unwind$??$?__M_JU?$ratio@$00$0PECEA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0PECEA@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0PECEA@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?__M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z DD imagerel $LN7
	DD	imagerel $LN7+204
	DD	imagerel $unwind$??$?__M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_JU?$ratio@$00$0PECEA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@12@@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$??$?0_JU?$ratio@$00$0PECEA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z DD imagerel $LN7
	DD	imagerel $LN7+171
	DD	imagerel $unwind$??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$distance@PEA_W@std@@YA_JPEA_W0@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??$distance@PEA_W@std@@YA_JPEA_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z DD imagerel $LN11
	DD	imagerel $LN11+546
	DD	imagerel $unwind$??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z@4HA DD imagerel ?dtor$0@?0???$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_To_absolute_time@_JU?$ratio@$00$0DOI@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+321
	DD	imagerel $unwind$??$_To_absolute_time@_JU?$ratio@$00$0DOI@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?__M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z DD imagerel $LN7
	DD	imagerel $LN7+204
	DD	imagerel $unwind$??$?__M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_JU?$ratio@$00$0DOI@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$??$?0_JU?$ratio@$00$0DOI@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@Ulog_@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$destroy@Ulog_@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@QEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+145
	DD	imagerel $unwind$?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+123
	DD	imagerel $unwind$??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Get_unwrapped@AEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD imagerel $LN9
	DD	imagerel $LN9+268
	DD	imagerel $unwind$??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA DD imagerel ?dtor$0@?0???$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+192
	DD	imagerel $unwind$??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD imagerel $LN8
	DD	imagerel $LN8+525
	DD	imagerel $unwind$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA DD imagerel ?dtor$0@?0???$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+296
	DD	imagerel $unwind$??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$_Destroy_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN13
	DD	imagerel $LN13+266
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@$$QEAPEAU10@@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@$$QEAPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@0@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@$$CB_W@std@@YAPEB_WPEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Unfancy@$$CB_W@std@@YAPEB_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z DD imagerel $LN3
	DD	imagerel $LN3+190
	DD	imagerel $unwind$??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD imagerel $LN6
	DD	imagerel $LN6+528
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+528
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@A6AXPEAVLogger@@@ZAEAPEAV3@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@0@A6AXPEAVLogger@@@ZAEAPEAV2@@Z DD imagerel $LN7
	DD	imagerel $LN7+134
	DD	imagerel $unwind$??$make_unique@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@A6AXPEAVLogger@@@ZAEAPEAV3@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@0@A6AXPEAVLogger@@@ZAEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@QEBAXPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??R?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@QEBAXPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEBAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?get@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEBAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?release@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?release@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+128
	DD	imagerel $unwind$??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0PECEA@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0PECEA@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0PECEA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z DD imagerel $LN9
	DD	imagerel $LN9+253
	DD	imagerel $unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0PECEA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_To_timespec64_sys_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAEAU_timespec64@@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+320
	DD	imagerel $unwind$??$_To_timespec64_sys_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAEAU_timespec64@@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z DD imagerel $LN9
	DD	imagerel $LN9+253
	DD	imagerel $unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@Ulog_@@@std@@YAXQEAUlog_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??$destroy_at@Ulog_@@@std@@YAXQEAUlog_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Attach_at_end@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$??$_Attach_at_end@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEAPEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEAPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@_K_K@std@@YA_KAEA_K$$QEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@_K_K@std@@YA_KAEA_K$$QEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@$$QEAPEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@$$QEAPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$$T@std@@YAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@AEAPEAV10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$$T@std@@YAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@AEAPEAV10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$?0U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$0A@P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAP6AXPEAVLogger@@@ZAEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??$get@$0A@P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAP6AXPEAVLogger@@@ZAEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$00P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAPEAVLogger@@AEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$get@$00P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAPEAVLogger@@AEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$invoke@P6AXPEAVLogger@@@ZPEAV1@$$V@std@@YAX$$QEAP6AXPEAVLogger@@@Z$$QEAPEAV1@@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$??$invoke@P6AXPEAVLogger@@@ZPEAV1@$$V@std@@YAX$$QEAP6AXPEAVLogger@@@Z$$QEAPEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_JU?$ratio@$00$0JIJGIA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$??$?0_JU?$ratio@$00$0JIJGIA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?__MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA?A_PAEBV?$duration@NU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z DD imagerel $LN9
	DD	imagerel $LN9+314
	DD	imagerel $unwind$??$?__MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA?A_PAEBV?$duration@NU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0NU?$ratio@$00$00@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@NU?$ratio@$00$00@std@@@12@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0NU?$ratio@$00$00@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@NU?$ratio@$00$00@std@@@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z DD imagerel $LN9
	DD	imagerel $LN9+241
	DD	imagerel $unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@Ulog_@@AEBU1@$0A@@std@@YAPEAUlog_@@QEAU1@AEBU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$construct_at@Ulog_@@AEBU1@$0A@@std@@YAPEAUlog_@@QEAU1@AEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Attach_before@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@AEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@QEAU21@@Z DD imagerel $LN4
	DD	imagerel $LN4+217
	DD	imagerel $unwind$??$_Attach_before@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@AEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@QEAU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$00@std@@@01@@Z DD imagerel $LN9
	DD	imagerel $LN9+253
	DD	imagerel $unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$00@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@A6AXPEAVLogger@@@ZAEAPEAV2@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@U_Exact_args_t@1@A6AXPEAVLogger@@@ZAEAPEAV3@@Z DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@A6AXPEAVLogger@@@ZAEAPEAV2@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@U_Exact_args_t@1@A6AXPEAVLogger@@@ZAEAPEAV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??$?0AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z DD imagerel $LN9
	DD	imagerel $LN9+247
	DD	imagerel $unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@NU?$ratio@$00$00@std@@@01@@Z DD imagerel $LN9
	DD	imagerel $LN9+275
	DD	imagerel $unwind$??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@NU?$ratio@$00$00@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z DD imagerel $LN9
	DD	imagerel $LN9+297
	DD	imagerel $unwind$??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@AEAPEAVLogger@@$$V$0A@@?$tuple@PEAVLogger@@@std@@QEAA@U_Exact_args_t@1@AEAPEAVLogger@@@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@AEAPEAVLogger@@$$V$0A@@?$tuple@PEAVLogger@@@std@@QEAA@U_Exact_args_t@1@AEAPEAVLogger@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0A6AXPEAVLogger@@@Z@?$_Tuple_val@P6AXPEAVLogger@@@Z@std@@QEAA@A6AXPEAVLogger@@@Z@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??$?0A6AXPEAVLogger@@@Z@?$_Tuple_val@P6AXPEAVLogger@@@Z@std@@QEAA@A6AXPEAVLogger@@@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAVLogger@@@?$_Tuple_val@PEAVLogger@@@std@@QEAA@AEAPEAVLogger@@@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$?0AEAPEAVLogger@@@?$_Tuple_val@PEAVLogger@@@std@@QEAA@AEAPEAVLogger@@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?l$initializer$@@3P6AXXZEA DQ FLAT:??__El@@YAXXZ	; l$initializer$
CRT$XCU	ENDS
;	COMDAT __real@41cdcd6500000000
CONST	SEGMENT
__real@41cdcd6500000000 DQ 041cdcd6500000000r	; 1e+09
CONST	ENDS
;	COMDAT __real@412a5e0000000000
CONST	SEGMENT
__real@412a5e0000000000 DQ 0412a5e0000000000r	; 864000
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD imagerel ??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD imagerel ??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 01H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	imagerel ??_R3bad_cast@std@@8
	DD	imagerel ??_R4bad_cast@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$rs	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0a8H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_1EG@NKDFABAL@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1EG@NKDFABAL@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ DB '"'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 's', 00H, 'p', 00H, 'o', 00H, 's', 00H, 'e', 00H, 'd', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KDGGCAAF@string?5iterator?5range?5transpose@
CONST	SEGMENT
??_C@_0CB@KDGGCAAF@string?5iterator?5range?5transpose@ DB 'string iterato'
	DB	'r range transposed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@MFNJODIC@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1HE@MFNJODIC@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ DB '"'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, ' '
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'r', 00H
	DB	'o', 00H, 'm', 00H, ' ', 00H, 'd', 00H, 'i', 00H, 'f', 00H, 'f'
	DB	00H, 'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n'
	DB	00H, 'e', 00H, 'r', 00H, 's', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FIGNHEDK@string?5iterators?5in?5range?5are?5f@
CONST	SEGMENT
??_C@_0DI@FIGNHEDK@string?5iterators?5in?5range?5are?5f@ DB 'string itera'
	DB	'tors in range are from different containers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ DB '"'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't', 00H, 'i'
	DB	00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38'
	DB	'.33030\include\xutility', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1COI@GKKHJOON@?$AA?$CC?$AAY?$AAo?$AAu?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn@
CONST	SEGMENT
??_C@_1COI@GKKHJOON@?$AA?$CC?$AAY?$AAo?$AAu?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn@ DB '"'
	DB	00H, 'Y', 00H, 'o', 00H, 'u', 00H, ' ', 00H, 'c', 00H, 'a', 00H
	DB	'n', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'n', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 't', 00H, 's', 00H, 'e'
	DB	00H, 'l', 00H, 'f', 00H, '.', 00H, ' ', 00H, 'S', 00H, 'e', 00H
	DB	'e', 00H, ' ', 00H, 'N', 00H, '4', 00H, '9', 00H, '5', 00H, '0'
	DB	00H, ' ', 00H, '[', 00H, 'r', 00H, 'e', 00H, 's', 00H, '.', 00H
	DB	'o', 00H, 'n', 00H, '.', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, ']', 00H
	DB	'/', 00H, '1', 00H, '.', 00H, '3', 00H, ':', 00H, ' ', 00H, '"'
	DB	00H, ' ', 00H, '"', 00H, 'I', 00H, 'f', 00H, ' ', 00H, 'a', 00H
	DB	' ', 00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'i'
	DB	00H, 's', 00H, ' ', 00H, 'b', 00H, 'o', 00H, 'u', 00H, 'n', 00H
	DB	'd', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'n'
	DB	00H, ' ', 00H, 'r', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H
	DB	'e', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, ',', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H
	DB	' ', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 'a', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'y', 00H, ' '
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, 'u', 00H, 'm', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, '"'
	DB	00H, ' ', 00H, '"', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'a', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'i', 00H, 'q'
	DB	00H, 'u', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H
	DB	's', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ',', 00H, ' ', 00H, 'e', 00H
	DB	'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't', 00H, ' ', 00H, 't'
	DB	00H, 'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'p', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, '"', 00H, ' ', 00H, '"', 00H, 'a', 00H, ' ', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, '-', 00H, 'a', 00H, 's'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'm', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'm', 00H
	DB	'a', 00H, 'y', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H, 'a'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, '*', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, '[', 00H, 'l', 00H, 'i', 00H, 'b', 00H, '.'
	DB	00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '.', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'd', 00H, 'f', 00H, 'r'
	DB	00H, 'o', 00H, 'm', 00H, ']', 00H, ')', 00H, '.', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@
CONST	SEGMENT
??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@ DB 'You cannot c'
	DB	'oncatenate the same moved string to itself. See N4950 [res.on'
	DB	'.arguments]/1.3: If a function argument is bound to an rvalue'
	DB	' reference parameter, the implementation may assume that this'
	DB	' parameter is a unique reference to this argument, except tha'
	DB	't the argument passed to a move-assignment operator may be a '
	DB	'reference to *this ([lib.types.movedfrom]).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@DINNLDHA@?$AA?$CC?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd@
CONST	SEGMENT
??_C@_1EC@DINNLDHA@?$AA?$CC?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd@ DB '"'
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H, 't', 00H, '(', 00H
	DB	')', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'e', 00H
	DB	'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PFIPNLNI@front?$CI?$CJ?5called?5on?5empty?5string@
CONST	SEGMENT
??_C@_0BP@PFIPNLNI@front?$CI?$CJ?5called?5on?5empty?5string@ DB 'front() '
	DB	'called on empty string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@CNEFBDCF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1EO@CNEFBDCF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JCBFHMPL@cannot?5dereference?5end?5list?5ite@
CONST	SEGMENT
??_C@_0CF@JCBFHMPL@cannot?5dereference?5end?5list?5ite@ DB 'cannot derefe'
	DB	'rence end list iterator', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@NKIMOCIG@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1GK@NKIMOCIG@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MBIHGLJE@cannot?5dereference?5value?9initia@
CONST	SEGMENT
??_C@_0DD@MBIHGLJE@cannot?5dereference?5value?9initia@ DB 'cannot derefer'
	DB	'ence value-initialized list iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38'
	DB	'.33030\include\xstring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@FHIDKIBN@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe@
CONST	SEGMENT
??_C@_1EI@FHIDKIBN@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe@ DB '"'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's', 00H, 'i', 00H, 'd'
	DB	00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H
	DB	'e', 00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KEJJOMBH@list?5erase?5iterator?5outside?5ran@
CONST	SEGMENT
??_C@_0CC@KEJJOMBH@list?5erase?5iterator?5outside?5ran@ DB 'list erase it'
	DB	'erator outside range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@KDLJAKOP@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs@
CONST	SEGMENT
??_C@_1DM@KDLJAKOP@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs@ DB '"'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'o', 00H
	DB	'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38'
	DB	'.33030\include\list', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BALDKKHE@list?5iterators?5incompatible@
CONST	SEGMENT
??_C@_0BM@BALDKKHE@list?5iterators?5incompatible@ DB 'list iterators inco'
	DB	'mpatible', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03NLJIHOMM@?5?9?5@
CONST	SEGMENT
??_C@_03NLJIHOMM@?5?9?5@ DB ' - ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LGFKMCHI@NULL?5@
CONST	SEGMENT
??_C@_05LGFKMCHI@NULL?5@ DB 'NULL ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NBJEAKGO@INFO?5@
CONST	SEGMENT
??_C@_05NBJEAKGO@INFO?5@ DB 'INFO ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LHCGJDCA@WARNIMG?5@
CONST	SEGMENT
??_C@_08LHCGJDCA@WARNIMG?5@ DB 'WARNIMG ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOPONJBP@ERROR?5@
CONST	SEGMENT
??_C@_06EOPONJBP@ERROR?5@ DB 'ERROR ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PBFOLPKM@?$FN?5@
CONST	SEGMENT
??_C@_02PBFOLPKM@?$FN?5@ DB '] ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FPOLKAEB@?4log@
CONST	SEGMENT
??_C@_04FPOLKAEB@?4log@ DB '.log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIDDFADP@logs?1@
CONST	SEGMENT
??_C@_05MIDDFADP@logs?1@ DB 'logs/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	0a8H
CONST	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0CA@CAEGLMPG@The?5system?5started?5successfully@
CONST	SEGMENT
??_C@_0CA@CAEGLMPG@The?5system?5started?5successfully@ DB 'The system sta'
	DB	'rted successfully', 00H			; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_cast@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT _CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
_CTA2?AVbad_cast@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI2?AVbad_cast@std@@
xdata$x	SEGMENT
_TI2?AVbad_cast@std@@ DD 00H
	DD	imagerel ??1bad_cast@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DQ FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DQ	FLAT:??_Ebad_cast@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
CONST	SEGMENT
??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DB '"'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'O', 00H, 'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T'
	DB	00H, ' ', 00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H
	DB	'P', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
CONST	SEGMENT
??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DB 'ITERATOR LIST CORRU'
	DB	'PTED!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e', 00H, 'm'
	DB	00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program Fi'
	DB	'les\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.'
	DB	'33030\include\xmemory', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA DD 09aH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?greater@strong_ordering@std@@2U12@B
CONST	SEGMENT
?greater@strong_ordering@std@@2U12@B DB 01H		; std::strong_ordering::greater
CONST	ENDS
;	COMDAT ?equal@strong_ordering@std@@2U12@B
CONST	SEGMENT
?equal@strong_ordering@std@@2U12@B DB 00H		; std::strong_ordering::equal
CONST	ENDS
;	COMDAT ?less@strong_ordering@std@@2U12@B
CONST	SEGMENT
?less@strong_ordering@std@@2U12@B DB 0ffH		; std::strong_ordering::less
CONST	ENDS
;	COMDAT ?unordered@partial_ordering@std@@2U12@B
CONST	SEGMENT
?unordered@partial_ordering@std@@2U12@B DB 080H		; std::partial_ordering::unordered
CONST	ENDS
;	COMDAT ?greater@partial_ordering@std@@2U12@B
CONST	SEGMENT
?greater@partial_ordering@std@@2U12@B DB 01H		; std::partial_ordering::greater
CONST	ENDS
;	COMDAT ?equivalent@partial_ordering@std@@2U12@B
CONST	SEGMENT
?equivalent@partial_ordering@std@@2U12@B DB 00H		; std::partial_ordering::equivalent
CONST	ENDS
;	COMDAT ?less@partial_ordering@std@@2U12@B
CONST	SEGMENT
?less@partial_ordering@std@@2U12@B DB 0ffH		; std::partial_ordering::less
CONST	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAVLogger@@@?$_Tuple_val@PEAVLogger@@@std@@QEAA@AEAPEAVLogger@@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0A6AXPEAVLogger@@@Z@?$_Tuple_val@P6AXPEAVLogger@@@Z@std@@QEAA@A6AXPEAVLogger@@@Z@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@AEAPEAVLogger@@$$V$0A@@?$tuple@PEAVLogger@@@std@@QEAA@U_Exact_args_t@1@AEAPEAVLogger@@@Z DD 025031801H
	DD	0d2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@NU?$ratio@$00$00@std@@@01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@A6AXPEAVLogger@@@ZAEAPEAV2@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@U_Exact_args_t@1@A6AXPEAVLogger@@@ZAEAPEAV3@@Z DD 025031d01H
	DD	0d218231dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$00@std@@@01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Attach_before@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@AEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@QEAU21@@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@Ulog_@@AEBU1@$0A@@std@@YAPEAUlog_@@QEAU1@AEBU1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0NU?$ratio@$00$00@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@NU?$ratio@$00$00@std@@@12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?__MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA?A_PAEBV?$duration@NU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_JU?$ratio@$00$0JIJGIA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$invoke@P6AXPEAVLogger@@@ZPEAV1@$$V@std@@YAX$$QEAP6AXPEAVLogger@@@Z$$QEAPEAV1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$00P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAPEAVLogger@@AEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$0A@P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAP6AXPEAVLogger@@@ZAEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z DB 060H
	DD	imagerel $ip2state$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z DD 025031919H
	DD	0d2142319H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$$T@std@@YAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@AEAPEAV10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@$$QEAPEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@_K_K@std@@YA_KAEA_K$$QEA_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEAPEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Attach_at_end@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@Ulog_@@@std@@YAXQEAUlog_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_To_timespec64_sys_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAEAU_timespec64@@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c0017H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0PECEA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0PECEA@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z DB 060H
	DD	imagerel $ip2state$??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z DD 025041219H
	DD	010d2312H
	DD	050060012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?release@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEBAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@QEBAXPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@A6AXPEAVLogger@@@ZAEAPEAV3@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@0@A6AXPEAVLogger@@@ZAEAPEAV2@@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	011H, 02H
	DB	02H
	DB	0e6H
	DB	00H
	DB	01cH
	DB	02H
	DB	0e5H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
	DD	imagerel $ip2state$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 025041c11H
	DD	0117231cH
	DD	050100018H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD 045042101H
	DD	011c4321H
	DD	05015001cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z DD 025041001H
	DD	0e20b2310H
	DD	050067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@$$CB_W@std@@YAPEB_WPEB_W@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@$$QEAPEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 035041201H
	DD	010d3312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'n'
	DB	02H
	DB	089H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
	DD	imagerel $ip2state$??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD 025041711H
	DD	01122317H
	DD	0500b0012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DB 06H
	DB	00H
	DB	00H
	DB	0b6H
	DB	02H
	DB	081H, 06H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
	DD	imagerel $ip2state$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD 025041c11H
	DD	0117231cH
	DD	050100014H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DB 06H
	DB	00H
	DB	00H
	DB	'a', 02H
	DB	02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
	DD	imagerel $ip2state$??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD 025041c11H
	DD	0117231cH
	DD	050100012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z DB 06H
	DB	00H
	DB	00H
	DB	'f'
	DB	02H
	DB	'|'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z
	DD	imagerel $ip2state$??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z DD 025031911H
	DD	0d2142319H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@QEAU32@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@Ulog_@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_JU?$ratio@$00$0DOI@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?__M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z DD 025041701H
	DD	01122317H
	DD	0500b0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_To_absolute_time@_JU?$ratio@$00$0DOI@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c0015H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z DB 06H
	DB	00H
	DB	00H
	DB	0deH
	DB	02H
	DB	085H, 06H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z
	DD	imagerel $ip2state$??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z DD 025042111H
	DD	011c2321H
	DD	05015001aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$distance@PEA_W@std@@YA_JPEA_W0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z DD 025051301H
	DD	010e2313H
	DD	070070013H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_JU?$ratio@$00$0PECEA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?__M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z DD 025041701H
	DD	01122317H
	DD	0500b0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0PECEA@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?__M_JU?$ratio@$00$0PECEA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@0@Z DD 025041701H
	DD	01122317H
	DD	0500b0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_To_absolute_time@_JU?$ratio@$00$0PECEA@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c0015H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 06H
	DB	00H
	DB	00H
	DB	'\'
	DB	02H
	DB	'm', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 025031411H
	DD	0d20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	'=', 03H
	DB	02H
	DB	'<'
	DB	04H
	DB	'M', 08H
	DB	02H
	DB	'x'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 025041c19H
	DD	0117231cH
	DD	050100014H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z DB 06H
	DB	00H
	DB	00H
	DB	'z'
	DB	02H
	DB	0e8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z
	DD	imagerel $ip2state$??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z DD 035041c11H
	DD	0117331cH
	DD	050100012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Verify_range@D@std@@YAXQEBD0@Z DD 035031401H
	DD	0d20f3314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	094H
	DB	02H
	DB	'I', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD 025032111H
	DD	0f21c2321H
	DD	05015H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z DD 025031301H
	DD	0d20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@_W@std@@YAPEA_WAEA_W@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@D@std@@YAPEADAEAD@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@D@std@@YAPEADPEAD@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 035042101H
	DD	011c3321H
	DD	05015001aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD 025042101H
	DD	011c2321H
	DD	050150012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 035042101H
	DD	011c3321H
	DD	05015001aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@$$CBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEBV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DB 060H
	DD	imagerel $ip2state$??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	011H, 02H
	DB	02H
	DB	098H
	DB	00H
	DB	01cH
	DB	02H
	DB	09dH, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
	DD	imagerel $ip2state$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 025041c11H
	DD	0117231cH
	DD	050100016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	011H, 02H
	DB	02H
	DB	0e6H
	DB	00H
	DB	01cH
	DB	02H
	DB	0e5H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
	DD	imagerel $ip2state$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 025041c11H
	DD	0117231cH
	DD	050100018H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_size@_K_K@std@@YA_K_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_W@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DB 0aH
	DB	00H
	DB	00H
	DB	0c0H
	DB	02H
	DB	'2'
	DB	04H
	DB	'h'
	DB	02H
	DB	014H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
	DD	imagerel $ip2state$??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD 025041c11H
	DD	0117231cH
	DD	050100014H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$assign@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@$0A@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@0@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocca@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@0@AEBV10@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@$$CBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@@std@@YAPEBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@0@AEBV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace@AEBUlog_@@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@QEAU21@AEBUlog_@@@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DB 060H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z DD 025041501H
	DD	0c2102315H
	DD	0500b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'V'
	DB	02H
	DB	05H, 02H
	DB	04H
	DB	'h'
	DB	02H
	DB	'"'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	imagerel $ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 025041211H
	DD	010d2312H
	DD	050060014H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0H$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEBH@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'B'
	DB	04H
	DB	'X'
	DB	06H
	DB	0c5H, 02H
	DB	02H
	DB	01aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z DD 025042111H
	DD	011c2321H
	DD	050150012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Verify_range@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z DD 035031701H
	DD	0f2123317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sleep_for@_JU?$ratio@$00$0PECEA@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@1@@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0H$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEBH@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEAUlog_@@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 035031701H
	DD	0f2123317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEBUlog_@@XZ DD 035031201H
	DD	0f20d3312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0aH
	DB	00H
	DB	00H
	DB	'q', 03H
	DB	02H
	DB	'<'
	DB	04H
	DB	0a9H, 08H
	DB	02H
	DB	'x'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 025041719H
	DD	01122317H
	DD	0500b0016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD 035031c01H
	DD	0f217331cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 035041201H
	DD	010d3312H
	DD	05006001aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD 045041c01H
	DD	0117431cH
	DD	050100016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 025041c01H
	DD	0117231cH
	DD	050100014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 016H
	DB	00H
	DB	00H
	DB	0edH, 03H
	DB	02H
	DB	'P'
	DB	00H
	DB	'('
	DB	02H
	DB	'e', 05H
	DB	00H
	DB	'"'
	DB	02H
	DB	'j'
	DB	00H
	DB	'"'
	DB	02H
	DB	016H
	DB	00H
	DB	'"'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 028H
	DD	imagerel $stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	imagerel $ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 045041211H
	DD	010d4312H
	DD	050060022H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 025031301H
	DD	0d20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 045041601H
	DD	01114316H
	DD	0500a001cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 06H
	DB	00H
	DB	00H
	DB	081H, 02H
	DB	02H
	DB	'2'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 028H
	DD	imagerel $stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	imagerel $ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 025042111H
	DD	011c2321H
	DD	050150012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 025030f19H
	DD	0b20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD 035031e01H
	DD	0d219331eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 0aH
	DB	00H
	DB	00H
	DB	0b8H
	DB	02H
	DB	'Z'
	DB	04H
	DB	09eH
	DB	06H
	DB	0aeH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
	DD	imagerel $ip2state$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD 025031e11H
	DD	0d219231eH
	DD	05015H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@thread@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fl@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__El@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Logger@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unlinknode@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXPEAU?$_List_node@Ulog_@@PEAX@2@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ DB 06H
	DB	00H
	DB	00H
	DB	0acH
	DB	02H
	DB	0beH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ
	DD	imagerel $ip2state$?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ DD 025041211H
	DD	010d2312H
	DD	050060012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXXZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@QEAU32@@Z DD 025041c01H
	DD	0117231cH
	DD	050100016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@@Z DD 035041c01H
	DD	0117331cH
	DD	050100012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_NXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@PEAU?$_List_node@Ulog_@@PEAX@2@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@AEBV01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@AEBV32@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@QEAU?$_List_node@Ulog_@@PEAX@2@_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@Ulog_@@PEAX@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?wait@Logger@@SAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z DB 0eH
	DB	00H
	DB	00H
	DB	','
	DB	02H
	DB	'^'
	DB	00H
	DB	'"'
	DB	02H
	DB	014H
	DB	04H
	DB	01H, 04H
	DB	02H
	DB	014H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z
	DD	imagerel $ip2state$?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z DD 025041611H
	DD	01112316H
	DD	0500a0028H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DB 014H
	DB	00H
	DB	00H
	DB	'8'
	DB	02H
	DB	'H'
	DB	04H
	DB	'l'
	DB	02H
	DB	014H
	DB	00H
	DB	'"'
	DB	04H
	DB	014H
	DB	06H
	DB	0a0H
	DB	04H
	DB	014H
	DB	02H
	DB	014H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
	DD	imagerel $ip2state$?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DD 025041c11H
	DD	0117231cH
	DD	050100018H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	','
	DB	02H
	DB	','
	DB	04H
	DB	09aH
	DB	02H
	DB	014H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
	DD	imagerel $ip2state$?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DD 025041611H
	DD	01112316H
	DD	0500a0016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ DB 06H
	DB	00H
	DB	00H
	DB	'n'
	DB	02H
	DB	0cdH, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ DB 028H
	DD	imagerel $stateUnwindMap$?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ
	DD	imagerel $ip2state$?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ DD 025042111H
	DD	011c2321H
	DD	05015001aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??logF@Logger@@SAXPEBDZZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?logF@Logger@@SAXPEBDZZ DB 06H
	DB	00H
	DB	00H
	DB	'n'
	DB	02H
	DB	0cdH, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?logF@Logger@@SAXPEBDZZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??logF@Logger@@SAXPEBDZZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?logF@Logger@@SAXPEBDZZ DB 028H
	DD	imagerel $stateUnwindMap$?logF@Logger@@SAXPEBDZZ
	DD	imagerel $ip2state$?logF@Logger@@SAXPEBDZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?logF@Logger@@SAXPEBDZZ DD 025042111H
	DD	011c2321H
	DD	05015001aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?logF@Logger@@SAXPEBDZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DB 0eH
	DB	00H
	DB	00H
	DB	','
	DB	02H
	DB	'^'
	DB	00H
	DB	01cH
	DB	02H
	DB	014H
	DB	04H
	DB	09aH
	DB	02H
	DB	014H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
	DD	imagerel $ip2state$?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z DD 025041611H
	DD	01112316H
	DD	0500a0016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Exit@Logger@@SAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??Initialize@Logger@@SAX_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Initialize@Logger@@SAX_K@Z DB 06H
	DB	00H
	DB	00H
	DB	0a4H
	DB	02H
	DB	0a0H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Initialize@Logger@@SAX_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??Initialize@Logger@@SAX_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Initialize@Logger@@SAX_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?Initialize@Logger@@SAX_K@Z
	DD	imagerel $ip2state$?Initialize@Logger@@SAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@Logger@@SAX_K@Z DD 025041211H
	DD	010d2312H
	DD	050060016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Initialize@Logger@@SAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Logger@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$18@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$17@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$16@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$15@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$14@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$12@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$11@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$9@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$8@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??record@@YAXAEAUlog_@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?record@@YAXAEAUlog_@@@Z DB 'N'
	DB	00H
	DB	00H
	DB	'^'
	DB	02H
	DB	'~'
	DB	04H
	DB	'd'
	DB	06H
	DB	'r'
	DB	08H
	DB	'X'
	DB	0aH
	DB	'^'
	DB	0cH
	DB	'z'
	DB	0eH
	DB	'^'
	DB	010H
	DB	'z'
	DB	012H
	DB	'^'
	DB	014H
	DB	'J'
	DB	018H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01cH
	DB	01aH
	DB	01eH
	DB	01aH
	DB	' '
	DB	01aH
	DB	'"'
	DB	01aH
	DB	'$'
	DB	01aH
	DB	'&'
	DB	01aH
	DB	'('
	DB	'`'
	DB	'*'
	DB	'd'
	DB	','
	DB	'd'
	DB	'.'
	DB	'^'
	DB	'0'
	DB	'^'
	DB	'2'
	DB	'z'
	DB	'4'
	DB	'^'
	DB	'6'
	DB	'z'
	DB	'8'
	DB	'6'
	DB	'<'
	DB	01aH
	DB	'>'
	DB	01aH
	DB	'@'
	DB	01aH
	DB	'B'
	DB	01aH
	DB	'D'
	DB	01aH
	DB	'F'
	DB	01aH
	DB	'H'
	DB	01aH
	DB	'J'
	DB	0dH, 05H
	DB	'('
	DB	01aH
	DB	02H
	DB	014H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?record@@YAXAEAUlog_@@@Z DB 04aH
	DB	0eH
	DD	imagerel ?dtor$0@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$8@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$9@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	07eH
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	0ceH
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	03dH
	DB	02H
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	0edH
	DB	02H
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	09dH
	DB	03H
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	04dH
	DB	04H
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	0fdH
	DB	04H
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	0adH
	DB	05H
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	05dH
	DB	06H
	DD	imagerel ?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	036H
	DD	imagerel ?dtor$11@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$12@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$13@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$14@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$15@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$16@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$17@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$18@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	07eH
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	0ceH
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	03dH
	DB	02H
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	0edH
	DB	02H
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	09dH
	DB	03H
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	04dH
	DB	04H
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	0fdH
	DB	04H
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
	DB	0bdH
	DB	05H
	DD	imagerel ?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?record@@YAXAEAUlog_@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?record@@YAXAEAUlog_@@@Z
	DD	imagerel $ip2state$?record@@YAXAEAUlog_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?record@@YAXAEAUlog_@@@Z DD 035041211H
	DD	010d3312H
	DD	0500600baH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?record@@YAXAEAUlog_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??logging@@YAXPEAVLogger@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?logging@@YAXPEAVLogger@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	0e4H
	DB	02H
	DB	09aH
	DB	00H
	DB	01cH
	DB	02H
	DB	0d8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?logging@@YAXPEAVLogger@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??logging@@YAXPEAVLogger@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?logging@@YAXPEAVLogger@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?logging@@YAXPEAVLogger@@@Z
	DD	imagerel $ip2state$?logging@@YAXPEAVLogger@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?logging@@YAXPEAVLogger@@@Z DD 025041211H
	DD	010d2312H
	DD	05006001eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?logging@@YAXPEAVLogger@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Glog_@@QEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4log_@@QEAAAEAU0@AEBU0@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0log_@@QEAA@AEBU0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1log_@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0log_@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?detach@thread@std@@QEAAXXZ DD 025051401H
	DD	0f20f2314H
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?joinable@thread@std@@QEBA_NXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1thread@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_JU?$ratio@$00$00@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$00@std@@@12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAAAEAV012@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD 025041201H
	DD	010d2312H
	DD	05006001cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD 025031301H
	DD	0d20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1locale@std@@QEAA@XZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_cast@std@@YAXXZ DD 025030e01H
	DD	0f209230eH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_cast@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_cast@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$localtime_s DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time DD	025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD 025041601H
	DD	01112316H
	DD	0500a0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 025031301H
	DD	0d20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD 025031219H
	DD	0f20d2312H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 025031219H
	DD	0f20d2312H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ DD 035030f01H
	DD	0d20a330fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z DD 025031601H
	DD	0f2112316H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z DD 025041c01H
	DD	0117231cH
	DD	050100012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 035042101H
	DD	011c3321H
	DD	050150016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 035041c01H
	DD	0117331cH
	DD	050100012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DB 0aH
	DB	00H
	DB	00H
	DB	0eaH
	DB	02H
	DB	'Q', 0bH
	DB	04H
	DB	'9', 04H
	DB	02H
	DB	01aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DD 025042011H
	DD	011b2320H
	DD	050140024H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 060H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 025031719H
	DD	0f2122317H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'l'
	DB	02H
	DB	'D'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 025031411H
	DD	0d20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	0baH
	DB	02H
	DB	'\'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 025031711H
	DD	0f2122317H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025041001H
	DD	0c20b2310H
	DD	050067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$allocator@D@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z DD 025030e01H
	DD	0d209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z DD 025031201H
	DD	0d20d2312H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z DD 025030e01H
	DD	0b209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z DD 025030e01H
	DD	0b209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ DD 035031201H
	DD	0f20d3312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Iterator_base12@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Iterator_base12@std@@QEAA@AEBU01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Iterator_base12@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_base12@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 035041701H
	DD	01123317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Nstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z DD 025031201H
	DD	0d20d2312H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Ostd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z DD 025031201H
	DD	0d20d2312H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Mstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z DD 025031201H
	DD	0d20d2312H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Mstd@@YA_NUpartial_ordering@0@U_Literal_zero@0@@Z DD 025031201H
	DD	0d20d2312H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 025030e01H
	DD	0f209230eH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 025041501H
	DD	0c2102315H
	DD	0500b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 025041a01H
	DD	0c215231aH
	DD	050107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max@?$numeric_limits@_J@std@@SA_JXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_constant_evaluated@std@@YA_NXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??2@YAPEAX_KPEAX@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odsp /ZI
;	COMDAT ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\tuple
;	COMDAT ??$?0AEAPEAVLogger@@@?$_Tuple_val@PEAVLogger@@@std@@QEAA@AEAPEAVLogger@@@Z
_TEXT	SEGMENT
this$ = 80
_Arg$ = 88
??$?0AEAPEAVLogger@@@?$_Tuple_val@PEAVLogger@@@std@@QEAA@AEAPEAVLogger@@@Z PROC ; std::_Tuple_val<Logger *>::_Tuple_val<Logger *><Logger * &>, COMDAT

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A0E057FF_tuple
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Arg$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$?0AEAPEAVLogger@@@?$_Tuple_val@PEAVLogger@@@std@@QEAA@AEAPEAVLogger@@@Z ENDP ; std::_Tuple_val<Logger *>::_Tuple_val<Logger *><Logger * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT

; 247  :     constexpr tuple(_Tag) noexcept /* strengthened */ {}

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A0E057FF_tuple
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z
_TEXT	SEGMENT
this$ = 80
_Val$ = 88
??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>, COMDAT

; 98   :             : _MyRep(static_cast<_Rep>(_Val)) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Val$[rbp]
  00028	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [rcx]
  0002c	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\tuple
;	COMDAT ??$?0A6AXPEAVLogger@@@Z@?$_Tuple_val@P6AXPEAVLogger@@@Z@std@@QEAA@A6AXPEAVLogger@@@Z@Z
_TEXT	SEGMENT
this$ = 80
_Arg$ = 88
??$?0A6AXPEAVLogger@@@Z@?$_Tuple_val@P6AXPEAVLogger@@@Z@std@@QEAA@A6AXPEAVLogger@@@Z@Z PROC ; std::_Tuple_val<void (__cdecl*)(Logger *)>::_Tuple_val<void (__cdecl*)(Logger *)><void (__cdecl&)(Logger *)>, COMDAT

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A0E057FF_tuple
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Arg$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??$?0A6AXPEAVLogger@@@Z@?$_Tuple_val@P6AXPEAVLogger@@@Z@std@@QEAA@A6AXPEAVLogger@@@Z@Z ENDP ; std::_Tuple_val<void (__cdecl*)(Logger *)>::_Tuple_val<void (__cdecl*)(Logger *)><void (__cdecl&)(Logger *)>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AEAPEAVLogger@@$$V$0A@@?$tuple@PEAVLogger@@@std@@QEAA@U_Exact_args_t@1@AEAPEAVLogger@@@Z
_TEXT	SEGMENT
$T1 = 64
tv75 = 72
this$ = 96
__formal$ = 104
_This_arg$ = 112
??$?0U_Exact_args_t@std@@AEAPEAVLogger@@$$V$0A@@?$tuple@PEAVLogger@@@std@@QEAA@U_Exact_args_t@1@AEAPEAVLogger@@@Z PROC ; std::tuple<Logger *>::tuple<Logger *><std::_Exact_args_t,Logger * &,0>, COMDAT

; 315  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A0E057FF_tuple
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00028	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002c	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
  00031	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  00039	48 8b 55 70	 mov	 rdx, QWORD PTR _This_arg$[rbp]
  0003d	48 8b 4d 48	 mov	 rcx, QWORD PTR tv75[rbp]
  00041	e8 00 00 00 00	 call	 ??$?0AEAPEAVLogger@@@?$_Tuple_val@PEAVLogger@@@std@@QEAA@AEAPEAVLogger@@@Z ; std::_Tuple_val<Logger *>::_Tuple_val<Logger *><Logger * &>
  00046	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
??$?0U_Exact_args_t@std@@AEAPEAVLogger@@$$V$0A@@?$tuple@PEAVLogger@@@std@@QEAA@U_Exact_args_t@1@AEAPEAVLogger@@@Z ENDP ; std::tuple<Logger *>::tuple<Logger *><std::_Exact_args_t,Logger * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
_Num_is_one$ = 0
_Den_is_one$ = 1
$T1 = 72
$T2 = 80
$T3 = 88
$T4 = 96
__$ReturnUdt$ = 128
_Dur$ = 136
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>, COMDAT

; 421  :         is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 422  :         // convert duration to another duration; truncate
; 423  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 424  : 
; 425  :         using _ToRep = typename _To::rep;
; 426  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 427  : 
; 428  :         constexpr bool _Num_is_one = _CF::num == 1;

  00023	c6 45 00 01	 mov	 BYTE PTR _Num_is_one$[rbp], 1

; 429  :         constexpr bool _Den_is_one = _CF::den == 1;

  00027	c6 45 01 01	 mov	 BYTE PTR _Den_is_one$[rbp], 1

; 430  : 
; 431  :         if (_Den_is_one) {

  0002b	33 c0		 xor	 eax, eax
  0002d	83 f8 01	 cmp	 eax, 1
  00030	74 74		 je	 SHORT $LN2@duration_c

; 432  :             if (_Num_is_one) {

  00032	33 c0		 xor	 eax, eax
  00034	83 f8 01	 cmp	 eax, 1
  00037	74 34		 je	 SHORT $LN4@duration_c

; 433  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00039	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  00040	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00045	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0004a	f2 0f 11 45 48	 movsd	 QWORD PTR $T1[rbp], xmm0
  0004f	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  00053	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0005a	e8 00 00 00 00	 call	 ??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
  0005f	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00066	e9 b8 00 00 00	 jmp	 $LN1@duration_c

; 434  :             } else {

  0006b	eb 37		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 435  :                 return static_cast<_To>(

  0006d	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  00074	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00079	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0007e	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00086	f2 0f 11 45 50	 movsd	 QWORD PTR $T2[rbp], xmm0
  0008b	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  0008f	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00096	e8 00 00 00 00	 call	 ??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
  0009b	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000a2	eb 7f		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 436  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 437  :             }
; 438  :         } else {

  000a4	eb 7d		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 439  :             if (_Num_is_one) {

  000a6	33 c0		 xor	 eax, eax
  000a8	83 f8 01	 cmp	 eax, 1
  000ab	74 39		 je	 SHORT $LN6@duration_c

; 440  :                 return static_cast<_To>(

  000ad	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000b4	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000b9	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  000be	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000c6	f2 0f 11 45 58	 movsd	 QWORD PTR $T3[rbp], xmm0
  000cb	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000cf	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000d6	e8 00 00 00 00	 call	 ??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
  000db	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000e2	eb 3f		 jmp	 SHORT $LN1@duration_c

; 441  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 442  :             } else {

  000e4	eb 3d		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 443  :                 return static_cast<_To>(static_cast<_ToRep>(

  000e6	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000ed	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000f2	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  000f7	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000ff	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00107	f2 0f 11 45 60	 movsd	 QWORD PTR $T4[rbp], xmm0
  0010c	48 8d 55 60	 lea	 rdx, QWORD PTR $T4[rbp]
  00110	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00117	e8 00 00 00 00	 call	 ??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
  0011c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@duration_c:

; 444  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 445  :             }
; 446  :         }
; 447  :     }

  00123	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00127	5d		 pop	 rbp
  00128	c3		 ret	 0
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@NU?$ratio@$00$00@std@@@01@@Z
_TEXT	SEGMENT
_Num_is_one$ = 0
_Den_is_one$ = 1
$T1 = 72
$T2 = 80
$T3 = 88
$T4 = 96
__$ReturnUdt$ = 128
_Dur$ = 136
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@NU?$ratio@$00$00@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,0>, COMDAT

; 421  :         is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 422  :         // convert duration to another duration; truncate
; 423  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 424  : 
; 425  :         using _ToRep = typename _To::rep;
; 426  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 427  : 
; 428  :         constexpr bool _Num_is_one = _CF::num == 1;

  00023	c6 45 00 00	 mov	 BYTE PTR _Num_is_one$[rbp], 0

; 429  :         constexpr bool _Den_is_one = _CF::den == 1;

  00027	c6 45 01 01	 mov	 BYTE PTR _Den_is_one$[rbp], 1

; 430  : 
; 431  :         if (_Den_is_one) {

  0002b	33 c0		 xor	 eax, eax
  0002d	83 f8 01	 cmp	 eax, 1
  00030	74 69		 je	 SHORT $LN2@duration_c

; 432  :             if (_Num_is_one) {

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	74 2f		 je	 SHORT $LN4@duration_c

; 433  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00038	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0003f	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
  00044	f2 0f 11 45 48	 movsd	 QWORD PTR $T1[rbp], xmm0
  00049	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0004d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00054	e8 00 00 00 00	 call	 ??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
  00059	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00060	e9 a8 00 00 00	 jmp	 $LN1@duration_c

; 434  :             } else {

  00065	eb 32		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 435  :                 return static_cast<_To>(

  00067	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0006e	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
  00073	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41cdcd6500000000
  0007b	f2 0f 11 45 50	 movsd	 QWORD PTR $T2[rbp], xmm0
  00080	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  00084	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0008b	e8 00 00 00 00	 call	 ??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
  00090	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00097	eb 74		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 436  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 437  :             }
; 438  :         } else {

  00099	eb 72		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 439  :             if (_Num_is_one) {

  0009b	33 c0		 xor	 eax, eax
  0009d	85 c0		 test	 eax, eax
  0009f	74 34		 je	 SHORT $LN6@duration_c

; 440  :                 return static_cast<_To>(

  000a1	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000a8	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
  000ad	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000b5	f2 0f 11 45 58	 movsd	 QWORD PTR $T3[rbp], xmm0
  000ba	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000be	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000c5	e8 00 00 00 00	 call	 ??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
  000ca	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000d1	eb 3a		 jmp	 SHORT $LN1@duration_c

; 441  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 442  :             } else {

  000d3	eb 38		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 443  :                 return static_cast<_To>(static_cast<_ToRep>(

  000d5	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000dc	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
  000e1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41cdcd6500000000
  000e9	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000f1	f2 0f 11 45 60	 movsd	 QWORD PTR $T4[rbp], xmm0
  000f6	48 8d 55 60	 lea	 rdx, QWORD PTR $T4[rbp]
  000fa	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00101	e8 00 00 00 00	 call	 ??$?0N$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,0>
  00106	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@duration_c:

; 444  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 445  :             }
; 446  :         }
; 447  :     }

  0010d	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00111	5d		 pop	 rbp
  00112	c3		 ret	 0
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@NU?$ratio@$00$00@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
_Num_is_one$ = 0
_Den_is_one$ = 1
$T1 = 72
$T2 = 80
$T3 = 88
$T4 = 96
__$ReturnUdt$ = 128
_Dur$ = 136
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,0>, COMDAT

; 421  :         is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 422  :         // convert duration to another duration; truncate
; 423  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 424  : 
; 425  :         using _ToRep = typename _To::rep;
; 426  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 427  : 
; 428  :         constexpr bool _Num_is_one = _CF::num == 1;

  00023	c6 45 00 00	 mov	 BYTE PTR _Num_is_one$[rbp], 0

; 429  :         constexpr bool _Den_is_one = _CF::den == 1;

  00027	c6 45 01 01	 mov	 BYTE PTR _Den_is_one$[rbp], 1

; 430  : 
; 431  :         if (_Den_is_one) {

  0002b	33 c0		 xor	 eax, eax
  0002d	83 f8 01	 cmp	 eax, 1
  00030	74 63		 je	 SHORT $LN2@duration_c

; 432  :             if (_Num_is_one) {

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	74 2e		 je	 SHORT $LN4@duration_c

; 433  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00038	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0003f	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00044	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00048	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0004c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00053	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00058	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0005f	e9 8d 00 00 00	 jmp	 $LN1@duration_c

; 434  :             } else {

  00064	eb 2d		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 435  :                 return static_cast<_To>(

  00066	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0006d	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00072	48 6b c0 64	 imul	 rax, rax, 100		; 00000064H
  00076	48 89 45 50	 mov	 QWORD PTR $T2[rbp], rax
  0007a	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  0007e	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00085	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  0008a	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00091	eb 5e		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 436  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 437  :             }
; 438  :         } else {

  00093	eb 5c		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 439  :             if (_Num_is_one) {

  00095	33 c0		 xor	 eax, eax
  00097	85 c0		 test	 eax, eax
  00099	74 2b		 je	 SHORT $LN6@duration_c

; 440  :                 return static_cast<_To>(

  0009b	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000a2	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  000a7	48 89 45 58	 mov	 QWORD PTR $T3[rbp], rax
  000ab	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000af	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000bb	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000c2	eb 2d		 jmp	 SHORT $LN1@duration_c

; 441  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 442  :             } else {

  000c4	eb 2b		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 443  :                 return static_cast<_To>(static_cast<_ToRep>(

  000c6	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000cd	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  000d2	48 6b c0 64	 imul	 rax, rax, 100		; 00000064H
  000d6	48 89 45 60	 mov	 QWORD PTR $T4[rbp], rax
  000da	48 8d 55 60	 lea	 rdx, QWORD PTR $T4[rbp]
  000de	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000e5	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000ea	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@duration_c:

; 444  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 445  :             }
; 446  :         }
; 447  :     }

  000f1	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000f5	5d		 pop	 rbp
  000f6	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
<_Val2_0>$ = 96
??$?0AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1><std::tuple<void (__cdecl*)(Logger *),Logger *> * &>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b 4d 60	 mov	 rcx, QWORD PTR <_Val2_0>$[rbp]
  0002c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00032	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
??$?0AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1><std::tuple<void (__cdecl*)(Logger *),Logger *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@A6AXPEAVLogger@@@ZAEAPEAV2@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@U_Exact_args_t@1@A6AXPEAVLogger@@@ZAEAPEAV3@@Z
_TEXT	SEGMENT
$T1 = 64
tv76 = 72
this$ = 96
__formal$ = 104
_This_arg$ = 112
<_Rest_arg_0>$ = 120
??$?0U_Exact_args_t@std@@A6AXPEAVLogger@@@ZAEAPEAV2@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@U_Exact_args_t@1@A6AXPEAVLogger@@@ZAEAPEAV3@@Z PROC ; std::tuple<void (__cdecl*)(Logger *),Logger *>::tuple<void (__cdecl*)(Logger *),Logger *><std::_Exact_args_t,void (__cdecl&)(Logger *),Logger * &,0>, COMDAT

; 315  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A0E057FF_tuple
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00029	4c 8b 45 78	 mov	 r8, QWORD PTR <_Rest_arg_0>$[rbp]
  0002d	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00031	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00035	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@AEAPEAVLogger@@$$V$0A@@?$tuple@PEAVLogger@@@std@@QEAA@U_Exact_args_t@1@AEAPEAVLogger@@@Z ; std::tuple<Logger *>::tuple<Logger *><std::_Exact_args_t,Logger * &,0>
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 83 c0 08	 add	 rax, 8
  00042	48 89 45 48	 mov	 QWORD PTR tv76[rbp], rax
  00046	48 8b 55 70	 mov	 rdx, QWORD PTR _This_arg$[rbp]
  0004a	48 8b 4d 48	 mov	 rcx, QWORD PTR tv76[rbp]
  0004e	e8 00 00 00 00	 call	 ??$?0A6AXPEAVLogger@@@Z@?$_Tuple_val@P6AXPEAVLogger@@@Z@std@@QEAA@A6AXPEAVLogger@@@Z@Z ; std::_Tuple_val<void (__cdecl*)(Logger *)>::_Tuple_val<void (__cdecl*)(Logger *)><void (__cdecl&)(Logger *)>
  00053	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00057	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005b	5d		 pop	 rbp
  0005c	c3		 ret	 0
??$?0U_Exact_args_t@std@@A6AXPEAVLogger@@@ZAEAPEAV2@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@U_Exact_args_t@1@A6AXPEAVLogger@@@ZAEAPEAV3@@Z ENDP ; std::tuple<void (__cdecl*)(Logger *),Logger *>::tuple<void (__cdecl*)(Logger *),Logger *><std::_Exact_args_t,void (__cdecl&)(Logger *),Logger * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$00@std@@@01@@Z
_TEXT	SEGMENT
_Num_is_one$ = 0
_Den_is_one$ = 1
$T1 = 72
$T2 = 80
$T3 = 88
$T4 = 96
__$ReturnUdt$ = 128
_Dur$ = 136
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$00@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,0>, COMDAT

; 421  :         is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 422  :         // convert duration to another duration; truncate
; 423  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 424  : 
; 425  :         using _ToRep = typename _To::rep;
; 426  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 427  : 
; 428  :         constexpr bool _Num_is_one = _CF::num == 1;

  00023	c6 45 00 00	 mov	 BYTE PTR _Num_is_one$[rbp], 0

; 429  :         constexpr bool _Den_is_one = _CF::den == 1;

  00027	c6 45 01 01	 mov	 BYTE PTR _Den_is_one$[rbp], 1

; 430  : 
; 431  :         if (_Den_is_one) {

  0002b	33 c0		 xor	 eax, eax
  0002d	83 f8 01	 cmp	 eax, 1
  00030	74 66		 je	 SHORT $LN2@duration_c

; 432  :             if (_Num_is_one) {

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	74 2e		 je	 SHORT $LN4@duration_c

; 433  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00038	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0003f	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  00044	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00048	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0004c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00053	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00058	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0005f	e9 93 00 00 00	 jmp	 $LN1@duration_c

; 434  :             } else {

  00064	eb 30		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 435  :                 return static_cast<_To>(

  00066	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0006d	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  00072	48 69 c0 00 ca
	9a 3b		 imul	 rax, rax, 1000000000	; 3b9aca00H
  00079	48 89 45 50	 mov	 QWORD PTR $T2[rbp], rax
  0007d	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  00081	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00088	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  0008d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00094	eb 61		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 436  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 437  :             }
; 438  :         } else {

  00096	eb 5f		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 439  :             if (_Num_is_one) {

  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	74 2b		 je	 SHORT $LN6@duration_c

; 440  :                 return static_cast<_To>(

  0009e	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000a5	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  000aa	48 89 45 58	 mov	 QWORD PTR $T3[rbp], rax
  000ae	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000b2	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000b9	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000be	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000c5	eb 30		 jmp	 SHORT $LN1@duration_c

; 441  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 442  :             } else {

  000c7	eb 2e		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 443  :                 return static_cast<_To>(static_cast<_ToRep>(

  000c9	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000d0	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  000d5	48 69 c0 00 ca
	9a 3b		 imul	 rax, rax, 1000000000	; 3b9aca00H
  000dc	48 89 45 60	 mov	 QWORD PTR $T4[rbp], rax
  000e0	48 8d 55 60	 lea	 rdx, QWORD PTR $T4[rbp]
  000e4	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000eb	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000f0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@duration_c:

; 444  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 445  :             }
; 446  :         }
; 447  :     }

  000f7	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000fb	5d		 pop	 rbp
  000fc	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Attach_before@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@AEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@QEAU21@@Z
_TEXT	SEGMENT
_Local_added$ = 0
_Local_head$ = 8
_Local_tail$ = 16
_Insert_after$ = 24
this$ = 112
_List_data$ = 120
_Insert_before$ = 128
??$_Attach_before@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@AEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@QEAU21@@Z PROC ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_before<std::_List_simple_types<log_> >, COMDAT

; 681  :     pointer _Attach_before(_List_val<_Val_types>& _List_data, const pointer _Insert_before) noexcept {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 682  :         // Attach the elements in *this before _Insert_before.
; 683  :         // If *this is empty, returns _Insert_before; otherwise returns a pointer to the first inserted list node.
; 684  :         // Resets *this to the default-initialized state.
; 685  : 
; 686  :         const auto _Local_added = _Added;

  00028	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00030	48 89 45 00	 mov	 QWORD PTR _Local_added$[rbp], rax

; 687  :         if (_Local_added == 0) {

  00034	48 83 7d 00 00	 cmp	 QWORD PTR _Local_added$[rbp], 0
  00039	75 0c		 jne	 SHORT $LN2@Attach_bef

; 688  :             return _Insert_before;

  0003b	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Insert_before$[rbp]
  00042	e9 8c 00 00 00	 jmp	 $LN1@Attach_bef
$LN2@Attach_bef:

; 689  :         }
; 690  : 
; 691  :         const auto _Local_head   = _Head;

  00047	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004f	48 89 45 08	 mov	 QWORD PTR _Local_head$[rbp], rax

; 692  :         const auto _Local_tail   = _Tail;

  00053	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00057	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005b	48 89 45 10	 mov	 QWORD PTR _Local_tail$[rbp], rax

; 693  :         const auto _Insert_after = _Insert_before->_Prev;

  0005f	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Insert_before$[rbp]
  00066	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006a	48 89 45 18	 mov	 QWORD PTR _Insert_after$[rbp], rax

; 694  : 
; 695  :         _Construct_in_place(_Local_head->_Prev, _Insert_after);

  0006e	48 8b 45 08	 mov	 rax, QWORD PTR _Local_head$[rbp]
  00072	48 83 c0 08	 add	 rax, 8
  00076	48 8d 55 18	 lea	 rdx, QWORD PTR _Insert_after$[rbp]
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &>

; 696  :         _Insert_after->_Next = _Local_head;

  00082	48 8b 45 18	 mov	 rax, QWORD PTR _Insert_after$[rbp]
  00086	48 8b 4d 08	 mov	 rcx, QWORD PTR _Local_head$[rbp]
  0008a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 697  :         _Construct_in_place(_Local_tail->_Next, _Insert_before);

  0008d	48 8b 45 10	 mov	 rax, QWORD PTR _Local_tail$[rbp]
  00091	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR _Insert_before$[rbp]
  00098	48 8b c8	 mov	 rcx, rax
  0009b	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &>

; 698  :         _Insert_before->_Prev = _Local_tail;

  000a0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Insert_before$[rbp]
  000a7	48 8b 4d 10	 mov	 rcx, QWORD PTR _Local_tail$[rbp]
  000ab	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 699  : 
; 700  :         _List_data._Mysize += _Local_added;

  000af	48 8b 45 78	 mov	 rax, QWORD PTR _List_data$[rbp]
  000b3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b7	48 03 45 00	 add	 rax, QWORD PTR _Local_added$[rbp]
  000bb	48 8b 4d 78	 mov	 rcx, QWORD PTR _List_data$[rbp]
  000bf	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 701  :         _Added = 0;

  000c3	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000c7	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 702  :         return _Local_head;

  000cf	48 8b 45 08	 mov	 rax, QWORD PTR _Local_head$[rbp]
$LN1@Attach_bef:

; 703  :     }

  000d3	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000d7	5d		 pop	 rbp
  000d8	c3		 ret	 0
??$_Attach_before@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@AEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@QEAU21@@Z ENDP ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_before<std::_List_simple_types<log_> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@Ulog_@@AEBU1@$0A@@std@@YAPEAUlog_@@QEAU1@AEBU1@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@Ulog_@@AEBU1@$0A@@std@@YAPEAUlog_@@QEAU1@AEBU1@@Z PROC ; std::construct_at<log_,log_ const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00036	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003a	e8 00 00 00 00	 call	 ??0log_@@QEAA@AEBU0@@Z

; 243  : }

  0003f	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00043	5d		 pop	 rbp
  00044	c3		 ret	 0
??$construct_at@Ulog_@@AEBU1@$0A@@std@@YAPEAUlog_@@QEAU1@AEBU1@@Z ENDP ; std::construct_at<log_,log_ const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z
_TEXT	SEGMENT
_Num_is_one$ = 0
_Den_is_one$ = 1
$T1 = 72
$T2 = 80
$T3 = 88
$T4 = 96
__$ReturnUdt$ = 128
_Dur$ = 136
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>, COMDAT

; 421  :         is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 422  :         // convert duration to another duration; truncate
; 423  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 424  : 
; 425  :         using _ToRep = typename _To::rep;
; 426  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 427  : 
; 428  :         constexpr bool _Num_is_one = _CF::num == 1;

  00023	c6 45 00 01	 mov	 BYTE PTR _Num_is_one$[rbp], 1

; 429  :         constexpr bool _Den_is_one = _CF::den == 1;

  00027	c6 45 01 01	 mov	 BYTE PTR _Den_is_one$[rbp], 1

; 430  : 
; 431  :         if (_Den_is_one) {

  0002b	33 c0		 xor	 eax, eax
  0002d	83 f8 01	 cmp	 eax, 1
  00030	74 60		 je	 SHORT $LN2@duration_c

; 432  :             if (_Num_is_one) {

  00032	33 c0		 xor	 eax, eax
  00034	83 f8 01	 cmp	 eax, 1
  00037	74 2e		 je	 SHORT $LN4@duration_c

; 433  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00039	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  00040	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00045	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00049	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0004d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00054	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00059	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00060	e9 86 00 00 00	 jmp	 $LN1@duration_c

; 434  :             } else {

  00065	eb 29		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 435  :                 return static_cast<_To>(

  00067	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0006e	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00073	48 89 45 50	 mov	 QWORD PTR $T2[rbp], rax
  00077	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  0007b	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00082	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00087	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0008e	eb 5b		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 436  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 437  :             }
; 438  :         } else {

  00090	eb 59		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 439  :             if (_Num_is_one) {

  00092	33 c0		 xor	 eax, eax
  00094	83 f8 01	 cmp	 eax, 1
  00097	74 2b		 je	 SHORT $LN6@duration_c

; 440  :                 return static_cast<_To>(

  00099	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000a0	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000a5	48 89 45 58	 mov	 QWORD PTR $T3[rbp], rax
  000a9	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000ad	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000b4	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000b9	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000c0	eb 29		 jmp	 SHORT $LN1@duration_c

; 441  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 442  :             } else {

  000c2	eb 27		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 443  :                 return static_cast<_To>(static_cast<_ToRep>(

  000c4	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000cb	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000d0	48 89 45 60	 mov	 QWORD PTR $T4[rbp], rax
  000d4	48 8d 55 60	 lea	 rdx, QWORD PTR $T4[rbp]
  000d8	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000df	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000e4	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@duration_c:

; 444  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 445  :             }
; 446  :         }
; 447  :     }

  000eb	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000ef	5d		 pop	 rbp
  000f0	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Dur$ = 104
??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,0>, COMDAT

; 106  :             : _MyRep(_CHRONO duration_cast<duration>(_Dur).count()) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 55 68	 mov	 rdx, QWORD PTR _Dur$[rbp]
  00024	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00028	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
  00035	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00039	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  0003d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0NU?$ratio@$00$00@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@NU?$ratio@$00$00@std@@@12@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Dur$ = 104
??$?0NU?$ratio@$00$00@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@NU?$ratio@$00$00@std@@@12@@Z PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,0>, COMDAT

; 106  :             : _MyRep(_CHRONO duration_cast<duration>(_Dur).count()) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 55 68	 mov	 rdx, QWORD PTR _Dur$[rbp]
  00024	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00028	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@NU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,0>
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
  00035	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00039	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  0003d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??$?0NU?$ratio@$00$00@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@NU?$ratio@$00$00@std@@@12@@Z ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?__MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA?A_PAEBV?$duration@NU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
$T4 = 88
$T5 = 96
$T6 = 97
$T7 = 104
$T8 = 112
$T9 = 113
$T10 = 120
$T11 = 128
$T12 = 129
$T13 = 130
tv79 = 136
tv77 = 144
_Left$ = 176
_Right$ = 184
??$?__MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA?A_PAEBV?$duration@NU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::operator<=><double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >, COMDAT

; 413  :             is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 414  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 415  :         return _CT(_Left).count() <=> _CT(_Right).count();

  00023	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR _Left$[rbp]
  0002a	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  0002e	e8 00 00 00 00	 call	 ??$?0NU?$ratio@$00$00@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@NU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,0>
  00033	48 8b c8	 mov	 rcx, rax
  00036	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
  0003b	f2 0f 11 45 40	 movsd	 QWORD PTR $T1[rbp], xmm0
  00040	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _Right$[rbp]
  00047	48 8d 4d 58	 lea	 rcx, QWORD PTR $T4[rbp]
  0004b	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@$0A@@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,0>
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
  00058	f2 0f 11 45 50	 movsd	 QWORD PTR $T3[rbp], xmm0
  0005d	f2 0f 10 45 50	 movsd	 xmm0, QWORD PTR $T3[rbp]
  00062	66 0f 2f 45 40	 comisd	 xmm0, QWORD PTR $T1[rbp]
  00067	76 19		 jbe	 SHORT $LN7@operator
  00069	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?less@partial_ordering@std@@2U12@B ; std::partial_ordering::less
  00070	88 45 60	 mov	 BYTE PTR $T5[rbp], al
  00073	0f b6 45 60	 movzx	 eax, BYTE PTR $T5[rbp]
  00077	88 85 82 00 00
	00		 mov	 BYTE PTR $T13[rbp], al
  0007d	e9 a8 00 00 00	 jmp	 $LN8@operator
$LN7@operator:
  00082	f2 0f 10 45 40	 movsd	 xmm0, QWORD PTR $T1[rbp]
  00087	66 0f 2f 45 50	 comisd	 xmm0, QWORD PTR $T3[rbp]
  0008c	76 17		 jbe	 SHORT $LN5@operator
  0008e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?greater@partial_ordering@std@@2U12@B ; std::partial_ordering::greater
  00095	88 45 70	 mov	 BYTE PTR $T8[rbp], al
  00098	48 8d 45 70	 lea	 rax, QWORD PTR $T8[rbp]
  0009c	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv79[rbp], rax
  000a3	eb 66		 jmp	 SHORT $LN6@operator
$LN5@operator:
  000a5	f2 0f 10 45 40	 movsd	 xmm0, QWORD PTR $T1[rbp]
  000aa	66 0f 2e 45 50	 ucomisd xmm0, QWORD PTR $T3[rbp]
  000af	7a 1f		 jp	 SHORT $LN3@operator
  000b1	75 1d		 jne	 SHORT $LN3@operator
  000b3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?equivalent@partial_ordering@std@@2U12@B ; std::partial_ordering::equivalent
  000ba	88 85 80 00 00
	00		 mov	 BYTE PTR $T11[rbp], al
  000c0	48 8d 85 80 00
	00 00		 lea	 rax, QWORD PTR $T11[rbp]
  000c7	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv77[rbp], rax
  000ce	eb 1b		 jmp	 SHORT $LN4@operator
$LN3@operator:
  000d0	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?unordered@partial_ordering@std@@2U12@B ; std::partial_ordering::unordered
  000d7	88 85 81 00 00
	00		 mov	 BYTE PTR $T12[rbp], al
  000dd	48 8d 85 81 00
	00 00		 lea	 rax, QWORD PTR $T12[rbp]
  000e4	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv77[rbp], rax
$LN4@operator:
  000eb	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR tv77[rbp]
  000f2	48 89 45 78	 mov	 QWORD PTR $T10[rbp], rax
  000f6	48 8b 45 78	 mov	 rax, QWORD PTR $T10[rbp]
  000fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000fd	88 45 71	 mov	 BYTE PTR $T9[rbp], al
  00100	48 8d 45 71	 lea	 rax, QWORD PTR $T9[rbp]
  00104	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv79[rbp], rax
$LN6@operator:
  0010b	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR tv79[rbp]
  00112	48 89 45 68	 mov	 QWORD PTR $T7[rbp], rax
  00116	48 8b 45 68	 mov	 rax, QWORD PTR $T7[rbp]
  0011a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0011d	88 45 61	 mov	 BYTE PTR $T6[rbp], al
  00120	0f b6 45 61	 movzx	 eax, BYTE PTR $T6[rbp]
  00124	88 85 82 00 00
	00		 mov	 BYTE PTR $T13[rbp], al
$LN8@operator:
  0012a	0f b6 85 82 00
	00 00		 movzx	 eax, BYTE PTR $T13[rbp]

; 416  :     }

  00131	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  00138	5d		 pop	 rbp
  00139	c3		 ret	 0
??$?__MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA?A_PAEBV?$duration@NU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::operator<=><double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0_JU?$ratio@$00$0JIJGIA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Dur$ = 104
??$?0_JU?$ratio@$00$0JIJGIA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,0>, COMDAT

; 106  :             : _MyRep(_CHRONO duration_cast<duration>(_Dur).count()) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 55 68	 mov	 rdx, QWORD PTR _Dur$[rbp]
  00024	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00028	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,0>
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00035	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax
  0003c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
??$?0_JU?$ratio@$00$0JIJGIA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
tv68 = 88
__$ReturnUdt$ = 112
_Left$ = 120
_Right$ = 128
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 289  :             is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 290  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 291  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  00028	48 8b 45 78	 mov	 rax, QWORD PTR _Left$[rbp]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00033	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Right$[rbp]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 89 45 50	 mov	 QWORD PTR $T3[rbp], rax
  00041	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00045	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  0004a	48 89 45 58	 mov	 QWORD PTR tv68[rbp], rax
  0004e	48 8d 4d 50	 lea	 rcx, QWORD PTR $T3[rbp]
  00052	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00057	48 8b 4d 58	 mov	 rcx, QWORD PTR tv68[rbp]
  0005b	48 2b c8	 sub	 rcx, rax
  0005e	48 8b c1	 mov	 rax, rcx
  00061	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00065	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00069	48 8b 4d 70	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0006d	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00072	48 8b 45 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 292  :     }

  00076	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0007a	5d		 pop	 rbp
  0007b	c3		 ret	 0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$invoke@P6AXPEAVLogger@@@ZPEAV1@$$V@std@@YAX$$QEAP6AXPEAVLogger@@@Z$$QEAPEAV1@@Z
_TEXT	SEGMENT
tv66 = 64
_Obj$ = 96
_Arg1$ = 104
??$invoke@P6AXPEAVLogger@@@ZPEAV1@$$V@std@@YAX$$QEAP6AXPEAVLogger@@@Z$$QEAPEAV1@@Z PROC ; std::invoke<void (__cdecl*)(Logger *),Logger *>, COMDAT

; 1743 :         static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1744 :     if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
; 1745 :         return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Obj$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 40	 mov	 QWORD PTR tv66[rbp], rax
  0002b	48 8b 45 68	 mov	 rax, QWORD PTR _Arg1$[rbp]
  0002f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00032	ff 55 40	 call	 QWORD PTR tv66[rbp]

; 1746 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
; 1747 :         return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1748 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
; 1749 :         return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1750 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
; 1751 :         return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
; 1752 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
; 1753 :         return static_cast<_Ty1&&>(_Arg1).*_Obj;
; 1754 :     } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
; 1755 :         return _Arg1.get().*_Obj;
; 1756 :     } else {
; 1757 :         _STL_INTERNAL_STATIC_ASSERT(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer);
; 1758 :         return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
; 1759 :     }
; 1760 : }

  00035	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
??$invoke@P6AXPEAVLogger@@@ZPEAV1@$$V@std@@YAX$$QEAP6AXPEAVLogger@@@Z$$QEAPEAV1@@Z ENDP ; std::invoke<void (__cdecl*)(Logger *),Logger *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\tuple
;	COMDAT ??$get@$00P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAPEAVLogger@@AEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 80
??$get@$00P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAPEAVLogger@@AEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z PROC ; std::get<1,void (__cdecl*)(Logger *),Logger *>, COMDAT

; 942  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A0E057FF_tuple
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 943  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 944  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Tuple$[rbp]

; 945  : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$get@$00P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAPEAVLogger@@AEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z ENDP ; std::get<1,void (__cdecl*)(Logger *),Logger *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\tuple
;	COMDAT ??$get@$0A@P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAP6AXPEAVLogger@@@ZAEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 80
??$get@$0A@P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAP6AXPEAVLogger@@@ZAEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z PROC ; std::get<0,void (__cdecl*)(Logger *),Logger *>, COMDAT

; 942  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A0E057FF_tuple
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 943  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 944  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Tuple$[rbp]
  0001f	48 83 c0 08	 add	 rax, 8

; 945  : }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
??$get@$0A@P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAP6AXPEAVLogger@@@ZAEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z ENDP ; std::get<0,void (__cdecl*)(Logger *),Logger *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ??$?0U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z
_TEXT	SEGMENT
$T1 = 64
tv70 = 72
this$ = 96
_Ptr$ = 104
??$?0U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > ><std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,0>, COMDAT

; 3223 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 48	 mov	 QWORD PTR tv70[rbp], rax
  00028	4c 8d 45 68	 lea	 r8, QWORD PTR _Ptr$[rbp]
  0002c	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00030	48 8b 4d 48	 mov	 rcx, QWORD PTR tv70[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1><std::tuple<void (__cdecl*)(Logger *),Logger *> * &>
  00039	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$?0U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > ><std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\tuple
;	COMDAT ??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_This_arg$ = 104
<_Rest_arg_0>$ = 112
??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z PROC ; std::tuple<void (__cdecl*)(Logger *),Logger *>::tuple<void (__cdecl*)(Logger *),Logger *><void (__cdecl&)(Logger *),Logger * &,0>, COMDAT

; 361  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A0E057FF_tuple
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	4c 8b 4d 70	 mov	 r9, QWORD PTR <_Rest_arg_0>$[rbp]
  00029	4c 8b 45 68	 mov	 r8, QWORD PTR _This_arg$[rbp]
  0002d	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00031	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00035	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@A6AXPEAVLogger@@@ZAEAPEAV2@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@U_Exact_args_t@1@A6AXPEAVLogger@@@ZAEAPEAV3@@Z ; std::tuple<void (__cdecl*)(Logger *),Logger *>::tuple<void (__cdecl*)(Logger *),Logger *><std::_Exact_args_t,void (__cdecl&)(Logger *),Logger * &,0>
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z ENDP ; std::tuple<void (__cdecl*)(Logger *),Logger *>::tuple<void (__cdecl*)(Logger *),Logger *><void (__cdecl&)(Logger *),Logger * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 96
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 00	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 0

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 69   :         if (_Count > _Max_possible) {
; 70   :             _Throw_bad_array_new_length(); // multiply overflow
; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  0001f	48 8b 45 60	 mov	 rax, QWORD PTR _Count$[rbp]

; 75   : }

  00023	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<log_,void *> *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<log_,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$$T@std@@YAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$$T@std@@YAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::tuple<void (__cdecl*)(Logger *),Logger *> *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$$T@std@@YAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::tuple<void (__cdecl*)(Logger *),Logger *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@$$QEAPEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@$$QEAPEAU10@@Z PROC ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@$$QEAPEAU10@@Z ENDP ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@_K_K@std@@YA_KAEA_K$$QEA_K@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@_K_K@std@@YA_KAEA_K$$QEA_K@Z PROC		; std::exchange<unsigned __int64,unsigned __int64>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@_K_K@std@@YA_KAEA_K$$QEA_K@Z ENDP		; std::exchange<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEAPEAU10@@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEAPEAU10@@Z PROC ; std::exchange<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEAPEAU10@@Z ENDP ; std::exchange<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@deallocate

; 709  :             _Al.deallocate(_Ptr, _Count);

  00031	4c 8b 45 60	 mov	 r8, QWORD PTR _Count$[rbp]
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00039	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate

; 710  :         } else

  00042	eb 11		 jmp	 SHORT $LN3@deallocate
$LN2@deallocate:

; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00044	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>
$LN3@deallocate:

; 715  :         }
; 716  :     }

  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Attach_at_end@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_List_data$ = 88
??$_Attach_at_end@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z PROC ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_at_end<std::_List_simple_types<log_> >, COMDAT

; 706  :     void _Attach_at_end(_List_val<_Val_types>& _List_data) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 707  :         _Attach_before(_List_data, _List_data._Myhead);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _List_data$[rbp]
  00024	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00028	48 8b 55 58	 mov	 rdx, QWORD PTR _List_data$[rbp]
  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00030	e8 00 00 00 00	 call	 ??$_Attach_before@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@AEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@QEAU21@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_before<std::_List_simple_types<log_> >

; 708  :     }

  00035	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
??$_Attach_at_end@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ENDP ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_at_end<std::_List_simple_types<log_> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::construct<log_,log_ const &>, COMDAT

; 719  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 720  : #if _HAS_CXX20
; 721  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00025	48 8b 55 60	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$construct_at@Ulog_@@AEBU1@$0A@@std@@YAPEAUlog_@@QEAU1@AEBU1@@Z ; std::construct_at<log_,log_ const &,0>

; 722  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 723  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 724  : #endif // ^^^ !_HAS_CXX20 ^^^
; 725  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::construct<log_,log_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy_at@Ulog_@@@std@@YAXQEAUlog_@@@Z
_TEXT	SEGMENT
_Location$ = 80
??$destroy_at@Ulog_@@@std@@YAXQEAUlog_@@@Z PROC		; std::destroy_at<log_>, COMDAT

; 313  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 314  : #if _HAS_CXX20
; 315  :     if constexpr (is_array_v<_Ty>) {
; 316  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 317  :     } else
; 318  : #endif // _HAS_CXX20
; 319  :     {
; 320  :         _Location->~_Ty();

  0001b	33 d2		 xor	 edx, edx
  0001d	48 8b 4d 50	 mov	 rcx, QWORD PTR _Location$[rbp]
  00021	e8 00 00 00 00	 call	 ??_Glog_@@QEAAPEAXI@Z

; 321  :     }
; 322  : }

  00026	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??$destroy_at@Ulog_@@@std@@YAXQEAUlog_@@@Z ENDP		; std::destroy_at<log_>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
_Num_is_one$ = 0
_Den_is_one$ = 1
$T1 = 72
$T2 = 80
$T3 = 88
$T4 = 96
__$ReturnUdt$ = 128
_Dur$ = 136
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,0>, COMDAT

; 421  :         is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 422  :         // convert duration to another duration; truncate
; 423  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 424  : 
; 425  :         using _ToRep = typename _To::rep;
; 426  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 427  : 
; 428  :         constexpr bool _Num_is_one = _CF::num == 1;

  00023	c6 45 00 00	 mov	 BYTE PTR _Num_is_one$[rbp], 0

; 429  :         constexpr bool _Den_is_one = _CF::den == 1;

  00027	c6 45 01 01	 mov	 BYTE PTR _Den_is_one$[rbp], 1

; 430  : 
; 431  :         if (_Den_is_one) {

  0002b	33 c0		 xor	 eax, eax
  0002d	83 f8 01	 cmp	 eax, 1
  00030	74 66		 je	 SHORT $LN2@duration_c

; 432  :             if (_Num_is_one) {

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	74 2e		 je	 SHORT $LN4@duration_c

; 433  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00038	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0003f	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  00044	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00048	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0004c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00053	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00058	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0005f	e9 93 00 00 00	 jmp	 $LN1@duration_c

; 434  :             } else {

  00064	eb 30		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 435  :                 return static_cast<_To>(

  00066	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0006d	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  00072	48 69 c0 40 42
	0f 00		 imul	 rax, rax, 1000000	; 000f4240H
  00079	48 89 45 50	 mov	 QWORD PTR $T2[rbp], rax
  0007d	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  00081	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00088	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  0008d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00094	eb 61		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 436  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 437  :             }
; 438  :         } else {

  00096	eb 5f		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 439  :             if (_Num_is_one) {

  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	74 2b		 je	 SHORT $LN6@duration_c

; 440  :                 return static_cast<_To>(

  0009e	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000a5	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  000aa	48 89 45 58	 mov	 QWORD PTR $T3[rbp], rax
  000ae	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000b2	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000b9	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000be	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000c5	eb 30		 jmp	 SHORT $LN1@duration_c

; 441  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 442  :             } else {

  000c7	eb 2e		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 443  :                 return static_cast<_To>(static_cast<_ToRep>(

  000c9	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000d0	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  000d5	48 69 c0 40 42
	0f 00		 imul	 rax, rax, 1000000	; 000f4240H
  000dc	48 89 45 60	 mov	 QWORD PTR $T4[rbp], rax
  000e0	48 8d 55 60	 lea	 rdx, QWORD PTR $T4[rbp]
  000e4	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000eb	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000f0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@duration_c:

; 444  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 445  :             }
; 446  :         }
; 447  :     }

  000f7	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000fb	5d		 pop	 rbp
  000fc	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
tv68 = 88
__$ReturnUdt$ = 112
_Left$ = 120
_Right$ = 128
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >, COMDAT

; 289  :             is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 290  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 291  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  00028	48 8b 45 78	 mov	 rax, QWORD PTR _Left$[rbp]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00033	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00037	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  0003c	48 89 45 58	 mov	 QWORD PTR tv68[rbp], rax
  00040	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Right$[rbp]
  00047	48 8d 4d 50	 lea	 rcx, QWORD PTR $T3[rbp]
  0004b	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$0DOI@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,0>
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00058	48 8b 4d 58	 mov	 rcx, QWORD PTR tv68[rbp]
  0005c	48 2b c8	 sub	 rcx, rax
  0005f	48 8b c1	 mov	 rax, rcx
  00062	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00066	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0006a	48 8b 4d 70	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0006e	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00073	48 8b 45 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 292  :     }

  00077	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0007b	5d		 pop	 rbp
  0007c	c3		 ret	 0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 52   :     _CONSTEXPR20 ~_Tidy_deallocate_guard() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 53   :         if (_Target) {

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 0c		 je	 SHORT $LN2@Tidy_deall

; 54   :             _Target->_Tidy_deallocate();

  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN2@Tidy_deall:

; 55   :         }
; 56   :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$_To_timespec64_sys_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAEAU_timespec64@@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z
_TEXT	SEGMENT
_Ten_days$ = 0
_Ten_days_d$ = 8
_Tx0$ = 16
_Clamped$ = 24
_Whole_seconds$ = 32
$T1 = 104
$T2 = 112
$T3 = 120
$T4 = 121
$T5 = 122
$T6 = 123
$T7 = 124
$T8 = 128
$T9 = 136
_Ts64$ = 176
_Rel_time$ = 184
??$_To_timespec64_sys_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAEAU_timespec64@@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z PROC ; std::_To_timespec64_sys_10_day_clamped<__int64,std::ratio<1,1000000000> >, COMDAT

; 720  :     _timespec64& _Ts64, const _CHRONO duration<_Rep, _Period>& _Rel_time) noexcept(is_arithmetic_v<_Rep>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 721  :     // Convert duration to _timespec64 representing system time, maximum 10 days from now, returns whether clamping
; 722  :     // occurred. If clamped, timeouts will be transformed into spurious non-timeout wakes, due to ABI restrictions where
; 723  :     // the other side of the DLL boundary overflows int32_t milliseconds.
; 724  :     // Every function calling this one is TRANSITION, ABI
; 725  :     constexpr _CHRONO nanoseconds _Ten_days{_CHRONO hours{24} * 10};

  00024	48 b8 00 00 16
	ad cd 11 03 00	 mov	 rax, 864000000000000	; 000311cdad160000H
  0002e	48 89 45 00	 mov	 QWORD PTR _Ten_days$[rbp], rax

; 726  :     constexpr _CHRONO duration<double> _Ten_days_d{_Ten_days};

  00032	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@412a5e0000000000
  0003a	f2 0f 11 45 08	 movsd	 QWORD PTR _Ten_days_d$[rbp], xmm0

; 727  :     _CHRONO nanoseconds _Tx0 = _CHRONO system_clock::duration{_Xtime_get_ticks()};

  0003f	e8 00 00 00 00	 call	 _Xtime_get_ticks
  00044	48 89 45 70	 mov	 QWORD PTR $T2[rbp], rax
  00048	48 8d 55 70	 lea	 rdx, QWORD PTR $T2[rbp]
  0004c	48 8d 4d 68	 lea	 rcx, QWORD PTR $T1[rbp]
  00050	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
  00055	48 8b d0	 mov	 rdx, rax
  00058	48 8d 4d 10	 lea	 rcx, QWORD PTR _Tx0$[rbp]
  0005c	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$0JIJGIA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,0>

; 728  :     const bool _Clamped      = _Ten_days_d < _Rel_time;

  00061	48 8d 45 78	 lea	 rax, QWORD PTR $T3[rbp]
  00065	48 8b f8	 mov	 rdi, rax
  00068	33 c0		 xor	 eax, eax
  0006a	b9 01 00 00 00	 mov	 ecx, 1
  0006f	f3 aa		 rep stosb
  00071	0f b6 45 78	 movzx	 eax, BYTE PTR $T3[rbp]
  00075	88 45 7a	 mov	 BYTE PTR $T5[rbp], al
  00078	0f b6 45 7a	 movzx	 eax, BYTE PTR $T5[rbp]
  0007c	88 45 7c	 mov	 BYTE PTR $T7[rbp], al
  0007f	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _Rel_time$[rbp]
  00086	48 8d 4d 08	 lea	 rcx, QWORD PTR _Ten_days_d$[rbp]
  0008a	e8 00 00 00 00	 call	 ??$?__MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA?A_PAEBV?$duration@NU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::operator<=><double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
  0008f	88 45 79	 mov	 BYTE PTR $T4[rbp], al
  00092	0f b6 45 79	 movzx	 eax, BYTE PTR $T4[rbp]
  00096	88 45 7b	 mov	 BYTE PTR $T6[rbp], al
  00099	0f b6 55 7c	 movzx	 edx, BYTE PTR $T7[rbp]
  0009d	0f b6 4d 7b	 movzx	 ecx, BYTE PTR $T6[rbp]
  000a1	e8 00 00 00 00	 call	 ??Mstd@@YA_NUpartial_ordering@0@U_Literal_zero@0@@Z ; std::operator<
  000a6	88 45 18	 mov	 BYTE PTR _Clamped$[rbp], al

; 729  :     if (_Clamped) {

  000a9	0f b6 45 18	 movzx	 eax, BYTE PTR _Clamped$[rbp]
  000ad	85 c0		 test	 eax, eax
  000af	74 0f		 je	 SHORT $LN2@To_timespe

; 730  :         _Tx0 += _Ten_days;

  000b1	48 8d 55 00	 lea	 rdx, QWORD PTR _Ten_days$[rbp]
  000b5	48 8d 4d 10	 lea	 rcx, QWORD PTR _Tx0$[rbp]
  000b9	e8 00 00 00 00	 call	 ??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=

; 731  :     } else {

  000be	eb 1f		 jmp	 SHORT $LN3@To_timespe
$LN2@To_timespe:

; 732  :         _Tx0 += _CHRONO duration_cast<_CHRONO nanoseconds>(_Rel_time);

  000c0	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _Rel_time$[rbp]
  000c7	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  000ce	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
  000d3	48 8b d0	 mov	 rdx, rax
  000d6	48 8d 4d 10	 lea	 rcx, QWORD PTR _Tx0$[rbp]
  000da	e8 00 00 00 00	 call	 ??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
$LN3@To_timespe:

; 733  :     }
; 734  : 
; 735  :     const auto _Whole_seconds = _CHRONO duration_cast<_CHRONO seconds>(_Tx0);

  000df	48 8d 55 10	 lea	 rdx, QWORD PTR _Tx0$[rbp]
  000e3	48 8d 4d 20	 lea	 rcx, QWORD PTR _Whole_seconds$[rbp]
  000e7	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,0>

; 736  :     _Ts64.tv_sec              = _Whole_seconds.count();

  000ec	48 8d 4d 20	 lea	 rcx, QWORD PTR _Whole_seconds$[rbp]
  000f0	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
  000f5	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR _Ts64$[rbp]
  000fc	48 89 01	 mov	 QWORD PTR [rcx], rax

; 737  :     _Tx0 -= _Whole_seconds;

  000ff	48 8d 55 20	 lea	 rdx, QWORD PTR _Whole_seconds$[rbp]
  00103	48 8d 8d 88 00
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  0010a	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$00@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,0>
  0010f	48 8d 95 88 00
	00 00		 lea	 rdx, QWORD PTR $T9[rbp]
  00116	48 8d 4d 10	 lea	 rcx, QWORD PTR _Tx0$[rbp]
  0011a	e8 00 00 00 00	 call	 ??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=

; 738  :     _Ts64.tv_nsec = static_cast<long>(_Tx0.count());

  0011f	48 8d 4d 10	 lea	 rcx, QWORD PTR _Tx0$[rbp]
  00123	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00128	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR _Ts64$[rbp]
  0012f	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 739  :     return _Clamped;

  00132	0f b6 45 18	 movzx	 eax, BYTE PTR _Clamped$[rbp]

; 740  : }

  00136	48 8d a5 98 00
	00 00		 lea	 rsp, QWORD PTR [rbp+152]
  0013d	5f		 pop	 rdi
  0013e	5d		 pop	 rbp
  0013f	c3		 ret	 0
??$_To_timespec64_sys_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAEAU_timespec64@@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ENDP ; std::_To_timespec64_sys_10_day_clamped<__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
tv77 = 80
tv75 = 88
__$ReturnUdt$ = 112
_Left$ = 120
_Right$ = 128
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 548  :             is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 549  :         return _Left.time_since_epoch() - _Right.time_since_epoch();

  00028	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0002c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  00033	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00038	48 89 45 50	 mov	 QWORD PTR tv77[rbp], rax
  0003c	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  00040	48 8b 4d 78	 mov	 rcx, QWORD PTR _Left$[rbp]
  00044	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00049	48 89 45 58	 mov	 QWORD PTR tv75[rbp], rax
  0004d	4c 8b 45 50	 mov	 r8, QWORD PTR tv77[rbp]
  00051	48 8b 55 58	 mov	 rdx, QWORD PTR tv75[rbp]
  00055	48 8b 4d 70	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00059	e8 00 00 00 00	 call	 ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
  0005e	48 8b 45 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 550  :     }

  00062	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00066	5d		 pop	 rbp
  00067	c3		 ret	 0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0PECEA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z
_TEXT	SEGMENT
_Num_is_one$ = 0
_Den_is_one$ = 1
$T1 = 72
$T2 = 80
$T3 = 88
$T4 = 96
__$ReturnUdt$ = 128
_Dur$ = 136
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0PECEA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000>,0>, COMDAT

; 421  :         is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 422  :         // convert duration to another duration; truncate
; 423  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 424  : 
; 425  :         using _ToRep = typename _To::rep;
; 426  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 427  : 
; 428  :         constexpr bool _Num_is_one = _CF::num == 1;

  00023	c6 45 00 00	 mov	 BYTE PTR _Num_is_one$[rbp], 0

; 429  :         constexpr bool _Den_is_one = _CF::den == 1;

  00027	c6 45 01 01	 mov	 BYTE PTR _Den_is_one$[rbp], 1

; 430  : 
; 431  :         if (_Den_is_one) {

  0002b	33 c0		 xor	 eax, eax
  0002d	83 f8 01	 cmp	 eax, 1
  00030	74 66		 je	 SHORT $LN2@duration_c

; 432  :             if (_Num_is_one) {

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	74 2e		 je	 SHORT $LN4@duration_c

; 433  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00038	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0003f	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
  00044	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00048	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0004c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00053	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00058	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0005f	e9 93 00 00 00	 jmp	 $LN1@duration_c

; 434  :             } else {

  00064	eb 30		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 435  :                 return static_cast<_To>(

  00066	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0006d	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
  00072	48 69 c0 e8 03
	00 00		 imul	 rax, rax, 1000		; 000003e8H
  00079	48 89 45 50	 mov	 QWORD PTR $T2[rbp], rax
  0007d	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  00081	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00088	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  0008d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00094	eb 61		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 436  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 437  :             }
; 438  :         } else {

  00096	eb 5f		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 439  :             if (_Num_is_one) {

  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	74 2b		 je	 SHORT $LN6@duration_c

; 440  :                 return static_cast<_To>(

  0009e	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000a5	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
  000aa	48 89 45 58	 mov	 QWORD PTR $T3[rbp], rax
  000ae	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000b2	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000b9	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000be	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000c5	eb 30		 jmp	 SHORT $LN1@duration_c

; 441  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 442  :             } else {

  000c7	eb 2e		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 443  :                 return static_cast<_To>(static_cast<_ToRep>(

  000c9	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000d0	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
  000d5	48 69 c0 e8 03
	00 00		 imul	 rax, rax, 1000		; 000003e8H
  000dc	48 89 45 60	 mov	 QWORD PTR $T4[rbp], rax
  000e0	48 8d 55 60	 lea	 rdx, QWORD PTR $T4[rbp]
  000e4	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000eb	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000f0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@duration_c:

; 444  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 445  :             }
; 446  :         }
; 447  :     }

  000f7	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000fb	5d		 pop	 rbp
  000fc	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0PECEA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0PECEA@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
tv68 = 88
__$ReturnUdt$ = 112
_Left$ = 120
_Right$ = 128
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0PECEA@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000> >, COMDAT

; 289  :             is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 290  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 291  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  00028	48 8b 45 78	 mov	 rax, QWORD PTR _Left$[rbp]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00033	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00037	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  0003c	48 89 45 58	 mov	 QWORD PTR tv68[rbp], rax
  00040	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Right$[rbp]
  00047	48 8d 4d 50	 lea	 rcx, QWORD PTR $T3[rbp]
  0004b	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$0PECEA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000>,0>
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00058	48 8b 4d 58	 mov	 rcx, QWORD PTR tv68[rbp]
  0005c	48 2b c8	 sub	 rcx, rax
  0005f	48 8b c1	 mov	 rax, rcx
  00062	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00066	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0006a	48 8b 4d 70	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0006e	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00073	48 8b 45 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 292  :     }

  00077	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0007b	5d		 pop	 rbp
  0007c	c3		 ret	 0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0PECEA@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z
_TEXT	SEGMENT
_FnVals$ = 0
_Tup$ = 8
$T1 = 80
tv79 = 88
tv77 = 96
_RawVals$ = 128
??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z PROC ; std::thread::_Invoke<std::tuple<void (__cdecl*)(Logger *),Logger *>,0,1>, COMDAT

; 50   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept /* terminates */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 51   :         // adapt invoke of user's callable object to _beginthreadex's thread procedure
; 52   :         const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals));

  0001e	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _RawVals$[rbp]
  00025	48 8d 4d 00	 lea	 rcx, QWORD PTR _FnVals$[rbp]
  00029	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > ><std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,0>

; 53   :         _Tuple& _Tup = *_FnVals.get(); // avoid ADL, handle incomplete types

  0002e	48 8d 4d 00	 lea	 rcx, QWORD PTR _FnVals$[rbp]
  00032	e8 00 00 00 00	 call	 ?get@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEBAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::get
  00037	48 89 45 08	 mov	 QWORD PTR _Tup$[rbp], rax

; 54   :         _STD invoke(_STD move(_STD get<_Indices>(_Tup))...);

  0003b	48 8b 4d 08	 mov	 rcx, QWORD PTR _Tup$[rbp]
  0003f	e8 00 00 00 00	 call	 ??$get@$00P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAPEAVLogger@@AEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z ; std::get<1,void (__cdecl*)(Logger *),Logger *>
  00044	48 89 45 58	 mov	 QWORD PTR tv79[rbp], rax
  00048	48 8b 4d 08	 mov	 rcx, QWORD PTR _Tup$[rbp]
  0004c	e8 00 00 00 00	 call	 ??$get@$0A@P6AXPEAVLogger@@@ZPEAV1@@std@@YAAEAP6AXPEAVLogger@@@ZAEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@@Z ; std::get<0,void (__cdecl*)(Logger *),Logger *>
  00051	48 89 45 60	 mov	 QWORD PTR tv77[rbp], rax
  00055	48 8b 55 58	 mov	 rdx, QWORD PTR tv79[rbp]
  00059	48 8b 4d 60	 mov	 rcx, QWORD PTR tv77[rbp]
  0005d	e8 00 00 00 00	 call	 ??$invoke@P6AXPEAVLogger@@@ZPEAV1@$$V@std@@YAX$$QEAP6AXPEAVLogger@@@Z$$QEAPEAV1@@Z ; std::invoke<void (__cdecl*)(Logger *),Logger *>

; 55   :         _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI

  00062	e8 00 00 00 00	 call	 _Cnd_do_broadcast_at_thread_exit

; 56   :         return 0;

  00067	c7 45 50 00 00
	00 00		 mov	 DWORD PTR $T1[rbp], 0
  0006e	48 8d 4d 00	 lea	 rcx, QWORD PTR _FnVals$[rbp]
  00072	e8 00 00 00 00	 call	 ??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::~unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >
  00077	8b 45 50	 mov	 eax, DWORD PTR $T1[rbp]

; 57   :     }

  0007a	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  0007e	5d		 pop	 rbp
  0007f	c3		 ret	 0
??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z ENDP ; std::thread::_Invoke<std::tuple<void (__cdecl*)(Logger *),Logger *>,0,1>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ?release@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ
_TEXT	SEGMENT
$T1 = 64
this$ = 96
?release@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::release, COMDAT

; 3308 :     _CONSTEXPR23 pointer release() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3309 :         return _STD exchange(_Mypair._Myval2, nullptr);

  0001b	48 c7 45 40 00
	00 00 00	 mov	 QWORD PTR $T1[rbp], 0
  00023	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	e8 00 00 00 00	 call	 ??$exchange@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$$T@std@@YAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::tuple<void (__cdecl*)(Logger *),Logger *> *,std::nullptr_t>

; 3310 :     }

  00033	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
?release@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ?get@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEBAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ
_TEXT	SEGMENT
this$ = 80
?get@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEBAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::get, COMDAT

; 3300 :     _NODISCARD _CONSTEXPR23 pointer get() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3301 :         return _Mypair._Myval2;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 3302 :     }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?get@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEBAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::get
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
tv77 = 64
tv75 = 72
this$ = 96
??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::~unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >, COMDAT

; 3278 :     _CONSTEXPR23 ~unique_ptr() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3279 :         if (_Mypair._Myval2) {

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 28		 je	 SHORT $LN2@unique_ptr

; 3280 :             _Mypair._Get_first()(_Mypair._Myval2);

  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@$00@std@@QEAAAEAU?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,std::tuple<void (__cdecl*)(Logger *),Logger *> *,1>::_Get_first
  00031	48 89 45 40	 mov	 QWORD PTR tv77[rbp], rax
  00035	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  00040	48 8b 55 48	 mov	 rdx, QWORD PTR tv75[rbp]
  00044	48 8b 4d 40	 mov	 rcx, QWORD PTR tv77[rbp]
  00048	e8 00 00 00 00	 call	 ??R?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@QEBAXPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ; std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >::operator()
$LN2@unique_ptr:

; 3281 :         }
; 3282 :     }

  0004d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00051	5d		 pop	 rbp
  00052	c3		 ret	 0
??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::~unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ??R?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@QEBAXPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Ptr$ = 104
??R?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@QEBAXPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z PROC ; std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >::operator(), COMDAT

; 3168 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3169 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3170 :         delete _Ptr;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00024	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00028	ba 10 00 00 00	 mov	 edx, 16
  0002d	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete

; 3171 :     }

  00036	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
??R?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@QEBAXPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ENDP ; std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ??$make_unique@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@A6AXPEAVLogger@@@ZAEAPEAV3@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@0@A6AXPEAVLogger@@@ZAEAPEAV2@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
tv76 = 80
__$ReturnUdt$ = 112
<_Args_0>$ = 120
<_Args_1>$ = 128
??$make_unique@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@A6AXPEAVLogger@@@ZAEAPEAV3@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@0@A6AXPEAVLogger@@@ZAEAPEAV2@@Z PROC ; std::make_unique<std::tuple<void (__cdecl*)(Logger *),Logger *>,void (__cdecl&)(Logger *),Logger * &,0>, COMDAT

; 3464 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	c7 45 48 00 00
	00 00		 mov	 DWORD PTR $T2[rbp], 0
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3465 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  0002f	b9 10 00 00 00	 mov	 ecx, 16
  00034	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00039	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0003d	48 83 7d 40 00	 cmp	 QWORD PTR $T1[rbp], 0
  00042	74 1a		 je	 SHORT $LN3@make_uniqu
  00044	4c 8b 85 80 00
	00 00		 mov	 r8, QWORD PTR <_Args_1>$[rbp]
  0004b	48 8b 55 78	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  0004f	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00053	e8 00 00 00 00	 call	 ??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z ; std::tuple<void (__cdecl*)(Logger *),Logger *>::tuple<void (__cdecl*)(Logger *),Logger *><void (__cdecl&)(Logger *),Logger * &,0>
  00058	48 89 45 50	 mov	 QWORD PTR tv76[rbp], rax
  0005c	eb 08		 jmp	 SHORT $LN4@make_uniqu
$LN3@make_uniqu:
  0005e	48 c7 45 50 00
	00 00 00	 mov	 QWORD PTR tv76[rbp], 0
$LN4@make_uniqu:
  00066	48 8b 55 50	 mov	 rdx, QWORD PTR tv76[rbp]
  0006a	48 8b 4d 70	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0006e	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@PEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@1@@Z ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > ><std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> >,0>
  00073	8b 45 48	 mov	 eax, DWORD PTR $T2[rbp]
  00076	83 c8 01	 or	 eax, 1
  00079	89 45 48	 mov	 DWORD PTR $T2[rbp], eax
  0007c	48 8b 45 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 3466 : }

  00080	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00084	5d		 pop	 rbp
  00085	c3		 ret	 0
??$make_unique@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@A6AXPEAVLogger@@@ZAEAPEAV3@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@0@A6AXPEAVLogger@@@ZAEAPEAV2@@Z ENDP ; std::make_unique<std::tuple<void (__cdecl*)(Logger *),Logger *>,void (__cdecl&)(Logger *),Logger * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
<_Val2_0>$ = 96
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b 4d 60	 mov	 rcx, QWORD PTR <_Val2_0>$[rbp]
  0002c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00032	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
_TEXT	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S19$ = 24
_Proxy$ = 32
_New_capacity$ = 48
_New_ptr$ = 56
$T1 = 128
$T2 = 129
tv154 = 136
tv152 = 144
this$ = 176
_Arg$ = 184
_Count$ = 192
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>, COMDAT

; 2609 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2610 :         auto& _My_data = _Mypair._Myval2;

  00028	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 2611 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2612 : 
; 2613 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2614 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2615 :         } else {
; 2616 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2617 :         }
; 2618 : 
; 2619 :         if (_Count > max_size()) {

  00033	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003a	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0003f	48 39 85 c0 00
	00 00		 cmp	 QWORD PTR _Count$[rbp], rax
  00046	76 05		 jbe	 SHORT $LN2@Construct

; 2620 :             _Xlen_string(); // result too long

  00048	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2621 :         }
; 2622 : 
; 2623 :         auto& _Al       = _Getal();

  0004d	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00054	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00059	48 89 45 08	 mov	 QWORD PTR _Al$[rbp], rax

; 2624 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0005d	48 8b 55 08	 mov	 rdx, QWORD PTR _Al$[rbp]
  00061	48 8d 4d 18	 lea	 rcx, QWORD PTR $S19$[rbp]
  00065	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0006a	48 8d 45 18	 lea	 rax, QWORD PTR $S19$[rbp]
  0006e	48 89 45 10	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 2625 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00072	4c 8b 45 00	 mov	 r8, QWORD PTR _My_data$[rbp]
  00076	48 8b 55 10	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  0007a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0007e	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00083	90		 npad	 1

; 2626 : 
; 2627 :         if (_Count < _BUF_SIZE) {

  00084	48 83 bd c0 00
	00 00 10	 cmp	 QWORD PTR _Count$[rbp], 16
  0008c	73 77		 jae	 SHORT $LN3@Construct

; 2628 :             _My_data._Mysize = _Count;

  0008e	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00092	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  00099	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2629 :             _My_data._Myres  = _BUF_SIZE - 1;

  0009d	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000a1	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 2630 : 
; 2631 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2632 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2633 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2634 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2635 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

  000a9	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000ad	48 83 c0 08	 add	 rax, 8
  000b1	4c 8b 85 c0 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  000b8	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _Arg$[rbp]
  000bf	48 8b c8	 mov	 rcx, rax
  000c2	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2636 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  000c7	c6 85 80 00 00
	00 00		 mov	 BYTE PTR $T1[rbp], 0
  000ce	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000d2	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  000d9	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  000de	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR $T1[rbp]
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2637 :             } else { // _Strat == _Construct_strategy::_From_string
; 2638 : #ifdef _INSERT_STRING_ANNOTATION
; 2639 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2640 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2641 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2642 : #endif // !_INSERT_STRING_ANNOTATION
; 2643 :             }
; 2644 : 
; 2645 :             _Proxy._Release();

  000ed	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000f1	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  000f6	90		 npad	 1

; 2646 :             return;

  000f7	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000fb	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00100	e9 02 01 00 00	 jmp	 $LN4@Construct
$LN3@Construct:

; 2647 :         }
; 2648 : 
; 2649 :         _My_data._Myres         = _BUF_SIZE - 1;

  00105	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00109	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 2650 :         size_type _New_capacity = _Calculate_growth(_Count);

  00111	48 8b 95 c0 00
	00 00		 mov	 rdx, QWORD PTR _Count$[rbp]
  00118	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011f	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00124	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2651 :         ++_New_capacity;

  00128	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  0012c	48 ff c0	 inc	 rax
  0012f	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2652 :         const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  00133	48 8d 55 30	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  00137	48 8b 4d 08	 mov	 rcx, QWORD PTR _Al$[rbp]
  0013b	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  00140	48 89 45 38	 mov	 QWORD PTR _New_ptr$[rbp], rax

; 2653 :         --_New_capacity;

  00144	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00148	48 ff c8	 dec	 rax
  0014b	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2654 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0014f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00153	48 83 c0 08	 add	 rax, 8
  00157	48 8d 55 38	 lea	 rdx, QWORD PTR _New_ptr$[rbp]
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2655 : 
; 2656 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  00163	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00167	48 ff c0	 inc	 rax
  0016a	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv154[rbp], rax
  00171	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00175	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  0017a	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv152[rbp], rax
  00181	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR tv154[rbp]
  00188	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv152[rbp]
  0018f	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 2657 : 
; 2658 :         _My_data._Mysize = _Count;

  00194	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00198	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  0019f	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2659 :         _My_data._Myres  = _New_capacity;

  001a3	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001a7	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  001ab	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2660 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2661 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2662 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2663 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2664 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

  001af	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  001b3	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  001b8	4c 8b 85 c0 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  001bf	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _Arg$[rbp]
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2665 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  001ce	c6 85 81 00 00
	00 00		 mov	 BYTE PTR $T2[rbp], 0
  001d5	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  001d9	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  001de	48 03 85 c0 00
	00 00		 add	 rax, QWORD PTR _Count$[rbp]
  001e5	48 8d 95 81 00
	00 00		 lea	 rdx, QWORD PTR $T2[rbp]
  001ec	48 8b c8	 mov	 rcx, rax
  001ef	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2666 :         } else { // _Strat == _Construct_strategy::_From_string
; 2667 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2668 :         }
; 2669 : 
; 2670 :         _ASAN_STRING_CREATE(*this);
; 2671 :         _Proxy._Release();

  001f4	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  001f8	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  001fd	90		 npad	 1

; 2672 :     }

  001fe	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00202	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
$LN4@Construct:
  00207	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  0020e	5d		 pop	 rbp
  0020f	c3		 ret	 0
$LN6@Construct:
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S19$ = 24
_Proxy$ = 32
_New_capacity$ = 48
_New_ptr$ = 56
$T1 = 128
$T2 = 129
tv154 = 136
tv152 = 144
this$ = 176
_Arg$ = 184
_Count$ = 192
?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z
_TEXT	SEGMENT
_It$ = 80
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z PROC	; std::_Get_unwrapped<char * &>, COMDAT

; 1171 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1172 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1173 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1174 :         return _It + 0;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _It$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1175 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1176 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1177 :     } else {
; 1178 :         return static_cast<_Iter&&>(_It);
; 1179 :     }
; 1180 : }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ENDP	; std::_Get_unwrapped<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
_TEXT	SEGMENT
_My_data$ = 0
_Old_size$ = 8
_New_size$ = 16
_Old_capacity$ = 24
_New_capacity$ = 32
_Al$ = 40
_New_ptr$ = 48
_Raw_new$ = 56
_Old_ptr$1 = 64
tv91 = 136
tv89 = 144
this$ = 176
_Size_increase$ = 184
_Fn$ = 192
<_Args_0>$ = 200
<_Args_1>$ = 208
<_Args_2>$ = 216
??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>, COMDAT

; 4776 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0001c	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4777 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4778 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4779 :         auto& _My_data            = _Mypair._Myval2;

  0002d	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 4780 :         const size_type _Old_size = _My_data._Mysize;

  00038	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0003c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00040	48 89 45 08	 mov	 QWORD PTR _Old_size$[rbp], rax

; 4781 :         if (max_size() - _Old_size < _Size_increase) {

  00044	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00050	48 2b 45 08	 sub	 rax, QWORD PTR _Old_size$[rbp]
  00054	48 3b 85 b8 00
	00 00		 cmp	 rax, QWORD PTR _Size_increase$[rbp]
  0005b	73 05		 jae	 SHORT $LN2@Reallocate

; 4782 :             _Xlen_string(); // result too long

  0005d	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4783 :         }
; 4784 : 
; 4785 :         const size_type _New_size     = _Old_size + _Size_increase;

  00062	48 8b 85 b8 00
	00 00		 mov	 rax, QWORD PTR _Size_increase$[rbp]
  00069	48 8b 4d 08	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 45 10	 mov	 QWORD PTR _New_size$[rbp], rax

; 4786 :         const size_type _Old_capacity = _My_data._Myres;

  00077	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0007b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007f	48 89 45 18	 mov	 QWORD PTR _Old_capacity$[rbp], rax

; 4787 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00083	48 8b 55 10	 mov	 rdx, QWORD PTR _New_size$[rbp]
  00087	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0008e	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00093	48 89 45 20	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4788 :         auto& _Al                     = _Getal();

  00097	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009e	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000a3	48 89 45 28	 mov	 QWORD PTR _Al$[rbp], rax

; 4789 :         ++_New_capacity;

  000a7	48 8b 45 20	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000ab	48 ff c0	 inc	 rax
  000ae	48 89 45 20	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4790 :         const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  000b2	48 8d 55 20	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  000b6	48 8b 4d 28	 mov	 rcx, QWORD PTR _Al$[rbp]
  000ba	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  000bf	48 89 45 30	 mov	 QWORD PTR _New_ptr$[rbp], rax

; 4791 :         --_New_capacity;

  000c3	48 8b 45 20	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000c7	48 ff c8	 dec	 rax
  000ca	48 89 45 20	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4792 : 
; 4793 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  000ce	48 8b 45 20	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000d2	48 ff c0	 inc	 rax
  000d5	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv91[rbp], rax
  000dc	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  000e0	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  000e5	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv89[rbp], rax
  000ec	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR tv91[rbp]
  000f3	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv89[rbp]
  000fa	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 4794 :         _My_data._Orphan_all();

  000ff	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00103	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 4795 :         _ASAN_STRING_REMOVE(*this);
; 4796 :         _My_data._Mysize      = _New_size;

  00108	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0010c	48 8b 4d 10	 mov	 rcx, QWORD PTR _New_size$[rbp]
  00110	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4797 :         _My_data._Myres       = _New_capacity;

  00114	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00118	48 8b 4d 20	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  0011c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4798 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00120	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00124	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00129	48 89 45 38	 mov	 QWORD PTR _Raw_new$[rbp], rax

; 4799 :         if (_BUF_SIZE <= _Old_capacity) {

  0012d	48 83 7d 18 10	 cmp	 QWORD PTR _Old_capacity$[rbp], 16
  00132	72 75		 jb	 SHORT $LN3@Reallocate

; 4800 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00134	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00138	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0013c	48 89 45 40	 mov	 QWORD PTR _Old_ptr$1[rbp], rax

; 4801 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  00140	48 8b 4d 40	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  00144	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00149	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR <_Args_2>$[rbp]
  00150	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00155	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR <_Args_1>$[rbp]
  0015c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00161	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00168	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0016d	4c 8b 4d 08	 mov	 r9, QWORD PTR _Old_size$[rbp]
  00171	4c 8b c0	 mov	 r8, rax
  00174	48 8b 55 38	 mov	 rdx, QWORD PTR _Raw_new$[rbp]
  00178	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR _Fn$[rbp]
  0017f	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator()

; 4802 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00184	48 8b 45 18	 mov	 rax, QWORD PTR _Old_capacity$[rbp]
  00188	48 ff c0	 inc	 rax
  0018b	4c 8b c0	 mov	 r8, rax
  0018e	48 8b 55 40	 mov	 rdx, QWORD PTR _Old_ptr$1[rbp]
  00192	48 8b 4d 28	 mov	 rcx, QWORD PTR _Al$[rbp]
  00196	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4803 :             _My_data._Bx._Ptr = _New_ptr;

  0019b	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0019f	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  001a3	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 4804 :         } else {

  001a7	eb 57		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4805 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  001a9	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001ad	48 83 c0 08	 add	 rax, 8
  001b1	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR <_Args_2>$[rbp]
  001b8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001bd	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR <_Args_1>$[rbp]
  001c4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c9	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  001d0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001d5	4c 8b 4d 08	 mov	 r9, QWORD PTR _Old_size$[rbp]
  001d9	4c 8b c0	 mov	 r8, rax
  001dc	48 8b 55 38	 mov	 rdx, QWORD PTR _Raw_new$[rbp]
  001e0	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR _Fn$[rbp]
  001e7	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator()

; 4806 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  001ec	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001f0	48 83 c0 08	 add	 rax, 8
  001f4	48 8d 55 30	 lea	 rdx, QWORD PTR _New_ptr$[rbp]
  001f8	48 8b c8	 mov	 rcx, rax
  001fb	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4807 :         }
; 4808 : 
; 4809 :         _ASAN_STRING_CREATE(*this);
; 4810 :         return *this;

  00200	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
$LN5@Reallocate:

; 4811 :     }

  00207	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  0020e	5d		 pop	 rbp
  0020f	c3		 ret	 0
??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z
_TEXT	SEGMENT
tv78 = 64
this$ = 96
_New_ptr$ = 104
_Old_ptr$ = 112
_Old_size$ = 120
_Off$ = 128
_Ptr$ = 136
_Count$ = 144
??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator(), COMDAT

; 3539 :                 const _Elem* const _Ptr, const size_type _Count) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3540 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);

  0002a	4c 8b 85 80 00
	00 00		 mov	 r8, QWORD PTR _Off$[rbp]
  00031	48 8b 55 70	 mov	 rdx, QWORD PTR _Old_ptr$[rbp]
  00035	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00039	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3541 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);

  0003e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Off$[rbp]
  00045	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00049	48 03 c8	 add	 rcx, rax
  0004c	48 8b c1	 mov	 rax, rcx
  0004f	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  00056	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR _Ptr$[rbp]
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3542 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00065	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Off$[rbp]
  0006c	48 8b 4d 78	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  00070	48 2b c8	 sub	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 ff c0	 inc	 rax
  00079	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR _Off$[rbp]
  00080	48 8b 55 70	 mov	 rdx, QWORD PTR _Old_ptr$[rbp]
  00084	48 03 d1	 add	 rdx, rcx
  00087	48 8b ca	 mov	 rcx, rdx
  0008a	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Off$[rbp]
  00091	4c 8b 45 68	 mov	 r8, QWORD PTR _New_ptr$[rbp]
  00095	4c 03 c2	 add	 r8, rdx
  00098	49 8b d0	 mov	 rdx, r8
  0009b	48 03 95 90 00
	00 00		 add	 rdx, QWORD PTR _Count$[rbp]
  000a2	48 89 55 40	 mov	 QWORD PTR tv78[rbp], rdx
  000a6	4c 8b c0	 mov	 r8, rax
  000a9	48 8b d1	 mov	 rdx, rcx
  000ac	48 8b 45 40	 mov	 rax, QWORD PTR tv78[rbp]
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3543 :             },

  000b8	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000bc	5d		 pop	 rbp
  000bd	c3		 ret	 0
??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
_Location$ = 112
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z PROC		; std::construct_at<char,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00017	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  0001c	48 c7 45 40 01
	00 00 00	 mov	 QWORD PTR $T1[rbp], 1
  00024	48 8b 55 70	 mov	 rdx, QWORD PTR _Location$[rbp]
  00028	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0002c	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00031	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00035	48 8b 7d 48	 mov	 rdi, QWORD PTR $T2[rbp]
  00039	33 c0		 xor	 eax, eax
  0003b	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003f	f3 aa		 rep stosb
  00041	48 8b 45 48	 mov	 rax, QWORD PTR $T2[rbp]

; 243  : }

  00045	48 8d 65 58	 lea	 rsp, QWORD PTR [rbp+88]
  00049	5f		 pop	 rdi
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z ENDP		; std::construct_at<char,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Lhs$ = 80
_Rhs$ = 88
??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z PROC ; std::_Allocators_equal<std::allocator<char> >, COMDAT

; 2173 : _NODISCARD constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2174 :     if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
; 2175 :         return true;

  00020	b0 01		 mov	 al, 1

; 2176 :     } else {
; 2177 :         return _Lhs == _Rhs;
; 2178 :     }
; 2179 : }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z ENDP ; std::_Allocators_equal<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
_Val1$ = 96
??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>, COMDAT

; 1524 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Unfancy@$$CB_W@std@@YAPEB_WPEB_W@Z
_TEXT	SEGMENT
_Ptr$ = 80
??$_Unfancy@$$CB_W@std@@YAPEB_WPEB_W@Z PROC		; std::_Unfancy<wchar_t const >, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Ptr$[rbp]

; 37   : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Unfancy@$$CB_W@std@@YAPEB_WPEB_W@Z ENDP		; std::_Unfancy<wchar_t const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::_Facet_base *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::_Facet_base *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<log_,void *> *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<log_,void *> *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@0@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@0@Z PROC ; std::exchange<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@0@Z ENDP ; std::exchange<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@$$QEAPEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@$$QEAPEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<log_,void *> *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@$$QEAPEAU10@@Z ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<log_,void *> *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@$$QEAPEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Block_size$ = 0
_Ptr_container$ = 8
_Ptr$ = 16
_Bytes$ = 112
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 136  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 137  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 138  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR _Bytes$[rbp]
  00022	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  00026	48 89 45 00	 mov	 QWORD PTR _Block_size$[rbp], rax

; 139  :     if (_Block_size <= _Bytes) {

  0002a	48 8b 45 70	 mov	 rax, QWORD PTR _Bytes$[rbp]
  0002e	48 39 45 00	 cmp	 QWORD PTR _Block_size$[rbp], rax
  00032	77 05		 ja	 SHORT $LN8@Allocate_m

; 140  :         _Throw_bad_array_new_length(); // add overflow

  00034	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 141  :     }
; 142  : 
; 143  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00039	48 8b 4d 00	 mov	 rcx, QWORD PTR _Block_size$[rbp]
  0003d	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  00042	48 89 45 08	 mov	 QWORD PTR _Ptr_container$[rbp], rax
$LN4@Allocate_m:

; 144  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00046	48 83 7d 08 00	 cmp	 QWORD PTR _Ptr_container$[rbp], 0
  0004b	74 02		 je	 SHORT $LN9@Allocate_m
  0004d	eb 6b		 jmp	 SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  00056	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00062	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00067	45 33 c9	 xor	 r9d, r9d
  0006a	41 b8 90 00 00
	00		 mov	 r8d, 144		; 00000090H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  00077	b9 02 00 00 00	 mov	 ecx, 2
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00082	83 f8 01	 cmp	 eax, 1
  00085	75 03		 jne	 SHORT $LN12@Allocate_m
  00087	cc		 int	 3
  00088	33 c0		 xor	 eax, eax
$LN12@Allocate_m:
  0008a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00093	41 b9 90 00 00
	00		 mov	 r9d, 144		; 00000090H
  00099	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	75 95		 jne	 SHORT $LN7@Allocate_m
$LN10@Allocate_m:
  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	75 86		 jne	 SHORT $LN4@Allocate_m

; 145  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000c0	48 8b 45 08	 mov	 rax, QWORD PTR _Ptr_container$[rbp]
  000c4	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  000c8	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H
  000cc	48 89 45 10	 mov	 QWORD PTR _Ptr$[rbp], rax

; 146  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000d0	b8 08 00 00 00	 mov	 eax, 8
  000d5	48 6b c0 ff	 imul	 rax, rax, -1
  000d9	48 8b 4d 10	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000dd	48 8b 55 08	 mov	 rdx, QWORD PTR _Ptr_container$[rbp]
  000e1	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 147  : 
; 148  : #ifdef _DEBUG
; 149  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000e5	b8 08 00 00 00	 mov	 eax, 8
  000ea	48 6b c0 fe	 imul	 rax, rax, -2
  000ee	48 8b 4d 10	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000f2	48 ba fa fa fa
	fa fa fa fa fa	 mov	 rdx, -361700864190383366 ; fafafafafafafafaH
  000fc	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 150  : #endif // _DEBUG
; 151  :     return _Ptr;

  00100	48 8b 45 10	 mov	 rax, QWORD PTR _Ptr$[rbp]
$LN11@Allocate_m:

; 152  : }

  00104	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00108	5d		 pop	 rbp
  00109	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z PROC ; std::construct_at<char *,char * &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ENDP ; std::construct_at<char *,char * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 80
??$_Destroy_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<log_,void *> *>, COMDAT

; 303  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 304  :     if constexpr (is_array_v<_Ty>) {
; 305  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 306  :     } else {
; 307  :         _Obj.~_Ty();
; 308  :     }
; 309  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$_Destroy_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<log_,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z PROC ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ENDP ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<log_,void *> *>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<log_,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Count$ = 88
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2198 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2199 : #if _HAS_CXX23
; 2200 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2201 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2202 :         _Count                  = _Allocated;
; 2203 :         return _Ptr;
; 2204 :     } else
; 2205 : #endif // _HAS_CXX23
; 2206 :     {
; 2207 :         return _Al.allocate(_Count);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Count$[rbp]
  00024	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002b	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2208 :     }
; 2209 : }

  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
_TEXT	SEGMENT
_Newnode$ = 0
_Local_added$ = 16
_Local_head$1 = 24
_Local_tail$2 = 32
$T3 = 104
this$ = 128
_List_data$ = 136
??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z PROC ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_head<std::_List_simple_types<log_> >, COMDAT

; 711  :     void _Attach_head(_List_val<_Val_types>& _List_data) {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 712  :         _Alloc_construct_ptr<_Alnode> _Newnode(_Al);

  00023	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002d	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  00031	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
  00036	90		 npad	 1

; 713  :         _Newnode._Allocate(); // throws

  00037	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  0003b	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Allocate

; 714  :         const auto _Local_added = _STD exchange(_Added, size_type{0});

  00040	48 c7 45 68 00
	00 00 00	 mov	 QWORD PTR $T3[rbp], 0
  00048	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004f	48 83 c0 08	 add	 rax, 8
  00053	48 8d 55 68	 lea	 rdx, QWORD PTR $T3[rbp]
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ??$exchange@_K_K@std@@YA_KAEA_K$$QEA_K@Z ; std::exchange<unsigned __int64,unsigned __int64>
  0005f	48 89 45 10	 mov	 QWORD PTR _Local_added$[rbp], rax

; 715  :         if (_Local_added == 0) {

  00063	48 83 7d 10 00	 cmp	 QWORD PTR _Local_added$[rbp], 0
  00068	75 26		 jne	 SHORT $LN2@Attach_hea

; 716  :             _Construct_in_place(_Newnode._Ptr->_Next, _Newnode._Ptr);

  0006a	48 8b 45 08	 mov	 rax, QWORD PTR _Newnode$[rbp+8]
  0006e	48 8d 55 08	 lea	 rdx, QWORD PTR _Newnode$[rbp+8]
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>

; 717  :             _Construct_in_place(_Newnode._Ptr->_Prev, _Newnode._Ptr);

  0007a	48 8b 45 08	 mov	 rax, QWORD PTR _Newnode$[rbp+8]
  0007e	48 83 c0 08	 add	 rax, 8
  00082	48 8d 55 08	 lea	 rdx, QWORD PTR _Newnode$[rbp+8]
  00086	48 8b c8	 mov	 rcx, rax
  00089	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>

; 718  :         } else {

  0008e	eb 66		 jmp	 SHORT $LN3@Attach_hea
$LN2@Attach_hea:

; 719  :             const auto _Local_head = _Head;

  00090	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00097	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009b	48 89 45 18	 mov	 QWORD PTR _Local_head$1[rbp], rax

; 720  :             const auto _Local_tail = _Tail;

  0009f	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000aa	48 89 45 20	 mov	 QWORD PTR _Local_tail$2[rbp], rax

; 721  :             _Construct_in_place(_Newnode._Ptr->_Next, _Local_head);

  000ae	48 8b 45 08	 mov	 rax, QWORD PTR _Newnode$[rbp+8]
  000b2	48 8d 55 18	 lea	 rdx, QWORD PTR _Local_head$1[rbp]
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &>

; 722  :             _Construct_in_place(_Newnode._Ptr->_Prev, _Local_tail);

  000be	48 8b 45 08	 mov	 rax, QWORD PTR _Newnode$[rbp+8]
  000c2	48 83 c0 08	 add	 rax, 8
  000c6	48 8d 55 20	 lea	 rdx, QWORD PTR _Local_tail$2[rbp]
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &>

; 723  :             _Construct_in_place(_Local_head->_Prev, _Newnode._Ptr);

  000d2	48 8b 45 18	 mov	 rax, QWORD PTR _Local_head$1[rbp]
  000d6	48 83 c0 08	 add	 rax, 8
  000da	48 8d 55 08	 lea	 rdx, QWORD PTR _Newnode$[rbp+8]
  000de	48 8b c8	 mov	 rcx, rax
  000e1	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>

; 724  :             _Construct_in_place(_Local_tail->_Next, _Newnode._Ptr);

  000e6	48 8b 45 20	 mov	 rax, QWORD PTR _Local_tail$2[rbp]
  000ea	48 8d 55 08	 lea	 rdx, QWORD PTR _Newnode$[rbp+8]
  000ee	48 8b c8	 mov	 rcx, rax
  000f1	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>
$LN3@Attach_hea:

; 725  :         }
; 726  : 
; 727  :         _List_data._Mysize = _Local_added;

  000f6	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR _List_data$[rbp]
  000fd	48 8b 4d 10	 mov	 rcx, QWORD PTR _Local_added$[rbp]
  00101	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 728  :         _List_data._Myhead = _Newnode._Release();

  00105	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  00109	e8 00 00 00 00	 call	 ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Release
  0010e	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _List_data$[rbp]
  00115	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 729  :     }

  00119	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  0011d	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
  00122	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00126	5d		 pop	 rbp
  00127	c3		 ret	 0
??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ENDP ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_head<std::_List_simple_types<log_> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Newnode$ = 0
_Local_added$ = 16
_Local_head$1 = 24
_Local_tail$2 = 32
$T3 = 104
this$ = 128
_List_data$ = 136
?dtor$0@?0???$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z@4HA PROC ; `std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_head<std::_List_simple_types<log_> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z@4HA ENDP ; `std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_head<std::_List_simple_types<log_> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
_TEXT	SEGMENT
_Newnode$ = 0
_Newhead$1 = 16
$T2 = 88
$T3 = 96
tv153 = 104
tv91 = 104
tv151 = 112
tv89 = 112
tv149 = 120
tv87 = 120
this$ = 144
_First$ = 152
_Last$ = 160
??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z PROC ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >, COMDAT

; 652  :     void _Append_range_unchecked(_InIt _First, const _Sentinel _Last) {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 653  :         // Append the values in [_First, _Last)
; 654  :         if (_First == _Last) { // throws

  00028	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR _Last$[rbp]
  0002f	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  00036	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator==
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	74 05		 je	 SHORT $LN4@Append_ran

; 655  :             return;

  00042	e9 bd 01 00 00	 jmp	 $LN1@Append_ran
$LN4@Append_ran:

; 656  :         }
; 657  : 
; 658  :         _Alloc_construct_ptr<_Alnode> _Newnode(_Al);

  00047	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00051	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  00055	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
  0005a	90		 npad	 1

; 659  :         if (_Added == 0) {

  0005b	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00062	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00067	0f 85 a8 00 00
	00		 jne	 $LN2@Append_ran

; 660  :             _Newnode._Allocate(); // throws

  0006d	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  00071	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Allocate

; 661  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), *_First); // throws

  00076	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  0007d	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator*
  00082	48 89 45 68	 mov	 QWORD PTR tv91[rbp], rax
  00086	48 8b 45 08	 mov	 rax, QWORD PTR _Newnode$[rbp+8]
  0008a	48 83 c0 10	 add	 rax, 16
  0008e	48 8b c8	 mov	 rcx, rax
  00091	e8 00 00 00 00	 call	 ??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z ; std::addressof<log_>
  00096	48 89 45 70	 mov	 QWORD PTR tv89[rbp], rax
  0009a	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a4	48 89 45 78	 mov	 QWORD PTR tv87[rbp], rax
  000a8	4c 8b 45 68	 mov	 r8, QWORD PTR tv91[rbp]
  000ac	48 8b 55 70	 mov	 rdx, QWORD PTR tv89[rbp]
  000b0	48 8b 4d 78	 mov	 rcx, QWORD PTR tv87[rbp]
  000b4	e8 00 00 00 00	 call	 ??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::construct<log_,log_ const &>

; 662  :             const auto _Newhead = _STD exchange(_Newnode._Ptr, pointer{});

  000b9	48 c7 45 58 00
	00 00 00	 mov	 QWORD PTR $T2[rbp], 0
  000c1	48 8d 55 58	 lea	 rdx, QWORD PTR $T2[rbp]
  000c5	48 8d 4d 08	 lea	 rcx, QWORD PTR _Newnode$[rbp+8]
  000c9	e8 00 00 00 00	 call	 ??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEAPEAU10@@Z ; std::exchange<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>
  000ce	48 89 45 10	 mov	 QWORD PTR _Newhead$1[rbp], rax

; 663  :             _Head               = _Newhead;

  000d2	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000d9	48 8b 4d 10	 mov	 rcx, QWORD PTR _Newhead$1[rbp]
  000dd	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 664  :             _Tail               = _Newhead;

  000e1	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000e8	48 8b 4d 10	 mov	 rcx, QWORD PTR _Newhead$1[rbp]
  000ec	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 665  :             ++_Added;

  000f0	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000f7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000fb	48 ff c0	 inc	 rax
  000fe	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00105	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 666  :             ++_First; // throws

  00109	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  00110	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator++
$LN2@Append_ran:

; 667  :         }
; 668  : 
; 669  :         while (_First != _Last) { // throws

  00115	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR _Last$[rbp]
  0011c	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  00123	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator==
  00128	0f b6 c0	 movzx	 eax, al
  0012b	85 c0		 test	 eax, eax
  0012d	0f 85 c8 00 00
	00		 jne	 $LN3@Append_ran

; 670  :             _Newnode._Allocate(); // throws

  00133	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  00137	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Allocate

; 671  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), *_First); // throws

  0013c	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  00143	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator*
  00148	48 89 45 68	 mov	 QWORD PTR tv153[rbp], rax
  0014c	48 8b 45 08	 mov	 rax, QWORD PTR _Newnode$[rbp+8]
  00150	48 83 c0 10	 add	 rax, 16
  00154	48 8b c8	 mov	 rcx, rax
  00157	e8 00 00 00 00	 call	 ??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z ; std::addressof<log_>
  0015c	48 89 45 70	 mov	 QWORD PTR tv151[rbp], rax
  00160	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00167	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016a	48 89 45 78	 mov	 QWORD PTR tv149[rbp], rax
  0016e	4c 8b 45 68	 mov	 r8, QWORD PTR tv153[rbp]
  00172	48 8b 55 70	 mov	 rdx, QWORD PTR tv151[rbp]
  00176	48 8b 4d 78	 mov	 rcx, QWORD PTR tv149[rbp]
  0017a	e8 00 00 00 00	 call	 ??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::construct<log_,log_ const &>

; 672  :             _Construct_in_place(_Tail->_Next, _Newnode._Ptr);

  0017f	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00186	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0018a	48 8d 55 08	 lea	 rdx, QWORD PTR _Newnode$[rbp+8]
  0018e	48 8b c8	 mov	 rcx, rax
  00191	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>

; 673  :             _Construct_in_place(_Newnode._Ptr->_Prev, _Tail);

  00196	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0019d	48 83 c0 10	 add	 rax, 16
  001a1	48 8b 4d 08	 mov	 rcx, QWORD PTR _Newnode$[rbp+8]
  001a5	48 83 c1 08	 add	 rcx, 8
  001a9	48 8b d0	 mov	 rdx, rax
  001ac	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>

; 674  :             _Tail = _STD exchange(_Newnode._Ptr, pointer{});

  001b1	48 c7 45 60 00
	00 00 00	 mov	 QWORD PTR $T3[rbp], 0
  001b9	48 8d 55 60	 lea	 rdx, QWORD PTR $T3[rbp]
  001bd	48 8d 4d 08	 lea	 rcx, QWORD PTR _Newnode$[rbp+8]
  001c1	e8 00 00 00 00	 call	 ??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEAPEAU10@@Z ; std::exchange<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>
  001c6	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cd	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 675  :             ++_Added;

  001d1	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001d8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001dc	48 ff c0	 inc	 rax
  001df	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001e6	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 676  :             ++_First; // throws

  001ea	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  001f1	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator++

; 677  :         }

  001f6	e9 1a ff ff ff	 jmp	 $LN2@Append_ran
$LN3@Append_ran:

; 678  :     }

  001fb	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  001ff	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
$LN1@Append_ran:
  00204	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  0020b	5d		 pop	 rbp
  0020c	c3		 ret	 0
??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ENDP ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Newnode$ = 0
_Newhead$1 = 16
$T2 = 88
$T3 = 96
tv153 = 104
tv91 = 104
tv151 = 112
tv89 = 112
tv149 = 120
tv87 = 120
this$ = 144
_First$ = 152
_Last$ = 160
?dtor$0@?0???$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA PROC ; `std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Newnode$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA ENDP ; `std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Subject$ = 0
$T1 = 72
$T2 = 80
tv86 = 88
tv84 = 96
this$ = 128
??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 731  :     ~_List_node_insert_op2() {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 732  :         if (_Added == 0) {

  0001e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00025	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0002a	75 05		 jne	 SHORT $LN4@List_node_

; 733  :             return;

  0002c	e9 89 00 00 00	 jmp	 $LN1@List_node_
$LN4@List_node_:

; 734  :         }
; 735  : 
; 736  :         _Construct_in_place(_Head->_Prev, pointer{});

  00031	48 c7 45 48 00
	00 00 00	 mov	 QWORD PTR $T1[rbp], 0
  00039	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00044	48 83 c0 08	 add	 rax, 8
  00048	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@$$QEAPEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>

; 737  :         _Construct_in_place(_Tail->_Next, pointer{});

  00054	48 c7 45 50 00
	00 00 00	 mov	 QWORD PTR $T2[rbp], 0
  0005c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00063	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00067	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@PEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@$$QEAPEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> *>

; 738  :         pointer _Subject = _Head;

  00073	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0007e	48 89 45 00	 mov	 QWORD PTR _Subject$[rbp], rax
$LN2@List_node_:

; 739  :         while (_Subject) {

  00082	48 83 7d 00 00	 cmp	 QWORD PTR _Subject$[rbp], 0
  00087	74 31		 je	 SHORT $LN1@List_node_

; 740  :             value_type::_Freenode(_Al, _STD exchange(_Subject, _Subject->_Next));

  00089	48 8b 45 00	 mov	 rax, QWORD PTR _Subject$[rbp]
  0008d	48 8b d0	 mov	 rdx, rax
  00090	48 8d 4d 00	 lea	 rcx, QWORD PTR _Subject$[rbp]
  00094	e8 00 00 00 00	 call	 ??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>
  00099	48 89 45 58	 mov	 QWORD PTR tv86[rbp], rax
  0009d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a7	48 89 45 60	 mov	 QWORD PTR tv84[rbp], rax
  000ab	48 8b 55 58	 mov	 rdx, QWORD PTR tv86[rbp]
  000af	48 8b 4d 60	 mov	 rcx, QWORD PTR tv84[rbp]
  000b3	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Freenode<std::allocator<std::_List_node<log_,void *> > >

; 741  :         }

  000b8	eb c8		 jmp	 SHORT $LN2@List_node_
$LN1@List_node_:

; 742  :     }

  000ba	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000be	5d		 pop	 rbp
  000bf	c3		 ret	 0
??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Al_$ = 88
??0?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z PROC ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 617  :     explicit _List_node_insert_op2(_Alnode& _Al_) : _Al(_Al_), _Added(0) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 618  : 
; 619  :     _List_node_insert_op2(const _List_node_insert_op2&)            = delete;
; 620  :     _List_node_insert_op2& operator=(const _List_node_insert_op2&) = delete;
; 621  : 
; 622  :     template <class... _CArgT>
; 623  :     void _Append_n(size_type _Count, const _CArgT&... _Carg) {
; 624  :         // Append _Count elements constructed from _Carg
; 625  :         if (_Count <= 0) {
; 626  :             return;
; 627  :         }
; 628  : 
; 629  :         _Alloc_construct_ptr<_Alnode> _Newnode(_Al);
; 630  :         if (_Added == 0) {
; 631  :             _Newnode._Allocate(); // throws
; 632  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _Carg...); // throws
; 633  :             _Head = _Newnode._Ptr;
; 634  :             _Tail = _Newnode._Ptr;
; 635  :             ++_Added;
; 636  :             --_Count;
; 637  :         }
; 638  : 
; 639  :         for (; 0 < _Count; --_Count) {
; 640  :             _Newnode._Allocate(); // throws
; 641  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _Carg...); // throws
; 642  :             _Construct_in_place(_Tail->_Next, _Newnode._Ptr);
; 643  :             _Construct_in_place(_Newnode._Ptr->_Prev, _Tail);
; 644  :             _Tail = _Newnode._Ptr;
; 645  :             ++_Added;
; 646  :         }
; 647  : 
; 648  :         _Newnode._Ptr = pointer{};
; 649  :     }
; 650  : 
; 651  :     template <class _InIt, class _Sentinel>
; 652  :     void _Append_range_unchecked(_InIt _First, const _Sentinel _Last) {
; 653  :         // Append the values in [_First, _Last)
; 654  :         if (_First == _Last) { // throws
; 655  :             return;
; 656  :         }
; 657  : 
; 658  :         _Alloc_construct_ptr<_Alnode> _Newnode(_Al);
; 659  :         if (_Added == 0) {
; 660  :             _Newnode._Allocate(); // throws
; 661  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), *_First); // throws
; 662  :             const auto _Newhead = _STD exchange(_Newnode._Ptr, pointer{});
; 663  :             _Head               = _Newhead;
; 664  :             _Tail               = _Newhead;
; 665  :             ++_Added;
; 666  :             ++_First; // throws
; 667  :         }
; 668  : 
; 669  :         while (_First != _Last) { // throws
; 670  :             _Newnode._Allocate(); // throws
; 671  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), *_First); // throws
; 672  :             _Construct_in_place(_Tail->_Next, _Newnode._Ptr);
; 673  :             _Construct_in_place(_Newnode._Ptr->_Prev, _Tail);
; 674  :             _Tail = _STD exchange(_Newnode._Ptr, pointer{});
; 675  :             ++_Added;
; 676  :             ++_First; // throws
; 677  :         }
; 678  :     }
; 679  : 
; 680  :     template <class _Val_types>
; 681  :     pointer _Attach_before(_List_val<_Val_types>& _List_data, const pointer _Insert_before) noexcept {
; 682  :         // Attach the elements in *this before _Insert_before.
; 683  :         // If *this is empty, returns _Insert_before; otherwise returns a pointer to the first inserted list node.
; 684  :         // Resets *this to the default-initialized state.
; 685  : 
; 686  :         const auto _Local_added = _Added;
; 687  :         if (_Local_added == 0) {
; 688  :             return _Insert_before;
; 689  :         }
; 690  : 
; 691  :         const auto _Local_head   = _Head;
; 692  :         const auto _Local_tail   = _Tail;
; 693  :         const auto _Insert_after = _Insert_before->_Prev;
; 694  : 
; 695  :         _Construct_in_place(_Local_head->_Prev, _Insert_after);
; 696  :         _Insert_after->_Next = _Local_head;
; 697  :         _Construct_in_place(_Local_tail->_Next, _Insert_before);
; 698  :         _Insert_before->_Prev = _Local_tail;
; 699  : 
; 700  :         _List_data._Mysize += _Local_added;
; 701  :         _Added = 0;
; 702  :         return _Local_head;
; 703  :     }
; 704  : 
; 705  :     template <class _Val_types>
; 706  :     void _Attach_at_end(_List_val<_Val_types>& _List_data) noexcept {
; 707  :         _Attach_before(_List_data, _List_data._Myhead);
; 708  :     }
; 709  : 
; 710  :     template <class _Val_types>
; 711  :     void _Attach_head(_List_val<_Val_types>& _List_data) {
; 712  :         _Alloc_construct_ptr<_Alnode> _Newnode(_Al);
; 713  :         _Newnode._Allocate(); // throws
; 714  :         const auto _Local_added = _STD exchange(_Added, size_type{0});
; 715  :         if (_Local_added == 0) {
; 716  :             _Construct_in_place(_Newnode._Ptr->_Next, _Newnode._Ptr);
; 717  :             _Construct_in_place(_Newnode._Ptr->_Prev, _Newnode._Ptr);
; 718  :         } else {
; 719  :             const auto _Local_head = _Head;
; 720  :             const auto _Local_tail = _Tail;
; 721  :             _Construct_in_place(_Newnode._Ptr->_Next, _Local_head);
; 722  :             _Construct_in_place(_Newnode._Ptr->_Prev, _Local_tail);
; 723  :             _Construct_in_place(_Local_head->_Prev, _Newnode._Ptr);
; 724  :             _Construct_in_place(_Local_tail->_Next, _Newnode._Ptr);
; 725  :         }
; 726  : 
; 727  :         _List_data._Mysize = _Local_added;
; 728  :         _List_data._Myhead = _Newnode._Release();
; 729  :     }
; 730  : 
; 731  :     ~_List_node_insert_op2() {
; 732  :         if (_Added == 0) {
; 733  :             return;
; 734  :         }
; 735  : 
; 736  :         _Construct_in_place(_Head->_Prev, pointer{});
; 737  :         _Construct_in_place(_Tail->_Next, pointer{});
; 738  :         pointer _Subject = _Head;
; 739  :         while (_Subject) {
; 740  :             value_type::_Freenode(_Al, _STD exchange(_Subject, _Subject->_Next));
; 741  :         }
; 742  :     }
; 743  : 
; 744  : private:
; 745  :     _Alnode& _Al;
; 746  :     size_type _Added; // if 0, the values of _Head and _Tail are indeterminate
; 747  :     pointer _Tail{}; // points to the most recently appended element; it doesn't have _Next constructed

  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 748  :     pointer _Head{}; // points to the first appended element; it doesn't have _Prev constructed

  00043	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00047	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 617  :     explicit _List_node_insert_op2(_Alnode& _Al_) : _Al(_Al_), _Added(0) {}

  0004f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00053	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00057	5d		 pop	 rbp
  00058	c3		 ret	 0
??0?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ENDP ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1123 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1124 :     // deallocate a plain pointer using an allocator
; 1125 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1126 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1127 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00020	41 b8 01 00 00
	00		 mov	 r8d, 1
  00026	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  00033	90		 npad	 1

; 1128 :     } else {
; 1129 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1130 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1131 :     }
; 1132 : }

  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
_TEXT	SEGMENT
_Myend$ = 0
_Old$ = 8
_Op$1 = 16
this$ = 128
_First$ = 136
_Last$ = 144
??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z PROC ; std::list<log_,std::allocator<log_> >::_Assign_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >, COMDAT

; 1306 :     void _Assign_unchecked(_Iter _First, const _Sent _Last) {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1307 :         // assign [_First, _Last)
; 1308 :         const auto _Myend = _Mypair._Myval2._Myhead;

  00028	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00033	48 89 45 00	 mov	 QWORD PTR _Myend$[rbp], rax

; 1309 :         auto _Old         = _Myend->_Next;

  00037	48 8b 45 00	 mov	 rax, QWORD PTR _Myend$[rbp]
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 89 45 08	 mov	 QWORD PTR _Old$[rbp], rax
$LN2@Assign_unc:

; 1310 :         for (;;) { // attempt to reuse a node
; 1311 :             if (_First == _Last) {

  00042	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR _Last$[rbp]
  00049	48 8d 8d 88 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  00050	e8 00 00 00 00	 call	 ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator==
  00055	0f b6 c0	 movzx	 eax, al
  00058	85 c0		 test	 eax, eax
  0005a	74 19		 je	 SHORT $LN5@Assign_unc

; 1312 :                 // input sequence exhausted; destroy and deallocate any tail of unneeded nodes
; 1313 :                 _Unchecked_erase(_Old, _Myend);

  0005c	4c 8b 45 00	 mov	 r8, QWORD PTR _Myend$[rbp]
  00060	48 8b 55 08	 mov	 rdx, QWORD PTR _Old$[rbp]
  00064	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006b	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@QEAU32@@Z ; std::list<log_,std::allocator<log_> >::_Unchecked_erase

; 1314 :                 return;

  00070	e9 91 00 00 00	 jmp	 $LN1@Assign_unc
$LN5@Assign_unc:

; 1315 :             }
; 1316 : 
; 1317 :             if (_Old == _Myend) { // no more nodes to reuse, append the rest

  00075	48 8b 45 00	 mov	 rax, QWORD PTR _Myend$[rbp]
  00079	48 39 45 08	 cmp	 QWORD PTR _Old$[rbp], rax
  0007d	75 4f		 jne	 SHORT $LN6@Assign_unc

; 1318 :                 _List_node_insert_op2<_Alnode> _Op(_Getal());

  0007f	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00086	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  0008b	48 8b d0	 mov	 rdx, rax
  0008e	48 8d 4d 10	 lea	 rcx, QWORD PTR _Op$1[rbp]
  00092	e8 00 00 00 00	 call	 ??0?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
  00097	90		 npad	 1

; 1319 :                 _Op._Append_range_unchecked(_STD move(_First), _Last);

  00098	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR _Last$[rbp]
  0009f	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR _First$[rbp]
  000a6	48 8d 4d 10	 lea	 rcx, QWORD PTR _Op$1[rbp]
  000aa	e8 00 00 00 00	 call	 ??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >

; 1320 :                 _Op._Attach_at_end(_Mypair._Myval2);

  000af	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b6	48 8b d0	 mov	 rdx, rax
  000b9	48 8d 4d 10	 lea	 rcx, QWORD PTR _Op$1[rbp]
  000bd	e8 00 00 00 00	 call	 ??$_Attach_at_end@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_at_end<std::_List_simple_types<log_> >
  000c2	90		 npad	 1

; 1321 :                 return;

  000c3	48 8d 4d 10	 lea	 rcx, QWORD PTR _Op$1[rbp]
  000c7	e8 00 00 00 00	 call	 ??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
  000cc	eb 38		 jmp	 SHORT $LN1@Assign_unc
$LN6@Assign_unc:

; 1322 :             }
; 1323 : 
; 1324 :             // reuse the node
; 1325 :             _Old->_Myval = *_First;

  000ce	48 8d 8d 88 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  000d5	e8 00 00 00 00	 call	 ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator*
  000da	48 8b 4d 08	 mov	 rcx, QWORD PTR _Old$[rbp]
  000de	48 83 c1 10	 add	 rcx, 16
  000e2	48 8b d0	 mov	 rdx, rax
  000e5	e8 00 00 00 00	 call	 ??4log_@@QEAAAEAU0@AEBU0@@Z

; 1326 :             _Old         = _Old->_Next;

  000ea	48 8b 45 08	 mov	 rax, QWORD PTR _Old$[rbp]
  000ee	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f1	48 89 45 08	 mov	 QWORD PTR _Old$[rbp], rax

; 1327 :             ++_First;

  000f5	48 8d 8d 88 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  000fc	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator++

; 1328 :         }

  00101	e9 3c ff ff ff	 jmp	 $LN2@Assign_unc
$LN1@Assign_unc:

; 1329 :     }

  00106	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  0010a	5d		 pop	 rbp
  0010b	c3		 ret	 0
??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ENDP ; std::list<log_,std::allocator<log_> >::_Assign_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Myend$ = 0
_Old$ = 8
_Op$1 = 16
this$ = 128
_First$ = 136
_Last$ = 144
?dtor$0@?0???$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA PROC ; `std::list<log_,std::allocator<log_> >::_Assign_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Op$1[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA ENDP ; `std::list<log_,std::allocator<log_> >::_Assign_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
_It$ = 80
??$_Get_unwrapped@AEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> &>, COMDAT

; 1171 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1172 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1173 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1174 :         return _It + 0;
; 1175 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1176 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1177 :     } else {
; 1178 :         return static_cast<_Iter&&>(_It);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _It$[rbp]

; 1179 :     }
; 1180 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Get_unwrapped@AEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >, COMDAT

; 1148 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1149 :     // check that [_First, _Last) forms an iterator range
; 1150 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1151 :         _Verify_range(_First, _Last);
; 1152 :     }
; 1153 : }

  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z
_TEXT	SEGMENT
tv132 = 64
tv130 = 72
this$ = 96
_Al_$ = 104
<_Vals_0>$ = 112
??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > ><log_ const &>, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 55 68	 mov	 rdx, QWORD PTR _Al_$[rbp]
  00029	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002d	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
  00032	90		 npad	 1

; 584  :         this->_Allocate();

  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Allocate

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0003c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 83 c0 10	 add	 rax, 16
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 ??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z ; std::addressof<log_>
  00050	48 89 45 40	 mov	 QWORD PTR tv132[rbp], rax
  00054	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005b	48 89 45 48	 mov	 QWORD PTR tv130[rbp], rax
  0005f	4c 8b 45 70	 mov	 r8, QWORD PTR <_Vals_0>$[rbp]
  00063	48 8b 55 40	 mov	 rdx, QWORD PTR tv132[rbp]
  00067	48 8b 4d 48	 mov	 rcx, QWORD PTR tv130[rbp]
  0006b	e8 00 00 00 00	 call	 ??$construct@Ulog_@@AEBU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@AEBU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::construct<log_,log_ const &>
  00070	90		 npad	 1

; 586  :     }

  00071	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00075	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00079	5d		 pop	 rbp
  0007a	c3		 ret	 0
??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > ><log_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
tv132 = 64
tv130 = 72
this$ = 96
_Al_$ = 104
<_Vals_0>$ = 112
?dtor$0@?0???$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > ><log_ const &>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > ><log_ const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@QEAU32@@Z
_TEXT	SEGMENT
_Insert_after$ = 0
_Result$ = 8
this$ = 96
_Insert_before$ = 104
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@QEAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_Transfer_before, COMDAT

; 597  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 598  :         const pointer _Insert_after = _Insert_before->_Prev;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Insert_before$[rbp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	48 89 45 00	 mov	 QWORD PTR _Insert_after$[rbp], rax

; 599  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  0002c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00030	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00034	48 8d 55 68	 lea	 rdx, QWORD PTR _Insert_before$[rbp]
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &>

; 600  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00040	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00044	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00048	48 83 c0 08	 add	 rax, 8
  0004c	48 8d 55 00	 lea	 rdx, QWORD PTR _Insert_after$[rbp]
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * const &>

; 601  :         const auto _Result    = this->_Ptr;

  00058	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0005c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00060	48 89 45 08	 mov	 QWORD PTR _Result$[rbp], rax

; 602  :         this->_Ptr            = pointer{};

  00064	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00068	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 603  :         _Insert_before->_Prev = _Result;

  00070	48 8b 45 68	 mov	 rax, QWORD PTR _Insert_before$[rbp]
  00074	48 8b 4d 08	 mov	 rcx, QWORD PTR _Result$[rbp]
  00078	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 604  :         _Insert_after->_Next  = _Result;

  0007c	48 8b 45 00	 mov	 rax, QWORD PTR _Insert_after$[rbp]
  00080	48 8b 4d 08	 mov	 rcx, QWORD PTR _Result$[rbp]
  00084	48 89 08	 mov	 QWORD PTR [rax], rcx

; 605  :         return _Result;

  00087	48 8b 45 08	 mov	 rax, QWORD PTR _Result$[rbp]

; 606  :     }

  0008b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0008f	5d		 pop	 rbp
  00090	c3		 ret	 0
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@QEAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv93 = 64
tv91 = 72
this$ = 96
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 589  :         if (this->_Ptr != pointer{}) {

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00024	74 30		 je	 SHORT $LN2@List_node_

; 590  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002e	48 83 c0 10	 add	 rax, 16
  00032	48 8b c8	 mov	 rcx, rax
  00035	e8 00 00 00 00	 call	 ??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z ; std::addressof<log_>
  0003a	48 89 45 40	 mov	 QWORD PTR tv93[rbp], rax
  0003e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	48 89 45 48	 mov	 QWORD PTR tv91[rbp], rax
  00049	48 8b 55 40	 mov	 rdx, QWORD PTR tv93[rbp]
  0004d	48 8b 4d 48	 mov	 rcx, QWORD PTR tv91[rbp]
  00051	e8 00 00 00 00	 call	 ??$destroy@Ulog_@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::destroy<log_>
$LN2@List_node_:

; 591  :         }
; 592  :     }

  00056	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0005a	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
  0005f	90		 npad	 1
  00060	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 64
this$ = 96
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 1159 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1160 :         if (_Ptr) {

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00024	74 23		 je	 SHORT $LN2@Alloc_cons

; 1161 :             _Al.deallocate(_Ptr, 1);

  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 45 40	 mov	 QWORD PTR tv72[rbp], rax
  00031	41 b8 01 00 00
	00		 mov	 r8d, 1
  00037	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0003f	48 8b 4d 40	 mov	 rcx, QWORD PTR tv72[rbp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ; std::allocator<std::_List_node<log_,void *> >::deallocate
  00048	90		 npad	 1
$LN2@Alloc_cons:

; 1162 :         }
; 1163 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 64
this$ = 96
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Allocate, COMDAT

; 1154 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1155 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1156 :         _Ptr = _Al.allocate(1);

  00027	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 89 45 40	 mov	 QWORD PTR tv73[rbp], rax
  00032	ba 01 00 00 00	 mov	 edx, 1
  00037	48 8b 4d 40	 mov	 rcx, QWORD PTR tv73[rbp]
  0003b	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ; std::allocator<std::_List_node<log_,void *> >::allocate
  00040	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00044	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1157 :     }

  00048	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@XZ
_TEXT	SEGMENT
$T1 = 64
this$ = 96
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Release, COMDAT

; 1150 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1151 :         return _STD exchange(_Ptr, nullptr);

  0001b	48 c7 45 40 00
	00 00 00	 mov	 QWORD PTR $T1[rbp], 0
  00023	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 83 c0 08	 add	 rax, 8
  0002b	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 ??$exchange@PEAU?$_List_node@Ulog_@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<log_,void *> *,std::nullptr_t>

; 1152 :     }

  00037	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003b	5d		 pop	 rbp
  0003c	c3		 ret	 0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Al_$ = 88
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 1148 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy@Ulog_@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
??$destroy@Ulog_@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::destroy<log_>, COMDAT

; 728  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 729  : #if _HAS_CXX20
; 730  :         _STD destroy_at(_Ptr);

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00024	e8 00 00 00 00	 call	 ??$destroy_at@Ulog_@@@std@@YAXQEAUlog_@@@Z ; std::destroy_at<log_>

; 731  : #else // _HAS_CXX20
; 732  :         _Ptr->~_Uty();
; 733  : #endif // _HAS_CXX20
; 734  :     }

  00029	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
??$destroy@Ulog_@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::destroy<log_>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z PROC	; std::addressof<log_>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z ENDP	; std::addressof<log_>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0_JU?$ratio@$00$0DOI@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Dur$ = 104
??$?0_JU?$ratio@$00$0DOI@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,0>, COMDAT

; 106  :             : _MyRep(_CHRONO duration_cast<duration>(_Dur).count()) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 55 68	 mov	 rdx, QWORD PTR _Dur$[rbp]
  00024	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00028	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,0>
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00035	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax
  0003c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
??$?0_JU?$ratio@$00$0DOI@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >, COMDAT

; 540  :             is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 541  :         using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
; 542  :         return _RT(_Left.time_since_epoch() - _Right);

  00025	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00029	48 8b 4d 68	 mov	 rcx, QWORD PTR _Left$[rbp]
  0002d	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00032	4c 8b 45 70	 mov	 r8, QWORD PTR _Right$[rbp]
  00036	48 8b d0	 mov	 rdx, rax
  00039	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  0003d	e8 00 00 00 00	 call	 ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
  00042	48 8b d0	 mov	 rdx, rax
  00045	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00049	e8 00 00 00 00	 call	 ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  0004e	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 543  :     }

  00052	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00056	5d		 pop	 rbp
  00057	c3		 ret	 0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?__M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
$T4 = 88
$T5 = 96
$T6 = 97
$T7 = 104
$T8 = 112
$T9 = 113
$T10 = 114
tv72 = 120
_Left$ = 144
_Right$ = 152
??$?__M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z PROC ; std::chrono::operator<=><__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >, COMDAT

; 413  :             is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 414  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 415  :         return _CT(_Left).count() <=> _CT(_Right).count();

  00023	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Left$[rbp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00031	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00035	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  0003a	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0003e	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Right$[rbp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 89 45 58	 mov	 QWORD PTR $T4[rbp], rax
  0004c	48 8d 4d 58	 lea	 rcx, QWORD PTR $T4[rbp]
  00050	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
  00055	48 89 45 50	 mov	 QWORD PTR $T3[rbp], rax
  00059	48 8b 45 50	 mov	 rax, QWORD PTR $T3[rbp]
  0005d	48 39 45 40	 cmp	 QWORD PTR $T1[rbp], rax
  00061	75 13		 jne	 SHORT $LN5@operator
  00063	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?equal@strong_ordering@std@@2U12@B ; std::strong_ordering::equal
  0006a	88 45 60	 mov	 BYTE PTR $T5[rbp], al
  0006d	0f b6 45 60	 movzx	 eax, BYTE PTR $T5[rbp]
  00071	88 45 72	 mov	 BYTE PTR $T10[rbp], al
  00074	eb 49		 jmp	 SHORT $LN6@operator
$LN5@operator:
  00076	48 8b 45 50	 mov	 rax, QWORD PTR $T3[rbp]
  0007a	48 39 45 40	 cmp	 QWORD PTR $T1[rbp], rax
  0007e	7d 14		 jge	 SHORT $LN3@operator
  00080	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?less@strong_ordering@std@@2U12@B ; std::strong_ordering::less
  00087	88 45 70	 mov	 BYTE PTR $T8[rbp], al
  0008a	48 8d 45 70	 lea	 rax, QWORD PTR $T8[rbp]
  0008e	48 89 45 78	 mov	 QWORD PTR tv72[rbp], rax
  00092	eb 12		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00094	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?greater@strong_ordering@std@@2U12@B ; std::strong_ordering::greater
  0009b	88 45 71	 mov	 BYTE PTR $T9[rbp], al
  0009e	48 8d 45 71	 lea	 rax, QWORD PTR $T9[rbp]
  000a2	48 89 45 78	 mov	 QWORD PTR tv72[rbp], rax
$LN4@operator:
  000a6	48 8b 45 78	 mov	 rax, QWORD PTR tv72[rbp]
  000aa	48 89 45 68	 mov	 QWORD PTR $T7[rbp], rax
  000ae	48 8b 45 68	 mov	 rax, QWORD PTR $T7[rbp]
  000b2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b5	88 45 61	 mov	 BYTE PTR $T6[rbp], al
  000b8	0f b6 45 61	 movzx	 eax, BYTE PTR $T6[rbp]
  000bc	88 45 72	 mov	 BYTE PTR $T10[rbp], al
$LN6@operator:
  000bf	0f b6 45 72	 movzx	 eax, BYTE PTR $T10[rbp]

; 416  :     }

  000c3	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  000ca	5d		 pop	 rbp
  000cb	c3		 ret	 0
??$?__M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z ENDP ; std::chrono::operator<=><__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ??$_To_absolute_time@_JU?$ratio@$00$0DOI@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z
_TEXT	SEGMENT
_Zero$ = 0
_Now$ = 8
_Forever$1 = 24
$T2 = 96
$T3 = 97
$T4 = 98
$T5 = 99
$T6 = 100
$T7 = 101
$T8 = 102
$T9 = 104
$T10 = 112
$T11 = 113
$T12 = 114
$T13 = 120
__$ReturnUdt$ = 160
_Rel_time$ = 168
??$_To_absolute_time@_JU?$ratio@$00$0DOI@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z PROC ; std::_To_absolute_time<__int64,std::ratio<1,1000> >, COMDAT

; 161  : _NODISCARD auto _To_absolute_time(const chrono::duration<_Rep, _Period>& _Rel_time) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 162  :     constexpr auto _Zero                 = chrono::duration<_Rep, _Period>::zero();

  00024	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Zero$[rbp], 0

; 163  :     const auto _Now                      = chrono::steady_clock::now();

  0002c	48 8d 4d 08	 lea	 rcx, QWORD PTR _Now$[rbp]
  00030	e8 00 00 00 00	 call	 ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 164  :     decltype(_Now + _Rel_time) _Abs_time = _Now; // return common type

  00035	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0003c	48 8b 4d 08	 mov	 rcx, QWORD PTR _Now$[rbp]
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx

; 165  :     if (_Rel_time > _Zero) {

  00043	48 8d 45 60	 lea	 rax, QWORD PTR $T2[rbp]
  00047	48 8b f8	 mov	 rdi, rax
  0004a	33 c0		 xor	 eax, eax
  0004c	b9 01 00 00 00	 mov	 ecx, 1
  00051	f3 aa		 rep stosb
  00053	0f b6 45 60	 movzx	 eax, BYTE PTR $T2[rbp]
  00057	88 45 62	 mov	 BYTE PTR $T4[rbp], al
  0005a	0f b6 45 62	 movzx	 eax, BYTE PTR $T4[rbp]
  0005e	88 45 64	 mov	 BYTE PTR $T6[rbp], al
  00061	48 8d 55 00	 lea	 rdx, QWORD PTR _Zero$[rbp]
  00065	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR _Rel_time$[rbp]
  0006c	e8 00 00 00 00	 call	 ??$?__M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z ; std::chrono::operator<=><__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
  00071	88 45 61	 mov	 BYTE PTR $T3[rbp], al
  00074	0f b6 45 61	 movzx	 eax, BYTE PTR $T3[rbp]
  00078	88 45 63	 mov	 BYTE PTR $T5[rbp], al
  0007b	0f b6 55 64	 movzx	 edx, BYTE PTR $T6[rbp]
  0007f	0f b6 4d 63	 movzx	 ecx, BYTE PTR $T5[rbp]
  00083	e8 00 00 00 00	 call	 ??Ostd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ; std::operator>
  00088	0f b6 c0	 movzx	 eax, al
  0008b	85 c0		 test	 eax, eax
  0008d	0f 84 9d 00 00
	00		 je	 $LN2@To_absolut

; 166  :         constexpr auto _Forever = (chrono::steady_clock::time_point::max)();

  00093	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0009d	48 89 45 18	 mov	 QWORD PTR _Forever$1[rbp], rax

; 167  :         if (_Abs_time < _Forever - _Rel_time) {

  000a1	48 8d 45 65	 lea	 rax, QWORD PTR $T7[rbp]
  000a5	48 8b f8	 mov	 rdi, rax
  000a8	33 c0		 xor	 eax, eax
  000aa	b9 01 00 00 00	 mov	 ecx, 1
  000af	f3 aa		 rep stosb
  000b1	0f b6 45 65	 movzx	 eax, BYTE PTR $T7[rbp]
  000b5	88 45 70	 mov	 BYTE PTR $T10[rbp], al
  000b8	0f b6 45 70	 movzx	 eax, BYTE PTR $T10[rbp]
  000bc	88 45 72	 mov	 BYTE PTR $T12[rbp], al
  000bf	4c 8b 85 a8 00
	00 00		 mov	 r8, QWORD PTR _Rel_time$[rbp]
  000c6	48 8d 55 18	 lea	 rdx, QWORD PTR _Forever$1[rbp]
  000ca	48 8d 4d 68	 lea	 rcx, QWORD PTR $T9[rbp]
  000ce	e8 00 00 00 00	 call	 ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
  000d3	48 8b d0	 mov	 rdx, rax
  000d6	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000dd	e8 00 00 00 00	 call	 ??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<=><std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  000e2	88 45 66	 mov	 BYTE PTR $T8[rbp], al
  000e5	0f b6 45 66	 movzx	 eax, BYTE PTR $T8[rbp]
  000e9	88 45 71	 mov	 BYTE PTR $T11[rbp], al
  000ec	0f b6 55 72	 movzx	 edx, BYTE PTR $T12[rbp]
  000f0	0f b6 4d 71	 movzx	 ecx, BYTE PTR $T11[rbp]
  000f4	e8 00 00 00 00	 call	 ??Mstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ; std::operator<
  000f9	0f b6 c0	 movzx	 eax, al
  000fc	85 c0		 test	 eax, eax
  000fe	74 22		 je	 SHORT $LN3@To_absolut

; 168  :             _Abs_time += _Rel_time;

  00100	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _Rel_time$[rbp]
  00107	48 8d 4d 78	 lea	 rcx, QWORD PTR $T13[rbp]
  0010b	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$0DOI@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,0>
  00110	48 8d 55 78	 lea	 rdx, QWORD PTR $T13[rbp]
  00114	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0011b	e8 00 00 00 00	 call	 ??Y?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAAAEAV012@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::operator+=

; 169  :         } else {

  00120	eb 0e		 jmp	 SHORT $LN2@To_absolut
$LN3@To_absolut:

; 170  :             _Abs_time = _Forever;

  00122	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00129	48 8b 4d 18	 mov	 rcx, QWORD PTR _Forever$1[rbp]
  0012d	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@To_absolut:

; 171  :         }
; 172  :     }
; 173  :     return _Abs_time;

  00130	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 174  : }

  00137	48 8d a5 88 00
	00 00		 lea	 rsp, QWORD PTR [rbp+136]
  0013e	5f		 pop	 rdi
  0013f	5d		 pop	 rbp
  00140	c3		 ret	 0
??$_To_absolute_time@_JU?$ratio@$00$0DOI@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z ENDP ; std::_To_absolute_time<__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z
_TEXT	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S18$ = 24
_Proxy$ = 32
_New_capacity$1 = 48
_New_ptr$2 = 56
_Guard$ = 64
_Ptr$3 = 72
_Ptr$ = 80
$T4 = 152
$T5 = 153
tv138 = 160
tv136 = 168
this$ = 192
_First$ = 200
_Last$ = 208
_Count$ = 216
??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<wchar_t *,wchar_t *,unsigned __int64>, COMDAT

; 2675 :     _CONSTEXPR20 void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {}) {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2676 :         // Pre: _First models input_iterator or meets the Cpp17InputIterator requirements
; 2677 :         // Pre: [_First, _Last) is a valid range
; 2678 :         // Pre: if is_same_v<_Size, size_type>, _Count is the length of [_First, _Last).
; 2679 :         // Pre: *this is in SSO mode; the lifetime of the SSO elements has already begun
; 2680 : 
; 2681 :         auto& _My_data  = _Mypair._Myval2;

  0002d	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 2682 :         auto& _Al       = _Getal();

  00038	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00044	48 89 45 08	 mov	 QWORD PTR _Al$[rbp], rax

; 2683 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  00048	48 8b 55 08	 mov	 rdx, QWORD PTR _Al$[rbp]
  0004c	48 8d 4d 18	 lea	 rcx, QWORD PTR $S18$[rbp]
  00050	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  00055	48 8d 45 18	 lea	 rax, QWORD PTR $S18$[rbp]
  00059	48 89 45 10	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 2684 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  0005d	4c 8b 45 00	 mov	 r8, QWORD PTR _My_data$[rbp]
  00061	48 8b 55 10	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  00065	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00069	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0006e	90		 npad	 1

; 2685 : 
; 2686 :         _My_data._Mysize = 0;

  0006f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00073	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 2687 :         _My_data._Myres  = _BUF_SIZE - 1;

  0007b	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0007f	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 2688 : 
; 2689 :         if constexpr (is_same_v<_Size, size_type>) {
; 2690 :             if (_Count > max_size()) {

  00087	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0008e	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00093	48 39 85 d8 00
	00 00		 cmp	 QWORD PTR _Count$[rbp], rax
  0009a	76 05		 jbe	 SHORT $LN5@Construct_

; 2691 :                 _Xlen_string(); // result too long

  0009c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN5@Construct_:

; 2692 :             }
; 2693 : 
; 2694 :             if (_Count >= _BUF_SIZE) {

  000a1	48 83 bd d8 00
	00 00 10	 cmp	 QWORD PTR _Count$[rbp], 16
  000a9	0f 82 8f 00 00
	00		 jb	 $LN6@Construct_

; 2695 :                 size_type _New_capacity = _Calculate_growth(_Count);

  000af	48 8b 95 d8 00
	00 00		 mov	 rdx, QWORD PTR _Count$[rbp]
  000b6	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000bd	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  000c2	48 89 45 30	 mov	 QWORD PTR _New_capacity$1[rbp], rax

; 2696 :                 ++_New_capacity;

  000c6	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$1[rbp]
  000ca	48 ff c0	 inc	 rax
  000cd	48 89 45 30	 mov	 QWORD PTR _New_capacity$1[rbp], rax

; 2697 :                 const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  000d1	48 8d 55 30	 lea	 rdx, QWORD PTR _New_capacity$1[rbp]
  000d5	48 8b 4d 08	 mov	 rcx, QWORD PTR _Al$[rbp]
  000d9	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  000de	48 89 45 38	 mov	 QWORD PTR _New_ptr$2[rbp], rax

; 2698 :                 --_New_capacity;

  000e2	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$1[rbp]
  000e6	48 ff c8	 dec	 rax
  000e9	48 89 45 30	 mov	 QWORD PTR _New_capacity$1[rbp], rax

; 2699 :                 _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000ed	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000f1	48 83 c0 08	 add	 rax, 8
  000f5	48 8d 55 38	 lea	 rdx, QWORD PTR _New_ptr$2[rbp]
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2700 :                 _My_data._Myres = _New_capacity;

  00101	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00105	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_capacity$1[rbp]
  00109	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2701 : 
; 2702 :                 _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  0010d	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$1[rbp]
  00111	48 ff c0	 inc	 rax
  00114	48 89 85 a0 00
	00 00		 mov	 QWORD PTR tv138[rbp], rax
  0011b	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$2[rbp]
  0011f	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00124	48 89 85 a8 00
	00 00		 mov	 QWORD PTR tv136[rbp], rax
  0012b	48 8b 95 a0 00
	00 00		 mov	 rdx, QWORD PTR tv138[rbp]
  00132	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR tv136[rbp]
  00139	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes
$LN6@Construct_:

; 2703 :             }
; 2704 :         }
; 2705 : 
; 2706 :         _Tidy_deallocate_guard<basic_string> _Guard{this};

  0013e	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00145	48 89 45 40	 mov	 QWORD PTR _Guard$[rbp], rax

; 2707 :         for (; _First != _Last; ++_First) {

  00149	eb 12		 jmp	 SHORT $LN4@Construct_
$LN2@Construct_:
  0014b	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  00152	48 83 c0 02	 add	 rax, 2
  00156	48 89 85 c8 00
	00 00		 mov	 QWORD PTR _First$[rbp], rax
$LN4@Construct_:
  0015d	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00164	48 39 85 c8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  0016b	74 53		 je	 SHORT $LN3@Construct_

; 2708 :             if constexpr (!is_same_v<_Size, size_type>) {
; 2709 :                 if (_My_data._Mysize == _My_data._Myres) { // Need to grow
; 2710 :                     if (_My_data._Mysize == max_size()) {
; 2711 :                         _Xlen_string(); // result too long
; 2712 :                     }
; 2713 : 
; 2714 :                     const auto _Old_ptr     = _My_data._Myptr();
; 2715 :                     size_type _New_capacity = _Calculate_growth(_My_data._Mysize);
; 2716 :                     ++_New_capacity;
; 2717 :                     const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws
; 2718 :                     --_New_capacity;
; 2719 : 
; 2720 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2721 :                     _Traits::copy(_Unfancy(_New_ptr), _Old_ptr, _My_data._Mysize);
; 2722 :                     if (_My_data._Myres >= _BUF_SIZE) { // Need to deallocate old storage
; 2723 :                         _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
; 2724 :                         _My_data._Bx._Ptr = _New_ptr;
; 2725 :                     } else {
; 2726 :                         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 2727 :                     }
; 2728 :                     _My_data._Myres = _New_capacity;
; 2729 :                 }
; 2730 :             }
; 2731 : 
; 2732 :             _Elem* const _Ptr = _My_data._Myptr();

  0016d	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00171	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00176	48 89 45 48	 mov	 QWORD PTR _Ptr$3[rbp], rax

; 2733 :             _Traits::assign(_Ptr[_My_data._Mysize], *_First);

  0017a	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  00181	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00184	88 85 98 00 00
	00		 mov	 BYTE PTR $T4[rbp], al
  0018a	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0018e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00192	48 8b 4d 48	 mov	 rcx, QWORD PTR _Ptr$3[rbp]
  00196	48 03 c8	 add	 rcx, rax
  00199	48 8b c1	 mov	 rax, rcx
  0019c	48 8d 95 98 00
	00 00		 lea	 rdx, QWORD PTR $T4[rbp]
  001a3	48 8b c8	 mov	 rcx, rax
  001a6	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2734 :             ++_My_data._Mysize;

  001ab	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001af	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001b3	48 ff c0	 inc	 rax
  001b6	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  001ba	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 2735 :         }

  001be	eb 8b		 jmp	 SHORT $LN2@Construct_
$LN3@Construct_:

; 2736 : 
; 2737 :         _Elem* const _Ptr = _My_data._Myptr();

  001c0	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  001c4	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  001c9	48 89 45 50	 mov	 QWORD PTR _Ptr$[rbp], rax

; 2738 :         _Traits::assign(_Ptr[_My_data._Mysize], _Elem());

  001cd	c6 85 99 00 00
	00 00		 mov	 BYTE PTR $T5[rbp], 0
  001d4	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001d8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001dc	48 8b 4d 50	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  001e0	48 03 c8	 add	 rcx, rax
  001e3	48 8b c1	 mov	 rax, rcx
  001e6	48 8d 95 99 00
	00 00		 lea	 rdx, QWORD PTR $T5[rbp]
  001ed	48 8b c8	 mov	 rcx, rax
  001f0	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2739 :         _ASAN_STRING_CREATE(*this);
; 2740 :         _Guard._Target = nullptr;

  001f5	48 c7 45 40 00
	00 00 00	 mov	 QWORD PTR _Guard$[rbp], 0

; 2741 :         _Proxy._Release();

  001fd	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00201	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2742 :     }

  00206	48 8d 4d 40	 lea	 rcx, QWORD PTR _Guard$[rbp]
  0020a	e8 00 00 00 00	 call	 ??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0020f	90		 npad	 1
  00210	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00214	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00219	48 8d a5 b0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+176]
  00220	5d		 pop	 rbp
  00221	c3		 ret	 0
$LN10@Construct_:
??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<wchar_t *,wchar_t *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S18$ = 24
_Proxy$ = 32
_New_capacity$1 = 48
_New_ptr$2 = 56
_Guard$ = 64
_Ptr$3 = 72
_Ptr$ = 80
$T4 = 152
$T5 = 153
tv138 = 160
tv136 = 168
this$ = 192
_First$ = 200
_Last$ = 208
_Count$ = 216
?dtor$0@?0???$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<wchar_t *,wchar_t *,unsigned __int64>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<wchar_t *,wchar_t *,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$distance@PEA_W@std@@YA_JPEA_W0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$distance@PEA_W@std@@YA_JPEA_W0@Z PROC		; std::distance<wchar_t *>, COMDAT

; 1436 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1437 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1438 :         return _Last - _First; // assume the iterator will do debug checking

  00020	48 8b 45 50	 mov	 rax, QWORD PTR _First$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Last$[rbp]
  00028	48 2b c8	 sub	 rcx, rax
  0002b	48 8b c1	 mov	 rax, rcx
  0002e	48 d1 f8	 sar	 rax, 1

; 1439 :     } else {
; 1440 :         _Adl_verify_range(_First, _Last);
; 1441 :         auto _UFirst             = _Get_unwrapped(_First);
; 1442 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1443 :         _Iter_diff_t<_InIt> _Off = 0;
; 1444 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1445 :             ++_Off;
; 1446 :         }
; 1447 : 
; 1448 :         return _Off;
; 1449 :     }
; 1450 : }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
??$distance@PEA_W@std@@YA_JPEA_W0@Z ENDP		; std::distance<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 80
??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &>, COMDAT

; 1171 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1172 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1173 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1174 :         return _It + 0;
; 1175 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1176 :         return static_cast<_Iter&&>(_It)._Unwrapped();

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR _It$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped

; 1177 :     } else {
; 1178 :         return static_cast<_Iter&&>(_It);
; 1179 :     }
; 1180 : }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >, COMDAT

; 1148 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1149 :     // check that [_First, _Last) forms an iterator range
; 1150 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1151 :         _Verify_range(_First, _Last);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Last$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR _First$[rbp]
  00028	e8 00 00 00 00	 call	 ?_Verify_range@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; std::_Verify_range

; 1152 :     }
; 1153 : }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
_Val1$ = 96
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT

; 1524 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z
_TEXT	SEGMENT
_Now$1 = 0
_Tgt$2 = 8
$T3 = 88
$T4 = 89
$T5 = 90
$T6 = 91
$T7 = 92
$T8 = 96
_Abs_time$ = 144
??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z PROC ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 184  :     void sleep_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@sleep_unti:

; 185  : #if _HAS_CXX20
; 186  :         static_assert(chrono::is_clock_v<_Clock>, "Clock type required");
; 187  : #endif // _HAS_CXX20
; 188  :         for (;;) {
; 189  :             const auto _Now = _Clock::now();

  0001f	48 8d 4d 00	 lea	 rcx, QWORD PTR _Now$1[rbp]
  00023	e8 00 00 00 00	 call	 ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 190  :             if (_Abs_time <= _Now) {

  00028	48 8d 45 58	 lea	 rax, QWORD PTR $T3[rbp]
  0002c	48 8b f8	 mov	 rdi, rax
  0002f	33 c0		 xor	 eax, eax
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	f3 aa		 rep stosb
  00038	0f b6 45 58	 movzx	 eax, BYTE PTR $T3[rbp]
  0003c	88 45 5a	 mov	 BYTE PTR $T5[rbp], al
  0003f	0f b6 45 5a	 movzx	 eax, BYTE PTR $T5[rbp]
  00043	88 45 5c	 mov	 BYTE PTR $T7[rbp], al
  00046	48 8d 55 00	 lea	 rdx, QWORD PTR _Now$1[rbp]
  0004a	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Abs_time$[rbp]
  00051	e8 00 00 00 00	 call	 ??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<=><std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  00056	88 45 59	 mov	 BYTE PTR $T4[rbp], al
  00059	0f b6 45 59	 movzx	 eax, BYTE PTR $T4[rbp]
  0005d	88 45 5b	 mov	 BYTE PTR $T6[rbp], al
  00060	0f b6 55 5c	 movzx	 edx, BYTE PTR $T7[rbp]
  00064	0f b6 4d 5b	 movzx	 ecx, BYTE PTR $T6[rbp]
  00068	e8 00 00 00 00	 call	 ??Nstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ; std::operator<=
  0006d	0f b6 c0	 movzx	 eax, al
  00070	85 c0		 test	 eax, eax
  00072	74 02		 je	 SHORT $LN5@sleep_unti

; 191  :                 return;

  00074	eb 2e		 jmp	 SHORT $LN1@sleep_unti
$LN5@sleep_unti:

; 192  :             }
; 193  : 
; 194  :             _timespec64 _Tgt;
; 195  :             (void) _To_timespec64_sys_10_day_clamped(_Tgt, _Abs_time - _Now);

  00076	4c 8d 45 00	 lea	 r8, QWORD PTR _Now$1[rbp]
  0007a	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR _Abs_time$[rbp]
  00081	48 8d 4d 60	 lea	 rcx, QWORD PTR $T8[rbp]
  00085	e8 00 00 00 00	 call	 ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  0008a	48 8b d0	 mov	 rdx, rax
  0008d	48 8d 4d 08	 lea	 rcx, QWORD PTR _Tgt$2[rbp]
  00091	e8 00 00 00 00	 call	 ??$_To_timespec64_sys_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAEAU_timespec64@@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ; std::_To_timespec64_sys_10_day_clamped<__int64,std::ratio<1,1000000000> >

; 196  :             _Thrd_sleep(&_Tgt);

  00096	48 8d 4d 08	 lea	 rcx, QWORD PTR _Tgt$2[rbp]
  0009a	e8 00 00 00 00	 call	 _Thrd_sleep

; 197  :         }

  0009f	e9 7b ff ff ff	 jmp	 $LN2@sleep_unti
$LN1@sleep_unti:

; 198  :     }

  000a4	48 8d 65 78	 lea	 rsp, QWORD PTR [rbp+120]
  000a8	5f		 pop	 rdi
  000a9	5d		 pop	 rbp
  000aa	c3		 ret	 0
??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ENDP ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0_JU?$ratio@$00$0PECEA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Dur$ = 104
??$?0_JU?$ratio@$00$0PECEA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000>,0>, COMDAT

; 106  :             : _MyRep(_CHRONO duration_cast<duration>(_Dur).count()) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 55 68	 mov	 rdx, QWORD PTR _Dur$[rbp]
  00024	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00028	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0PECEA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000>,0>
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00035	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax
  0003c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
??$?0_JU?$ratio@$00$0PECEA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
tv76 = 88
tv74 = 96
_Left$ = 128
_Right$ = 136
??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator<=><std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 600  :             is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 601  :         return _Left.time_since_epoch() <=> _Right.time_since_epoch();

  00023	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  00027	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  0002e	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00033	48 89 45 58	 mov	 QWORD PTR tv76[rbp], rax
  00037	48 8d 55 50	 lea	 rdx, QWORD PTR $T3[rbp]
  0003b	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR _Left$[rbp]
  00042	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00047	48 89 45 60	 mov	 QWORD PTR tv74[rbp], rax
  0004b	48 8b 55 58	 mov	 rdx, QWORD PTR tv76[rbp]
  0004f	48 8b 4d 60	 mov	 rcx, QWORD PTR tv74[rbp]
  00053	e8 00 00 00 00	 call	 ??$?__M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ; std::chrono::operator<=><__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
  00058	88 45 40	 mov	 BYTE PTR $T1[rbp], al
  0005b	0f b6 45 40	 movzx	 eax, BYTE PTR $T1[rbp]

; 602  :     }

  0005f	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator<=><std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?__M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
$T4 = 88
$T5 = 96
$T6 = 97
$T7 = 104
$T8 = 112
$T9 = 113
$T10 = 114
tv72 = 120
_Left$ = 144
_Right$ = 152
??$?__M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z PROC ; std::chrono::operator<=><__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 413  :             is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 414  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 415  :         return _CT(_Left).count() <=> _CT(_Right).count();

  00023	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Left$[rbp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00031	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00035	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  0003a	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0003e	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Right$[rbp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 89 45 58	 mov	 QWORD PTR $T4[rbp], rax
  0004c	48 8d 4d 58	 lea	 rcx, QWORD PTR $T4[rbp]
  00050	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00055	48 89 45 50	 mov	 QWORD PTR $T3[rbp], rax
  00059	48 8b 45 50	 mov	 rax, QWORD PTR $T3[rbp]
  0005d	48 39 45 40	 cmp	 QWORD PTR $T1[rbp], rax
  00061	75 13		 jne	 SHORT $LN5@operator
  00063	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?equal@strong_ordering@std@@2U12@B ; std::strong_ordering::equal
  0006a	88 45 60	 mov	 BYTE PTR $T5[rbp], al
  0006d	0f b6 45 60	 movzx	 eax, BYTE PTR $T5[rbp]
  00071	88 45 72	 mov	 BYTE PTR $T10[rbp], al
  00074	eb 49		 jmp	 SHORT $LN6@operator
$LN5@operator:
  00076	48 8b 45 50	 mov	 rax, QWORD PTR $T3[rbp]
  0007a	48 39 45 40	 cmp	 QWORD PTR $T1[rbp], rax
  0007e	7d 14		 jge	 SHORT $LN3@operator
  00080	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?less@strong_ordering@std@@2U12@B ; std::strong_ordering::less
  00087	88 45 70	 mov	 BYTE PTR $T8[rbp], al
  0008a	48 8d 45 70	 lea	 rax, QWORD PTR $T8[rbp]
  0008e	48 89 45 78	 mov	 QWORD PTR tv72[rbp], rax
  00092	eb 12		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00094	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?greater@strong_ordering@std@@2U12@B ; std::strong_ordering::greater
  0009b	88 45 71	 mov	 BYTE PTR $T9[rbp], al
  0009e	48 8d 45 71	 lea	 rax, QWORD PTR $T9[rbp]
  000a2	48 89 45 78	 mov	 QWORD PTR tv72[rbp], rax
$LN4@operator:
  000a6	48 8b 45 78	 mov	 rax, QWORD PTR tv72[rbp]
  000aa	48 89 45 68	 mov	 QWORD PTR $T7[rbp], rax
  000ae	48 8b 45 68	 mov	 rax, QWORD PTR $T7[rbp]
  000b2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b5	88 45 61	 mov	 BYTE PTR $T6[rbp], al
  000b8	0f b6 45 61	 movzx	 eax, BYTE PTR $T6[rbp]
  000bc	88 45 72	 mov	 BYTE PTR $T10[rbp], al
$LN6@operator:
  000bf	0f b6 45 72	 movzx	 eax, BYTE PTR $T10[rbp]

; 416  :     }

  000c3	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  000ca	5d		 pop	 rbp
  000cb	c3		 ret	 0
??$?__M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ENDP ; std::chrono::operator<=><__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0PECEA@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0PECEA@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000> >, COMDAT

; 540  :             is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 541  :         using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
; 542  :         return _RT(_Left.time_since_epoch() - _Right);

  00025	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00029	48 8b 4d 68	 mov	 rcx, QWORD PTR _Left$[rbp]
  0002d	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00032	4c 8b 45 70	 mov	 r8, QWORD PTR _Right$[rbp]
  00036	48 8b d0	 mov	 rdx, rax
  00039	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  0003d	e8 00 00 00 00	 call	 ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0PECEA@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000> >
  00042	48 8b d0	 mov	 rdx, rax
  00045	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00049	e8 00 00 00 00	 call	 ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  0004e	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 543  :     }

  00052	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00056	5d		 pop	 rbp
  00057	c3		 ret	 0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0PECEA@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?__M_JU?$ratio@$00$0PECEA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@0@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
$T3 = 80
$T4 = 88
$T5 = 96
$T6 = 97
$T7 = 104
$T8 = 112
$T9 = 113
$T10 = 114
tv72 = 120
_Left$ = 144
_Right$ = 152
??$?__M_JU?$ratio@$00$0PECEA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@0@Z PROC ; std::chrono::operator<=><__int64,std::ratio<1,1000000>,__int64,std::ratio<1,1000000> >, COMDAT

; 413  :             is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 414  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 415  :         return _CT(_Left).count() <=> _CT(_Right).count();

  00023	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Left$[rbp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00031	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00035	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
  0003a	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0003e	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Right$[rbp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 89 45 58	 mov	 QWORD PTR $T4[rbp], rax
  0004c	48 8d 4d 58	 lea	 rcx, QWORD PTR $T4[rbp]
  00050	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
  00055	48 89 45 50	 mov	 QWORD PTR $T3[rbp], rax
  00059	48 8b 45 50	 mov	 rax, QWORD PTR $T3[rbp]
  0005d	48 39 45 40	 cmp	 QWORD PTR $T1[rbp], rax
  00061	75 13		 jne	 SHORT $LN5@operator
  00063	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?equal@strong_ordering@std@@2U12@B ; std::strong_ordering::equal
  0006a	88 45 60	 mov	 BYTE PTR $T5[rbp], al
  0006d	0f b6 45 60	 movzx	 eax, BYTE PTR $T5[rbp]
  00071	88 45 72	 mov	 BYTE PTR $T10[rbp], al
  00074	eb 49		 jmp	 SHORT $LN6@operator
$LN5@operator:
  00076	48 8b 45 50	 mov	 rax, QWORD PTR $T3[rbp]
  0007a	48 39 45 40	 cmp	 QWORD PTR $T1[rbp], rax
  0007e	7d 14		 jge	 SHORT $LN3@operator
  00080	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?less@strong_ordering@std@@2U12@B ; std::strong_ordering::less
  00087	88 45 70	 mov	 BYTE PTR $T8[rbp], al
  0008a	48 8d 45 70	 lea	 rax, QWORD PTR $T8[rbp]
  0008e	48 89 45 78	 mov	 QWORD PTR tv72[rbp], rax
  00092	eb 12		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00094	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?greater@strong_ordering@std@@2U12@B ; std::strong_ordering::greater
  0009b	88 45 71	 mov	 BYTE PTR $T9[rbp], al
  0009e	48 8d 45 71	 lea	 rax, QWORD PTR $T9[rbp]
  000a2	48 89 45 78	 mov	 QWORD PTR tv72[rbp], rax
$LN4@operator:
  000a6	48 8b 45 78	 mov	 rax, QWORD PTR tv72[rbp]
  000aa	48 89 45 68	 mov	 QWORD PTR $T7[rbp], rax
  000ae	48 8b 45 68	 mov	 rax, QWORD PTR $T7[rbp]
  000b2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b5	88 45 61	 mov	 BYTE PTR $T6[rbp], al
  000b8	0f b6 45 61	 movzx	 eax, BYTE PTR $T6[rbp]
  000bc	88 45 72	 mov	 BYTE PTR $T10[rbp], al
$LN6@operator:
  000bf	0f b6 45 72	 movzx	 eax, BYTE PTR $T10[rbp]

; 416  :     }

  000c3	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  000ca	5d		 pop	 rbp
  000cb	c3		 ret	 0
??$?__M_JU?$ratio@$00$0PECEA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@0@Z ENDP ; std::chrono::operator<=><__int64,std::ratio<1,1000000>,__int64,std::ratio<1,1000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ??$_To_absolute_time@_JU?$ratio@$00$0PECEA@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@0@@Z
_TEXT	SEGMENT
_Zero$ = 0
_Now$ = 8
_Forever$1 = 24
$T2 = 96
$T3 = 97
$T4 = 98
$T5 = 99
$T6 = 100
$T7 = 101
$T8 = 102
$T9 = 104
$T10 = 112
$T11 = 113
$T12 = 114
$T13 = 120
__$ReturnUdt$ = 160
_Rel_time$ = 168
??$_To_absolute_time@_JU?$ratio@$00$0PECEA@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@0@@Z PROC ; std::_To_absolute_time<__int64,std::ratio<1,1000000> >, COMDAT

; 161  : _NODISCARD auto _To_absolute_time(const chrono::duration<_Rep, _Period>& _Rel_time) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 162  :     constexpr auto _Zero                 = chrono::duration<_Rep, _Period>::zero();

  00024	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Zero$[rbp], 0

; 163  :     const auto _Now                      = chrono::steady_clock::now();

  0002c	48 8d 4d 08	 lea	 rcx, QWORD PTR _Now$[rbp]
  00030	e8 00 00 00 00	 call	 ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 164  :     decltype(_Now + _Rel_time) _Abs_time = _Now; // return common type

  00035	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0003c	48 8b 4d 08	 mov	 rcx, QWORD PTR _Now$[rbp]
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx

; 165  :     if (_Rel_time > _Zero) {

  00043	48 8d 45 60	 lea	 rax, QWORD PTR $T2[rbp]
  00047	48 8b f8	 mov	 rdi, rax
  0004a	33 c0		 xor	 eax, eax
  0004c	b9 01 00 00 00	 mov	 ecx, 1
  00051	f3 aa		 rep stosb
  00053	0f b6 45 60	 movzx	 eax, BYTE PTR $T2[rbp]
  00057	88 45 62	 mov	 BYTE PTR $T4[rbp], al
  0005a	0f b6 45 62	 movzx	 eax, BYTE PTR $T4[rbp]
  0005e	88 45 64	 mov	 BYTE PTR $T6[rbp], al
  00061	48 8d 55 00	 lea	 rdx, QWORD PTR _Zero$[rbp]
  00065	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR _Rel_time$[rbp]
  0006c	e8 00 00 00 00	 call	 ??$?__M_JU?$ratio@$00$0PECEA@@std@@_JU01@@chrono@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@0@Z ; std::chrono::operator<=><__int64,std::ratio<1,1000000>,__int64,std::ratio<1,1000000> >
  00071	88 45 61	 mov	 BYTE PTR $T3[rbp], al
  00074	0f b6 45 61	 movzx	 eax, BYTE PTR $T3[rbp]
  00078	88 45 63	 mov	 BYTE PTR $T5[rbp], al
  0007b	0f b6 55 64	 movzx	 edx, BYTE PTR $T6[rbp]
  0007f	0f b6 4d 63	 movzx	 ecx, BYTE PTR $T5[rbp]
  00083	e8 00 00 00 00	 call	 ??Ostd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ; std::operator>
  00088	0f b6 c0	 movzx	 eax, al
  0008b	85 c0		 test	 eax, eax
  0008d	0f 84 9d 00 00
	00		 je	 $LN2@To_absolut

; 166  :         constexpr auto _Forever = (chrono::steady_clock::time_point::max)();

  00093	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0009d	48 89 45 18	 mov	 QWORD PTR _Forever$1[rbp], rax

; 167  :         if (_Abs_time < _Forever - _Rel_time) {

  000a1	48 8d 45 65	 lea	 rax, QWORD PTR $T7[rbp]
  000a5	48 8b f8	 mov	 rdi, rax
  000a8	33 c0		 xor	 eax, eax
  000aa	b9 01 00 00 00	 mov	 ecx, 1
  000af	f3 aa		 rep stosb
  000b1	0f b6 45 65	 movzx	 eax, BYTE PTR $T7[rbp]
  000b5	88 45 70	 mov	 BYTE PTR $T10[rbp], al
  000b8	0f b6 45 70	 movzx	 eax, BYTE PTR $T10[rbp]
  000bc	88 45 72	 mov	 BYTE PTR $T12[rbp], al
  000bf	4c 8b 85 a8 00
	00 00		 mov	 r8, QWORD PTR _Rel_time$[rbp]
  000c6	48 8d 55 18	 lea	 rdx, QWORD PTR _Forever$1[rbp]
  000ca	48 8d 4d 68	 lea	 rcx, QWORD PTR $T9[rbp]
  000ce	e8 00 00 00 00	 call	 ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0PECEA@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@AEBV201@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000> >
  000d3	48 8b d0	 mov	 rdx, rax
  000d6	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000dd	e8 00 00 00 00	 call	 ??$?__MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?A_PAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<=><std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  000e2	88 45 66	 mov	 BYTE PTR $T8[rbp], al
  000e5	0f b6 45 66	 movzx	 eax, BYTE PTR $T8[rbp]
  000e9	88 45 71	 mov	 BYTE PTR $T11[rbp], al
  000ec	0f b6 55 72	 movzx	 edx, BYTE PTR $T12[rbp]
  000f0	0f b6 4d 71	 movzx	 ecx, BYTE PTR $T11[rbp]
  000f4	e8 00 00 00 00	 call	 ??Mstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ; std::operator<
  000f9	0f b6 c0	 movzx	 eax, al
  000fc	85 c0		 test	 eax, eax
  000fe	74 22		 je	 SHORT $LN3@To_absolut

; 168  :             _Abs_time += _Rel_time;

  00100	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _Rel_time$[rbp]
  00107	48 8d 4d 78	 lea	 rcx, QWORD PTR $T13[rbp]
  0010b	e8 00 00 00 00	 call	 ??$?0_JU?$ratio@$00$0PECEA@@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000>,0>
  00110	48 8d 55 78	 lea	 rdx, QWORD PTR $T13[rbp]
  00114	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0011b	e8 00 00 00 00	 call	 ??Y?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAAAEAV012@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::operator+=

; 169  :         } else {

  00120	eb 0e		 jmp	 SHORT $LN2@To_absolut
$LN3@To_absolut:

; 170  :             _Abs_time = _Forever;

  00122	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00129	48 8b 4d 18	 mov	 rcx, QWORD PTR _Forever$1[rbp]
  0012d	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@To_absolut:

; 171  :         }
; 172  :     }
; 173  :     return _Abs_time;

  00130	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 174  : }

  00137	48 8d a5 88 00
	00 00		 lea	 rsp, QWORD PTR [rbp+136]
  0013e	5f		 pop	 rdi
  0013f	5d		 pop	 rbp
  00140	c3		 ret	 0
??$_To_absolute_time@_JU?$ratio@$00$0PECEA@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@0@@Z ENDP ; std::_To_absolute_time<__int64,std::ratio<1,1000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 80
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 128  :         explicit __CLR_OR_THIS_CALL operator bool() const {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DF087383_ostream
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 129  :             return _Ok;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]

; 130  :         }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Zero_uncaught_exceptions$ = 0
tv71 = 65
this$ = 96
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 113  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DF087383_ostream
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 114  : #if !_HAS_EXCEPTIONS
; 115  :             const bool _Zero_uncaught_exceptions = true;
; 116  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 118  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 119  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

  0001b	e8 00 00 00 00	 call	 ?uncaught_exceptions@std@@YAHXZ ; std::uncaught_exceptions
  00020	85 c0		 test	 eax, eax
  00022	75 06		 jne	 SHORT $LN4@sentry
  00024	c6 45 41 01	 mov	 BYTE PTR tv71[rbp], 1
  00028	eb 04		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  0002a	c6 45 41 00	 mov	 BYTE PTR tv71[rbp], 0
$LN5@sentry:
  0002e	0f b6 45 41	 movzx	 eax, BYTE PTR tv71[rbp]
  00032	88 45 00	 mov	 BYTE PTR _Zero_uncaught_exceptions$[rbp], al

; 120  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 121  : 
; 122  :             if (_Zero_uncaught_exceptions) {

  00035	0f b6 45 00	 movzx	 eax, BYTE PTR _Zero_uncaught_exceptions$[rbp]
  00039	85 c0		 test	 eax, eax
  0003b	74 0d		 je	 SHORT $LN2@sentry

; 123  :                 this->_Myostr._Osfx();

  0003d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
$LN2@sentry:

; 124  :             }
; 125  :         }

  0004a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0004e	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00053	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00057	5d		 pop	 rbp
  00058	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Tied$ = 0
this$ = 96
_Ostr$ = 104
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 96   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DF087383_ostream
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 55 68	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00024	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  0002d	90		 npad	 1

; 97   :             if (!_Ostr.good()) {

  0002e	48 8b 45 68	 mov	 rax, QWORD PTR _Ostr$[rbp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00039	48 8b 4d 68	 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0003d	48 03 c8	 add	 rcx, rax
  00040	48 8b c1	 mov	 rax, rcx
  00043	48 8b c8	 mov	 rcx, rax
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
  0004c	0f b6 c0	 movzx	 eax, al
  0004f	85 c0		 test	 eax, eax
  00051	75 0a		 jne	 SHORT $LN2@sentry

; 98   :                 _Ok = false;

  00053	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00057	c6 40 08 00	 mov	 BYTE PTR [rax+8], 0

; 99   :                 return;

  0005b	eb 6c		 jmp	 SHORT $LN1@sentry
$LN2@sentry:

; 100  :             }
; 101  : 
; 102  :             const auto _Tied = _Ostr.tie();

  0005d	48 8b 45 68	 mov	 rax, QWORD PTR _Ostr$[rbp]
  00061	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00064	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00068	48 8b 4d 68	 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0006c	48 03 c8	 add	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	48 8b c8	 mov	 rcx, rax
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0007b	48 89 45 00	 mov	 QWORD PTR _Tied$[rbp], rax

; 103  :             if (!_Tied || _Tied == &_Ostr) {

  0007f	48 83 7d 00 00	 cmp	 QWORD PTR _Tied$[rbp], 0
  00084	74 0a		 je	 SHORT $LN4@sentry
  00086	48 8b 45 68	 mov	 rax, QWORD PTR _Ostr$[rbp]
  0008a	48 39 45 00	 cmp	 QWORD PTR _Tied$[rbp], rax
  0008e	75 0a		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 104  :                 _Ok = true;

  00090	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00094	c6 40 08 01	 mov	 BYTE PTR [rax+8], 1

; 105  :                 return;

  00098	eb 2f		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 106  :             }
; 107  : 
; 108  :             _Tied->flush();

  0009a	48 8b 4d 00	 mov	 rcx, QWORD PTR _Tied$[rbp]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 109  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000a4	48 8b 45 68	 mov	 rax, QWORD PTR _Ostr$[rbp]
  000a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ab	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000af	48 8b 4d 68	 mov	 rcx, QWORD PTR _Ostr$[rbp]
  000b3	48 03 c8	 add	 rcx, rax
  000b6	48 8b c1	 mov	 rax, rcx
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
  000c2	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  000c6	88 41 08	 mov	 BYTE PTR [rcx+8], al
$LN1@sentry:

; 110  :         }

  000c9	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000cd	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000d1	5d		 pop	 rbp
  000d2	c3		 ret	 0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Tied$ = 0
this$ = 96
_Ostr$ = 104
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 0
tv72 = 72
this$ = 96
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 82   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DF087383_ostream
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 83   :             const auto _Rdbuf = _Myostr.rdbuf();

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 89 45 48	 mov	 QWORD PTR tv72[rbp], rax
  00026	48 8b 45 48	 mov	 rax, QWORD PTR tv72[rbp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00031	48 8b 4d 48	 mov	 rcx, QWORD PTR tv72[rbp]
  00035	48 03 c8	 add	 rcx, rax
  00038	48 8b c1	 mov	 rax, rcx
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00044	48 89 45 00	 mov	 QWORD PTR _Rdbuf$[rbp], rax

; 84   :             if (_Rdbuf) {

  00048	48 83 7d 00 00	 cmp	 QWORD PTR _Rdbuf$[rbp], 0
  0004d	74 0f		 je	 SHORT $LN2@Sentry_bas

; 85   :                 _Rdbuf->_Unlock();

  0004f	48 8b 45 00	 mov	 rax, QWORD PTR _Rdbuf$[rbp]
  00053	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00056	48 8b 4d 00	 mov	 rcx, QWORD PTR _Rdbuf$[rbp]
  0005a	ff 50 10	 call	 QWORD PTR [rax+16]
  0005d	90		 npad	 1
$LN2@Sentry_bas:

; 86   :             }
; 87   :         }

  0005e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00062	5d		 pop	 rbp
  00063	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 0
tv73 = 72
this$ = 96
_Ostr$ = 104
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 75   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DF087383_ostream
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 68	 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx

; 76   :             const auto _Rdbuf = _Myostr.rdbuf();

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 89 45 48	 mov	 QWORD PTR tv73[rbp], rax
  00036	48 8b 45 48	 mov	 rax, QWORD PTR tv73[rbp]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00041	48 8b 4d 48	 mov	 rcx, QWORD PTR tv73[rbp]
  00045	48 03 c8	 add	 rcx, rax
  00048	48 8b c1	 mov	 rax, rcx
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00054	48 89 45 00	 mov	 QWORD PTR _Rdbuf$[rbp], rax

; 77   :             if (_Rdbuf) {

  00058	48 83 7d 00 00	 cmp	 QWORD PTR _Rdbuf$[rbp], 0
  0005d	74 0e		 je	 SHORT $LN2@Sentry_bas

; 78   :                 _Rdbuf->_Lock();

  0005f	48 8b 45 00	 mov	 rax, QWORD PTR _Rdbuf$[rbp]
  00063	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00066	48 8b 4d 00	 mov	 rcx, QWORD PTR _Rdbuf$[rbp]
  0006a	ff 50 08	 call	 QWORD PTR [rax+8]
$LN2@Sentry_bas:

; 79   :             }
; 80   :         }

  0006d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00071	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00075	5d		 pop	 rbp
  00076	c3		 ret	 0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
_TEXT	SEGMENT
_State$ = 0
_Pad$ = 8
_Ok$ = 16
$T1 = 96
tv310 = 104
tv295 = 104
tv281 = 104
tv256 = 104
tv220 = 104
tv191 = 104
tv315 = 112
tv254 = 112
tv189 = 112
tv316 = 116
tv136 = 116
tv263 = 120
tv198 = 120
tv261 = 124
tv196 = 124
_Ostr$ = 144
_Data$ = 152
_Size$ = 160
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>, COMDAT

; 490  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 491  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 492  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 493  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

  00028	c7 45 00 00 00
	00 00		 mov	 DWORD PTR _State$[rbp], 0

; 494  : 
; 495  :     _SizeT _Pad;
; 496  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

  0002f	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0003d	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00044	48 03 c8	 add	 rcx, rax
  00047	48 8b c1	 mov	 rax, rcx
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  00053	48 85 c0	 test	 rax, rax
  00056	7e 2d		 jle	 SHORT $LN10@Insert_str
  00058	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00066	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 8b c8	 mov	 rcx, rax
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  0007c	48 3b 85 a0 00
	00 00		 cmp	 rax, QWORD PTR _Size$[rbp]
  00083	77 0a		 ja	 SHORT $LN8@Insert_str
$LN10@Insert_str:

; 497  :         _Pad = 0;

  00085	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR _Pad$[rbp], 0

; 498  :     } else {

  0008d	eb 2f		 jmp	 SHORT $LN9@Insert_str
$LN8@Insert_str:

; 499  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

  0008f	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00096	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00099	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0009d	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 8b c8	 mov	 rcx, rax
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  000b3	48 2b 85 a0 00
	00 00		 sub	 rax, QWORD PTR _Size$[rbp]
  000ba	48 89 45 08	 mov	 QWORD PTR _Pad$[rbp], rax
$LN9@Insert_str:

; 500  :     }
; 501  : 
; 502  :     const typename _Ostr_t::sentry _Ok(_Ostr);

  000be	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR _Ostr$[rbp]
  000c5	48 8d 4d 10	 lea	 rcx, QWORD PTR _Ok$[rbp]
  000c9	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000ce	90		 npad	 1

; 503  : 
; 504  :     if (!_Ok) {

  000cf	48 8d 4d 10	 lea	 rcx, QWORD PTR _Ok$[rbp]
  000d3	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000d8	0f b6 c0	 movzx	 eax, al
  000db	85 c0		 test	 eax, eax
  000dd	75 0e		 jne	 SHORT $LN11@Insert_str

; 505  :         _State |= _Ostr_t::badbit;

  000df	8b 45 00	 mov	 eax, DWORD PTR _State$[rbp]
  000e2	83 c8 04	 or	 eax, 4
  000e5	89 45 00	 mov	 DWORD PTR _State$[rbp], eax

; 506  :     } else { // state okay, insert characters

  000e8	e9 15 02 00 00	 jmp	 $LN12@Insert_str
$LN11@Insert_str:

; 507  :         _TRY_IO_BEGIN
; 508  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

  000ed	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  000f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000fb	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00102	48 03 c8	 add	 rcx, rax
  00105	48 8b c1	 mov	 rax, rcx
  00108	48 8b c8	 mov	 rcx, rax
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flags@ios_base@std@@QEBAHXZ
  00111	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00116	83 f8 40	 cmp	 eax, 64			; 00000040H
  00119	0f 84 a8 00 00
	00		 je	 $LN14@Insert_str

; 509  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0011f	eb 0b		 jmp	 SHORT $LN4@Insert_str
$LN2@Insert_str:
  00121	48 8b 45 08	 mov	 rax, QWORD PTR _Pad$[rbp]
  00125	48 ff c8	 dec	 rax
  00128	48 89 45 08	 mov	 QWORD PTR _Pad$[rbp], rax
$LN4@Insert_str:
  0012c	48 83 7d 08 00	 cmp	 QWORD PTR _Pad$[rbp], 0
  00131	0f 86 90 00 00
	00		 jbe	 $LN14@Insert_str

; 510  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00137	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0013e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00141	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00145	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0014c	48 03 c8	 add	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 8b c8	 mov	 rcx, rax
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0015b	48 89 45 68	 mov	 QWORD PTR tv191[rbp], rax
  0015f	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00166	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00169	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0016d	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00174	48 03 c8	 add	 rcx, rax
  00177	48 8b c1	 mov	 rax, rcx
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  00183	88 45 70	 mov	 BYTE PTR tv189[rbp], al
  00186	0f b6 55 70	 movzx	 edx, BYTE PTR tv189[rbp]
  0018a	48 8b 4d 68	 mov	 rcx, QWORD PTR tv191[rbp]
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  00194	89 45 74	 mov	 DWORD PTR tv136[rbp], eax
  00197	8b 45 74	 mov	 eax, DWORD PTR tv136[rbp]
  0019a	89 45 78	 mov	 DWORD PTR tv198[rbp], eax
  0019d	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  001a2	89 45 7c	 mov	 DWORD PTR tv196[rbp], eax
  001a5	8b 55 78	 mov	 edx, DWORD PTR tv198[rbp]
  001a8	8b 4d 7c	 mov	 ecx, DWORD PTR tv196[rbp]
  001ab	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  001b0	0f b6 c0	 movzx	 eax, al
  001b3	85 c0		 test	 eax, eax
  001b5	74 0b		 je	 SHORT $LN15@Insert_str

; 511  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  001b7	8b 45 00	 mov	 eax, DWORD PTR _State$[rbp]
  001ba	83 c8 04	 or	 eax, 4
  001bd	89 45 00	 mov	 DWORD PTR _State$[rbp], eax

; 512  :                     break;

  001c0	eb 05		 jmp	 SHORT $LN14@Insert_str
$LN15@Insert_str:

; 513  :                 }
; 514  :             }

  001c2	e9 5a ff ff ff	 jmp	 $LN2@Insert_str
$LN14@Insert_str:

; 515  :         }
; 516  : 
; 517  :         if (_State == _Ostr_t::goodbit
; 518  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  001c7	83 7d 00 00	 cmp	 DWORD PTR _State$[rbp], 0
  001cb	75 5f		 jne	 SHORT $LN16@Insert_str
  001cd	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  001d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001d7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  001db	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  001e2	48 03 c8	 add	 rcx, rax
  001e5	48 8b c1	 mov	 rax, rcx
  001e8	48 8b c8	 mov	 rcx, rax
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001f1	48 89 45 68	 mov	 QWORD PTR tv220[rbp], rax
  001f5	4c 8b 85 a0 00
	00 00		 mov	 r8, QWORD PTR _Size$[rbp]
  001fc	48 8b 95 98 00
	00 00		 mov	 rdx, QWORD PTR _Data$[rbp]
  00203	48 8b 4d 68	 mov	 rcx, QWORD PTR tv220[rbp]
  00207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  0020d	48 89 45 70	 mov	 QWORD PTR tv315[rbp], rax
  00211	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Size$[rbp]
  00218	48 39 45 70	 cmp	 QWORD PTR tv315[rbp], rax
  0021c	74 0e		 je	 SHORT $LN16@Insert_str

; 519  :             _State |= _Ostr_t::badbit;

  0021e	8b 45 00	 mov	 eax, DWORD PTR _State$[rbp]
  00221	83 c8 04	 or	 eax, 4
  00224	89 45 00	 mov	 DWORD PTR _State$[rbp], eax

; 520  :         } else {

  00227	e9 a8 00 00 00	 jmp	 $LN17@Insert_str
$LN16@Insert_str:

; 521  :             for (; 0 < _Pad; --_Pad) { // pad on right

  0022c	eb 0b		 jmp	 SHORT $LN7@Insert_str
$LN5@Insert_str:
  0022e	48 8b 45 08	 mov	 rax, QWORD PTR _Pad$[rbp]
  00232	48 ff c8	 dec	 rax
  00235	48 89 45 08	 mov	 QWORD PTR _Pad$[rbp], rax
$LN7@Insert_str:
  00239	48 83 7d 08 00	 cmp	 QWORD PTR _Pad$[rbp], 0
  0023e	0f 86 90 00 00
	00		 jbe	 $LN17@Insert_str

; 522  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00244	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0024b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0024e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00252	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00259	48 03 c8	 add	 rcx, rax
  0025c	48 8b c1	 mov	 rax, rcx
  0025f	48 8b c8	 mov	 rcx, rax
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00268	48 89 45 68	 mov	 QWORD PTR tv256[rbp], rax
  0026c	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00273	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00276	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0027a	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00281	48 03 c8	 add	 rcx, rax
  00284	48 8b c1	 mov	 rax, rcx
  00287	48 8b c8	 mov	 rcx, rax
  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  00290	88 45 70	 mov	 BYTE PTR tv254[rbp], al
  00293	0f b6 55 70	 movzx	 edx, BYTE PTR tv254[rbp]
  00297	48 8b 4d 68	 mov	 rcx, QWORD PTR tv256[rbp]
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  002a1	89 45 74	 mov	 DWORD PTR tv316[rbp], eax
  002a4	8b 45 74	 mov	 eax, DWORD PTR tv316[rbp]
  002a7	89 45 78	 mov	 DWORD PTR tv263[rbp], eax
  002aa	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  002af	89 45 7c	 mov	 DWORD PTR tv261[rbp], eax
  002b2	8b 55 78	 mov	 edx, DWORD PTR tv263[rbp]
  002b5	8b 4d 7c	 mov	 ecx, DWORD PTR tv261[rbp]
  002b8	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  002bd	0f b6 c0	 movzx	 eax, al
  002c0	85 c0		 test	 eax, eax
  002c2	74 0b		 je	 SHORT $LN18@Insert_str

; 523  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  002c4	8b 45 00	 mov	 eax, DWORD PTR _State$[rbp]
  002c7	83 c8 04	 or	 eax, 4
  002ca	89 45 00	 mov	 DWORD PTR _State$[rbp], eax

; 524  :                     break;

  002cd	eb 05		 jmp	 SHORT $LN17@Insert_str
$LN18@Insert_str:

; 525  :                 }
; 526  :             }

  002cf	e9 5a ff ff ff	 jmp	 $LN5@Insert_str
$LN17@Insert_str:

; 527  :         }
; 528  : 
; 529  :         _Ostr.width(0);

  002d4	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  002db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002de	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002e2	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  002e9	48 03 c8	 add	 rcx, rax
  002ec	48 8b c1	 mov	 rax, rcx
  002ef	48 89 45 68	 mov	 QWORD PTR tv281[rbp], rax
  002f3	33 d2		 xor	 edx, edx
  002f5	48 8b 4d 68	 mov	 rcx, QWORD PTR tv281[rbp]
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
  002ff	90		 npad	 1
  00300	eb 00		 jmp	 SHORT $LN12@Insert_str
$LN24@Insert_str:
$LN12@Insert_str:

; 530  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 531  :     }
; 532  : 
; 533  :     _Ostr.setstate(_State);

  00302	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00309	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0030c	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00310	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00317	48 03 c8	 add	 rcx, rax
  0031a	48 8b c1	 mov	 rax, rcx
  0031d	48 89 45 68	 mov	 QWORD PTR tv310[rbp], rax
  00321	45 33 c0	 xor	 r8d, r8d
  00324	8b 55 00	 mov	 edx, DWORD PTR _State$[rbp]
  00327	48 8b 4d 68	 mov	 rcx, QWORD PTR tv310[rbp]
  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 534  :     return _Ostr;

  00331	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00338	48 89 45 60	 mov	 QWORD PTR $T1[rbp], rax
  0033c	48 8d 4d 10	 lea	 rcx, QWORD PTR _Ok$[rbp]
  00340	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00345	48 8b 45 60	 mov	 rax, QWORD PTR $T1[rbp]

; 535  : }

  00349	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  00350	5d		 pop	 rbp
  00351	c3		 ret	 0
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 0
_Pad$ = 8
_Ok$ = 16
$T1 = 96
tv310 = 104
tv295 = 104
tv281 = 104
tv256 = 104
tv220 = 104
tv191 = 104
tv315 = 112
tv254 = 112
tv189 = 112
tv316 = 116
tv136 = 116
tv263 = 120
tv198 = 120
tv261 = 124
tv196 = 124
_Ostr$ = 144
_Data$ = 152
_Size$ = 160
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Ok$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 0
_Pad$ = 8
_Ok$ = 16
$T1 = 96
tv310 = 104
tv295 = 104
tv281 = 104
tv256 = 104
tv220 = 104
tv191 = 104
tv315 = 112
tv254 = 112
tv189 = 112
tv316 = 116
tv136 = 116
tv263 = 120
tv198 = 120
tv261 = 124
tv196 = 124
_Ostr$ = 144
_Data$ = 152
_Size$ = 160
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1

; 530  :         _CATCH_IO_(_Ostr_t, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  0000e	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00015	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00018	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001c	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx
  00029	48 89 45 68	 mov	 QWORD PTR tv295[rbp], rax
  0002d	41 b0 01	 mov	 r8b, 1
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	48 8b 4d 68	 mov	 rcx, QWORD PTR tv295[rbp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0003f	90		 npad	 1
  00040	48 8d 05 00 00
	00 00		 lea	 rax, $LN24@catch$1
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
  0004d	cc		 int	 3
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z
_TEXT	SEGMENT
_Decay_copied$ = 0
_Invoker_proc$ = 8
tv73 = 80
this$ = 112
_Fx$ = 120
<_Ax_0>$ = 128
??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z PROC ; std::thread::_Start<void (__cdecl&)(Logger *),Logger * &>, COMDAT

; 67   :     void _Start(_Fn&& _Fx, _Args&&... _Ax) {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 68   :         using _Tuple                 = tuple<decay_t<_Fn>, decay_t<_Args>...>;
; 69   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

  00028	4c 8b 85 80 00
	00 00		 mov	 r8, QWORD PTR <_Ax_0>$[rbp]
  0002f	48 8b 55 78	 mov	 rdx, QWORD PTR _Fx$[rbp]
  00033	48 8d 4d 00	 lea	 rcx, QWORD PTR _Decay_copied$[rbp]
  00037	e8 00 00 00 00	 call	 ??$make_unique@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@A6AXPEAVLogger@@@ZAEAPEAV3@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@0@A6AXPEAVLogger@@@ZAEAPEAV2@@Z ; std::make_unique<std::tuple<void (__cdecl*)(Logger *),Logger *>,void (__cdecl&)(Logger *),Logger * &,0>
  0003c	90		 npad	 1

; 70   :         constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{});

  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??$_Invoke@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@$0A@$00@thread@std@@CAIPEAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(Logger *),Logger *>,0,1>
  00044	48 89 45 08	 mov	 QWORD PTR _Invoker_proc$[rbp], rax

; 71   : 
; 72   :         _Thr._Hnd =

  00048	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 83 c0 08	 add	 rax, 8
  00050	48 89 45 50	 mov	 QWORD PTR tv73[rbp], rax
  00054	48 8d 4d 00	 lea	 rcx, QWORD PTR _Decay_copied$[rbp]
  00058	e8 00 00 00 00	 call	 ?get@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEBAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::get
  0005d	48 8b 4d 50	 mov	 rcx, QWORD PTR tv73[rbp]
  00061	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00066	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0006e	4c 8b c8	 mov	 r9, rax
  00071	4c 8b 45 08	 mov	 r8, QWORD PTR _Invoker_proc$[rbp]
  00075	33 d2		 xor	 edx, edx
  00077	33 c9		 xor	 ecx, ecx
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__beginthreadex
  0007f	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00083	48 89 01	 mov	 QWORD PTR [rcx], rax

; 73   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 74   : 
; 75   :         if (_Thr._Hnd) { // ownership transferred to the thread

  00086	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0008a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008e	74 0b		 je	 SHORT $LN2@Start

; 76   :             (void) _Decay_copied.release();

  00090	48 8d 4d 00	 lea	 rcx, QWORD PTR _Decay_copied$[rbp]
  00094	e8 00 00 00 00	 call	 ?release@?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAAPEAV?$tuple@P6AXPEAVLogger@@@ZPEAV1@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::release

; 77   :         } else { // failed to start thread

  00099	eb 16		 jmp	 SHORT $LN3@Start
$LN2@Start:

; 78   :             _Thr._Id = 0;

  0009b	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0009f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 79   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

  000a6	b9 06 00 00 00	 mov	 ecx, 6
  000ab	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  000b0	90		 npad	 1
$LN3@Start:

; 80   :         }
; 81   :     }

  000b1	48 8d 4d 00	 lea	 rcx, QWORD PTR _Decay_copied$[rbp]
  000b5	e8 00 00 00 00	 call	 ??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::~unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >
  000ba	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000be	5d		 pop	 rbp
  000bf	c3		 ret	 0
$LN6@Start:
??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z ENDP ; std::thread::_Start<void (__cdecl&)(Logger *),Logger * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Decay_copied$ = 0
_Invoker_proc$ = 8
tv73 = 80
this$ = 112
_Fx$ = 120
<_Ax_0>$ = 128
?dtor$0@?0???$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z@4HA PROC ; `std::thread::_Start<void (__cdecl&)(Logger *),Logger * &>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Decay_copied$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$unique_ptr@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@U?$default_delete@V?$tuple@P6AXPEAVLogger@@@ZPEAV1@@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >::~unique_ptr<std::tuple<void (__cdecl*)(Logger *),Logger *>,std::default_delete<std::tuple<void (__cdecl*)(Logger *),Logger *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z@4HA ENDP ; `std::thread::_Start<void (__cdecl&)(Logger *),Logger * &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = 64
tv70 = 72
this$ = 96
_Ptr$ = 104
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT

; 3223 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 48	 mov	 QWORD PTR tv70[rbp], rax
  00028	4c 8d 45 68	 lea	 r8, QWORD PTR _Ptr$[rbp]
  0002c	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00030	48 8b 4d 48	 mov	 rcx, QWORD PTR tv70[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
  00039	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ
_TEXT	SEGMENT
$T1 = 64
this$ = 96
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT

; 3308 :     _CONSTEXPR23 pointer release() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3309 :         return _STD exchange(_Mypair._Myval2, nullptr);

  0001b	48 c7 45 40 00
	00 00 00	 mov	 QWORD PTR $T1[rbp], 0
  00023	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	e8 00 00 00 00	 call	 ??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>

; 3310 :     }

  00033	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
tv77 = 64
tv75 = 72
this$ = 96
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT

; 3278 :     _CONSTEXPR23 ~unique_ptr() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3279 :         if (_Mypair._Myval2) {

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 28		 je	 SHORT $LN2@unique_ptr

; 3280 :             _Mypair._Get_first()(_Mypair._Myval2);

  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
  00031	48 89 45 40	 mov	 QWORD PTR tv77[rbp], rax
  00035	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  00040	48 8b 55 48	 mov	 rdx, QWORD PTR tv75[rbp]
  00044	48 8b 4d 40	 mov	 rcx, QWORD PTR tv77[rbp]
  00048	e8 00 00 00 00	 call	 ??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
$LN2@unique_ptr:

; 3281 :         }
; 3282 :     }

  0004d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00051	5d		 pop	 rbp
  00052	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = 64
tv71 = 72
tv72 = 80
this$ = 112
_Ptr$ = 120
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT

; 3168 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E5F4B71E_memory
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3169 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3170 :         delete _Ptr;

  00023	48 8b 45 78	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00027	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0002b	48 83 7d 40 00	 cmp	 QWORD PTR $T1[rbp], 0
  00030	74 20		 je	 SHORT $LN3@operator
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 45 48	 mov	 QWORD PTR tv71[rbp], rax
  00040	ba 01 00 00 00	 mov	 edx, 1
  00045	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00049	ff 55 48	 call	 QWORD PTR tv71[rbp]
  0004c	48 89 45 50	 mov	 QWORD PTR tv72[rbp], rax
  00050	eb 08		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00052	48 c7 45 50 00
	00 00 00	 mov	 QWORD PTR tv72[rbp], 0
$LN4@operator:

; 3171 :     }

  0005a	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Verify_range@D@std@@YAXQEBD0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Verify_range@D@std@@YAXQEBD0@Z PROC			; std::_Verify_range<char>, COMDAT

; 1126 : constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@Verify_ran:

; 1127 :     // special case range verification for pointers
; 1128 :     _STL_VERIFY(_First <= _Last, "transposed pointer range");

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Last$[rbp]
  00024	48 39 45 50	 cmp	 QWORD PTR _First$[rbp], rax
  00028	77 02		 ja	 SHORT $LN7@Verify_ran
  0002a	eb 6b		 jmp	 SHORT $LN9@Verify_ran
$LN7@Verify_ran:
  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0003f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00044	45 33 c9	 xor	 r9d, r9d
  00047	41 b8 68 04 00
	00		 mov	 r8d, 1128		; 00000468H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@IHPKJKEH@C?3?2Program?5Files?2Microsoft?5Visu@
  00054	b9 02 00 00 00	 mov	 ecx, 2
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  0005f	83 f8 01	 cmp	 eax, 1
  00062	75 03		 jne	 SHORT $LN11@Verify_ran
  00064	cc		 int	 3
  00065	33 c0		 xor	 eax, eax
$LN11@Verify_ran:
  00067	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00070	41 b9 68 04 00
	00		 mov	 r9d, 1128		; 00000468H
  00076	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MC@NIKDFAJH@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 95		 jne	 SHORT $LN7@Verify_ran
$LN9@Verify_ran:
  00097	33 c0		 xor	 eax, eax
  00099	85 c0		 test	 eax, eax
  0009b	75 83		 jne	 SHORT $LN4@Verify_ran

; 1129 : }

  0009d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000a1	5d		 pop	 rbp
  000a2	c3		 ret	 0
??$_Verify_range@D@std@@YAXQEBD0@Z ENDP			; std::_Verify_range<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
_UFirst$ = 0
_ULast$ = 8
$T1 = 80
$T2 = 81
tv94 = 88
tv70 = 88
this$ = 112
_First$ = 120
_Last$ = 128
_Al$ = 136
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>, COMDAT

; 2569 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0002d	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 89 45 58	 mov	 QWORD PTR tv70[rbp], rax
  00035	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR _Al$[rbp]
  0003c	0f b6 55 50	 movzx	 edx, BYTE PTR $T1[rbp]
  00040	48 8b 4d 58	 mov	 rcx, QWORD PTR tv70[rbp]
  00044	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
  00049	90		 npad	 1

; 2570 :         _Adl_verify_range(_First, _Last);

  0004a	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR _Last$[rbp]
  00051	48 8d 4d 78	 lea	 rcx, QWORD PTR _First$[rbp]
  00055	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>

; 2571 :         auto _UFirst = _Get_unwrapped(_First);

  0005a	48 8d 4d 78	 lea	 rcx, QWORD PTR _First$[rbp]
  0005e	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ; std::_Get_unwrapped<char * &>
  00063	48 89 45 00	 mov	 QWORD PTR _UFirst$[rbp], rax

; 2572 :         auto _ULast  = _Get_unwrapped(_Last);

  00067	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR _Last$[rbp]
  0006e	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ; std::_Get_unwrapped<char * &>
  00073	48 89 45 08	 mov	 QWORD PTR _ULast$[rbp], rax

; 2573 :         if (_UFirst == _ULast) {

  00077	48 8b 45 08	 mov	 rax, QWORD PTR _ULast$[rbp]
  0007b	48 39 45 00	 cmp	 QWORD PTR _UFirst$[rbp], rax
  0007f	75 34		 jne	 SHORT $LN2@allocator

; 2574 :             _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00081	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00085	48 89 45 58	 mov	 QWORD PTR tv94[rbp], rax
  00089	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0008d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00092	48 8b d0	 mov	 rdx, rax
  00095	48 8d 4d 51	 lea	 rcx, QWORD PTR $T2[rbp]
  00099	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0009e	48 8b d0	 mov	 rdx, rax
  000a1	48 8b 4d 58	 mov	 rcx, QWORD PTR tv94[rbp]
  000a5	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2575 :             _Tidy_init();

  000aa	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  000ae	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2576 :         } else {

  000b3	eb 27		 jmp	 SHORT $LN3@allocator
$LN2@allocator:

; 2577 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2578 :                 _Construct<_Construct_strategy::_From_ptr>(

  000b5	48 8b 45 00	 mov	 rax, QWORD PTR _UFirst$[rbp]
  000b9	48 8b 4d 08	 mov	 rcx, QWORD PTR _ULast$[rbp]
  000bd	48 2b c8	 sub	 rcx, rax
  000c0	48 8b c1	 mov	 rax, rcx
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	e8 00 00 00 00	 call	 ??$_Convert_size@_K_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64,unsigned __int64>
  000cb	4c 8b c0	 mov	 r8, rax
  000ce	48 8b 55 00	 mov	 rdx, QWORD PTR _UFirst$[rbp]
  000d2	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  000d6	e8 00 00 00 00	 call	 ??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
  000db	90		 npad	 1
$LN3@allocator:

; 2579 :                     _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2580 :             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
; 2581 :                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 2582 :                 const auto _Count  = _Convert_size<size_type>(_Length);
; 2583 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);
; 2584 :             } else {
; 2585 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
; 2586 :             }
; 2587 :         }
; 2588 :     }

  000dc	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000e0	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000e4	5d		 pop	 rbp
  000e5	c3		 ret	 0
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 0
_ULast$ = 8
$T1 = 80
$T2 = 81
tv94 = 88
tv70 = 88
this$ = 112
_First$ = 120
_Last$ = 128
_Al$ = 136
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\string
;	COMDAT ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
_TEXT	SEGMENT
_UVal_trunc$ = 0
_RNext$ = 96
_UVal$ = 104
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z PROC	; std::_UIntegral_to_buff<char,unsigned int>, COMDAT

; 441  : _NODISCARD _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__91273182_string
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 442  :     // format _UVal into buffer *ending at* _RNext
; 443  :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 444  : 
; 445  : #ifdef _WIN64
; 446  :     auto _UVal_trunc = _UVal;

  0001f	8b 45 68	 mov	 eax, DWORD PTR _UVal$[rbp]
  00022	89 45 00	 mov	 DWORD PTR _UVal_trunc$[rbp], eax
$LN4@UIntegral_:

; 447  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 448  : 
; 449  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 450  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 451  :         while (_UVal > 0xFFFFFFFFU) {
; 452  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 453  :             _UVal /= 1000000000;
; 454  : 
; 455  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 456  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 457  :                 _UVal_chunk /= 10;
; 458  :             }
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 463  : #endif // _WIN64
; 464  : 
; 465  :     do {
; 466  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

  00025	48 8b 45 60	 mov	 rax, QWORD PTR _RNext$[rbp]
  00029	48 ff c8	 dec	 rax
  0002c	48 89 45 60	 mov	 QWORD PTR _RNext$[rbp], rax
  00030	33 d2		 xor	 edx, edx
  00032	8b 45 00	 mov	 eax, DWORD PTR _UVal_trunc$[rbp]
  00035	b9 0a 00 00 00	 mov	 ecx, 10
  0003a	f7 f1		 div	 ecx
  0003c	8b c2		 mov	 eax, edx
  0003e	83 c0 30	 add	 eax, 48			; 00000030H
  00041	48 8b 4d 60	 mov	 rcx, QWORD PTR _RNext$[rbp]
  00045	88 01		 mov	 BYTE PTR [rcx], al

; 467  :         _UVal_trunc /= 10;

  00047	33 d2		 xor	 edx, edx
  00049	8b 45 00	 mov	 eax, DWORD PTR _UVal_trunc$[rbp]
  0004c	b9 0a 00 00 00	 mov	 ecx, 10
  00051	f7 f1		 div	 ecx
  00053	89 45 00	 mov	 DWORD PTR _UVal_trunc$[rbp], eax

; 468  :     } while (_UVal_trunc != 0);

  00056	83 7d 00 00	 cmp	 DWORD PTR _UVal_trunc$[rbp], 0
  0005a	75 c9		 jne	 SHORT $LN4@UIntegral_

; 469  :     return _RNext;

  0005c	48 8b 45 60	 mov	 rax, QWORD PTR _RNext$[rbp]

; 470  : }

  00060	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ENDP	; std::_UIntegral_to_buff<char,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z
_TEXT	SEGMENT
_Array$ = 80
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z PROC		; std::end<char,21>, COMDAT

; 1825 : _NODISCARD constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1826 :     return _Array + _Size;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Array$[rbp]
  0001f	48 83 c0 15	 add	 rax, 21

; 1827 : }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ENDP		; std::end<char,21>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 10 00 00 00	 mov	 ecx, 16
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00036	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00039	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003d	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 243  : }

  00042	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00046	5d		 pop	 rbp
  00047	c3		 ret	 0
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z PROC ; std::construct_at<wchar_t,wchar_t const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 02 00 00 00	 mov	 ecx, 2
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0003d	66 89 08	 mov	 WORD PTR [rax], cx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z ENDP ; std::construct_at<wchar_t,wchar_t const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@_W@std@@YAPEA_WAEA_W@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@_W@std@@YAPEA_WAEA_W@Z PROC		; std::addressof<wchar_t>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@_W@std@@YAPEA_WAEA_W@Z ENDP		; std::addressof<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z PROC	; std::construct_at<char,char const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 01 00 00 00	 mov	 ecx, 1
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0003d	88 08		 mov	 BYTE PTR [rax], cl
  0003f	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00043	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z ENDP	; std::construct_at<char,char const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Max_possible$1 = 8
_Count$ = 96
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 01	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00029	48 89 45 08	 mov	 QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

  0002d	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00037	48 39 45 60	 cmp	 QWORD PTR _Count$[rbp], rax
  0003b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

  0003d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  00042	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
$LN3@Get_size_o:

; 75   : }

  00047	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 80
_Bytes$ = 88
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 251  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0b		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 256  :     } else

  00035	eb 25		 jmp	 SHORT $LN3@Deallocate
$LN2@Deallocate:

; 257  : #endif // _HAS_CXX20
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00037	48 81 7d 58 00
	10 00 00	 cmp	 QWORD PTR _Bytes$[rbp], 4096 ; 00001000H
  0003f	72 0d		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00041	48 8d 55 58	 lea	 rdx, QWORD PTR _Bytes$[rbp]
  00045	48 8d 4d 50	 lea	 rcx, QWORD PTR _Ptr$[rbp]
  00049	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0004e	48 8b 55 58	 mov	 rdx, QWORD PTR _Bytes$[rbp]
  00052	48 8b 4d 50	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00056	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0005b	90		 npad	 1
$LN3@Deallocate:

; 265  :     }
; 266  : }

  0005c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 80
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 230  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 231  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 232  : #if defined(_M_IX86) || defined(_M_X64)
; 233  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 234  :     if (!_STD is_constant_evaluated())

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	75 15		 jne	 SHORT $LN2@Allocate

; 235  : #endif // _HAS_CXX20
; 236  :     {
; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00027	48 81 7d 50 00
	10 00 00	 cmp	 QWORD PTR _Bytes$[rbp], 4096 ; 00001000H
  0002f	72 0b		 jb	 SHORT $LN3@Allocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00031	48 8b 4d 50	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00035	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0003a	eb 14		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:
$LN2@Allocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  0003c	48 83 7d 50 00	 cmp	 QWORD PTR _Bytes$[rbp], 0
  00041	74 0b		 je	 SHORT $LN4@Allocate

; 244  :         return _Traits::_Allocate(_Bytes);

  00043	48 8b 4d 50	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00047	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  0004c	eb 02		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  0004e	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 248  : }

  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Max_possible$1 = 8
_Count$ = 96
??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<80>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 01	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	48 b8 33 33 33
	33 33 33 33 03	 mov	 rax, 230584300921369395	; 0333333333333333H
  00029	48 89 45 08	 mov	 QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

  0002d	48 b8 33 33 33
	33 33 33 33 03	 mov	 rax, 230584300921369395	; 0333333333333333H
  00037	48 39 45 60	 cmp	 QWORD PTR _Count$[rbp], rax
  0003b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

  0003d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  00042	48 6b 45 60 50	 imul	 rax, QWORD PTR _Count$[rbp], 80 ; 00000050H
$LN3@Get_size_o:

; 75   : }

  00047	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<80>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
$T1 = 64
tv65 = 72
_Left$ = 96
_Right$ = 104
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Left$[rbp]
  00024	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	73 0a		 jae	 SHORT $LN3@max
  00030	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00034	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
  00038	eb 08		 jmp	 SHORT $LN4@max
$LN3@max:
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR _Left$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
$LN4@max:
  00042	48 8b 45 48	 mov	 rax, QWORD PTR tv65[rbp]
  00046	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0004a	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 78   : }

  0004e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
_TEXT	SEGMENT
_Ptr$ = 80
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Ptr$[rbp]

; 37   : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 80
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Ptr$[rbp]

; 37   : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 0
_Old_size$ = 8
_New_size$ = 16
_Old_capacity$ = 24
_New_capacity$ = 32
_Al$ = 40
_New_ptr$ = 48
_Raw_new$ = 56
_Old_ptr$1 = 64
tv91 = 136
tv89 = 144
this$ = 176
_Size_increase$ = 184
_Fn$ = 192
<_Args_0>$ = 200
<_Args_1>$ = 208
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>, COMDAT

; 4776 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4777 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4778 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4779 :         auto& _My_data            = _Mypair._Myval2;

  0002d	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 4780 :         const size_type _Old_size = _My_data._Mysize;

  00038	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0003c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00040	48 89 45 08	 mov	 QWORD PTR _Old_size$[rbp], rax

; 4781 :         if (max_size() - _Old_size < _Size_increase) {

  00044	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00050	48 2b 45 08	 sub	 rax, QWORD PTR _Old_size$[rbp]
  00054	48 3b 85 b8 00
	00 00		 cmp	 rax, QWORD PTR _Size_increase$[rbp]
  0005b	73 05		 jae	 SHORT $LN2@Reallocate

; 4782 :             _Xlen_string(); // result too long

  0005d	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4783 :         }
; 4784 : 
; 4785 :         const size_type _New_size     = _Old_size + _Size_increase;

  00062	48 8b 85 b8 00
	00 00		 mov	 rax, QWORD PTR _Size_increase$[rbp]
  00069	48 8b 4d 08	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 45 10	 mov	 QWORD PTR _New_size$[rbp], rax

; 4786 :         const size_type _Old_capacity = _My_data._Myres;

  00077	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0007b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007f	48 89 45 18	 mov	 QWORD PTR _Old_capacity$[rbp], rax

; 4787 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00083	48 8b 55 10	 mov	 rdx, QWORD PTR _New_size$[rbp]
  00087	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0008e	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00093	48 89 45 20	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4788 :         auto& _Al                     = _Getal();

  00097	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009e	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000a3	48 89 45 28	 mov	 QWORD PTR _Al$[rbp], rax

; 4789 :         ++_New_capacity;

  000a7	48 8b 45 20	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000ab	48 ff c0	 inc	 rax
  000ae	48 89 45 20	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4790 :         const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  000b2	48 8d 55 20	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  000b6	48 8b 4d 28	 mov	 rcx, QWORD PTR _Al$[rbp]
  000ba	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  000bf	48 89 45 30	 mov	 QWORD PTR _New_ptr$[rbp], rax

; 4791 :         --_New_capacity;

  000c3	48 8b 45 20	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000c7	48 ff c8	 dec	 rax
  000ca	48 89 45 20	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4792 : 
; 4793 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  000ce	48 8b 45 20	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000d2	48 ff c0	 inc	 rax
  000d5	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv91[rbp], rax
  000dc	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  000e0	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  000e5	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv89[rbp], rax
  000ec	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR tv91[rbp]
  000f3	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv89[rbp]
  000fa	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 4794 :         _My_data._Orphan_all();

  000ff	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00103	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 4795 :         _ASAN_STRING_REMOVE(*this);
; 4796 :         _My_data._Mysize      = _New_size;

  00108	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0010c	48 8b 4d 10	 mov	 rcx, QWORD PTR _New_size$[rbp]
  00110	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4797 :         _My_data._Myres       = _New_capacity;

  00114	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00118	48 8b 4d 20	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  0011c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4798 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00120	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00124	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00129	48 89 45 38	 mov	 QWORD PTR _Raw_new$[rbp], rax

; 4799 :         if (_BUF_SIZE <= _Old_capacity) {

  0012d	48 83 7d 18 10	 cmp	 QWORD PTR _Old_capacity$[rbp], 16
  00132	72 69		 jb	 SHORT $LN3@Reallocate

; 4800 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00134	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00138	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0013c	48 89 45 40	 mov	 QWORD PTR _Old_ptr$1[rbp], rax

; 4801 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  00140	48 8b 4d 40	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  00144	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00149	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR <_Args_1>$[rbp]
  00150	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00155	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0015c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00161	4c 8b 4d 08	 mov	 r9, QWORD PTR _Old_size$[rbp]
  00165	4c 8b c0	 mov	 r8, rax
  00168	48 8b 55 38	 mov	 rdx, QWORD PTR _Raw_new$[rbp]
  0016c	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR _Fn$[rbp]
  00173	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()

; 4802 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00178	48 8b 45 18	 mov	 rax, QWORD PTR _Old_capacity$[rbp]
  0017c	48 ff c0	 inc	 rax
  0017f	4c 8b c0	 mov	 r8, rax
  00182	48 8b 55 40	 mov	 rdx, QWORD PTR _Old_ptr$1[rbp]
  00186	48 8b 4d 28	 mov	 rcx, QWORD PTR _Al$[rbp]
  0018a	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4803 :             _My_data._Bx._Ptr = _New_ptr;

  0018f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00193	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00197	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 4804 :         } else {

  0019b	eb 4b		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4805 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  0019d	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001a1	48 83 c0 08	 add	 rax, 8
  001a5	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR <_Args_1>$[rbp]
  001ac	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b1	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  001b8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001bd	4c 8b 4d 08	 mov	 r9, QWORD PTR _Old_size$[rbp]
  001c1	4c 8b c0	 mov	 r8, rax
  001c4	48 8b 55 38	 mov	 rdx, QWORD PTR _Raw_new$[rbp]
  001c8	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR _Fn$[rbp]
  001cf	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()

; 4806 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  001d4	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001d8	48 83 c0 08	 add	 rax, 8
  001dc	48 8d 55 30	 lea	 rdx, QWORD PTR _New_ptr$[rbp]
  001e0	48 8b c8	 mov	 rcx, rax
  001e3	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4807 :         }
; 4808 : 
; 4809 :         _ASAN_STRING_CREATE(*this);
; 4810 :         return *this;

  001e8	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
$LN5@Reallocate:

; 4811 :     }

  001ef	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  001f6	5d		 pop	 rbp
  001f7	c3		 ret	 0
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_New_ptr$ = 104
_Old_ptr$ = 112
_Old_size$ = 120
_Ptr$ = 128
_Count$ = 136
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator(), COMDAT

; 3295 :                 const size_type _Count) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3296 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  0002a	4c 8b 45 78	 mov	 r8, QWORD PTR _Old_size$[rbp]
  0002e	48 8b 55 70	 mov	 rdx, QWORD PTR _Old_ptr$[rbp]
  00032	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00036	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3297 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  0003b	48 8b 45 78	 mov	 rax, QWORD PTR _Old_size$[rbp]
  0003f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00043	48 03 c8	 add	 rcx, rax
  00046	48 8b c1	 mov	 rax, rcx
  00049	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  00050	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3298 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0005f	c6 45 40 00	 mov	 BYTE PTR $T1[rbp], 0
  00063	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  0006a	48 8b 4d 78	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  0006e	48 03 c8	 add	 rcx, rax
  00071	48 8b c1	 mov	 rax, rcx
  00074	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00078	48 03 c8	 add	 rcx, rax
  0007b	48 8b c1	 mov	 rax, rcx
  0007e	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3299 :             },

  0008a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0008e	5d		 pop	 rbp
  0008f	c3		 ret	 0
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
_TEXT	SEGMENT
_Old_capacity$ = 0
_New_capacity$ = 8
_Al$ = 16
_New_ptr$ = 24
tv88 = 96
tv86 = 104
this$ = 128
_New_size$ = 136
_Fn$ = 144
<_Args_0>$ = 152
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>, COMDAT

; 4744 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4745 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4746 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4747 :         if (_New_size > max_size()) {

  0002d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00039	48 39 85 88 00
	00 00		 cmp	 QWORD PTR _New_size$[rbp], rax
  00040	76 05		 jbe	 SHORT $LN2@Reallocate

; 4748 :             _Xlen_string(); // result too long

  00042	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4749 :         }
; 4750 : 
; 4751 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00047	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00052	48 89 45 00	 mov	 QWORD PTR _Old_capacity$[rbp], rax

; 4752 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00056	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR _New_size$[rbp]
  0005d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00064	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00069	48 89 45 08	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4753 :         auto& _Al                     = _Getal();

  0006d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00074	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00079	48 89 45 10	 mov	 QWORD PTR _Al$[rbp], rax

; 4754 :         ++_New_capacity;

  0007d	48 8b 45 08	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00081	48 ff c0	 inc	 rax
  00084	48 89 45 08	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4755 :         const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  00088	48 8d 55 08	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  0008c	48 8b 4d 10	 mov	 rcx, QWORD PTR _Al$[rbp]
  00090	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  00095	48 89 45 18	 mov	 QWORD PTR _New_ptr$[rbp], rax

; 4756 :         --_New_capacity;

  00099	48 8b 45 08	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  0009d	48 ff c8	 dec	 rax
  000a0	48 89 45 08	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4757 : 
; 4758 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  000a4	48 8b 45 08	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000a8	48 ff c0	 inc	 rax
  000ab	48 89 45 60	 mov	 QWORD PTR tv88[rbp], rax
  000af	48 8b 4d 18	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  000b3	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  000b8	48 89 45 68	 mov	 QWORD PTR tv86[rbp], rax
  000bc	48 8b 55 60	 mov	 rdx, QWORD PTR tv88[rbp]
  000c0	48 8b 4d 68	 mov	 rcx, QWORD PTR tv86[rbp]
  000c4	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 4759 :         _Mypair._Myval2._Orphan_all();

  000c9	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 4760 :         _ASAN_STRING_REMOVE(*this);
; 4761 :         _Mypair._Myval2._Mysize = _New_size;

  000d8	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000df	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _New_size$[rbp]
  000e6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4762 :         _Mypair._Myval2._Myres  = _New_capacity;

  000ea	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000f1	48 8b 4d 08	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  000f5	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4763 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  000f9	48 8b 4d 18	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  000fd	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00102	4c 8b 8d 98 00
	00 00		 mov	 r9, QWORD PTR <_Args_0>$[rbp]
  00109	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR _New_size$[rbp]
  00110	48 8b d0	 mov	 rdx, rax
  00113	48 8d 8d 90 00
	00 00		 lea	 rcx, QWORD PTR _Fn$[rbp]
  0011a	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()

; 4764 :         if (_BUF_SIZE <= _Old_capacity) {

  0011f	48 83 7d 00 10	 cmp	 QWORD PTR _Old_capacity$[rbp], 16
  00124	72 2f		 jb	 SHORT $LN3@Reallocate

; 4765 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00126	48 8b 45 00	 mov	 rax, QWORD PTR _Old_capacity$[rbp]
  0012a	48 ff c0	 inc	 rax
  0012d	4c 8b c0	 mov	 r8, rax
  00130	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00137	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0013b	48 8b 4d 10	 mov	 rcx, QWORD PTR _Al$[rbp]
  0013f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4766 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  00144	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0014b	48 8b 4d 18	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  0014f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 4767 :         } else {

  00153	eb 17		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4768 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00155	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0015c	48 83 c0 08	 add	 rax, 8
  00160	48 8d 55 18	 lea	 rdx, QWORD PTR _New_ptr$[rbp]
  00164	48 8b c8	 mov	 rcx, rax
  00167	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4769 :         }
; 4770 : 
; 4771 :         _ASAN_STRING_CREATE(*this);
; 4772 :         return *this;

  0016c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
$LN5@Reallocate:

; 4773 :     }

  00173	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00177	5d		 pop	 rbp
  00178	c3		 ret	 0
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_New_ptr$ = 104
_Count$ = 112
_Ptr$ = 120
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator(), COMDAT

; 3399 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3400 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  0002a	4c 8b 45 70	 mov	 r8, QWORD PTR _Count$[rbp]
  0002e	48 8b 55 78	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00032	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00036	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3401 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0003b	c6 45 40 00	 mov	 BYTE PTR $T1[rbp], 0
  0003f	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  00043	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00047	48 03 c8	 add	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3402 :             },

  00059	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005d	5d		 pop	 rbp
  0005e	c3		 ret	 0
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
_TEXT	SEGMENT
_My_data$ = 0
_Old_size$ = 8
_New_size$ = 16
_Old_capacity$ = 24
_New_capacity$ = 32
_Al$ = 40
_New_ptr$ = 48
_Raw_new$ = 56
_Old_ptr$1 = 64
tv91 = 136
tv89 = 144
this$ = 176
_Size_increase$ = 184
_Fn$ = 192
<_Args_0>$ = 200
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>, COMDAT

; 4776 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4777 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4778 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4779 :         auto& _My_data            = _Mypair._Myval2;

  0002d	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 4780 :         const size_type _Old_size = _My_data._Mysize;

  00038	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0003c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00040	48 89 45 08	 mov	 QWORD PTR _Old_size$[rbp], rax

; 4781 :         if (max_size() - _Old_size < _Size_increase) {

  00044	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00050	48 2b 45 08	 sub	 rax, QWORD PTR _Old_size$[rbp]
  00054	48 3b 85 b8 00
	00 00		 cmp	 rax, QWORD PTR _Size_increase$[rbp]
  0005b	73 05		 jae	 SHORT $LN2@Reallocate

; 4782 :             _Xlen_string(); // result too long

  0005d	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4783 :         }
; 4784 : 
; 4785 :         const size_type _New_size     = _Old_size + _Size_increase;

  00062	48 8b 85 b8 00
	00 00		 mov	 rax, QWORD PTR _Size_increase$[rbp]
  00069	48 8b 4d 08	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 45 10	 mov	 QWORD PTR _New_size$[rbp], rax

; 4786 :         const size_type _Old_capacity = _My_data._Myres;

  00077	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0007b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007f	48 89 45 18	 mov	 QWORD PTR _Old_capacity$[rbp], rax

; 4787 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00083	48 8b 55 10	 mov	 rdx, QWORD PTR _New_size$[rbp]
  00087	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0008e	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00093	48 89 45 20	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4788 :         auto& _Al                     = _Getal();

  00097	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009e	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000a3	48 89 45 28	 mov	 QWORD PTR _Al$[rbp], rax

; 4789 :         ++_New_capacity;

  000a7	48 8b 45 20	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000ab	48 ff c0	 inc	 rax
  000ae	48 89 45 20	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4790 :         const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  000b2	48 8d 55 20	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  000b6	48 8b 4d 28	 mov	 rcx, QWORD PTR _Al$[rbp]
  000ba	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  000bf	48 89 45 30	 mov	 QWORD PTR _New_ptr$[rbp], rax

; 4791 :         --_New_capacity;

  000c3	48 8b 45 20	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000c7	48 ff c8	 dec	 rax
  000ca	48 89 45 20	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4792 : 
; 4793 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  000ce	48 8b 45 20	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000d2	48 ff c0	 inc	 rax
  000d5	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv91[rbp], rax
  000dc	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  000e0	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  000e5	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv89[rbp], rax
  000ec	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR tv91[rbp]
  000f3	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv89[rbp]
  000fa	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 4794 :         _My_data._Orphan_all();

  000ff	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00103	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 4795 :         _ASAN_STRING_REMOVE(*this);
; 4796 :         _My_data._Mysize      = _New_size;

  00108	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0010c	48 8b 4d 10	 mov	 rcx, QWORD PTR _New_size$[rbp]
  00110	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4797 :         _My_data._Myres       = _New_capacity;

  00114	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00118	48 8b 4d 20	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  0011c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4798 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00120	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00124	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00129	48 89 45 38	 mov	 QWORD PTR _Raw_new$[rbp], rax

; 4799 :         if (_BUF_SIZE <= _Old_capacity) {

  0012d	48 83 7d 18 10	 cmp	 QWORD PTR _Old_capacity$[rbp], 16
  00132	72 5c		 jb	 SHORT $LN3@Reallocate

; 4800 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00134	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00138	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0013c	48 89 45 40	 mov	 QWORD PTR _Old_ptr$1[rbp], rax

; 4801 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  00140	48 8b 4d 40	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  00144	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00149	0f b6 8d c8 00
	00 00		 movzx	 ecx, BYTE PTR <_Args_0>$[rbp]
  00150	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  00154	4c 8b 4d 08	 mov	 r9, QWORD PTR _Old_size$[rbp]
  00158	4c 8b c0	 mov	 r8, rax
  0015b	48 8b 55 38	 mov	 rdx, QWORD PTR _Raw_new$[rbp]
  0015f	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR _Fn$[rbp]
  00166	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()

; 4802 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  0016b	48 8b 45 18	 mov	 rax, QWORD PTR _Old_capacity$[rbp]
  0016f	48 ff c0	 inc	 rax
  00172	4c 8b c0	 mov	 r8, rax
  00175	48 8b 55 40	 mov	 rdx, QWORD PTR _Old_ptr$1[rbp]
  00179	48 8b 4d 28	 mov	 rcx, QWORD PTR _Al$[rbp]
  0017d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4803 :             _My_data._Bx._Ptr = _New_ptr;

  00182	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00186	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  0018a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 4804 :         } else {

  0018e	eb 3e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4805 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  00190	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00194	48 83 c0 08	 add	 rax, 8
  00198	0f b6 8d c8 00
	00 00		 movzx	 ecx, BYTE PTR <_Args_0>$[rbp]
  0019f	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  001a3	4c 8b 4d 08	 mov	 r9, QWORD PTR _Old_size$[rbp]
  001a7	4c 8b c0	 mov	 r8, rax
  001aa	48 8b 55 38	 mov	 rdx, QWORD PTR _Raw_new$[rbp]
  001ae	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR _Fn$[rbp]
  001b5	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()

; 4806 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  001ba	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001be	48 83 c0 08	 add	 rax, 8
  001c2	48 8d 55 30	 lea	 rdx, QWORD PTR _New_ptr$[rbp]
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4807 :         }
; 4808 : 
; 4809 :         _ASAN_STRING_CREATE(*this);
; 4810 :         return *this;

  001ce	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
$LN5@Reallocate:

; 4811 :     }

  001d5	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  001dc	5d		 pop	 rbp
  001dd	c3		 ret	 0
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_New_ptr$ = 104
_Old_ptr$ = 112
_Old_size$ = 120
_Ch$ = 128
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator(), COMDAT

; 4071 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4072 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  0002a	4c 8b 45 78	 mov	 r8, QWORD PTR _Old_size$[rbp]
  0002e	48 8b 55 70	 mov	 rdx, QWORD PTR _Old_ptr$[rbp]
  00032	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00036	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 4073 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0003b	48 8b 45 78	 mov	 rax, QWORD PTR _Old_size$[rbp]
  0003f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00043	48 03 c8	 add	 rcx, rax
  00046	48 8b c1	 mov	 rax, rcx
  00049	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR _Ch$[rbp]
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4074 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00058	c6 45 40 00	 mov	 BYTE PTR $T1[rbp], 0
  0005c	48 8b 45 68	 mov	 rax, QWORD PTR _New_ptr$[rbp]
  00060	48 8b 4d 78	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  00064	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  00069	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4075 :             },

  00075	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00079	5d		 pop	 rbp
  0007a	c3		 ret	 0
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 80
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 303  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 304  :     if constexpr (is_array_v<_Ty>) {
; 305  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 306  :     } else {
; 307  :         _Obj.~_Ty();
; 308  :     }
; 309  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 80
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Ptr$[rbp]

; 37   : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z
_TEXT	SEGMENT
_Obj$ = 80
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z PROC	; std::_Destroy_in_place<wchar_t *>, COMDAT

; 303  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 304  :     if constexpr (is_array_v<_Ty>) {
; 305  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 306  :     } else {
; 307  :         _Obj.~_Ty();
; 308  :     }
; 309  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z ENDP	; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<log_> > const >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<log_> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<log_,void *>::_Freenode0<std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<log_,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0002c	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00030	48 83 c0 08	 add	 rax, 8
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<log_,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

  0003c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00042	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00046	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0004a	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@QEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::deallocate
  0004f	90		 npad	 1

; 313  :     }

  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<log_,void *>::_Freenode0<std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<log_,void *> *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAU?$_List_node@Ulog_@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@Ulog_@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<log_,void *> *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT

; 1483 :     _CONSTEXPR20 ~_Container_proxy_ptr12() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1484 :         if (_Ptr) {

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 14		 je	 SHORT $LN2@Container_

; 1485 :             _Delete_plain_internal(_Al, _Ptr);

  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00030	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00034	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
$LN2@Container_:

; 1486 :         }
; 1487 :     }

  00039	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Al_$ = 104
_Mycont$ = 112
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT

; 1469 :     _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00029	e8 00 00 00 00	 call	 ??0_Basic_container_proxy_ptr12@std@@IEAA@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
  0002e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 4d 68	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00036	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1470 :         // create a new _Container_proxy pointing at _Mycont
; 1471 :         _Ptr = _Unfancy(_Al_.allocate(1));

  0003a	ba 01 00 00 00	 mov	 edx, 1
  0003f	48 8b 4d 68	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00043	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00050	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00054	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1472 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  00057	48 8b 4d 70	 mov	 rcx, QWORD PTR _Mycont$[rbp]
  0005b	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ; std::addressof<std::_Container_base12>
  00060	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00064	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00068	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0006c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006f	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>

; 1473 :         _Mycont._Myproxy = _Ptr;

  00074	48 8b 45 70	 mov	 rax, QWORD PTR _Mycont$[rbp]
  00078	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0007c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1474 :     }

  00082	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00086	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0008a	5d		 pop	 rbp
  0008b	c3		 ret	 0
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z PROC ; std::addressof<std::codecvt<char,char,_Mbstatet> const >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ENDP ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S16$ = 24
_Proxy$ = 32
_New_capacity$ = 48
_New_ptr$ = 56
tv152 = 128
tv148 = 128
tv146 = 136
this$ = 160
_Arg$ = 168
_Count$ = 176
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 2609 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2610 :         auto& _My_data = _Mypair._Myval2;

  00028	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 2611 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2612 : 
; 2613 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2614 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2615 :         } else {
; 2616 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2617 :         }
; 2618 : 
; 2619 :         if (_Count > max_size()) {

  00033	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003a	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0003f	48 39 85 b0 00
	00 00		 cmp	 QWORD PTR _Count$[rbp], rax
  00046	76 05		 jbe	 SHORT $LN2@Construct

; 2620 :             _Xlen_string(); // result too long

  00048	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2621 :         }
; 2622 : 
; 2623 :         auto& _Al       = _Getal();

  0004d	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00054	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00059	48 89 45 08	 mov	 QWORD PTR _Al$[rbp], rax

; 2624 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0005d	48 8b 55 08	 mov	 rdx, QWORD PTR _Al$[rbp]
  00061	48 8d 4d 18	 lea	 rcx, QWORD PTR $S16$[rbp]
  00065	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0006a	48 8d 45 18	 lea	 rax, QWORD PTR $S16$[rbp]
  0006e	48 89 45 10	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 2625 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00072	4c 8b 45 00	 mov	 r8, QWORD PTR _My_data$[rbp]
  00076	48 8b 55 10	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  0007a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0007e	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00083	90		 npad	 1

; 2626 : 
; 2627 :         if (_Count < _BUF_SIZE) {

  00084	48 83 bd b0 00
	00 00 10	 cmp	 QWORD PTR _Count$[rbp], 16
  0008c	73 50		 jae	 SHORT $LN3@Construct

; 2628 :             _My_data._Mysize = _Count;

  0008e	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00092	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  00099	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2629 :             _My_data._Myres  = _BUF_SIZE - 1;

  0009d	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000a1	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 2630 : 
; 2631 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2632 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2633 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2634 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2635 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2636 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2637 :             } else { // _Strat == _Construct_strategy::_From_string
; 2638 : #ifdef _INSERT_STRING_ANNOTATION
; 2639 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2640 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2641 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

  000a9	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000ad	48 83 c0 08	 add	 rax, 8
  000b1	41 b8 10 00 00
	00		 mov	 r8d, 16
  000b7	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _Arg$[rbp]
  000be	48 8b c8	 mov	 rcx, rax
  000c1	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2642 : #endif // !_INSERT_STRING_ANNOTATION
; 2643 :             }
; 2644 : 
; 2645 :             _Proxy._Release();

  000c6	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000ca	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  000cf	90		 npad	 1

; 2646 :             return;

  000d0	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000d4	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000d9	e9 f0 00 00 00	 jmp	 $LN4@Construct
$LN3@Construct:

; 2647 :         }
; 2648 : 
; 2649 :         _My_data._Myres         = _BUF_SIZE - 1;

  000de	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000e2	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 2650 :         size_type _New_capacity = _Calculate_growth(_Count);

  000ea	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR _Count$[rbp]
  000f1	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f8	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  000fd	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2651 :         ++_New_capacity;

  00101	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00105	48 ff c0	 inc	 rax
  00108	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2652 :         const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  0010c	48 8d 55 30	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  00110	48 8b 4d 08	 mov	 rcx, QWORD PTR _Al$[rbp]
  00114	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  00119	48 89 45 38	 mov	 QWORD PTR _New_ptr$[rbp], rax

; 2653 :         --_New_capacity;

  0011d	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00121	48 ff c8	 dec	 rax
  00124	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2654 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00128	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0012c	48 83 c0 08	 add	 rax, 8
  00130	48 8d 55 38	 lea	 rdx, QWORD PTR _New_ptr$[rbp]
  00134	48 8b c8	 mov	 rcx, rax
  00137	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2655 : 
; 2656 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  0013c	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00140	48 ff c0	 inc	 rax
  00143	48 89 85 80 00
	00 00		 mov	 QWORD PTR tv148[rbp], rax
  0014a	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  0014e	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00153	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv146[rbp], rax
  0015a	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR tv148[rbp]
  00161	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR tv146[rbp]
  00168	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 2657 : 
; 2658 :         _My_data._Mysize = _Count;

  0016d	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00171	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  00178	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2659 :         _My_data._Myres  = _New_capacity;

  0017c	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00180	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  00184	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2660 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2661 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2662 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2663 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2664 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2665 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2666 :         } else { // _Strat == _Construct_strategy::_From_string
; 2667 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  00188	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  0018f	48 ff c0	 inc	 rax
  00192	48 89 85 80 00
	00 00		 mov	 QWORD PTR tv152[rbp], rax
  00199	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  0019d	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  001a2	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR tv152[rbp]
  001a9	4c 8b c1	 mov	 r8, rcx
  001ac	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _Arg$[rbp]
  001b3	48 8b c8	 mov	 rcx, rax
  001b6	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2668 :         }
; 2669 : 
; 2670 :         _ASAN_STRING_CREATE(*this);
; 2671 :         _Proxy._Release();

  001bb	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  001bf	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  001c4	90		 npad	 1

; 2672 :     }

  001c5	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  001c9	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
$LN4@Construct:
  001ce	48 8d a5 90 00
	00 00		 lea	 rsp, QWORD PTR [rbp+144]
  001d5	5d		 pop	 rbp
  001d6	c3		 ret	 0
$LN6@Construct:
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S16$ = 24
_Proxy$ = 32
_New_capacity$ = 48
_New_ptr$ = 56
tv152 = 128
tv148 = 128
tv146 = 136
this$ = 160
_Arg$ = 168
_Count$ = 176
?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S15$ = 24
_Proxy$ = 32
_New_capacity$ = 48
_New_ptr$ = 56
$T1 = 128
$T2 = 129
tv154 = 136
tv152 = 144
this$ = 176
_Arg$ = 184
_Count$ = 192
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 2609 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2610 :         auto& _My_data = _Mypair._Myval2;

  00028	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 2611 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2612 : 
; 2613 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2614 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2615 :         } else {
; 2616 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2617 :         }
; 2618 : 
; 2619 :         if (_Count > max_size()) {

  00033	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003a	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0003f	48 39 85 c0 00
	00 00		 cmp	 QWORD PTR _Count$[rbp], rax
  00046	76 05		 jbe	 SHORT $LN2@Construct

; 2620 :             _Xlen_string(); // result too long

  00048	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2621 :         }
; 2622 : 
; 2623 :         auto& _Al       = _Getal();

  0004d	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00054	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00059	48 89 45 08	 mov	 QWORD PTR _Al$[rbp], rax

; 2624 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0005d	48 8b 55 08	 mov	 rdx, QWORD PTR _Al$[rbp]
  00061	48 8d 4d 18	 lea	 rcx, QWORD PTR $S15$[rbp]
  00065	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0006a	48 8d 45 18	 lea	 rax, QWORD PTR $S15$[rbp]
  0006e	48 89 45 10	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 2625 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00072	4c 8b 45 00	 mov	 r8, QWORD PTR _My_data$[rbp]
  00076	48 8b 55 10	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  0007a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0007e	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00083	90		 npad	 1

; 2626 : 
; 2627 :         if (_Count < _BUF_SIZE) {

  00084	48 83 bd c0 00
	00 00 10	 cmp	 QWORD PTR _Count$[rbp], 16
  0008c	73 77		 jae	 SHORT $LN3@Construct

; 2628 :             _My_data._Mysize = _Count;

  0008e	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00092	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  00099	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2629 :             _My_data._Myres  = _BUF_SIZE - 1;

  0009d	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000a1	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 2630 : 
; 2631 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2632 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2633 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2634 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2635 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

  000a9	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000ad	48 83 c0 08	 add	 rax, 8
  000b1	4c 8b 85 c0 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  000b8	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _Arg$[rbp]
  000bf	48 8b c8	 mov	 rcx, rax
  000c2	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2636 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  000c7	c6 85 80 00 00
	00 00		 mov	 BYTE PTR $T1[rbp], 0
  000ce	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000d2	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  000d9	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  000de	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR $T1[rbp]
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2637 :             } else { // _Strat == _Construct_strategy::_From_string
; 2638 : #ifdef _INSERT_STRING_ANNOTATION
; 2639 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2640 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2641 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2642 : #endif // !_INSERT_STRING_ANNOTATION
; 2643 :             }
; 2644 : 
; 2645 :             _Proxy._Release();

  000ed	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000f1	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  000f6	90		 npad	 1

; 2646 :             return;

  000f7	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000fb	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00100	e9 02 01 00 00	 jmp	 $LN4@Construct
$LN3@Construct:

; 2647 :         }
; 2648 : 
; 2649 :         _My_data._Myres         = _BUF_SIZE - 1;

  00105	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00109	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 2650 :         size_type _New_capacity = _Calculate_growth(_Count);

  00111	48 8b 95 c0 00
	00 00		 mov	 rdx, QWORD PTR _Count$[rbp]
  00118	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011f	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00124	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2651 :         ++_New_capacity;

  00128	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  0012c	48 ff c0	 inc	 rax
  0012f	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2652 :         const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  00133	48 8d 55 30	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  00137	48 8b 4d 08	 mov	 rcx, QWORD PTR _Al$[rbp]
  0013b	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  00140	48 89 45 38	 mov	 QWORD PTR _New_ptr$[rbp], rax

; 2653 :         --_New_capacity;

  00144	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00148	48 ff c8	 dec	 rax
  0014b	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2654 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0014f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00153	48 83 c0 08	 add	 rax, 8
  00157	48 8d 55 38	 lea	 rdx, QWORD PTR _New_ptr$[rbp]
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2655 : 
; 2656 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  00163	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00167	48 ff c0	 inc	 rax
  0016a	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv154[rbp], rax
  00171	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00175	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  0017a	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv152[rbp], rax
  00181	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR tv154[rbp]
  00188	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv152[rbp]
  0018f	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 2657 : 
; 2658 :         _My_data._Mysize = _Count;

  00194	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00198	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  0019f	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2659 :         _My_data._Myres  = _New_capacity;

  001a3	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001a7	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  001ab	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2660 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2661 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2662 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2663 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2664 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

  001af	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  001b3	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  001b8	4c 8b 85 c0 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  001bf	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _Arg$[rbp]
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2665 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  001ce	c6 85 81 00 00
	00 00		 mov	 BYTE PTR $T2[rbp], 0
  001d5	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  001d9	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  001de	48 03 85 c0 00
	00 00		 add	 rax, QWORD PTR _Count$[rbp]
  001e5	48 8d 95 81 00
	00 00		 lea	 rdx, QWORD PTR $T2[rbp]
  001ec	48 8b c8	 mov	 rcx, rax
  001ef	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2666 :         } else { // _Strat == _Construct_strategy::_From_string
; 2667 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2668 :         }
; 2669 : 
; 2670 :         _ASAN_STRING_CREATE(*this);
; 2671 :         _Proxy._Release();

  001f4	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  001f8	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  001fd	90		 npad	 1

; 2672 :     }

  001fe	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00202	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
$LN4@Construct:
  00207	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  0020e	5d		 pop	 rbp
  0020f	c3		 ret	 0
$LN6@Construct:
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S15$ = 24
_Proxy$ = 32
_New_capacity$ = 48
_New_ptr$ = 56
$T1 = 128
$T2 = 129
tv154 = 136
tv152 = 144
this$ = 176
_Arg$ = 184
_Count$ = 192
?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  00028	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
_Val1$ = 96
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1524 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1070 : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1071 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1072 :         _Left = _STD move(_Right);
; 1073 :     }
; 1074 : }

  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1063 : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1064 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1065 :         _Left = _Right;
; 1066 :     }
; 1067 : }

  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 80
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1108 :     sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1109 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1110 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1111 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1112 : 
; 1113 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1114 :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 1115 :             _Xlength_error("size is too long for _Size_type");
; 1116 :         }
; 1117 :     }
; 1118 : 
; 1119 :     return static_cast<_Size_type>(_Len);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Len$[rbp]

; 1120 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
_New_proxy$ = 0
$T1 = 72
this$ = 96
_Al$ = 104
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT

; 1207 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1208 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  00020	ba 01 00 00 00	 mov	 edx, 1
  00025	48 8b 4d 68	 mov	 rcx, QWORD PTR _Al$[rbp]
  00029	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00036	48 89 45 00	 mov	 QWORD PTR _New_proxy$[rbp], rax

; 1209 :         _Construct_in_place(*_New_proxy, this);

  0003a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00042	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  00046	48 8b 4d 00	 mov	 rcx, QWORD PTR _New_proxy$[rbp]
  0004a	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>

; 1210 :         _Myproxy            = _New_proxy;

  0004f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00053	48 8b 4d 00	 mov	 rcx, QWORD PTR _New_proxy$[rbp]
  00057	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1211 :         _New_proxy->_Mycont = this;

  0005a	48 8b 45 00	 mov	 rax, QWORD PTR _New_proxy$[rbp]
  0005e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00062	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1212 :     }

  00065	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0_W@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0_W@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><wchar_t>, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0_W@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 80
??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z PROC		; std::_Refancy<wchar_t *,0>, COMDAT

; 295  : _CONSTEXPR20 _Pointer _Refancy(_Pointer _Ptr) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 296  :     return _Ptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Ptr$[rbp]

; 297  : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z ENDP		; std::_Refancy<wchar_t *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1><>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	e8 00 00 00 00	 call	 ??0?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_List_node<log_,void *> >::allocator<std::_List_node<log_,void *> >
  00028	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 ??0?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<log_> >::_List_val<std::_List_simple_types<log_> >
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
_TEXT	SEGMENT
_Alproxy$ = 0
$S8$ = 8
_Proxy$ = 16
_Appended$ = 32
this$ = 144
_First$ = 152
_Last$ = 160
??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z PROC ; std::list<log_,std::allocator<log_> >::_Construct_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >, COMDAT

; 855  :     void _Construct_range_unchecked(_Iter _First, const _Sent _Last) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 856  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00028	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  00034	48 8b d0	 mov	 rdx, rax
  00037	48 8d 4d 08	 lea	 rcx, QWORD PTR $S8$[rbp]
  0003b	e8 00 00 00 00	 call	 ??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<log_,void *> >
  00040	48 8d 45 08	 lea	 rax, QWORD PTR $S8$[rbp]
  00044	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 857  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00048	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004f	4c 8b c0	 mov	 r8, rax
  00052	48 8b 55 00	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  00056	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0005a	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0005f	90		 npad	 1

; 858  :         _List_node_insert_op2<_Alnode> _Appended(_Getal());

  00060	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00067	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  0006c	48 8b d0	 mov	 rdx, rax
  0006f	48 8d 4d 20	 lea	 rcx, QWORD PTR _Appended$[rbp]
  00073	e8 00 00 00 00	 call	 ??0?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
  00078	90		 npad	 1

; 859  :         _Appended._Append_range_unchecked(_STD move(_First), _Last);

  00079	4c 8b 85 a0 00
	00 00		 mov	 r8, QWORD PTR _Last$[rbp]
  00080	48 8b 95 98 00
	00 00		 mov	 rdx, QWORD PTR _First$[rbp]
  00087	48 8d 4d 20	 lea	 rcx, QWORD PTR _Appended$[rbp]
  0008b	e8 00 00 00 00	 call	 ??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >

; 860  :         _Appended._Attach_head(_Mypair._Myval2);

  00090	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00097	48 8b d0	 mov	 rdx, rax
  0009a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Appended$[rbp]
  0009e	e8 00 00 00 00	 call	 ??$_Attach_head@U?$_List_simple_types@Ulog_@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAXAEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::_Attach_head<std::_List_simple_types<log_> >

; 861  :         _Proxy._Release();

  000a3	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000a7	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  000ac	90		 npad	 1

; 862  :     }

  000ad	48 8d 4d 20	 lea	 rcx, QWORD PTR _Appended$[rbp]
  000b1	e8 00 00 00 00	 call	 ??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
  000b6	90		 npad	 1
  000b7	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000bb	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000c0	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  000c7	5d		 pop	 rbp
  000c8	c3		 ret	 0
??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ENDP ; std::list<log_,std::allocator<log_> >::_Construct_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Alproxy$ = 0
$S8$ = 8
_Proxy$ = 16
_Appended$ = 32
this$ = 144
_First$ = 152
_Last$ = 160
?dtor$0@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA PROC ; `std::list<log_,std::allocator<log_> >::_Construct_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA ENDP ; `std::list<log_,std::allocator<log_> >::_Construct_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Alproxy$ = 0
$S8$ = 8
_Proxy$ = 16
_Appended$ = 32
this$ = 144
_First$ = 152
_Last$ = 160
?dtor$1@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA PROC ; `std::list<log_,std::allocator<log_> >::_Construct_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Appended$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<log_,void *> > >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$1@?0???$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z@4HA ENDP ; `std::list<log_,std::allocator<log_> >::_Construct_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
_Val1$ = 96
??$?0V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1><std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 1524 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??0?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<log_> >::_List_val<std::_List_simple_types<log_> >
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$?0V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1><std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1135 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1136 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1137 :     using _Ty = typename _Alloc::value_type;
; 1138 :     _Ptr->~_Ty();
; 1139 :     _Deallocate_plain(_Al, _Ptr);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00028	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >

; 1140 : }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<log_,void *> >, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<log_,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ; std::_Get_size_of_n<16>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bb	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$assign@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@$0A@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@0@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
this$ = 96
_First$ = 104
_Last$ = 112
??$assign@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@$0A@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@0@Z PROC ; std::list<log_,std::allocator<log_> >::assign<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,0>, COMDAT

; 1333 :     void assign(_Iter _First, _Iter _Last) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1334 :         _Adl_verify_range(_First, _Last);

  00025	48 8d 55 70	 lea	 rdx, QWORD PTR _Last$[rbp]
  00029	48 8d 4d 68	 lea	 rcx, QWORD PTR _First$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >

; 1335 :         _Assign_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last));

  00032	48 8d 4d 70	 lea	 rcx, QWORD PTR _Last$[rbp]
  00036	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> &>
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00042	48 8d 4d 68	 lea	 rcx, QWORD PTR _First$[rbp]
  00046	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> &>
  0004b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00052	4c 8b 45 48	 mov	 r8, QWORD PTR $T2[rbp]
  00056	48 8b 55 40	 mov	 rdx, QWORD PTR $T1[rbp]
  0005a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0005e	e8 00 00 00 00	 call	 ??$_Assign_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::list<log_,std::allocator<log_> >::_Assign_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >

; 1336 :     }

  00063	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00067	5d		 pop	 rbp
  00068	c3		 ret	 0
??$assign@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@$0A@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@0@Z ENDP ; std::list<log_,std::allocator<log_> >::assign<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 64
this$ = 96
_Right$ = 104
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 72   :         return _Ptr == _Right._Ptr;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	75 09		 jne	 SHORT $LN3@operator
  00030	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv67[rbp], 1
  00037	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00039	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv67[rbp], 0
$LN4@operator:
  00040	0f b6 45 40	 movzx	 eax, BYTE PTR tv67[rbp]

; 73   :     }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 80
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 50   :         _Ptr = _Ptr->_Next;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 01	 mov	 QWORD PTR [rcx], rax

; 51   :         return *this;

  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 52   :     }

  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ
_TEXT	SEGMENT
this$ = 80
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 42   :         return _Ptr->_Myval;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 83 c0 10	 add	 rax, 16

; 43   :     }

  00026	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBUlog_@@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Pnode$ = 88
_Plist$ = 96
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

  00030	48 8b 55 60	 mov	 rdx, QWORD PTR _Plist$[rbp]
  00034	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt

; 39   :     }

  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
??$_Pocca@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 1063 : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1064 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1065 :         _Left = _Right;
; 1066 :     }
; 1067 : }

  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
??$_Pocca@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@$$CBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@@std@@YAPEBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@$$CBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@@std@@YAPEBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::list<log_,std::allocator<log_> > const >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@$$CBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@@std@@YAPEBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::list<log_,std::allocator<log_> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Emplace@AEBUlog_@@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@QEAU21@AEBUlog_@@@Z
_TEXT	SEGMENT
_Mysize$ = 0
_Op$ = 8
$T1 = 88
this$ = 112
_Where$ = 120
<_Val_0>$ = 128
??$_Emplace@AEBUlog_@@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@QEAU21@AEBUlog_@@@Z PROC ; std::list<log_,std::allocator<log_> >::_Emplace<log_ const &>, COMDAT

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00028	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 83 c0 10	 add	 rax, 16
  00030	48 89 45 00	 mov	 QWORD PTR _Mysize$[rbp], rax

; 1014 :         if (_Mysize == max_size()) {

  00034	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00038	e8 00 00 00 00	 call	 ?max_size@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_KXZ ; std::list<log_,std::allocator<log_> >::max_size
  0003d	48 8b 4d 00	 mov	 rcx, QWORD PTR _Mysize$[rbp]
  00041	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00044	75 0c		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NKNMEGII@list?5too?5long@
  0004d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1016 :         }
; 1017 : 
; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00052	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00056	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  0005b	4c 8b 85 80 00
	00 00		 mov	 r8, QWORD PTR <_Val_0>$[rbp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	48 8d 4d 08	 lea	 rcx, QWORD PTR _Op$[rbp]
  00069	e8 00 00 00 00	 call	 ??$?0AEBUlog_@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@AEBUlog_@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > ><log_ const &>

; 1019 :         ++_Mysize;

  0006e	48 8b 45 00	 mov	 rax, QWORD PTR _Mysize$[rbp]
  00072	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00075	48 ff c0	 inc	 rax
  00078	48 8b 4d 00	 mov	 rcx, QWORD PTR _Mysize$[rbp]
  0007c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1020 :         return _Op._Transfer_before(_Where);

  0007f	48 8b 55 78	 mov	 rdx, QWORD PTR _Where$[rbp]
  00083	48 8d 4d 08	 lea	 rcx, QWORD PTR _Op$[rbp]
  00087	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@QEAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::_Transfer_before
  0008c	48 89 45 58	 mov	 QWORD PTR $T1[rbp], rax
  00090	48 8d 4d 08	 lea	 rcx, QWORD PTR _Op$[rbp]
  00094	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<log_,void *> > >
  00099	48 8b 45 58	 mov	 rax, QWORD PTR $T1[rbp]

; 1021 :     }

  0009d	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a1	5d		 pop	 rbp
  000a2	c3		 ret	 0
??$_Emplace@AEBUlog_@@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@QEAU21@AEBUlog_@@@Z ENDP ; std::list<log_,std::allocator<log_> >::_Emplace<log_ const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<log_,void *>::_Freenode<std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00024	48 83 c0 10	 add	 rax, 16
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??$addressof@Ulog_@@@std@@YAPEAUlog_@@AEAU1@@Z ; std::addressof<log_>
  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00037	e8 00 00 00 00	 call	 ??$destroy@Ulog_@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@QEAUlog_@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::destroy<log_>

; 318  :         _Freenode0(_Al, _Ptr);

  0003c	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00040	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00044	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Freenode0<std::allocator<std::_List_node<log_,void *> > >
  00049	90		 npad	 1

; 319  :     }

  0004a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<log_,void *>::_Freenode<std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<log_> > >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<log_> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 0
_Pnext$1 = 8
_Al$ = 96
_Head$ = 104
??$_Free_non_head@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<log_,void *>::_Free_non_head<std::allocator<std::_List_node<log_,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 324  :         _Head->_Prev->_Next = nullptr;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Head$[rbp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0002f	48 8b 45 68	 mov	 rax, QWORD PTR _Head$[rbp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 89 45 00	 mov	 QWORD PTR _Pnode$[rbp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0003a	eb 08		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00040	48 89 45 00	 mov	 QWORD PTR _Pnode$[rbp], rax
$LN4@Free_non_h:
  00044	48 83 7d 00 00	 cmp	 QWORD PTR _Pnode$[rbp], 0
  00049	74 1a		 je	 SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  0004b	48 8b 45 00	 mov	 rax, QWORD PTR _Pnode$[rbp]
  0004f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00052	48 89 45 08	 mov	 QWORD PTR _Pnext$1[rbp], rax

; 329  :             _Freenode(_Al, _Pnode);

  00056	48 8b 55 00	 mov	 rdx, QWORD PTR _Pnode$[rbp]
  0005a	48 8b 4d 60	 mov	 rcx, QWORD PTR _Al$[rbp]
  0005e	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Freenode<std::allocator<std::_List_node<log_,void *> > >

; 330  :         }

  00063	eb d7		 jmp	 SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

  00065	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<log_,void *>::_Free_non_head<std::allocator<std::_List_node<log_,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
$T1 = 64
tv65 = 72
_Left$ = 96
_Right$ = 104
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 98   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 99   :     // return smaller of _Left and _Right
; 100  :     return _Right < _Left ? _Right : _Left;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00024	48 8b 4d 60	 mov	 rcx, QWORD PTR _Left$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	73 0a		 jae	 SHORT $LN3@min
  00030	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00034	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
  00038	eb 08		 jmp	 SHORT $LN4@min
$LN3@min:
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR _Left$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
$LN4@min:
  00042	48 8b 45 48	 mov	 rax, QWORD PTR tv65[rbp]
  00046	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0004a	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 101  : }

  0004e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 80
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 64   :     operator streamoff() const noexcept /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__95B36E16_iosfwd
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :         // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
; 66   :         // basic_filebuf would set _Fpos.
; 67   :         return _Myoff + _Fpos;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]

; 68   :     }

  0002a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT

; 56   :     _NODISCARD _Statetype state() const {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__95B36E16_iosfwd
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 57   :         return _Mystate;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00028	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0002c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002f	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 58   :     }

  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
this$ = 80
_State$ = 88
_Fileposition$ = 96
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__95B36E16_iosfwd
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 4d 60	 mov	 rcx, QWORD PTR _Fileposition$[rbp]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 4d 58	 mov	 rcx, QWORD PTR _State$[rbp]
  00044	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 96
_Off$ = 104
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__95B36E16_iosfwd
  0001c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00021	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8b 4d 68	 mov	 rcx, QWORD PTR _Off$[rbp]
  00029	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00030	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00038	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 83 c0 10	 add	 rax, 16
  00040	48 8b f8	 mov	 rdi, rax
  00043	33 c0		 xor	 eax, eax
  00045	b9 08 00 00 00	 mov	 ecx, 8
  0004a	f3 aa		 rep stosb
  0004c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00050	48 8d 65 48	 lea	 rsp, QWORD PTR [rbp+72]
  00054	5f		 pop	 rdi
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
_Lock$1 = 0
_Psave$2 = 8
_Id$3 = 16
_Pf$4 = 24
_Pfmod$5 = 32
_Psave_guard$6 = 40
$T7 = 112
_Loc$ = 144
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT

; 434  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__CC18A947_xlocale
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 435  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  0001e	33 d2		 xor	 edx, edx
  00020	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$1[rbp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  0002a	90		 npad	 1

; 436  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
  00032	48 89 45 08	 mov	 QWORD PTR _Psave$2[rbp], rax

; 437  : 
; 438  :     const size_t _Id         = _Facet::id;

  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??Bid@locale@std@@QEAA_KXZ
  00043	48 89 45 10	 mov	 QWORD PTR _Id$3[rbp], rax

; 439  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  00047	48 8b 55 10	 mov	 rdx, QWORD PTR _Id$3[rbp]
  0004b	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Loc$[rbp]
  00052	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ; std::locale::_Getfacet
  00057	48 89 45 18	 mov	 QWORD PTR _Pf$4[rbp], rax

; 440  : 
; 441  :     if (!_Pf) {

  0005b	48 83 7d 18 00	 cmp	 QWORD PTR _Pf$4[rbp], 0
  00060	0f 85 83 00 00
	00		 jne	 $LN2@use_facet

; 442  :         if (_Psave) {

  00066	48 83 7d 08 00	 cmp	 QWORD PTR _Psave$2[rbp], 0
  0006b	74 0a		 je	 SHORT $LN3@use_facet

; 443  :             _Pf = _Psave; // lazy facet already allocated

  0006d	48 8b 45 08	 mov	 rax, QWORD PTR _Psave$2[rbp]
  00071	48 89 45 18	 mov	 QWORD PTR _Pf$4[rbp], rax
  00075	eb 72		 jmp	 SHORT $LN2@use_facet
$LN3@use_facet:

; 444  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  00077	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR _Loc$[rbp]
  0007e	48 8d 4d 08	 lea	 rcx, QWORD PTR _Psave$2[rbp]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
  00088	48 83 f8 ff	 cmp	 rax, -1
  0008c	75 08		 jne	 SHORT $LN5@use_facet

; 445  : #if _HAS_EXCEPTIONS
; 446  :             _Throw_bad_cast(); // lazy disallowed

  0008e	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
  00093	90		 npad	 1

; 447  : #else // _HAS_EXCEPTIONS
; 448  :             _CSTD abort(); // lazy disallowed
; 449  : #endif // _HAS_EXCEPTIONS
; 450  :         } else { // queue up lazy facet for destruction

  00094	eb 53		 jmp	 SHORT $LN2@use_facet
$LN5@use_facet:

; 451  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  00096	48 8b 45 08	 mov	 rax, QWORD PTR _Psave$2[rbp]
  0009a	48 89 45 20	 mov	 QWORD PTR _Pfmod$5[rbp], rax

; 452  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  0009e	48 8b 55 20	 mov	 rdx, QWORD PTR _Pfmod$5[rbp]
  000a2	48 8d 4d 28	 lea	 rcx, QWORD PTR _Psave_guard$6[rbp]
  000a6	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
  000ab	90		 npad	 1

; 453  : 
; 454  : #if defined(_M_CEE)
; 455  :             _Facet_Register_m(_Pfmod);
; 456  : #else // defined(_M_CEE)
; 457  :             _Facet_Register(_Pfmod);

  000ac	48 8b 4d 20	 mov	 rcx, QWORD PTR _Pfmod$5[rbp]
  000b0	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 458  : #endif // defined(_M_CEE)
; 459  : 
; 460  :             _Pfmod->_Incref();

  000b5	48 8b 45 20	 mov	 rax, QWORD PTR _Pfmod$5[rbp]
  000b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bc	48 8b 4d 20	 mov	 rcx, QWORD PTR _Pfmod$5[rbp]
  000c0	ff 50 08	 call	 QWORD PTR [rax+8]

; 461  :             _Facetptr<_Facet>::_Psave = _Psave;

  000c3	48 8b 45 08	 mov	 rax, QWORD PTR _Psave$2[rbp]
  000c7	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB, rax ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 462  :             _Pf                       = _Psave;

  000ce	48 8b 45 08	 mov	 rax, QWORD PTR _Psave$2[rbp]
  000d2	48 89 45 18	 mov	 QWORD PTR _Pf$4[rbp], rax

; 463  : 
; 464  :             (void) _Psave_guard.release();

  000d6	48 8d 4d 28	 lea	 rcx, QWORD PTR _Psave_guard$6[rbp]
  000da	e8 00 00 00 00	 call	 ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
  000df	90		 npad	 1

; 465  :         }

  000e0	48 8d 4d 28	 lea	 rcx, QWORD PTR _Psave_guard$6[rbp]
  000e4	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  000e9	48 8b 45 18	 mov	 rax, QWORD PTR _Pf$4[rbp]
  000ed	48 89 45 70	 mov	 QWORD PTR $T7[rbp], rax
  000f1	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$1[rbp]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000fb	48 8b 45 70	 mov	 rax, QWORD PTR $T7[rbp]

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

  000ff	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  00106	5d		 pop	 rbp
  00107	c3		 ret	 0
$LN10@use_facet:
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 0
_Psave$2 = 8
_Id$3 = 16
_Pf$4 = 24
_Pfmod$5 = 32
_Psave_guard$6 = 40
$T7 = 112
_Loc$ = 144
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$1[rbp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00014	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00018	5d		 pop	 rbp
  00019	c3		 ret	 0
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 0
_Psave$2 = 8
_Id$3 = 16
_Pf$4 = 24
_Pfmod$5 = 32
_Psave_guard$6 = 40
$T7 = 112
_Loc$ = 144
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 28	 lea	 rcx, QWORD PTR _Psave_guard$6[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z
_TEXT	SEGMENT
$T1 = 64
_Rel_time$ = 96
??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z PROC ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >, COMDAT

; 201  :     void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 202  :         sleep_until(_To_absolute_time(_Rel_time));

  0001b	48 8b 55 60	 mov	 rdx, QWORD PTR _Rel_time$[rbp]
  0001f	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00023	e8 00 00 00 00	 call	 ??$_To_absolute_time@_JU?$ratio@$00$0DOI@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z ; std::_To_absolute_time<__int64,std::ratio<1,1000> >
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >

; 203  :     }

  00030	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ENDP ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0H$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEBH@Z
_TEXT	SEGMENT
this$ = 80
_Val$ = 88
??$?0H$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEBH@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,0>, COMDAT

; 98   :             : _MyRep(static_cast<_Rep>(_Val)) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$?0H$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEBH@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Length$1 = 16
_Count$2 = 24
$T3 = 96
$T4 = 97
tv128 = 104
tv72 = 104
this$ = 128
_First$ = 136
_Last$ = 144
_Al$ = 152
??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>, COMDAT

; 2569 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0002d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 89 45 68	 mov	 QWORD PTR tv72[rbp], rax
  00038	4c 8b 85 98 00
	00 00		 mov	 r8, QWORD PTR _Al$[rbp]
  0003f	0f b6 55 60	 movzx	 edx, BYTE PTR $T3[rbp]
  00043	48 8b 4d 68	 mov	 rcx, QWORD PTR tv72[rbp]
  00047	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
  0004c	90		 npad	 1

; 2570 :         _Adl_verify_range(_First, _Last);

  0004d	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR _Last$[rbp]
  00054	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _First$[rbp]
  0005b	e8 00 00 00 00	 call	 ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >

; 2571 :         auto _UFirst = _Get_unwrapped(_First);

  00060	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _First$[rbp]
  00067	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &>
  0006c	48 89 45 00	 mov	 QWORD PTR _UFirst$[rbp], rax

; 2572 :         auto _ULast  = _Get_unwrapped(_Last);

  00070	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  00077	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &>
  0007c	48 89 45 08	 mov	 QWORD PTR _ULast$[rbp], rax

; 2573 :         if (_UFirst == _ULast) {

  00080	48 8b 45 08	 mov	 rax, QWORD PTR _ULast$[rbp]
  00084	48 39 45 00	 cmp	 QWORD PTR _UFirst$[rbp], rax
  00088	75 3d		 jne	 SHORT $LN2@allocator

; 2574 :             _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0008a	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00091	48 89 45 68	 mov	 QWORD PTR tv128[rbp], rax
  00095	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000a1	48 8b d0	 mov	 rdx, rax
  000a4	48 8d 4d 61	 lea	 rcx, QWORD PTR $T4[rbp]
  000a8	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  000ad	48 8b d0	 mov	 rdx, rax
  000b0	48 8b 4d 68	 mov	 rcx, QWORD PTR tv128[rbp]
  000b4	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2575 :             _Tidy_init();

  000b9	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c0	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2576 :         } else {

  000c5	eb 37		 jmp	 SHORT $LN3@allocator
$LN2@allocator:

; 2577 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2578 :                 _Construct<_Construct_strategy::_From_ptr>(
; 2579 :                     _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2580 :             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
; 2581 :                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));

  000c7	48 8b 55 08	 mov	 rdx, QWORD PTR _ULast$[rbp]
  000cb	48 8b 4d 00	 mov	 rcx, QWORD PTR _UFirst$[rbp]
  000cf	e8 00 00 00 00	 call	 ??$distance@PEA_W@std@@YA_JPEA_W0@Z ; std::distance<wchar_t *>
  000d4	48 89 45 10	 mov	 QWORD PTR _Length$1[rbp], rax

; 2582 :                 const auto _Count  = _Convert_size<size_type>(_Length);

  000d8	48 8b 4d 10	 mov	 rcx, QWORD PTR _Length$1[rbp]
  000dc	e8 00 00 00 00	 call	 ??$_Convert_size@_K_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64,unsigned __int64>
  000e1	48 89 45 18	 mov	 QWORD PTR _Count$2[rbp], rax

; 2583 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);

  000e5	4c 8b 4d 18	 mov	 r9, QWORD PTR _Count$2[rbp]
  000e9	4c 8b 45 08	 mov	 r8, QWORD PTR _ULast$[rbp]
  000ed	48 8b 55 00	 mov	 rdx, QWORD PTR _UFirst$[rbp]
  000f1	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f8	e8 00 00 00 00	 call	 ??$_Construct_from_iter@PEA_WPEA_W_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXPEA_WQEA_W_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<wchar_t *,wchar_t *,unsigned __int64>
  000fd	90		 npad	 1
$LN3@allocator:

; 2584 :             } else {
; 2585 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
; 2586 :             }
; 2587 :         }
; 2588 :     }

  000fe	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _First$[rbp]
  00105	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ
  0010a	90		 npad	 1
  0010b	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  00112	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ
  00117	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0011e	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00122	5d		 pop	 rbp
  00123	c3		 ret	 0
??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Length$1 = 16
_Count$2 = 24
$T3 = 96
$T4 = 97
tv128 = 104
tv72 = 104
this$ = 128
_First$ = 136
_Last$ = 144
_Al$ = 152
?dtor$0@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Length$1 = 16
_Count$2 = 24
$T3 = 96
$T4 = 97
tv128 = 104
tv72 = 104
this$ = 128
_First$ = 136
_Last$ = 144
_Al$ = 152
?dtor$1@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _First$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$1@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Length$1 = 16
_Count$2 = 24
$T3 = 96
$T4 = 97
tv128 = 104
tv72 = 104
this$ = 128
_First$ = 136
_Last$ = 144
_Al$ = 152
?dtor$2@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$2@?0???$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ
_TEXT	SEGMENT
this$ = 80
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped, COMDAT

; 2157 :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2158 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00023	e8 00 00 00 00	 call	 ??$_Unfancy@$$CB_W@std@@YAPEB_WPEB_W@Z ; std::_Unfancy<wchar_t const >

; 2159 :     }

  00028	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QEAA@XZ ; std::_Iterator_base12::~_Iterator_base12
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Verify_range@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
_TEXT	SEGMENT
tv69 = 64
_First$ = 96
_Last$ = 104
?_Verify_range@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z PROC ; std::_Verify_range, COMDAT

; 2025 :         const _String_const_iterator& _First, const _String_const_iterator& _Last) noexcept {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@Verify_ran:

; 2026 :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "string iterators in range are from different containers");

  00023	48 8b 4d 60	 mov	 rcx, QWORD PTR _First$[rbp]
  00027	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002c	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  00030	48 8b 4d 68	 mov	 rcx, QWORD PTR _Last$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00039	48 8b 4d 40	 mov	 rcx, QWORD PTR tv69[rbp]
  0003d	48 3b c8	 cmp	 rcx, rax
  00040	75 02		 jne	 SHORT $LN7@Verify_ran
  00042	eb 6b		 jmp	 SHORT $LN15@Verify_ran
$LN7@Verify_ran:
  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DI@FIGNHEDK@string?5iterators?5in?5range?5are?5f@
  0004b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00057	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005c	45 33 c9	 xor	 r9d, r9d
  0005f	41 b8 ea 07 00
	00		 mov	 r8d, 2026		; 000007eaH
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@
  0006c	b9 02 00 00 00	 mov	 ecx, 2
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00077	83 f8 01	 cmp	 eax, 1
  0007a	75 03		 jne	 SHORT $LN19@Verify_ran
  0007c	cc		 int	 3
  0007d	33 c0		 xor	 eax, eax
$LN19@Verify_ran:
  0007f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00088	41 b9 ea 07 00
	00		 mov	 r9d, 2026		; 000007eaH
  0008e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HE@MFNJODIC@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 95		 jne	 SHORT $LN7@Verify_ran
$LN15@Verify_ran:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	0f 85 6a ff ff
	ff		 jne	 $LN4@Verify_ran
$LN10@Verify_ran:

; 2027 :         _STL_VERIFY(_First._Ptr <= _Last._Ptr, "string iterator range transposed");

  000b9	48 8b 45 60	 mov	 rax, QWORD PTR _First$[rbp]
  000bd	48 8b 4d 68	 mov	 rcx, QWORD PTR _Last$[rbp]
  000c1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000c5	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000c9	77 02		 ja	 SHORT $LN13@Verify_ran
  000cb	eb 6b		 jmp	 SHORT $LN17@Verify_ran
$LN13@Verify_ran:
  000cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CB@KDGGCAAF@string?5iterator?5range?5transpose@
  000d4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  000e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e5	45 33 c9	 xor	 r9d, r9d
  000e8	41 b8 eb 07 00
	00		 mov	 r8d, 2027		; 000007ebH
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@
  000f5	b9 02 00 00 00	 mov	 ecx, 2
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00100	83 f8 01	 cmp	 eax, 1
  00103	75 03		 jne	 SHORT $LN20@Verify_ran
  00105	cc		 int	 3
  00106	33 c0		 xor	 eax, eax
$LN20@Verify_ran:
  00108	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00111	41 b9 eb 07 00
	00		 mov	 r9d, 2027		; 000007ebH
  00117	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@NKDFABAL@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 95		 jne	 SHORT $LN13@Verify_ran
$LN17@Verify_ran:
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 77 ff ff
	ff		 jne	 $LN10@Verify_ran

; 2028 :     }

  00142	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00146	5d		 pop	 rbp
  00147	c3		 ret	 0
?_Verify_range@std@@YAXAEBV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ENDP ; std::_Verify_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 80
_Parg$ = 88
_Pstring$ = 96
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1852 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00029	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QEAA@XZ ; std::_Iterator_base12::_Iterator_base12
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 4d 58	 mov	 rcx, QWORD PTR _Parg$[rbp]
  00036	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1853 :         this->_Adopt(_Pstring);

  0003a	48 8b 55 60	 mov	 rdx, QWORD PTR _Pstring$[rbp]
  0003e	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00042	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 1854 :     }

  00047	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ??$sleep_for@_JU?$ratio@$00$0PECEA@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@1@@Z
_TEXT	SEGMENT
$T1 = 64
_Rel_time$ = 96
??$sleep_for@_JU?$ratio@$00$0PECEA@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@1@@Z PROC ; std::this_thread::sleep_for<__int64,std::ratio<1,1000000> >, COMDAT

; 201  :     void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 202  :         sleep_until(_To_absolute_time(_Rel_time));

  0001b	48 8b 55 60	 mov	 rdx, QWORD PTR _Rel_time$[rbp]
  0001f	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00023	e8 00 00 00 00	 call	 ??$_To_absolute_time@_JU?$ratio@$00$0PECEA@@std@@@std@@YA?A_PAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@0@@Z ; std::_To_absolute_time<__int64,std::ratio<1,1000000> >
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXAEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >

; 203  :     }

  00030	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??$sleep_for@_JU?$ratio@$00$0PECEA@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@1@@Z ENDP ; std::this_thread::sleep_for<__int64,std::ratio<1,1000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0H$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEBH@Z
_TEXT	SEGMENT
this$ = 80
_Val$ = 88
??$?0H$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEBH@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000> >::duration<__int64,std::ratio<1,1000000> ><int,0>, COMDAT

; 98   :             : _MyRep(static_cast<_Rep>(_Val)) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$?0H$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEBH@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000> >::duration<__int64,std::ratio<1,1000000> ><int,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::~_List_iterator<std::_List_val<std::_List_simple_types<log_> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::~_List_iterator<std::_List_val<std::_List_simple_types<log_> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEAUlog_@@XZ
_TEXT	SEGMENT
this$ = 80
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEAUlog_@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator*, COMDAT

; 237  :     _NODISCARD reference operator*() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 238  :         return const_cast<reference>(_Mybase::operator*());

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEBUlog_@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator*

; 239  :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEAUlog_@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__param0$ = 88
__param1$ = 96
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	4c 8b 45 60	 mov	 r8, QWORD PTR __param1$[rbp]
  0001d	48 8b 55 58	 mov	 rdx, QWORD PTR __param0$[rbp]
  00021	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>
  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::~_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::~_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv136 = 64
tv69 = 64
this$ = 96
_Right$ = 104
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator==, COMDAT

; 192  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const noexcept {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@operator:

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");

  00023	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00027	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002c	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  00030	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00039	48 8b 4d 40	 mov	 rcx, QWORD PTR tv69[rbp]
  0003d	48 3b c8	 cmp	 rcx, rax
  00040	75 02		 jne	 SHORT $LN7@operator
  00042	eb 6b		 jmp	 SHORT $LN9@operator
$LN7@operator:
  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@BALDKKHE@list?5iterators?5incompatible@
  0004b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00057	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005c	45 33 c9	 xor	 r9d, r9d
  0005f	41 b8 c2 00 00
	00		 mov	 r8d, 194		; 000000c2H
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@
  0006c	b9 02 00 00 00	 mov	 ecx, 2
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00077	83 f8 01	 cmp	 eax, 1
  0007a	75 03		 jne	 SHORT $LN11@operator
  0007c	cc		 int	 3
  0007d	33 c0		 xor	 eax, eax
$LN11@operator:
  0007f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00088	41 b9 c2 00 00
	00		 mov	 r9d, 194		; 000000c2H
  0008e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@KDLJAKOP@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs@
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 95		 jne	 SHORT $LN7@operator
$LN9@operator:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	0f 85 6a ff ff
	ff		 jne	 $LN4@operator

; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

  000b9	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000bd	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  000c1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000c5	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000c9	75 09		 jne	 SHORT $LN12@operator
  000cb	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv136[rbp], 1
  000d2	eb 07		 jmp	 SHORT $LN13@operator
$LN12@operator:
  000d4	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv136[rbp], 0
$LN13@operator:
  000db	0f b6 45 40	 movzx	 eax, BYTE PTR tv136[rbp]

; 198  :     }

  000df	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000e3	5d		 pop	 rbp
  000e4	c3		 ret	 0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEBUlog_@@XZ
_TEXT	SEGMENT
_Mycont$ = 0
this$ = 96
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEBUlog_@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());

  0001e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00022	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00027	48 89 45 00	 mov	 QWORD PTR _Mycont$[rbp], rax
$LN4@operator:

; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");

  0002b	48 83 7d 00 00	 cmp	 QWORD PTR _Mycont$[rbp], 0
  00030	74 02		 je	 SHORT $LN7@operator
  00032	eb 6b		 jmp	 SHORT $LN15@operator
$LN7@operator:
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DD@MBIHGLJE@cannot?5dereference?5value?9initia@
  0003b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00047	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004c	45 33 c9	 xor	 r9d, r9d
  0004f	41 b8 92 00 00
	00		 mov	 r8d, 146		; 00000092H
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@
  0005c	b9 02 00 00 00	 mov	 ecx, 2
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00067	83 f8 01	 cmp	 eax, 1
  0006a	75 03		 jne	 SHORT $LN19@operator
  0006c	cc		 int	 3
  0006d	33 c0		 xor	 eax, eax
$LN19@operator:
  0006f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00078	41 b9 92 00 00
	00		 mov	 r9d, 146		; 00000092H
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GK@NKIMOCIG@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 95		 jne	 SHORT $LN7@operator
$LN15@operator:
  0009f	33 c0		 xor	 eax, eax
  000a1	85 c0		 test	 eax, eax
  000a3	75 86		 jne	 SHORT $LN4@operator
$LN10@operator:

; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");

  000a5	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000a9	48 8b 4d 00	 mov	 rcx, QWORD PTR _Mycont$[rbp]
  000ad	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b1	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000b5	74 02		 je	 SHORT $LN13@operator
  000b7	eb 6b		 jmp	 SHORT $LN17@operator
$LN13@operator:
  000b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@JCBFHMPL@cannot?5dereference?5end?5list?5ite@
  000c0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  000cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d1	45 33 c9	 xor	 r9d, r9d
  000d4	41 b8 93 00 00
	00		 mov	 r8d, 147		; 00000093H
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@
  000e1	b9 02 00 00 00	 mov	 ecx, 2
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  000ec	83 f8 01	 cmp	 eax, 1
  000ef	75 03		 jne	 SHORT $LN20@operator
  000f1	cc		 int	 3
  000f2	33 c0		 xor	 eax, eax
$LN20@operator:
  000f4	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000fd	41 b9 93 00 00
	00		 mov	 r9d, 147		; 00000093H
  00103	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@CNEFBDCF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 95		 jne	 SHORT $LN13@operator
$LN17@operator:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	0f 85 77 ff ff
	ff		 jne	 $LN10@operator

; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

  0012e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00132	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00136	48 83 c0 10	 add	 rax, 16

; 151  :     }

  0013a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0013e	5d		 pop	 rbp
  0013f	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEBUlog_@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QEAA@AEBU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8b 4d 58	 mov	 rcx, QWORD PTR __that$[rbp]
  00029	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@AEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QEAA@XZ ; std::_Iterator_base12::~_Iterator_base12
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Pnode$ = 88
_Plist$ = 96
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00029	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QEAA@XZ ; std::_Iterator_base12::_Iterator_base12
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 4d 58	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  00036	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 38   :         this->_Adopt(_Plist);

  0003a	48 8b 55 60	 mov	 rdx, QWORD PTR _Plist$[rbp]
  0003e	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00042	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 39   :     }

  00047	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base12@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_State$ = 0
_Count$ = 8
_Pad$ = 16
_Ok$ = 24
$T1 = 104
tv314 = 112
tv299 = 112
tv285 = 112
tv260 = 112
tv223 = 112
tv194 = 112
tv137 = 112
tv319 = 120
tv258 = 120
tv192 = 120
tv320 = 124
tv139 = 124
tv267 = 128
tv201 = 128
tv265 = 132
tv199 = 132
_Ostr$ = 160
_Val$ = 168
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 766  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DF087383_ostream
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 767  :     // insert NTBS into char stream
; 768  :     using _Elem = char;
; 769  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 770  : 
; 771  :     ios_base::iostate _State = ios_base::goodbit;

  00023	c7 45 00 00 00
	00 00		 mov	 DWORD PTR _State$[rbp], 0

; 772  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  0002a	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR _Val$[rbp]
  00031	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  00036	48 89 45 08	 mov	 QWORD PTR _Count$[rbp], rax

; 773  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  0003a	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00041	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00044	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00048	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0004f	48 03 c8	 add	 rcx, rax
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 8b c8	 mov	 rcx, rax
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  0005e	48 85 c0	 test	 rax, rax
  00061	7e 58		 jle	 SHORT $LN17@operator
  00063	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006d	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00071	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00078	48 03 c8	 add	 rcx, rax
  0007b	48 8b c1	 mov	 rax, rcx
  0007e	48 8b c8	 mov	 rcx, rax
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  00087	48 3b 45 08	 cmp	 rax, QWORD PTR _Count$[rbp]
  0008b	7e 2e		 jle	 SHORT $LN17@operator
  0008d	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00094	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00097	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0009b	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  000a2	48 03 c8	 add	 rcx, rax
  000a5	48 8b c1	 mov	 rax, rcx
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  000b1	48 2b 45 08	 sub	 rax, QWORD PTR _Count$[rbp]
  000b5	48 89 45 70	 mov	 QWORD PTR tv137[rbp], rax
  000b9	eb 08		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000bb	48 c7 45 70 00
	00 00 00	 mov	 QWORD PTR tv137[rbp], 0
$LN18@operator:
  000c3	48 8b 45 70	 mov	 rax, QWORD PTR tv137[rbp]
  000c7	48 89 45 10	 mov	 QWORD PTR _Pad$[rbp], rax

; 774  :     const typename _Myos::sentry _Ok(_Ostr);

  000cb	48 8b 95 a0 00
	00 00		 mov	 rdx, QWORD PTR _Ostr$[rbp]
  000d2	48 8d 4d 18	 lea	 rcx, QWORD PTR _Ok$[rbp]
  000d6	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000db	90		 npad	 1

; 775  : 
; 776  :     if (!_Ok) {

  000dc	48 8d 4d 18	 lea	 rcx, QWORD PTR _Ok$[rbp]
  000e0	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000e5	0f b6 c0	 movzx	 eax, al
  000e8	85 c0		 test	 eax, eax
  000ea	75 0e		 jne	 SHORT $LN8@operator

; 777  :         _State |= ios_base::badbit;

  000ec	8b 45 00	 mov	 eax, DWORD PTR _State$[rbp]
  000ef	83 c8 04	 or	 eax, 4
  000f2	89 45 00	 mov	 DWORD PTR _State$[rbp], eax

; 778  :     } else { // state okay, insert

  000f5	e9 2c 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 779  :         _TRY_IO_BEGIN
; 780  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000fa	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00101	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00104	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00108	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0010f	48 03 c8	 add	 rcx, rax
  00112	48 8b c1	 mov	 rax, rcx
  00115	48 8b c8	 mov	 rcx, rax
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flags@ios_base@std@@QEBAHXZ
  0011e	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00123	83 f8 40	 cmp	 eax, 64			; 00000040H
  00126	0f 84 b4 00 00
	00		 je	 $LN11@operator

; 781  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0012c	eb 0b		 jmp	 SHORT $LN4@operator
$LN2@operator:
  0012e	48 8b 45 10	 mov	 rax, QWORD PTR _Pad$[rbp]
  00132	48 ff c8	 dec	 rax
  00135	48 89 45 10	 mov	 QWORD PTR _Pad$[rbp], rax
$LN4@operator:
  00139	48 83 7d 10 00	 cmp	 QWORD PTR _Pad$[rbp], 0
  0013e	0f 8e 9c 00 00
	00		 jle	 $LN11@operator

; 782  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00144	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0014b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00152	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00159	48 03 c8	 add	 rcx, rax
  0015c	48 8b c1	 mov	 rax, rcx
  0015f	48 8b c8	 mov	 rcx, rax
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00168	48 89 45 70	 mov	 QWORD PTR tv194[rbp], rax
  0016c	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00173	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00176	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0017a	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00181	48 03 c8	 add	 rcx, rax
  00184	48 8b c1	 mov	 rax, rcx
  00187	48 8b c8	 mov	 rcx, rax
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  00190	88 45 78	 mov	 BYTE PTR tv192[rbp], al
  00193	0f b6 55 78	 movzx	 edx, BYTE PTR tv192[rbp]
  00197	48 8b 4d 70	 mov	 rcx, QWORD PTR tv194[rbp]
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  001a1	89 45 7c	 mov	 DWORD PTR tv139[rbp], eax
  001a4	8b 45 7c	 mov	 eax, DWORD PTR tv139[rbp]
  001a7	89 85 80 00 00
	00		 mov	 DWORD PTR tv201[rbp], eax
  001ad	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  001b2	89 85 84 00 00
	00		 mov	 DWORD PTR tv199[rbp], eax
  001b8	8b 95 80 00 00
	00		 mov	 edx, DWORD PTR tv201[rbp]
  001be	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR tv199[rbp]
  001c4	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  001c9	0f b6 c0	 movzx	 eax, al
  001cc	85 c0		 test	 eax, eax
  001ce	74 0b		 je	 SHORT $LN12@operator

; 783  :                     _State |= ios_base::badbit; // insertion failed, quit

  001d0	8b 45 00	 mov	 eax, DWORD PTR _State$[rbp]
  001d3	83 c8 04	 or	 eax, 4
  001d6	89 45 00	 mov	 DWORD PTR _State$[rbp], eax

; 784  :                     break;

  001d9	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 785  :                 }
; 786  :             }

  001db	e9 4e ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 787  :         }
; 788  : 
; 789  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  001e0	83 7d 00 00	 cmp	 DWORD PTR _State$[rbp], 0
  001e4	75 54		 jne	 SHORT $LN13@operator
  001e6	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  001ed	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  001f4	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  001fb	48 03 c8	 add	 rcx, rax
  001fe	48 8b c1	 mov	 rax, rcx
  00201	48 8b c8	 mov	 rcx, rax
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0020a	48 89 45 70	 mov	 QWORD PTR tv223[rbp], rax
  0020e	4c 8b 45 08	 mov	 r8, QWORD PTR _Count$[rbp]
  00212	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _Val$[rbp]
  00219	48 8b 4d 70	 mov	 rcx, QWORD PTR tv223[rbp]
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  00223	48 89 45 78	 mov	 QWORD PTR tv319[rbp], rax
  00227	48 8b 45 08	 mov	 rax, QWORD PTR _Count$[rbp]
  0022b	48 39 45 78	 cmp	 QWORD PTR tv319[rbp], rax
  0022f	74 09		 je	 SHORT $LN13@operator

; 790  :             _State |= ios_base::badbit;

  00231	8b 45 00	 mov	 eax, DWORD PTR _State$[rbp]
  00234	83 c8 04	 or	 eax, 4
  00237	89 45 00	 mov	 DWORD PTR _State$[rbp], eax
$LN13@operator:

; 791  :         }
; 792  : 
; 793  :         if (_State == ios_base::goodbit) {

  0023a	83 7d 00 00	 cmp	 DWORD PTR _State$[rbp], 0
  0023e	0f 85 b4 00 00
	00		 jne	 $LN14@operator

; 794  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00244	eb 0b		 jmp	 SHORT $LN7@operator
$LN5@operator:
  00246	48 8b 45 10	 mov	 rax, QWORD PTR _Pad$[rbp]
  0024a	48 ff c8	 dec	 rax
  0024d	48 89 45 10	 mov	 QWORD PTR _Pad$[rbp], rax
$LN7@operator:
  00251	48 83 7d 10 00	 cmp	 QWORD PTR _Pad$[rbp], 0
  00256	0f 8e 9c 00 00
	00		 jle	 $LN14@operator

; 795  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0025c	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00263	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00266	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0026a	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00271	48 03 c8	 add	 rcx, rax
  00274	48 8b c1	 mov	 rax, rcx
  00277	48 8b c8	 mov	 rcx, rax
  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00280	48 89 45 70	 mov	 QWORD PTR tv260[rbp], rax
  00284	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0028b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0028e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00292	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00299	48 03 c8	 add	 rcx, rax
  0029c	48 8b c1	 mov	 rax, rcx
  0029f	48 8b c8	 mov	 rcx, rax
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  002a8	88 45 78	 mov	 BYTE PTR tv258[rbp], al
  002ab	0f b6 55 78	 movzx	 edx, BYTE PTR tv258[rbp]
  002af	48 8b 4d 70	 mov	 rcx, QWORD PTR tv260[rbp]
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  002b9	89 45 7c	 mov	 DWORD PTR tv320[rbp], eax
  002bc	8b 45 7c	 mov	 eax, DWORD PTR tv320[rbp]
  002bf	89 85 80 00 00
	00		 mov	 DWORD PTR tv267[rbp], eax
  002c5	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  002ca	89 85 84 00 00
	00		 mov	 DWORD PTR tv265[rbp], eax
  002d0	8b 95 80 00 00
	00		 mov	 edx, DWORD PTR tv267[rbp]
  002d6	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR tv265[rbp]
  002dc	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  002e1	0f b6 c0	 movzx	 eax, al
  002e4	85 c0		 test	 eax, eax
  002e6	74 0b		 je	 SHORT $LN15@operator

; 796  :                     _State |= ios_base::badbit; // insertion failed, quit

  002e8	8b 45 00	 mov	 eax, DWORD PTR _State$[rbp]
  002eb	83 c8 04	 or	 eax, 4
  002ee	89 45 00	 mov	 DWORD PTR _State$[rbp], eax

; 797  :                     break;

  002f1	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 798  :                 }
; 799  :             }

  002f3	e9 4e ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 800  :         }
; 801  : 
; 802  :         _Ostr.width(0);

  002f8	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  002ff	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00302	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00306	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0030d	48 03 c8	 add	 rcx, rax
  00310	48 8b c1	 mov	 rax, rcx
  00313	48 89 45 70	 mov	 QWORD PTR tv285[rbp], rax
  00317	33 d2		 xor	 edx, edx
  00319	48 8b 4d 70	 mov	 rcx, QWORD PTR tv285[rbp]
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
  00323	90		 npad	 1
  00324	eb 00		 jmp	 SHORT $LN9@operator
$LN23@operator:
$LN9@operator:

; 803  :         _CATCH_IO_(ios_base, _Ostr)
; 804  :     }
; 805  : 
; 806  :     _Ostr.setstate(_State);

  00326	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0032d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00330	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00334	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0033b	48 03 c8	 add	 rcx, rax
  0033e	48 8b c1	 mov	 rax, rcx
  00341	48 89 45 70	 mov	 QWORD PTR tv314[rbp], rax
  00345	45 33 c0	 xor	 r8d, r8d
  00348	8b 55 00	 mov	 edx, DWORD PTR _State$[rbp]
  0034b	48 8b 4d 70	 mov	 rcx, QWORD PTR tv314[rbp]
  0034f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 807  :     return _Ostr;

  00355	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0035c	48 89 45 68	 mov	 QWORD PTR $T1[rbp], rax
  00360	48 8d 4d 18	 lea	 rcx, QWORD PTR _Ok$[rbp]
  00364	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00369	48 8b 45 68	 mov	 rax, QWORD PTR $T1[rbp]

; 808  : }

  0036d	48 8d a5 90 00
	00 00		 lea	 rsp, QWORD PTR [rbp+144]
  00374	5d		 pop	 rbp
  00375	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 0
_Count$ = 8
_Pad$ = 16
_Ok$ = 24
$T1 = 104
tv314 = 112
tv299 = 112
tv285 = 112
tv260 = 112
tv223 = 112
tv194 = 112
tv137 = 112
tv319 = 120
tv258 = 120
tv192 = 120
tv320 = 124
tv139 = 124
tv267 = 128
tv201 = 128
tv265 = 132
tv199 = 132
_Ostr$ = 160
_Val$ = 168
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 18	 lea	 rcx, QWORD PTR _Ok$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 0
_Count$ = 8
_Pad$ = 16
_Ok$ = 24
$T1 = 104
tv314 = 112
tv299 = 112
tv285 = 112
tv260 = 112
tv223 = 112
tv194 = 112
tv137 = 112
tv319 = 120
tv258 = 120
tv192 = 120
tv320 = 124
tv139 = 124
tv267 = 128
tv201 = 128
tv265 = 132
tv199 = 132
_Ostr$ = 160
_Val$ = 168
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1

; 803  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000e	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00015	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00018	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001c	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx
  00029	48 89 45 70	 mov	 QWORD PTR tv299[rbp], rax
  0002d	41 b0 01	 mov	 r8b, 1
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	48 8b 4d 70	 mov	 rcx, QWORD PTR tv299[rbp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0003f	90		 npad	 1
  00040	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$1
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
  0004d	cc		 int	 3
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv75 = 64
tv73 = 72
_Ostr$ = 96
_Str$ = 104
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5203 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5204 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  00020	48 8b 4d 68	 mov	 rcx, QWORD PTR _Str$[rbp]
  00024	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00029	48 89 45 40	 mov	 QWORD PTR tv75[rbp], rax
  0002d	48 8b 4d 68	 mov	 rcx, QWORD PTR _Str$[rbp]
  00031	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  00036	48 89 45 48	 mov	 QWORD PTR tv73[rbp], rax
  0003a	4c 8b 45 40	 mov	 r8, QWORD PTR tv75[rbp]
  0003e	48 8b 55 48	 mov	 rdx, QWORD PTR tv73[rbp]
  00042	48 8b 4d 60	 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00046	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>

; 5205 : }

  0004b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
_TEXT	SEGMENT
$T1 = 64
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5002 :     _In_z_ const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	c7 45 40 00 00
	00 00		 mov	 DWORD PTR $T1[rbp], 0
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5003 :     return _STD move(_Right.insert(0, _Left));

  0002c	4c 8b 45 68	 mov	 r8, QWORD PTR _Left$[rbp]
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 4d 70	 mov	 rcx, QWORD PTR _Right$[rbp]
  00036	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  0003b	48 8b d0	 mov	 rdx, rax
  0003e	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00042	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00047	8b 45 40	 mov	 eax, DWORD PTR $T1[rbp]
  0004a	83 c8 01	 or	 eax, 1
  0004d	89 45 40	 mov	 DWORD PTR $T1[rbp], eax
  00050	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 5004 : }

  00054	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00058	5d		 pop	 rbp
  00059	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
_TEXT	SEGMENT
$T1 = 64
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5014 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	c7 45 40 00 00
	00 00		 mov	 DWORD PTR $T1[rbp], 0
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5015 :     return _STD move(_Left.append(_Right));

  0002c	48 8b 55 70	 mov	 rdx, QWORD PTR _Right$[rbp]
  00030	48 8b 4d 68	 mov	 rcx, QWORD PTR _Left$[rbp]
  00034	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00039	48 8b d0	 mov	 rdx, rax
  0003c	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00040	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00045	8b 45 40	 mov	 eax, DWORD PTR $T1[rbp]
  00048	83 c8 01	 or	 eax, 1
  0004b	89 45 40	 mov	 DWORD PTR $T1[rbp], eax
  0004e	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 5016 : }

  00052	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00056	5d		 pop	 rbp
  00057	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z
_TEXT	SEGMENT
$T1 = 64
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4977 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	c7 45 40 00 00
	00 00		 mov	 DWORD PTR $T1[rbp], 0
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4978 :     return _STD move(_Right.insert(0, _Left));

  0002c	4c 8b 45 68	 mov	 r8, QWORD PTR _Left$[rbp]
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 4d 70	 mov	 rcx, QWORD PTR _Right$[rbp]
  00036	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  0003b	48 8b d0	 mov	 rdx, rax
  0003e	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00042	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00047	8b 45 40	 mov	 eax, DWORD PTR $T1[rbp]
  0004a	83 c8 01	 or	 eax, 1
  0004d	89 45 40	 mov	 DWORD PTR $T1[rbp], eax
  00050	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 4979 : }

  00054	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00058	5d		 pop	 rbp
  00059	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 68
tv64 = 72
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4989 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001c	c7 45 44 00 00
	00 00		 mov	 DWORD PTR $T2[rbp], 0
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@operator:

; 4990 : #if _ITERATOR_DEBUG_LEVEL == 2
; 4991 :     _STL_VERIFY(_STD addressof(_Left) != _STD addressof(_Right),

  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _Left$[rbp]
  00033	e8 00 00 00 00	 call	 ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00038	48 89 45 48	 mov	 QWORD PTR tv64[rbp], rax
  0003c	48 8b 4d 70	 mov	 rcx, QWORD PTR _Right$[rbp]
  00040	e8 00 00 00 00	 call	 ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00045	48 8b 4d 48	 mov	 rcx, QWORD PTR tv64[rbp]
  00049	48 3b c8	 cmp	 rcx, rax
  0004c	74 02		 je	 SHORT $LN7@operator
  0004e	eb 6b		 jmp	 SHORT $LN9@operator
$LN7@operator:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@
  00057	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00063	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00068	45 33 c9	 xor	 r9d, r9d
  0006b	41 b8 83 13 00
	00		 mov	 r8d, 4995		; 00001383H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@
  00078	b9 02 00 00 00	 mov	 ecx, 2
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00083	83 f8 01	 cmp	 eax, 1
  00086	75 03		 jne	 SHORT $LN11@operator
  00088	cc		 int	 3
  00089	33 c0		 xor	 eax, eax
$LN11@operator:
  0008b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00094	41 b9 83 13 00
	00		 mov	 r9d, 4995		; 00001383H
  0009a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1COI@GKKHJOON@?$AA?$CC?$AAY?$AAo?$AAu?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn@
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000b5	33 c0		 xor	 eax, eax
  000b7	85 c0		 test	 eax, eax
  000b9	75 95		 jne	 SHORT $LN7@operator
$LN9@operator:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	0f 85 6a ff ff
	ff		 jne	 $LN4@operator

; 4992 :         "You cannot concatenate the same moved string to itself. See N4950 [res.on.arguments]/1.3: "
; 4993 :         "If a function argument is bound to an rvalue reference parameter, the implementation may assume that "
; 4994 :         "this parameter is a unique reference to this argument, except that the argument passed to "
; 4995 :         "a move-assignment operator may be a reference to *this ([lib.types.movedfrom]).");
; 4996 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 4997 :     return {_String_constructor_concat_tag{}, _Left, _Right};

  000c5	4c 8b 4d 70	 mov	 r9, QWORD PTR _Right$[rbp]
  000c9	4c 8b 45 68	 mov	 r8, QWORD PTR _Left$[rbp]
  000cd	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  000d1	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000d5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000da	8b 45 44	 mov	 eax, DWORD PTR $T2[rbp]
  000dd	83 c8 01	 or	 eax, 1
  000e0	89 45 44	 mov	 DWORD PTR $T2[rbp], eax
  000e3	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 4998 : }

  000e7	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000eb	5d		 pop	 rbp
  000ec	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 05 a8 00 00
	00		 add	 rax, 168		; 000000a8H
  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 05 a8 00 00
	00		 add	 rax, 168		; 000000a8H
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00017	48 2d a8 00 00
	00		 sub	 rax, 168		; 000000a8H
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00025	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	74 17		 je	 SHORT $LN2@scalar
  0002f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 2d a8 00 00
	00		 sub	 rax, 168		; 000000a8H
  00039	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00046	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 2d a8 00 00
	00		 sub	 rax, 168		; 000000a8H
  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 98 00 00 00	 mov	 edx, 152		; 00000098H
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT

; 795  :     void _Set_back() noexcept { // set up putback area

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 796  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00025	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00029	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0002d	48 3b c1	 cmp	 rax, rcx
  00030	74 2a		 je	 SHORT $LN2@Set_back

; 797  :             _Set_eback = _Mysb::eback();

  00032	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0003c	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00040	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 798  :             _Set_egptr = _Mysb::egptr();

  00047	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00051	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00055	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax
$LN2@Set_back:

; 799  :         }
; 800  :         _Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

  0005c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00060	48 83 c0 71	 add	 rax, 113		; 00000071H
  00064	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00068	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0006c	48 8b 55 50	 mov	 rdx, QWORD PTR this$[rbp]
  00070	48 83 c2 70	 add	 rdx, 112		; 00000070H
  00074	4c 8b c8	 mov	 r9, rax
  00077	4c 8b c1	 mov	 r8, rcx
  0007a	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 801  :     }

  00084	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00088	5d		 pop	 rbp
  00089	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT

; 789  :     void _Reset_back() noexcept { // restore buffer after putback

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 790  :         if (_Mysb::eback() == &_Mychar) {

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00025	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00029	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0002d	48 3b c1	 cmp	 rax, rcx
  00030	75 2b		 jne	 SHORT $LN2@Reset_back

; 791  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00032	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00036	4c 8b 88 90 00
	00 00		 mov	 r9, QWORD PTR [rax+144]
  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	4c 8b 80 88 00
	00 00		 mov	 r8, QWORD PTR [rax+136]
  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8b 90 88 00
	00 00		 mov	 rdx, QWORD PTR [rax+136]
  00053	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN2@Reset_back:

; 792  :         }
; 793  :     }

  0005d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
this$ = 80
_Newcvt$ = 88
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT

; 772  :     void _Initcvt(const _Cvt& _Newcvt) noexcept { // initialize codecvt pointer

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 773  :         if (_Newcvt.always_noconv()) {

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Newcvt$[rbp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 0e		 je	 SHORT $LN2@Initcvt

; 774  :             _Pcvt = nullptr; // nothing to do

  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 775  :         } else { // set up for nontrivial codecvt facet

  0003d	eb 1b		 jmp	 SHORT $LN3@Initcvt
$LN2@Initcvt:

; 776  :             _Pcvt = _STD addressof(_Newcvt);

  0003f	48 8b 4d 58	 mov	 rcx, QWORD PTR _Newcvt$[rbp]
  00043	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
  00048	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0004c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 777  :             _Mysb::_Init(); // reset any buffering

  00050	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
$LN3@Initcvt:

; 778  :         }
; 779  :     }

  0005a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
_TEXT	SEGMENT
_Codecvt_temp_buf$ = 0
_Str$ = 8
_Dest$ = 48
_Count$1 = 56
tv150 = 128
tv135 = 128
tv83 = 128
tv136 = 136
tv81 = 136
tv90 = 140
tv88 = 144
this$ = 176
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT

; 735  :     bool _Endwrite() { // put shift to initial conversion state, as needed

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 736  :         if (!_Pcvt || !_Wrotesome) {

  0001e	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00025	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0002a	74 0f		 je	 SHORT $LN5@Endwrite
  0002c	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	0f b6 40 71	 movzx	 eax, BYTE PTR [rax+113]
  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN4@Endwrite
$LN5@Endwrite:

; 737  :             return true;

  0003b	b0 01		 mov	 al, 1
  0003d	e9 64 01 00 00	 jmp	 $LN1@Endwrite
$LN4@Endwrite:

; 738  :         }
; 739  : 
; 740  :         // may have to put
; 741  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  00042	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00050	48 89 85 80 00
	00 00		 mov	 QWORD PTR tv83[rbp], rax
  00057	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0005c	89 85 88 00 00
	00		 mov	 DWORD PTR tv81[rbp], eax
  00062	8b 95 88 00 00
	00		 mov	 edx, DWORD PTR tv81[rbp]
  00068	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006f	ff 95 80 00 00
	00		 call	 QWORD PTR tv83[rbp]
  00075	89 85 8c 00 00
	00		 mov	 DWORD PTR tv90[rbp], eax
  0007b	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00080	89 85 90 00 00
	00		 mov	 DWORD PTR tv88[rbp], eax
  00086	8b 95 8c 00 00
	00		 mov	 edx, DWORD PTR tv90[rbp]
  0008c	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR tv88[rbp]
  00092	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00097	0f b6 c0	 movzx	 eax, al
  0009a	85 c0		 test	 eax, eax
  0009c	74 07		 je	 SHORT $LN6@Endwrite

; 742  :             return false;

  0009e	32 c0		 xor	 al, al
  000a0	e9 01 01 00 00	 jmp	 $LN1@Endwrite
$LN6@Endwrite:

; 743  :         }
; 744  : 
; 745  :         constexpr size_t _Codecvt_temp_buf = 32;

  000a5	48 c7 45 00 20
	00 00 00	 mov	 QWORD PTR _Codecvt_temp_buf$[rbp], 32 ; 00000020H

; 746  :         char _Str[_Codecvt_temp_buf];
; 747  :         char* _Dest;
; 748  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  000ad	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 89 85 80 00
	00 00		 mov	 QWORD PTR tv135[rbp], rax
  000bf	48 8d 45 28	 lea	 rax, QWORD PTR _Str$[rbp+32]
  000c3	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000ca	48 83 c1 74	 add	 rcx, 116		; 00000074H
  000ce	48 8d 55 30	 lea	 rdx, QWORD PTR _Dest$[rbp]
  000d2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000d7	4c 8b c8	 mov	 r9, rax
  000da	4c 8d 45 08	 lea	 r8, QWORD PTR _Str$[rbp]
  000de	48 8b d1	 mov	 rdx, rcx
  000e1	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR tv135[rbp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z
  000ee	89 85 88 00 00
	00		 mov	 DWORD PTR tv136[rbp], eax
  000f4	83 bd 88 00 00
	00 00		 cmp	 DWORD PTR tv136[rbp], 0
  000fb	74 1b		 je	 SHORT $LN7@Endwrite
  000fd	83 bd 88 00 00
	00 01		 cmp	 DWORD PTR tv136[rbp], 1
  00104	74 1d		 je	 SHORT $LN8@Endwrite
  00106	83 bd 88 00 00
	00 03		 cmp	 DWORD PTR tv136[rbp], 3
  0010d	0f 84 82 00 00
	00		 je	 $LN10@Endwrite
  00113	e9 8c 00 00 00	 jmp	 $LN11@Endwrite
$LN7@Endwrite:

; 749  :         case codecvt_base::ok:
; 750  :             _Wrotesome = false; // homed successfully

  00118	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0011f	c6 40 71 00	 mov	 BYTE PTR [rax+113], 0
$LN8@Endwrite:

; 751  :             _FALLTHROUGH;
; 752  : 
; 753  :         case codecvt_base::partial:
; 754  :             { // put any generated bytes
; 755  :                 const auto _Count = static_cast<size_t>(_Dest - _Str);

  00123	48 8d 45 08	 lea	 rax, QWORD PTR _Str$[rbp]
  00127	48 8b 4d 30	 mov	 rcx, QWORD PTR _Dest$[rbp]
  0012b	48 2b c8	 sub	 rcx, rax
  0012e	48 8b c1	 mov	 rax, rcx
  00131	48 89 45 38	 mov	 QWORD PTR _Count$1[rbp], rax

; 756  :                 if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  00135	48 83 7d 38 00	 cmp	 QWORD PTR _Count$1[rbp], 0
  0013a	76 2b		 jbe	 SHORT $LN9@Endwrite
  0013c	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00143	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  0014a	4c 8b 45 38	 mov	 r8, QWORD PTR _Count$1[rbp]
  0014e	ba 01 00 00 00	 mov	 edx, 1
  00153	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  0015d	48 39 45 38	 cmp	 QWORD PTR _Count$1[rbp], rax
  00161	74 04		 je	 SHORT $LN9@Endwrite

; 757  :                     return false; // write failed

  00163	32 c0		 xor	 al, al
  00165	eb 3f		 jmp	 SHORT $LN1@Endwrite
$LN9@Endwrite:

; 758  :                 }
; 759  : 
; 760  :                 return !_Wrotesome;

  00167	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0016e	0f b6 40 71	 movzx	 eax, BYTE PTR [rax+113]
  00172	85 c0		 test	 eax, eax
  00174	75 0c		 jne	 SHORT $LN13@Endwrite
  00176	c7 85 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv150[rbp], 1
  00180	eb 0a		 jmp	 SHORT $LN14@Endwrite
$LN13@Endwrite:
  00182	c7 85 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv150[rbp], 0
$LN14@Endwrite:
  0018c	0f b6 85 80 00
	00 00		 movzx	 eax, BYTE PTR tv150[rbp]
  00193	eb 11		 jmp	 SHORT $LN1@Endwrite
$LN10@Endwrite:

; 761  :             }
; 762  : 
; 763  :         case codecvt_base::noconv:
; 764  :             _Wrotesome = false; // homed successfully

  00195	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0019c	c6 40 71 00	 mov	 BYTE PTR [rax+113], 0

; 765  :             return true; // nothing else to do

  001a0	b0 01		 mov	 al, 1
  001a2	eb 02		 jmp	 SHORT $LN1@Endwrite
$LN11@Endwrite:

; 766  : 
; 767  :         default:
; 768  :             return false; // conversion failed

  001a4	32 c0		 xor	 al, al
$LN1@Endwrite:

; 769  :         }
; 770  :     }

  001a6	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  001ad	5d		 pop	 rbp
  001ae	c3		 ret	 0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
_Pb$1 = 0
_Pn$2 = 8
_Nr$3 = 16
_Nw$4 = 24
tv66 = 96
this$ = 128
_File$ = 136
_Which$ = 144
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT

; 708  :     void _Init(FILE* _File, _Initfl _Which) noexcept { // initialize to C stream _File after {new, open, close}

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 709  :         using _State_type = typename _Traits::state_type;
; 710  : 
; 711  :         __PURE_APPDOMAIN_GLOBAL static _State_type _Stinit; // initial state
; 712  : 
; 713  :         _Closef    = _Which == _Openfl;

  00028	83 bd 90 00 00
	00 01		 cmp	 DWORD PTR _Which$[rbp], 1
  0002f	75 09		 jne	 SHORT $LN4@Init
  00031	c7 45 60 01 00
	00 00		 mov	 DWORD PTR tv66[rbp], 1
  00038	eb 07		 jmp	 SHORT $LN5@Init
$LN4@Init:
  0003a	c7 45 60 00 00
	00 00		 mov	 DWORD PTR tv66[rbp], 0
$LN5@Init:
  00041	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00048	0f b6 4d 60	 movzx	 ecx, BYTE PTR tv66[rbp]
  0004c	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 714  :         _Wrotesome = false;

  0004f	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00056	c6 40 71 00	 mov	 BYTE PTR [rax+113], 0

; 715  : 
; 716  :         _Mysb::_Init(); // initialize stream buffer base object

  0005a	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 717  : 
; 718  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

  00067	48 83 bd 88 00
	00 00 00	 cmp	 QWORD PTR _File$[rbp], 0
  0006f	74 74		 je	 SHORT $LN2@Init
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 01	 cmp	 eax, 1
  00076	74 6d		 je	 SHORT $LN2@Init

; 719  :             _Elem** _Pb = nullptr;

  00078	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Pb$1[rbp], 0

; 720  :             _Elem** _Pn = nullptr;

  00080	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR _Pn$2[rbp], 0

; 721  :             int* _Nr    = nullptr;

  00088	48 c7 45 10 00
	00 00 00	 mov	 QWORD PTR _Nr$3[rbp], 0

; 722  : 
; 723  :             ::_get_stream_buffer_pointers(

  00090	4c 8d 4d 10	 lea	 r9, QWORD PTR _Nr$3[rbp]
  00094	4c 8d 45 08	 lea	 r8, QWORD PTR _Pn$2[rbp]
  00098	48 8d 55 00	 lea	 rdx, QWORD PTR _Pb$1[rbp]
  0009c	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _File$[rbp]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers

; 724  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 725  :             int* _Nw = _Nr;

  000a9	48 8b 45 10	 mov	 rax, QWORD PTR _Nr$3[rbp]
  000ad	48 89 45 18	 mov	 QWORD PTR _Nw$4[rbp], rax

; 726  : 
; 727  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);

  000b1	48 8b 45 18	 mov	 rax, QWORD PTR _Nw$4[rbp]
  000b5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000ba	48 8b 45 08	 mov	 rax, QWORD PTR _Pn$2[rbp]
  000be	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c3	48 8b 45 00	 mov	 rax, QWORD PTR _Pb$1[rbp]
  000c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cc	4c 8b 4d 10	 mov	 r9, QWORD PTR _Nr$3[rbp]
  000d0	4c 8b 45 08	 mov	 r8, QWORD PTR _Pn$2[rbp]
  000d4	48 8b 55 00	 mov	 rdx, QWORD PTR _Pb$1[rbp]
  000d8	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAPEAD0PEAH001@Z
$LN2@Init:

; 728  :         }
; 729  : 
; 730  :         _Myfile = _File;

  000e5	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ec	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _File$[rbp]
  000f3	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 731  :         _State  = _Stinit;

  000fa	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00101	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00108	48 89 48 74	 mov	 QWORD PTR [rax+116], rcx

; 732  :         _Pcvt   = nullptr; // pointer to codecvt facet

  0010c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00113	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 733  :     }

  0011b	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  0011f	5d		 pop	 rbp
  00120	c3		 ret	 0
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
_TEXT	SEGMENT
this$ = 80
_Loc$ = 88
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT

; 703  :     void __CLR_OR_THIS_CALL imbue(const locale& _Loc) override {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 704  :         // set locale to argument (capture nontrivial codecvt facet)
; 705  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Loc$[rbp]
  00024	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  00029	48 8b d0	 mov	 rdx, rax
  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00030	e8 00 00 00 00	 call	 ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt

; 706  :     }

  00035	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
tv80 = 64
tv78 = 72
tv87 = 76
tv85 = 80
this$ = 112
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT

; 695  :     int __CLR_OR_THIS_CALL sync() override { // synchronize C stream with external file

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 696  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0002a	74 53		 je	 SHORT $LN3@sync
  0002c	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00037	48 89 45 40	 mov	 QWORD PTR tv80[rbp], rax
  0003b	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00040	89 45 48	 mov	 DWORD PTR tv78[rbp], eax
  00043	8b 55 48	 mov	 edx, DWORD PTR tv78[rbp]
  00046	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0004a	ff 55 40	 call	 QWORD PTR tv80[rbp]
  0004d	89 45 4c	 mov	 DWORD PTR tv87[rbp], eax
  00050	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00055	89 45 50	 mov	 DWORD PTR tv85[rbp], eax
  00058	8b 55 4c	 mov	 edx, DWORD PTR tv87[rbp]
  0005b	8b 4d 50	 mov	 ecx, DWORD PTR tv85[rbp]
  0005e	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00063	0f b6 c0	 movzx	 eax, al
  00066	85 c0		 test	 eax, eax
  00068	75 15		 jne	 SHORT $LN3@sync
  0006a	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0006e	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
  0007b	85 c0		 test	 eax, eax
  0007d	7c 04		 jl	 SHORT $LN2@sync
$LN3@sync:

; 697  :             return 0;

  0007f	33 c0		 xor	 eax, eax
  00081	eb 05		 jmp	 SHORT $LN1@sync
$LN2@sync:

; 698  :         }
; 699  : 
; 700  :         return -1;

  00083	b8 ff ff ff ff	 mov	 eax, -1
$LN1@sync:

; 701  :     }

  00088	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0008c	5d		 pop	 rbp
  0008d	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
_TEXT	SEGMENT
_Mode$ = 0
_Size$ = 8
this$ = 96
_Buffer$ = 104
_Count$ = 112
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT

; 676  :     _Mysb* __CLR_OR_THIS_CALL setbuf(_Elem* _Buffer, streamsize _Count) override { // offer _Buffer to C stream

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 677  :         int _Mode;
; 678  :         if (!_Buffer && _Count == 0) {

  00025	48 83 7d 68 00	 cmp	 QWORD PTR _Buffer$[rbp], 0
  0002a	75 10		 jne	 SHORT $LN2@setbuf
  0002c	48 83 7d 70 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 09		 jne	 SHORT $LN2@setbuf

; 679  :             _Mode = _IONBF;

  00033	c7 45 00 04 00
	00 00		 mov	 DWORD PTR _Mode$[rbp], 4

; 680  :         } else {

  0003a	eb 07		 jmp	 SHORT $LN3@setbuf
$LN2@setbuf:

; 681  :             _Mode = _IOFBF;

  0003c	c7 45 00 00 00
	00 00		 mov	 DWORD PTR _Mode$[rbp], 0
$LN3@setbuf:

; 682  :         }
; 683  : 
; 684  :         const size_t _Size = static_cast<size_t>(_Count) * sizeof(_Elem);

  00043	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  00047	48 89 45 08	 mov	 QWORD PTR _Size$[rbp], rax

; 685  : 
; 686  :         if (!_Myfile || _CSTD setvbuf(_Myfile, reinterpret_cast<char*>(_Buffer), _Mode, _Size) != 0) {

  0004b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00057	74 21		 je	 SHORT $LN5@setbuf
  00059	4c 8b 4d 08	 mov	 r9, QWORD PTR _Size$[rbp]
  0005d	44 8b 45 00	 mov	 r8d, DWORD PTR _Mode$[rbp]
  00061	48 8b 55 68	 mov	 rdx, QWORD PTR _Buffer$[rbp]
  00065	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00069	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
  00076	85 c0		 test	 eax, eax
  00078	74 04		 je	 SHORT $LN4@setbuf
$LN5@setbuf:

; 687  :             return nullptr; // failed

  0007a	33 c0		 xor	 eax, eax
  0007c	eb 1e		 jmp	 SHORT $LN1@setbuf
$LN4@setbuf:

; 688  :         }
; 689  : 
; 690  :         // new buffer, reinitialize pointers
; 691  :         _Init(_Myfile, _Openfl);

  0007e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00084	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00088	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  0008f	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00093	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 692  :         return this;

  00098	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
$LN1@setbuf:

; 693  :     }

  0009c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000a0	5d		 pop	 rbp
  000a1	c3		 ret	 0
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_Off$ = 0
$T1 = 72
this$ = 96
__$ReturnUdt$ = 104
_Pos$ = 112
__formal$ = 120
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT

; 663  :     pos_type __CLR_OR_THIS_CALL seekpos(pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 664  :         // change position to _Pos
; 665  :         off_type _Off = static_cast<off_type>(_Pos);

  0002a	48 8b 4d 70	 mov	 rcx, QWORD PTR _Pos$[rbp]
  0002e	e8 00 00 00 00	 call	 ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ; std::fpos<_Mbstatet>::operator __int64
  00033	48 89 45 00	 mov	 QWORD PTR _Off$[rbp], rax

; 666  : 
; 667  :         if (!_Myfile || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0) {

  00037	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00043	74 29		 je	 SHORT $LN3@seekpos
  00045	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0004e	0f b6 c0	 movzx	 eax, al
  00051	85 c0		 test	 eax, eax
  00053	74 19		 je	 SHORT $LN3@seekpos
  00055	48 8d 55 00	 lea	 rdx, QWORD PTR _Off$[rbp]
  00059	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0005d	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fsetpos
  0006a	85 c0		 test	 eax, eax
  0006c	74 16		 je	 SHORT $LN2@seekpos
$LN3@seekpos:

; 668  :             return pos_type{off_type{-1}}; // report failure

  0006e	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00075	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00079	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  0007e	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00082	eb 3a		 jmp	 SHORT $LN1@seekpos
$LN2@seekpos:

; 669  :         }
; 670  : 
; 671  :         _State = _Pos.state();

  00084	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  00088	48 8b 4d 70	 mov	 rcx, QWORD PTR _Pos$[rbp]
  0008c	e8 00 00 00 00	 call	 ?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
  00091	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00094	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00098	48 89 41 74	 mov	 QWORD PTR [rcx+116], rax

; 672  :         _Reset_back(); // revert from _Mychar buffer, discarding any putback

  0009c	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  000a0	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 673  :         return pos_type{_State, _Off}; // return new position

  000a5	4c 8b 45 00	 mov	 r8, QWORD PTR _Off$[rbp]
  000a9	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000ad	48 8b 50 74	 mov	 rdx, QWORD PTR [rax+116]
  000b1	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000b5	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  000ba	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@seekpos:

; 674  :     }

  000be	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000c2	5d		 pop	 rbp
  000c3	c3		 ret	 0
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_Fileposition$ = 0
this$ = 96
__$ReturnUdt$ = 104
_Off$ = 112
_Way$ = 120
__formal$ = 128
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT

; 644  :         ios_base::openmode = ios_base::in | ios_base::out) override { // change position by _Off

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 645  :         fpos_t _Fileposition;
; 646  : 
; 647  :         if (_Mysb::gptr() == &_Mychar // something putback
; 648  :             && _Way == ios_base::cur // a relative seek
; 649  :             && !_Pcvt) { // not converting

  0002a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00034	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00038	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0003c	48 3b c1	 cmp	 rax, rcx
  0003f	75 1c		 jne	 SHORT $LN2@seekoff
  00041	83 7d 78 01	 cmp	 DWORD PTR _Way$[rbp], 1
  00045	75 16		 jne	 SHORT $LN2@seekoff
  00047	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00050	75 0b		 jne	 SHORT $LN2@seekoff

; 650  :             _Off -= static_cast<off_type>(sizeof(_Elem)); // back up over _Elem bytes

  00052	48 8b 45 70	 mov	 rax, QWORD PTR _Off$[rbp]
  00056	48 ff c8	 dec	 rax
  00059	48 89 45 70	 mov	 QWORD PTR _Off$[rbp], rax
$LN2@seekoff:

; 651  :         }
; 652  : 
; 653  :         if (!_Myfile || !_Endwrite()
; 654  :             || ((_Off != 0 || _Way != ios_base::cur) && _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 655  :             || _CSTD fgetpos(_Myfile, &_Fileposition) != 0) {

  0005d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00061	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00069	74 53		 je	 SHORT $LN4@seekoff
  0006b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0006f	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00074	0f b6 c0	 movzx	 eax, al
  00077	85 c0		 test	 eax, eax
  00079	74 43		 je	 SHORT $LN4@seekoff
  0007b	48 83 7d 70 00	 cmp	 QWORD PTR _Off$[rbp], 0
  00080	75 06		 jne	 SHORT $LN6@seekoff
  00082	83 7d 78 01	 cmp	 DWORD PTR _Way$[rbp], 1
  00086	74 1d		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  00088	44 8b 45 78	 mov	 r8d, DWORD PTR _Way$[rbp]
  0008c	48 8b 55 70	 mov	 rdx, QWORD PTR _Off$[rbp]
  00090	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00094	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  000a1	85 c0		 test	 eax, eax
  000a3	75 19		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  000a5	48 8d 55 00	 lea	 rdx, QWORD PTR _Fileposition$[rbp]
  000a9	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000ad	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetpos
  000ba	85 c0		 test	 eax, eax
  000bc	74 16		 je	 SHORT $LN3@seekoff
$LN4@seekoff:

; 656  :             return pos_type{off_type{-1}}; // report failure

  000be	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  000c5	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000c9	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  000ce	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000d2	eb 22		 jmp	 SHORT $LN1@seekoff
$LN3@seekoff:

; 657  :         }
; 658  : 
; 659  :         _Reset_back(); // revert from _Mychar buffer, discarding any putback

  000d4	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  000d8	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 660  :         return pos_type{_State, _Fileposition}; // return new position

  000dd	4c 8b 45 00	 mov	 r8, QWORD PTR _Fileposition$[rbp]
  000e1	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000e5	48 8b 50 74	 mov	 rdx, QWORD PTR [rax+116]
  000e9	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000ed	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  000f2	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@seekoff:

; 661  :     }

  000f6	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000fa	5d		 pop	 rbp
  000fb	c3		 ret	 0
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
_TEXT	SEGMENT
_Start_count$1 = 0
_Size$2 = 8
this$ = 96
_Ptr$ = 104
_Count$ = 112
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsputn, COMDAT

; 613  :     streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) override {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 614  :         // put _Count characters to stream
; 615  :         if constexpr (sizeof(_Elem) == 1) {
; 616  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0002e	74 17		 je	 SHORT $LN2@xsputn

; 617  :                 return _Mysb::xsputn(_Ptr, _Count);

  00030	4c 8b 45 70	 mov	 r8, QWORD PTR _Count$[rbp]
  00034	48 8b 55 68	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00038	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
  00042	e9 d0 00 00 00	 jmp	 $LN1@xsputn
$LN2@xsputn:

; 618  :             }
; 619  : 
; 620  :             const streamsize _Start_count = _Count;

  00047	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  0004b	48 89 45 00	 mov	 QWORD PTR _Start_count$1[rbp], rax

; 621  :             streamsize _Size              = _Mysb::_Pnavail();

  0004f	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
  00059	48 89 45 08	 mov	 QWORD PTR _Size$2[rbp], rax

; 622  :             if (0 < _Count && 0 < _Size) { // copy to write buffer

  0005d	48 83 7d 70 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00062	7e 64		 jle	 SHORT $LN3@xsputn
  00064	48 83 7d 08 00	 cmp	 QWORD PTR _Size$2[rbp], 0
  00069	7e 5d		 jle	 SHORT $LN3@xsputn

; 623  :                 if (_Count < _Size) {

  0006b	48 8b 45 08	 mov	 rax, QWORD PTR _Size$2[rbp]
  0006f	48 39 45 70	 cmp	 QWORD PTR _Count$[rbp], rax
  00073	7d 08		 jge	 SHORT $LN4@xsputn

; 624  :                     _Size = _Count;

  00075	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  00079	48 89 45 08	 mov	 QWORD PTR _Size$2[rbp], rax
$LN4@xsputn:

; 625  :                 }
; 626  : 
; 627  :                 _Traits::copy(_Mysb::pptr(), _Ptr, static_cast<size_t>(_Size));

  0007d	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00087	4c 8b 45 08	 mov	 r8, QWORD PTR _Size$2[rbp]
  0008b	48 8b 55 68	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 628  :                 _Ptr += _Size;

  00097	48 8b 45 08	 mov	 rax, QWORD PTR _Size$2[rbp]
  0009b	48 8b 4d 68	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0009f	48 03 c8	 add	 rcx, rax
  000a2	48 8b c1	 mov	 rax, rcx
  000a5	48 89 45 68	 mov	 QWORD PTR _Ptr$[rbp], rax

; 629  :                 _Count -= _Size;

  000a9	48 8b 45 08	 mov	 rax, QWORD PTR _Size$2[rbp]
  000ad	48 8b 4d 70	 mov	 rcx, QWORD PTR _Count$[rbp]
  000b1	48 2b c8	 sub	 rcx, rax
  000b4	48 8b c1	 mov	 rax, rcx
  000b7	48 89 45 70	 mov	 QWORD PTR _Count$[rbp], rax

; 630  :                 _Mysb::pbump(static_cast<int>(_Size));

  000bb	8b 55 08	 mov	 edx, DWORD PTR _Size$2[rbp]
  000be	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z
$LN3@xsputn:

; 631  :             }
; 632  : 
; 633  :             if (0 < _Count && _Myfile) { // open C stream, attempt write

  000c8	48 83 7d 70 00	 cmp	 QWORD PTR _Count$[rbp], 0
  000cd	7e 3a		 jle	 SHORT $LN5@xsputn
  000cf	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000d3	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000db	74 2c		 je	 SHORT $LN5@xsputn

; 634  :                 _Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

  000dd	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000e1	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  000e8	4c 8b 45 70	 mov	 r8, QWORD PTR _Count$[rbp]
  000ec	ba 01 00 00 00	 mov	 edx, 1
  000f1	48 8b 4d 68	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  000fb	48 8b 4d 70	 mov	 rcx, QWORD PTR _Count$[rbp]
  000ff	48 2b c8	 sub	 rcx, rax
  00102	48 8b c1	 mov	 rax, rcx
  00105	48 89 45 70	 mov	 QWORD PTR _Count$[rbp], rax
$LN5@xsputn:

; 635  :             }
; 636  : 
; 637  :             return _Start_count - _Count;

  00109	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  0010d	48 8b 4d 00	 mov	 rcx, QWORD PTR _Start_count$1[rbp]
  00111	48 2b c8	 sub	 rcx, rax
  00114	48 8b c1	 mov	 rax, rcx
$LN1@xsputn:

; 638  :         } else { // non-chars always get element-by-element processing
; 639  :             return _Mysb::xsputn(_Ptr, _Count);
; 640  :         }
; 641  :     }

  00117	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0011b	5d		 pop	 rbp
  0011c	c3		 ret	 0
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
_TEXT	SEGMENT
_Count_s$1 = 0
_Start_count$2 = 8
_Available$3 = 16
_Read_size$4 = 24
_Read_size$5 = 32
_Actual_read$6 = 40
tv158 = 112
tv156 = 120
this$ = 144
_Ptr$ = 152
_Count$ = 160
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn, COMDAT

; 565  :     streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) override {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 566  :         // get _Count characters from stream
; 567  :         if constexpr (sizeof(_Elem) == 1) {
; 568  :             if (_Count <= 0) {

  00028	48 83 bd a0 00
	00 00 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00030	7f 07		 jg	 SHORT $LN4@xsgetn

; 569  :                 return 0;

  00032	33 c0		 xor	 eax, eax
  00034	e9 c4 01 00 00	 jmp	 $LN1@xsgetn
$LN4@xsgetn:

; 570  :             }
; 571  : 
; 572  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  00039	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00045	74 20		 je	 SHORT $LN5@xsgetn

; 573  :                 return _Mysb::xsgetn(_Ptr, _Count);

  00047	4c 8b 85 a0 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  0004e	48 8b 95 98 00
	00 00		 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00055	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
  00062	e9 96 01 00 00	 jmp	 $LN1@xsgetn
$LN5@xsgetn:

; 574  :             }
; 575  : 
; 576  :             // assuming this is OK because _Ptr + _Count must be valid
; 577  :             auto _Count_s           = static_cast<size_t>(_Count);

  00067	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  0006e	48 89 45 00	 mov	 QWORD PTR _Count_s$1[rbp], rax

; 578  :             const auto _Start_count = _Count;

  00072	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  00079	48 89 45 08	 mov	 QWORD PTR _Start_count$2[rbp], rax

; 579  :             const auto _Available   = static_cast<size_t>(_Mysb::_Gnavail());

  0007d	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
  0008a	48 89 45 10	 mov	 QWORD PTR _Available$3[rbp], rax

; 580  :             if (0 < _Available) { // copy from get area

  0008e	48 83 7d 10 00	 cmp	 QWORD PTR _Available$3[rbp], 0
  00093	76 6e		 jbe	 SHORT $LN6@xsgetn

; 581  :                 const auto _Read_size = (_STD min)(_Count_s, _Available);

  00095	48 8d 55 10	 lea	 rdx, QWORD PTR _Available$3[rbp]
  00099	48 8d 4d 00	 lea	 rcx, QWORD PTR _Count_s$1[rbp]
  0009d	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  000a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a5	48 89 45 18	 mov	 QWORD PTR _Read_size$4[rbp], rax

; 582  :                 _Traits::copy(_Ptr, _Mysb::gptr(), _Read_size);

  000a9	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000b6	4c 8b 45 18	 mov	 r8, QWORD PTR _Read_size$4[rbp]
  000ba	48 8b d0	 mov	 rdx, rax
  000bd	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000c4	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 583  :                 _Ptr += _Read_size;

  000c9	48 8b 45 18	 mov	 rax, QWORD PTR _Read_size$4[rbp]
  000cd	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000d4	48 03 c8	 add	 rcx, rax
  000d7	48 8b c1	 mov	 rax, rcx
  000da	48 89 85 98 00
	00 00		 mov	 QWORD PTR _Ptr$[rbp], rax

; 584  :                 _Count_s -= _Read_size;

  000e1	48 8b 45 18	 mov	 rax, QWORD PTR _Read_size$4[rbp]
  000e5	48 8b 4d 00	 mov	 rcx, QWORD PTR _Count_s$1[rbp]
  000e9	48 2b c8	 sub	 rcx, rax
  000ec	48 8b c1	 mov	 rax, rcx
  000ef	48 89 45 00	 mov	 QWORD PTR _Count_s$1[rbp], rax

; 585  :                 _Mysb::gbump(static_cast<int>(_Read_size));

  000f3	8b 55 18	 mov	 edx, DWORD PTR _Read_size$4[rbp]
  000f6	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z
$LN6@xsgetn:

; 586  :             }
; 587  : 
; 588  :             if (_Myfile) { // open C stream, attempt read

  00103	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0010a	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00112	0f 84 d7 00 00
	00		 je	 $LN7@xsgetn

; 589  :                 _Reset_back(); // revert from _Mychar buffer

  00118	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011f	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 590  :                 // process in 4k - 1 chunks to avoid tripping over fread's clobber-the-end behavior when
; 591  :                 // doing \r\n -> \n translation
; 592  :                 constexpr size_t _Read_size = 4095; // _INTERNAL_BUFSIZ - 1

  00124	48 c7 45 20 ff
	0f 00 00	 mov	 QWORD PTR _Read_size$5[rbp], 4095 ; 00000fffH
$LN2@xsgetn:

; 593  :                 while (_Read_size < _Count_s) {

  0012c	48 81 7d 00 ff
	0f 00 00	 cmp	 QWORD PTR _Count_s$1[rbp], 4095 ; 00000fffH
  00134	76 70		 jbe	 SHORT $LN3@xsgetn

; 594  :                     const auto _Actual_read = _CSTD fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);

  00136	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0013d	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  00144	41 b8 ff 0f 00
	00		 mov	 r8d, 4095		; 00000fffH
  0014a	ba 01 00 00 00	 mov	 edx, 1
  0014f	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0015c	48 89 45 28	 mov	 QWORD PTR _Actual_read$6[rbp], rax

; 595  :                     _Ptr += _Actual_read;

  00160	48 8b 45 28	 mov	 rax, QWORD PTR _Actual_read$6[rbp]
  00164	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0016b	48 03 c8	 add	 rcx, rax
  0016e	48 8b c1	 mov	 rax, rcx
  00171	48 89 85 98 00
	00 00		 mov	 QWORD PTR _Ptr$[rbp], rax

; 596  :                     _Count_s -= _Actual_read;

  00178	48 8b 45 28	 mov	 rax, QWORD PTR _Actual_read$6[rbp]
  0017c	48 8b 4d 00	 mov	 rcx, QWORD PTR _Count_s$1[rbp]
  00180	48 2b c8	 sub	 rcx, rax
  00183	48 8b c1	 mov	 rax, rcx
  00186	48 89 45 00	 mov	 QWORD PTR _Count_s$1[rbp], rax

; 597  :                     if (_Actual_read != _Read_size) {

  0018a	48 81 7d 28 ff
	0f 00 00	 cmp	 QWORD PTR _Actual_read$6[rbp], 4095 ; 00000fffH
  00192	74 10		 je	 SHORT $LN8@xsgetn

; 598  :                         return static_cast<streamsize>(_Start_count - _Count_s);

  00194	48 8b 45 00	 mov	 rax, QWORD PTR _Count_s$1[rbp]
  00198	48 8b 4d 08	 mov	 rcx, QWORD PTR _Start_count$2[rbp]
  0019c	48 2b c8	 sub	 rcx, rax
  0019f	48 8b c1	 mov	 rax, rcx
  001a2	eb 59		 jmp	 SHORT $LN1@xsgetn
$LN8@xsgetn:

; 599  :                     }
; 600  :                 }

  001a4	eb 86		 jmp	 SHORT $LN2@xsgetn
$LN3@xsgetn:

; 601  : 
; 602  :                 if (0 < _Count_s) {

  001a6	48 83 7d 00 00	 cmp	 QWORD PTR _Count_s$1[rbp], 0
  001ab	76 42		 jbe	 SHORT $LN9@xsgetn

; 603  :                     _Count_s -= _CSTD fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);

  001ad	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001b4	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  001bb	4c 8b 45 00	 mov	 r8, QWORD PTR _Count_s$1[rbp]
  001bf	ba 01 00 00 00	 mov	 edx, 1
  001c4	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  001d1	48 89 45 70	 mov	 QWORD PTR tv158[rbp], rax
  001d5	48 8b 45 00	 mov	 rax, QWORD PTR _Count_s$1[rbp]
  001d9	48 89 45 78	 mov	 QWORD PTR tv156[rbp], rax
  001dd	48 8b 45 70	 mov	 rax, QWORD PTR tv158[rbp]
  001e1	48 8b 4d 78	 mov	 rcx, QWORD PTR tv156[rbp]
  001e5	48 2b c8	 sub	 rcx, rax
  001e8	48 8b c1	 mov	 rax, rcx
  001eb	48 89 45 00	 mov	 QWORD PTR _Count_s$1[rbp], rax
$LN9@xsgetn:
$LN7@xsgetn:

; 604  :                 }
; 605  :             }
; 606  : 
; 607  :             return static_cast<streamsize>(_Start_count - _Count_s);

  001ef	48 8b 45 00	 mov	 rax, QWORD PTR _Count_s$1[rbp]
  001f3	48 8b 4d 08	 mov	 rcx, QWORD PTR _Start_count$2[rbp]
  001f7	48 2b c8	 sub	 rcx, rax
  001fa	48 8b c1	 mov	 rax, rcx
$LN1@xsgetn:

; 608  :         } else { // non-chars always get element-by-element processing
; 609  :             return _Mysb::xsgetn(_Ptr, _Count);
; 610  :         }
; 611  :     }

  001fd	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  00204	5d		 pop	 rbp
  00205	c3		 ret	 0
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
_Ch$1 = 0
_Str$ = 8
_Src$2 = 48
_Meta$3 = 56
_Ch$4 = 60
_Dest$5 = 64
_Nleft$6 = 72
$T7 = 144
$T8 = 148
$T9 = 152
$T10 = 156
tv178 = 160
tv174 = 160
tv139 = 160
tv76 = 160
tv159 = 168
tv172 = 176
tv170 = 184
tv175 = 192
this$ = 224
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT

; 508  :     int_type __CLR_OR_THIS_CALL uflow() override { // get an element from stream, point past it

$LN22:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  0000d	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 509  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0001e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 47		 je	 SHORT $LN9@uflow
  00030	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0003d	48 89 85 a0 00
	00 00		 mov	 QWORD PTR tv76[rbp], rax
  00044	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00051	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR tv76[rbp]
  00058	48 3b c8	 cmp	 rcx, rax
  0005b	73 1a		 jae	 SHORT $LN9@uflow

; 510  :             return _Traits::to_int_type(*_Mysb::_Gninc()); // return buffered

  0005d	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
  0006a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0006d	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00072	e9 9b 02 00 00	 jmp	 $LN1@uflow
$LN9@uflow:

; 511  :         }
; 512  : 
; 513  :         if (!_Myfile) {

  00077	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00086	75 0a		 jne	 SHORT $LN10@uflow

; 514  :             return _Traits::eof(); // no open C stream, fail

  00088	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0008d	e9 80 02 00 00	 jmp	 $LN1@uflow
$LN10@uflow:

; 515  :         }
; 516  : 
; 517  :         _Reset_back(); // revert from _Mychar buffer

  00092	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00099	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 518  :         if (!_Pcvt) { // no codecvt facet, just get it

  0009e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a5	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000aa	75 45		 jne	 SHORT $LN11@uflow

; 519  :             _Elem _Ch;
; 520  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  000ac	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b3	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  000ba	48 8d 4d 00	 lea	 rcx, QWORD PTR _Ch$1[rbp]
  000be	e8 00 00 00 00	 call	 ??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z ; std::_Fgetc<char>
  000c3	0f b6 c0	 movzx	 eax, al
  000c6	85 c0		 test	 eax, eax
  000c8	74 11		 je	 SHORT $LN19@uflow
  000ca	0f b6 4d 00	 movzx	 ecx, BYTE PTR _Ch$1[rbp]
  000ce	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  000d3	89 85 a0 00 00
	00		 mov	 DWORD PTR tv139[rbp], eax
  000d9	eb 0b		 jmp	 SHORT $LN20@uflow
$LN19@uflow:
  000db	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000e0	89 85 a0 00 00
	00		 mov	 DWORD PTR tv139[rbp], eax
$LN20@uflow:
  000e6	8b 85 a0 00 00
	00		 mov	 eax, DWORD PTR tv139[rbp]
  000ec	e9 21 02 00 00	 jmp	 $LN1@uflow
$LN11@uflow:

; 521  :         }
; 522  : 
; 523  :         // build string until codecvt succeeds
; 524  :         string _Str;

  000f1	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  000f5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000fa	90		 npad	 1
$LN2@uflow:

; 525  : 
; 526  :         for (;;) { // get using codecvt facet
; 527  :             const char* _Src;
; 528  :             int _Meta = _CSTD fgetc(_Myfile);

  000fb	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00102	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  0010f	89 45 38	 mov	 DWORD PTR _Meta$3[rbp], eax

; 529  : 
; 530  :             if (_Meta == EOF) {

  00112	83 7d 38 ff	 cmp	 DWORD PTR _Meta$3[rbp], -1
  00116	75 1f		 jne	 SHORT $LN12@uflow

; 531  :                 return _Traits::eof(); // partial char?

  00118	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0011d	89 85 90 00 00
	00		 mov	 DWORD PTR $T7[rbp], eax
  00123	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  00127	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0012c	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR $T7[rbp]
  00132	e9 db 01 00 00	 jmp	 $LN1@uflow
$LN12@uflow:

; 532  :             }
; 533  : 
; 534  :             _Str.push_back(static_cast<char>(_Meta)); // append byte and convert

  00137	0f b6 55 38	 movzx	 edx, BYTE PTR _Meta$3[rbp]
  0013b	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  0013f	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 535  : 
; 536  :             _Elem _Ch;
; 537  :             _Elem* _Dest;
; 538  : 
; 539  :             // test result of converting one element
; 540  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {

  00144	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0014b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014f	48 89 85 a0 00
	00 00		 mov	 QWORD PTR tv174[rbp], rax
  00156	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  0015a	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  0015f	48 89 85 a8 00
	00 00		 mov	 QWORD PTR tv159[rbp], rax
  00166	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  0016a	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0016f	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR tv159[rbp]
  00176	48 03 c8	 add	 rcx, rax
  00179	48 8b c1	 mov	 rax, rcx
  0017c	48 89 85 b0 00
	00 00		 mov	 QWORD PTR tv172[rbp], rax
  00183	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  00187	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  0018c	48 89 85 b8 00
	00 00		 mov	 QWORD PTR tv170[rbp], rax
  00193	48 8d 45 3d	 lea	 rax, QWORD PTR _Ch$4[rbp+1]
  00197	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0019e	48 83 c1 74	 add	 rcx, 116		; 00000074H
  001a2	48 8d 55 40	 lea	 rdx, QWORD PTR _Dest$5[rbp]
  001a6	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  001ab	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001b0	48 8d 45 3c	 lea	 rax, QWORD PTR _Ch$4[rbp]
  001b4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b9	48 8d 45 30	 lea	 rax, QWORD PTR _Src$2[rbp]
  001bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c2	4c 8b 8d b0 00
	00 00		 mov	 r9, QWORD PTR tv172[rbp]
  001c9	4c 8b 85 b8 00
	00 00		 mov	 r8, QWORD PTR tv170[rbp]
  001d0	48 8b d1	 mov	 rdx, rcx
  001d3	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR tv174[rbp]
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  001e0	89 85 c0 00 00
	00		 mov	 DWORD PTR tv175[rbp], eax
  001e6	83 bd c0 00 00
	00 00		 cmp	 DWORD PTR tv175[rbp], 0
  001ed	74 1b		 je	 SHORT $LN14@uflow
  001ef	83 bd c0 00 00
	00 01		 cmp	 DWORD PTR tv175[rbp], 1
  001f6	74 12		 je	 SHORT $LN14@uflow
  001f8	83 bd c0 00 00
	00 03		 cmp	 DWORD PTR tv175[rbp], 3
  001ff	0f 84 bf 00 00
	00		 je	 $LN16@uflow
  00205	e9 dd 00 00 00	 jmp	 $LN17@uflow
$LN14@uflow:

; 541  :             case codecvt_base::partial:
; 542  :             case codecvt_base::ok:
; 543  :                 if (_Dest != &_Ch) { // got an element, put back excess and deliver it

  0020a	48 8d 45 3c	 lea	 rax, QWORD PTR _Ch$4[rbp]
  0020e	48 39 45 40	 cmp	 QWORD PTR _Dest$5[rbp], rax
  00212	0f 84 89 00 00
	00		 je	 $LN15@uflow

; 544  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

  00218	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  0021c	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  00221	48 89 85 a0 00
	00 00		 mov	 QWORD PTR tv178[rbp], rax
  00228	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  0022c	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00231	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR tv178[rbp]
  00238	48 03 c8	 add	 rcx, rax
  0023b	48 8b c1	 mov	 rax, rcx
  0023e	48 2b 45 30	 sub	 rax, QWORD PTR _Src$2[rbp]
  00242	48 89 45 48	 mov	 QWORD PTR _Nleft$6[rbp], rax
$LN7@uflow:

; 545  :                     while (0 < _Nleft) {

  00246	48 83 7d 48 00	 cmp	 QWORD PTR _Nleft$6[rbp], 0
  0024b	7e 34		 jle	 SHORT $LN8@uflow

; 546  :                         _CSTD ungetc(_Src[--_Nleft], _Myfile);

  0024d	48 8b 45 48	 mov	 rax, QWORD PTR _Nleft$6[rbp]
  00251	48 ff c8	 dec	 rax
  00254	48 89 45 48	 mov	 QWORD PTR _Nleft$6[rbp], rax
  00258	48 8b 45 48	 mov	 rax, QWORD PTR _Nleft$6[rbp]
  0025c	48 8b 4d 30	 mov	 rcx, QWORD PTR _Src$2[rbp]
  00260	48 03 c8	 add	 rcx, rax
  00263	48 8b c1	 mov	 rax, rcx
  00266	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00269	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00270	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  00277	8b c8		 mov	 ecx, eax
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc

; 547  :                     }

  0027f	eb c5		 jmp	 SHORT $LN7@uflow
$LN8@uflow:

; 548  : 
; 549  :                     return _Traits::to_int_type(_Ch);

  00281	0f b6 4d 3c	 movzx	 ecx, BYTE PTR _Ch$4[rbp]
  00285	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  0028a	89 85 94 00 00
	00		 mov	 DWORD PTR $T8[rbp], eax
  00290	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  00294	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00299	8b 85 94 00 00
	00		 mov	 eax, DWORD PTR $T8[rbp]
  0029f	eb 71		 jmp	 SHORT $LN1@uflow
$LN15@uflow:

; 550  :                 }
; 551  : 
; 552  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

  002a1	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  002a5	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  002aa	48 8b 4d 30	 mov	 rcx, QWORD PTR _Src$2[rbp]
  002ae	48 2b c8	 sub	 rcx, rax
  002b1	48 8b c1	 mov	 rax, rcx
  002b4	4c 8b c0	 mov	 r8, rax
  002b7	33 d2		 xor	 edx, edx
  002b9	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  002bd	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 553  :                 break;

  002c2	eb 3f		 jmp	 SHORT $LN5@uflow
$LN16@uflow:

; 554  : 
; 555  :             case codecvt_base::noconv:
; 556  :                 // noconv is only possible if _Elem is char, so we can use it directly
; 557  :                 return static_cast<int_type>(_Str.front());

  002c4	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  002c8	e8 00 00 00 00	 call	 ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
  002cd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002d0	89 85 98 00 00
	00		 mov	 DWORD PTR $T9[rbp], eax
  002d6	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  002da	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002df	8b 85 98 00 00
	00		 mov	 eax, DWORD PTR $T9[rbp]
  002e5	eb 2b		 jmp	 SHORT $LN1@uflow
$LN17@uflow:

; 558  : 
; 559  :             default:
; 560  :                 return _Traits::eof(); // conversion failed

  002e7	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  002ec	89 85 9c 00 00
	00		 mov	 DWORD PTR $T10[rbp], eax
  002f2	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  002f6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002fb	8b 85 9c 00 00
	00		 mov	 eax, DWORD PTR $T10[rbp]
  00301	eb 0f		 jmp	 SHORT $LN1@uflow
$LN5@uflow:

; 561  :             }
; 562  :         }

  00303	e9 f3 fd ff ff	 jmp	 $LN2@uflow

; 563  :     }

  00308	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  0030c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00311	90		 npad	 1
$LN1@uflow:
  00312	48 8d a5 d0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+208]
  00319	5d		 pop	 rbp
  0031a	c3		 ret	 0
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 0
_Str$ = 8
_Src$2 = 48
_Meta$3 = 56
_Ch$4 = 60
_Dest$5 = 64
_Nleft$6 = 72
$T7 = 144
$T8 = 148
$T9 = 152
$T10 = 156
tv178 = 160
tv174 = 160
tv139 = 160
tv76 = 160
tv159 = 168
tv172 = 176
tv170 = 184
tv175 = 192
this$ = 224
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 40	 lea	 rbp, QWORD PTR [rdx+64]
  0000a	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
_Meta$ = 0
tv139 = 68
tv152 = 72
tv137 = 72
tv76 = 72
this$ = 96
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT

; 496  :     int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 497  :         int_type _Meta;
; 498  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00025	48 85 c0	 test	 rax, rax
  00028	74 37		 je	 SHORT $LN2@underflow
  0002a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00034	48 89 45 48	 mov	 QWORD PTR tv76[rbp], rax
  00038	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00042	48 8b 4d 48	 mov	 rcx, QWORD PTR tv76[rbp]
  00046	48 3b c8	 cmp	 rcx, rax
  00049	73 16		 jae	 SHORT $LN2@underflow

; 499  :             return _Traits::to_int_type(*_Mysb::gptr()); // return buffered

  0004b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00055	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00058	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  0005d	eb 56		 jmp	 SHORT $LN1@underflow
  0005f	eb 54		 jmp	 SHORT $LN3@underflow
$LN2@underflow:

; 500  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  00061	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0006c	ff 50 38	 call	 QWORD PTR [rax+56]
  0006f	89 45 00	 mov	 DWORD PTR _Meta$[rbp], eax
  00072	8b 45 00	 mov	 eax, DWORD PTR _Meta$[rbp]
  00075	89 45 44	 mov	 DWORD PTR tv139[rbp], eax
  00078	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0007d	89 45 48	 mov	 DWORD PTR tv137[rbp], eax
  00080	8b 55 44	 mov	 edx, DWORD PTR tv139[rbp]
  00083	8b 4d 48	 mov	 ecx, DWORD PTR tv137[rbp]
  00086	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0008b	0f b6 c0	 movzx	 eax, al
  0008e	85 c0		 test	 eax, eax
  00090	74 07		 je	 SHORT $LN4@underflow

; 501  :             return _Meta; // uflow failed, return EOF

  00092	8b 45 00	 mov	 eax, DWORD PTR _Meta$[rbp]
  00095	eb 1e		 jmp	 SHORT $LN1@underflow

; 502  :         } else { // get a char, don't point past it

  00097	eb 1c		 jmp	 SHORT $LN5@underflow
$LN4@underflow:

; 503  :             pbackfail(_Meta);

  00099	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0009d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000a4	48 89 45 48	 mov	 QWORD PTR tv152[rbp], rax
  000a8	8b 55 00	 mov	 edx, DWORD PTR _Meta$[rbp]
  000ab	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  000af	ff 55 48	 call	 QWORD PTR tv152[rbp]

; 504  :             return _Meta;

  000b2	8b 45 00	 mov	 eax, DWORD PTR _Meta$[rbp]
$LN5@underflow:
$LN3@underflow:
$LN1@underflow:

; 505  :         }
; 506  :     }

  000b5	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000b9	5d		 pop	 rbp
  000ba	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
$T1 = 64
tv162 = 72
tv76 = 72
this$ = 96
_Meta$ = 104
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT

; 475  :     int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

$LN13:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 476  :         // put an element back to stream
; 477  :         if (_Mysb::gptr() && _Mysb::eback() < _Mysb::gptr()
; 478  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001f	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00029	48 85 c0	 test	 rax, rax
  0002c	0f 84 80 00 00
	00		 je	 $LN2@pbackfail
  00032	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0003c	48 89 45 48	 mov	 QWORD PTR tv76[rbp], rax
  00040	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0004a	48 8b 4d 48	 mov	 rcx, QWORD PTR tv76[rbp]
  0004e	48 3b c8	 cmp	 rcx, rax
  00051	73 5f		 jae	 SHORT $LN2@pbackfail
  00053	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00058	8b 55 68	 mov	 edx, DWORD PTR _Meta$[rbp]
  0005b	8b c8		 mov	 ecx, eax
  0005d	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00062	0f b6 c0	 movzx	 eax, al
  00065	85 c0		 test	 eax, eax
  00067	75 2d		 jne	 SHORT $LN4@pbackfail
  00069	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00073	b9 01 00 00 00	 mov	 ecx, 1
  00078	48 6b c9 ff	 imul	 rcx, rcx, -1
  0007c	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00080	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00085	8b 55 68	 mov	 edx, DWORD PTR _Meta$[rbp]
  00088	8b c8		 mov	 ecx, eax
  0008a	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0008f	0f b6 c0	 movzx	 eax, al
  00092	85 c0		 test	 eax, eax
  00094	74 1c		 je	 SHORT $LN2@pbackfail
$LN4@pbackfail:

; 479  :                 || _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
; 480  :                     _Meta))) { // just back up position
; 481  :             _Mysb::_Gndec();

  00096	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ

; 482  :             return _Traits::not_eof(_Meta);

  000a0	8b 4d 68	 mov	 ecx, DWORD PTR _Meta$[rbp]
  000a3	e8 00 00 00 00	 call	 ?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z ; std::_Narrow_char_traits<char,int>::not_eof
  000a8	e9 ad 00 00 00	 jmp	 $LN1@pbackfail
  000ad	e9 a8 00 00 00	 jmp	 $LN3@pbackfail
$LN2@pbackfail:

; 483  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  000b2	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000b6	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000be	74 16		 je	 SHORT $LN7@pbackfail
  000c0	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000c5	8b 55 68	 mov	 edx, DWORD PTR _Meta$[rbp]
  000c8	8b c8		 mov	 ecx, eax
  000ca	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  000cf	0f b6 c0	 movzx	 eax, al
  000d2	85 c0		 test	 eax, eax
  000d4	74 09		 je	 SHORT $LN5@pbackfail
$LN7@pbackfail:

; 484  :             return _Traits::eof(); // no open C stream or EOF, fail

  000d6	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000db	eb 7d		 jmp	 SHORT $LN1@pbackfail
  000dd	eb 7b		 jmp	 SHORT $LN6@pbackfail
$LN5@pbackfail:

; 485  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  000df	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000e3	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000e8	75 35		 jne	 SHORT $LN8@pbackfail
  000ea	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000ee	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000f5	48 89 45 48	 mov	 QWORD PTR tv162[rbp], rax
  000f9	8b 4d 68	 mov	 ecx, DWORD PTR _Meta$[rbp]
  000fc	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00101	88 45 40	 mov	 BYTE PTR $T1[rbp], al
  00104	48 8b 55 48	 mov	 rdx, QWORD PTR tv162[rbp]
  00108	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0010c	e8 00 00 00 00	 call	 ??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z ; std::_Ungetc<char>
  00111	0f b6 c0	 movzx	 eax, al
  00114	85 c0		 test	 eax, eax
  00116	74 07		 je	 SHORT $LN8@pbackfail

; 486  :             return _Meta; // no facet and unget succeeded, return

  00118	8b 45 68	 mov	 eax, DWORD PTR _Meta$[rbp]
  0011b	eb 3d		 jmp	 SHORT $LN1@pbackfail
  0011d	eb 3b		 jmp	 SHORT $LN9@pbackfail
$LN8@pbackfail:

; 487  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

  0011f	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00129	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0012d	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00131	48 3b c1	 cmp	 rax, rcx
  00134	74 1f		 je	 SHORT $LN10@pbackfail

; 488  :             _Mychar = _Traits::to_char_type(_Meta);

  00136	8b 4d 68	 mov	 ecx, DWORD PTR _Meta$[rbp]
  00139	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  0013e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00142	88 41 70	 mov	 BYTE PTR [rcx+112], al

; 489  :             _Set_back(); // switch to _Mychar buffer

  00145	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00149	e8 00 00 00 00	 call	 ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back

; 490  :             return _Meta;

  0014e	8b 45 68	 mov	 eax, DWORD PTR _Meta$[rbp]
  00151	eb 07		 jmp	 SHORT $LN1@pbackfail

; 491  :         } else {

  00153	eb 05		 jmp	 SHORT $LN11@pbackfail
$LN10@pbackfail:

; 492  :             return _Traits::eof(); // nowhere to put back

  00155	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
$LN11@pbackfail:
$LN9@pbackfail:
$LN6@pbackfail:
$LN3@pbackfail:
$LN1@pbackfail:

; 493  :         }
; 494  :     }

  0015a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0015e	5d		 pop	 rbp
  0015f	c3		 ret	 0
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
_Codecvt_temp_buf$ = 0
_Str$ = 8
_Ch$ = 48
_Src$ = 56
_Dest$ = 64
_Count$1 = 72
tv192 = 144
tv170 = 144
tv149 = 144
tv133 = 144
tv84 = 144
tv171 = 152
tv147 = 152
tv153 = 156
this$ = 176
_Meta$ = 184
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT

; 422  :     int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

$LN19:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00011	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 423  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00022	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00027	8b 95 b8 00 00
	00		 mov	 edx, DWORD PTR _Meta$[rbp]
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00034	0f b6 c0	 movzx	 eax, al
  00037	85 c0		 test	 eax, eax
  00039	74 10		 je	 SHORT $LN4@overflow

; 424  :             return _Traits::not_eof(_Meta); // EOF, return success code

  0003b	8b 8d b8 00 00
	00		 mov	 ecx, DWORD PTR _Meta$[rbp]
  00041	e8 00 00 00 00	 call	 ?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z ; std::_Narrow_char_traits<char,int>::not_eof
  00046	e9 4e 02 00 00	 jmp	 $LN1@overflow
$LN4@overflow:

; 425  :         }
; 426  : 
; 427  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  0004b	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00058	48 85 c0	 test	 rax, rax
  0005b	74 5f		 je	 SHORT $LN5@overflow
  0005d	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0006a	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv84[rbp], rax
  00071	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0007e	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv84[rbp]
  00085	48 3b c8	 cmp	 rcx, rax
  00088	73 32		 jae	 SHORT $LN5@overflow

; 428  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0008a	8b 8d b8 00 00
	00		 mov	 ecx, DWORD PTR _Meta$[rbp]
  00090	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00095	88 85 90 00 00
	00		 mov	 BYTE PTR tv133[rbp], al
  0009b	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
  000a8	0f b6 8d 90 00
	00 00		 movzx	 ecx, BYTE PTR tv133[rbp]
  000af	88 08		 mov	 BYTE PTR [rax], cl

; 429  :             return _Meta;

  000b1	8b 85 b8 00 00
	00		 mov	 eax, DWORD PTR _Meta$[rbp]
  000b7	e9 dd 01 00 00	 jmp	 $LN1@overflow
$LN5@overflow:

; 430  :         }
; 431  : 
; 432  :         if (!_Myfile) {

  000bc	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c3	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000cb	75 0a		 jne	 SHORT $LN6@overflow

; 433  :             return _Traits::eof(); // no open C stream, fail

  000cd	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000d2	e9 c2 01 00 00	 jmp	 $LN1@overflow
$LN6@overflow:

; 434  :         }
; 435  : 
; 436  :         _Reset_back(); // revert from _Mychar buffer

  000d7	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000de	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 437  :         if (!_Pcvt) { // no codecvt facet, put as is

  000e3	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ea	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000ef	75 64		 jne	 SHORT $LN7@overflow

; 438  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

  000f1	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000f8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000ff	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv149[rbp], rax
  00106	8b 8d b8 00 00
	00		 mov	 ecx, DWORD PTR _Meta$[rbp]
  0010c	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00111	88 85 98 00 00
	00		 mov	 BYTE PTR tv147[rbp], al
  00117	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR tv149[rbp]
  0011e	0f b6 8d 98 00
	00 00		 movzx	 ecx, BYTE PTR tv147[rbp]
  00125	e8 00 00 00 00	 call	 ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ; std::_Fputc<char>
  0012a	0f b6 c0	 movzx	 eax, al
  0012d	85 c0		 test	 eax, eax
  0012f	74 0e		 je	 SHORT $LN15@overflow
  00131	8b 85 b8 00 00
	00		 mov	 eax, DWORD PTR _Meta$[rbp]
  00137	89 85 9c 00 00
	00		 mov	 DWORD PTR tv153[rbp], eax
  0013d	eb 0b		 jmp	 SHORT $LN16@overflow
$LN15@overflow:
  0013f	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00144	89 85 9c 00 00
	00		 mov	 DWORD PTR tv153[rbp], eax
$LN16@overflow:
  0014a	8b 85 9c 00 00
	00		 mov	 eax, DWORD PTR tv153[rbp]
  00150	e9 44 01 00 00	 jmp	 $LN1@overflow
$LN7@overflow:

; 439  :         }
; 440  : 
; 441  :         // put using codecvt facet
; 442  :         constexpr size_t _Codecvt_temp_buf = 32;

  00155	48 c7 45 00 20
	00 00 00	 mov	 QWORD PTR _Codecvt_temp_buf$[rbp], 32 ; 00000020H

; 443  :         char _Str[_Codecvt_temp_buf];
; 444  :         const _Elem _Ch = _Traits::to_char_type(_Meta);

  0015d	8b 8d b8 00 00
	00		 mov	 ecx, DWORD PTR _Meta$[rbp]
  00163	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00168	88 45 30	 mov	 BYTE PTR _Ch$[rbp], al

; 445  :         const _Elem* _Src;
; 446  :         char* _Dest;
; 447  : 
; 448  :         // test result of converting one element
; 449  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf, _Dest)) {

  0016b	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00172	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00176	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv170[rbp], rax
  0017d	48 8d 45 28	 lea	 rax, QWORD PTR _Str$[rbp+32]
  00181	48 8d 4d 31	 lea	 rcx, QWORD PTR _Ch$[rbp+1]
  00185	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0018c	48 83 c2 74	 add	 rdx, 116		; 00000074H
  00190	4c 8d 45 40	 lea	 r8, QWORD PTR _Dest$[rbp]
  00194	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  00199	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0019e	48 8d 45 08	 lea	 rax, QWORD PTR _Str$[rbp]
  001a2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a7	48 8d 45 38	 lea	 rax, QWORD PTR _Src$[rbp]
  001ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b0	4c 8b c9	 mov	 r9, rcx
  001b3	4c 8d 45 30	 lea	 r8, QWORD PTR _Ch$[rbp]
  001b7	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv170[rbp]
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  001c4	89 85 98 00 00
	00		 mov	 DWORD PTR tv171[rbp], eax
  001ca	83 bd 98 00 00
	00 00		 cmp	 DWORD PTR tv171[rbp], 0
  001d1	74 17		 je	 SHORT $LN9@overflow
  001d3	83 bd 98 00 00
	00 01		 cmp	 DWORD PTR tv171[rbp], 1
  001da	74 0e		 je	 SHORT $LN8@overflow
  001dc	83 bd 98 00 00
	00 03		 cmp	 DWORD PTR tv171[rbp], 3
  001e3	74 70		 je	 SHORT $LN12@overflow
  001e5	e9 aa 00 00 00	 jmp	 $LN13@overflow
$LN8@overflow:
$LN9@overflow:

; 450  :         case codecvt_base::partial:
; 451  :         case codecvt_base::ok:
; 452  :             { // converted something, try to put it out
; 453  :                 const auto _Count = static_cast<size_t>(_Dest - _Str);

  001ea	48 8d 45 08	 lea	 rax, QWORD PTR _Str$[rbp]
  001ee	48 8b 4d 40	 mov	 rcx, QWORD PTR _Dest$[rbp]
  001f2	48 2b c8	 sub	 rcx, rax
  001f5	48 8b c1	 mov	 rax, rcx
  001f8	48 89 45 48	 mov	 QWORD PTR _Count$1[rbp], rax

; 454  :                 if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  001fc	48 83 7d 48 00	 cmp	 QWORD PTR _Count$1[rbp], 0
  00201	76 2e		 jbe	 SHORT $LN10@overflow
  00203	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0020a	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  00211	4c 8b 45 48	 mov	 r8, QWORD PTR _Count$1[rbp]
  00215	ba 01 00 00 00	 mov	 edx, 1
  0021a	48 8d 4d 08	 lea	 rcx, QWORD PTR _Str$[rbp]
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  00224	48 39 45 48	 cmp	 QWORD PTR _Count$1[rbp], rax
  00228	74 07		 je	 SHORT $LN10@overflow

; 455  :                     return _Traits::eof(); // write failed

  0022a	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0022f	eb 68		 jmp	 SHORT $LN1@overflow
$LN10@overflow:

; 456  :                 }
; 457  : 
; 458  :                 _Wrotesome = true; // write succeeded

  00231	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00238	c6 40 71 01	 mov	 BYTE PTR [rax+113], 1

; 459  :                 if (_Src != &_Ch) {

  0023c	48 8d 45 30	 lea	 rax, QWORD PTR _Ch$[rbp]
  00240	48 39 45 38	 cmp	 QWORD PTR _Src$[rbp], rax
  00244	74 08		 je	 SHORT $LN11@overflow

; 460  :                     return _Meta; // converted whole element

  00246	8b 85 b8 00 00
	00		 mov	 eax, DWORD PTR _Meta$[rbp]
  0024c	eb 4b		 jmp	 SHORT $LN1@overflow
$LN11@overflow:

; 461  :                 }
; 462  : 
; 463  :                 return _Traits::eof(); // conversion failed

  0024e	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00253	eb 44		 jmp	 SHORT $LN1@overflow
$LN12@overflow:

; 464  :             }
; 465  : 
; 466  :         case codecvt_base::noconv:
; 467  :             // no conversion, put as is
; 468  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  00255	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0025c	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  00263	0f b6 4d 30	 movzx	 ecx, BYTE PTR _Ch$[rbp]
  00267	e8 00 00 00 00	 call	 ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ; std::_Fputc<char>
  0026c	0f b6 c0	 movzx	 eax, al
  0026f	85 c0		 test	 eax, eax
  00271	74 0e		 je	 SHORT $LN17@overflow
  00273	8b 85 b8 00 00
	00		 mov	 eax, DWORD PTR _Meta$[rbp]
  00279	89 85 90 00 00
	00		 mov	 DWORD PTR tv192[rbp], eax
  0027f	eb 0b		 jmp	 SHORT $LN18@overflow
$LN17@overflow:
  00281	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00286	89 85 90 00 00
	00		 mov	 DWORD PTR tv192[rbp], eax
$LN18@overflow:
  0028c	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR tv192[rbp]
  00292	eb 05		 jmp	 SHORT $LN1@overflow
$LN13@overflow:

; 469  : 
; 470  :         default:
; 471  :             return _Traits::eof(); // conversion failed

  00294	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
$LN1@overflow:

; 472  :         }
; 473  :     }

  00299	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  002a0	5d		 pop	 rbp
  002a1	c3		 ret	 0
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT

; 410  :     void __CLR_OR_THIS_CALL _Unlock() override { // unlock file instead of stream buffer

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 411  :         if (_Myfile) {

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00027	74 11		 je	 SHORT $LN2@Unlock

; 412  :             _CSTD _unlock_file(_Myfile);

  00029	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__unlock_file
$LN2@Unlock:

; 413  :         }
; 414  :     }

  0003a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT

; 404  :     void __CLR_OR_THIS_CALL _Lock() override { // lock file instead of stream buffer

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 405  :         if (_Myfile) {

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00027	74 11		 je	 SHORT $LN2@Lock

; 406  :             _CSTD _lock_file(_Myfile);

  00029	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lock_file
$LN2@Lock:

; 407  :         }
; 408  :     }

  0003a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
_TEXT	SEGMENT
_Ans$ = 0
this$ = 96
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT

; 383  :     basic_filebuf* close() {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 384  :         basic_filebuf* _Ans;
; 385  :         if (_Myfile) { // put any homing sequence and close file

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00027	74 48		 je	 SHORT $LN2@close

; 386  :             _Reset_back(); // revert from _Mychar buffer

  00029	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002d	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 387  : 
; 388  :             _Ans = this;

  00032	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00036	48 89 45 00	 mov	 QWORD PTR _Ans$[rbp], rax

; 389  :             if (!_Endwrite()) {

  0003a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00043	0f b6 c0	 movzx	 eax, al
  00046	85 c0		 test	 eax, eax
  00048	75 08		 jne	 SHORT $LN4@close

; 390  :                 _Ans = nullptr;

  0004a	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Ans$[rbp], 0
$LN4@close:

; 391  :             }
; 392  : 
; 393  :             if (_CSTD fclose(_Myfile) != 0) {

  00052	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00056	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  00063	85 c0		 test	 eax, eax
  00065	74 08		 je	 SHORT $LN5@close

; 394  :                 _Ans = nullptr;

  00067	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Ans$[rbp], 0
$LN5@close:

; 395  :             }
; 396  :         } else {

  0006f	eb 08		 jmp	 SHORT $LN3@close
$LN2@close:

; 397  :             _Ans = nullptr;

  00071	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Ans$[rbp], 0
$LN3@close:

; 398  :         }
; 399  : 
; 400  :         _Init(nullptr, _Closefl);

  00079	41 b8 02 00 00
	00		 mov	 r8d, 2
  0007f	33 d2		 xor	 edx, edx
  00081	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00085	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 401  :         return _Ans;

  0008a	48 8b 45 00	 mov	 rax, QWORD PTR _Ans$[rbp]

; 402  :     }

  0008e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00092	5d		 pop	 rbp
  00093	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
_TEXT	SEGMENT
_File$ = 0
$T1 = 72
tv90 = 88
tv89 = 96
this$ = 128
_Filename$ = 136
_Mode$ = 144
_Prot$ = 152
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT

; 284  :     basic_filebuf* open(const char* _Filename, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 285  :         // _Prot is an extension
; 286  :         if (_Myfile) {

  0002d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0003c	74 07		 je	 SHORT $LN2@open

; 287  :             return nullptr;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 84 00 00 00	 jmp	 $LN1@open
$LN2@open:

; 288  :         }
; 289  : 
; 290  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

  00045	44 8b 85 98 00
	00 00		 mov	 r8d, DWORD PTR _Prot$[rbp]
  0004c	8b 95 90 00 00
	00		 mov	 edx, DWORD PTR _Mode$[rbp]
  00052	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Filename$[rbp]
  00059	e8 00 00 00 00	 call	 ?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z ; std::_Fiopen
  0005e	48 89 45 00	 mov	 QWORD PTR _File$[rbp], rax

; 291  :         if (!_File) {

  00062	48 83 7d 00 00	 cmp	 QWORD PTR _File$[rbp], 0
  00067	75 04		 jne	 SHORT $LN3@open

; 292  :             return nullptr; // open failed

  00069	33 c0		 xor	 eax, eax
  0006b	eb 5c		 jmp	 SHORT $LN1@open
$LN3@open:

; 293  :         }
; 294  : 
; 295  :         _Init(_File, _Openfl);

  0006d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00073	48 8b 55 00	 mov	 rdx, QWORD PTR _File$[rbp]
  00077	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007e	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 296  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  00083	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  00087	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
  00094	48 89 45 58	 mov	 QWORD PTR tv90[rbp], rax
  00098	48 8b 45 58	 mov	 rax, QWORD PTR tv90[rbp]
  0009c	48 89 45 60	 mov	 QWORD PTR tv89[rbp], rax
  000a0	48 8b 4d 60	 mov	 rcx, QWORD PTR tv89[rbp]
  000a4	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  000a9	48 8b d0	 mov	 rdx, rax
  000ac	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b3	e8 00 00 00 00	 call	 ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
  000b8	90		 npad	 1
  000b9	48 8d 4d 48	 lea	 rcx, QWORD PTR $T1[rbp]
  000bd	e8 00 00 00 00	 call	 ??1locale@std@@QEAA@XZ	; std::locale::~locale

; 297  :         return this; // open succeeded

  000c2	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
$LN1@open:

; 298  :     }

  000c9	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000cd	5d		 pop	 rbp
  000ce	c3		 ret	 0
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_File$ = 0
$T1 = 72
tv90 = 88
tv89 = 96
this$ = 128
_Filename$ = 136
_Mode$ = 144
_Prot$ = 152
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 48	 lea	 rcx, QWORD PTR $T1[rbp]
  0000e	e8 00 00 00 00	 call	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT

; 179  :     __CLR_OR_THIS_CALL ~basic_filebuf() noexcept override {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00026	48 89 08	 mov	 QWORD PTR [rax], rcx

; 180  :         if (_Myfile) {

  00029	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00035	74 09		 je	 SHORT $LN2@basic_file

; 181  :             _Reset_back(); // revert from _Mychar buffer

  00037	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0003b	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
$LN2@basic_file:

; 182  :         }
; 183  : 
; 184  :         if (_Closef) {

  00040	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00044	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00048	85 c0		 test	 eax, eax
  0004a	74 09		 je	 SHORT $LN3@basic_file

; 185  :             close();

  0004c	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00050	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN3@basic_file:

; 186  :         }
; 187  :     }

  00055	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  0005f	90		 npad	 1
  00060	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT

; 171  :     basic_filebuf() : _Mysb() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00030	48 89 08	 mov	 QWORD PTR [rax], rcx

; 172  :         _Init(nullptr, _Newfl);

  00033	45 33 c0	 xor	 r8d, r8d
  00036	33 d2		 xor	 edx, edx
  00038	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 173  :     }

  00041	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\fstream
;	COMDAT ?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv82 = 64
this$ = 96
?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::close, COMDAT

; 374  :     void close() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__4A903650_fstream
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 375  :         if (!_Filebuffer.close()) {

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 c0 08	 add	 rax, 8
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  0002b	48 85 c0	 test	 rax, rax
  0002e	75 2b		 jne	 SHORT $LN2@close

; 376  :             _Myios::setstate(ios_base::failbit);

  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0003b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003f	48 03 c8	 add	 rcx, rax
  00042	48 8b c1	 mov	 rax, rcx
  00045	48 89 45 40	 mov	 QWORD PTR tv82[rbp], rax
  00049	45 33 c0	 xor	 r8d, r8d
  0004c	ba 02 00 00 00	 mov	 edx, 2
  00051	48 8b 4d 40	 mov	 rcx, QWORD PTR tv82[rbp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@close:

; 377  :         }
; 378  :     }

  0005b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\fstream
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT

; 343  :     __CLR_OR_THIS_CALL ~basic_ofstream() noexcept override {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__4A903650_fstream
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 80 58 ff
	ff ff		 mov	 rax, QWORD PTR [rax-168]
  00026	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00035	48 89 94 01 58
	ff ff ff	 mov	 QWORD PTR [rcx+rax-168], rdx
  0003d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8b 80 58 ff
	ff ff		 mov	 rax, QWORD PTR [rax-168]
  00048	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0004c	48 2d a8 00 00
	00		 sub	 rax, 168		; 000000a8H
  00052	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00056	48 8b 89 58 ff
	ff ff		 mov	 rcx, QWORD PTR [rcx-168]
  0005d	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00061	48 8b 55 50	 mov	 rdx, QWORD PTR this$[rbp]
  00065	89 84 0a 54 ff
	ff ff		 mov	 DWORD PTR [rdx+rcx-172], eax
  0006c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00070	48 2d a0 00 00
	00		 sub	 rax, 160		; 000000a0H
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0007e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00082	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00091	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00095	5d		 pop	 rbp
  00096	c3		 ret	 0
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
_TEXT	SEGMENT
this$ = 80
_Str$ = 88
_Mode$ = 96
_Prot$ = 104
$initVBases$ = 112
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT

; 223  :     explicit basic_ofstream(

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__4A903650_fstream
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 224  :         const string& _Str, ios_base::openmode _Mode = ios_base::out, int _Prot = ios_base::_Default_open_prot)
; 225  :         : basic_ofstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

  0002a	48 8b 4d 58	 mov	 rcx, QWORD PTR _Str$[rbp]
  0002e	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00033	8b 4d 70	 mov	 ecx, DWORD PTR $initVBases$[rbp]
  00036	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0003a	44 8b 4d 68	 mov	 r9d, DWORD PTR _Prot$[rbp]
  0003e	44 8b 45 60	 mov	 r8d, DWORD PTR _Mode$[rbp]
  00042	48 8b d0	 mov	 rdx, rax
  00045	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
  0004e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00059	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00064	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00068	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0006c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006f	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00073	48 2d a8 00 00
	00		 sub	 rax, 168		; 000000a8H
  00079	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0007d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00080	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00084	48 8b 55 50	 mov	 rdx, QWORD PTR this$[rbp]
  00088	89 44 0a fc	 mov	 DWORD PTR [rdx+rcx-4], eax
  0008c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00090	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00094	5d		 pop	 rbp
  00095	c3		 ret	 0
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
_TEXT	SEGMENT
$T1 = 64
tv187 = 72
tv171 = 72
this$ = 96
_Filename$ = 104
_Mode$ = 112
_Prot$ = 120
$initVBases$ = 128
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT

; 215  :     explicit basic_ofstream(const char* _Filename, ios_base::openmode _Mode = ios_base::out,

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	c7 45 40 00 00
	00 00		 mov	 DWORD PTR $T1[rbp], 0
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__4A903650_fstream
  0002c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 216  :         int _Prot = ios_base::_Default_open_prot)
; 217  :         : _Mybase(_STD addressof(_Filebuffer)) { // _Prot is an extension

  00031	83 bd 80 00 00
	00 00		 cmp	 DWORD PTR $initVBases$[rbp], 0
  00038	74 2b		 je	 SHORT $LN2@basic_ofst
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
  00045	48 89 08	 mov	 QWORD PTR [rax], rcx
  00048	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 05 a8 00 00
	00		 add	 rax, 168		; 000000a8H
  00052	48 8b c8	 mov	 rcx, rax
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0005b	90		 npad	 1
  0005c	8b 45 40	 mov	 eax, DWORD PTR $T1[rbp]
  0005f	83 c8 01	 or	 eax, 1
  00062	89 45 40	 mov	 DWORD PTR $T1[rbp], eax
$LN2@basic_ofst:
  00065	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00069	48 83 c0 08	 add	 rax, 8
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 ??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
  00075	45 33 c9	 xor	 r9d, r9d
  00078	45 33 c0	 xor	 r8d, r8d
  0007b	48 8b d0	 mov	 rdx, rax
  0007e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00088	90		 npad	 1
  00089	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0008d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00090	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00094	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0009f	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  000a3	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000a7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000aa	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000ae	48 2d a8 00 00
	00		 sub	 rax, 168		; 000000a8H
  000b4	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  000b8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000bb	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  000bf	48 8b 55 60	 mov	 rdx, QWORD PTR this$[rbp]
  000c3	89 44 0a fc	 mov	 DWORD PTR [rdx+rcx-4], eax
  000c7	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000cb	48 83 c0 08	 add	 rax, 8
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
  000d7	90		 npad	 1

; 218  :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot)) {

  000d8	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000dc	48 83 c0 08	 add	 rax, 8
  000e0	48 89 45 48	 mov	 QWORD PTR tv171[rbp], rax
  000e4	8b 45 70	 mov	 eax, DWORD PTR _Mode$[rbp]
  000e7	83 c8 02	 or	 eax, 2
  000ea	44 8b 4d 78	 mov	 r9d, DWORD PTR _Prot$[rbp]
  000ee	44 8b c0	 mov	 r8d, eax
  000f1	48 8b 55 68	 mov	 rdx, QWORD PTR _Filename$[rbp]
  000f5	48 8b 4d 48	 mov	 rcx, QWORD PTR tv171[rbp]
  000f9	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000fe	48 85 c0	 test	 rax, rax
  00101	75 2c		 jne	 SHORT $LN3@basic_ofst

; 219  :             _Myios::setstate(ios_base::failbit);

  00103	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00107	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010a	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0010e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00112	48 03 c8	 add	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	48 89 45 48	 mov	 QWORD PTR tv187[rbp], rax
  0011c	45 33 c0	 xor	 r8d, r8d
  0011f	ba 02 00 00 00	 mov	 edx, 2
  00124	48 8b 4d 48	 mov	 rcx, QWORD PTR tv187[rbp]
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0012e	90		 npad	 1
$LN3@basic_ofst:

; 220  :         }
; 221  :     }

  0012f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00133	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00137	5d		 pop	 rbp
  00138	c3		 ret	 0
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
tv187 = 72
tv171 = 72
this$ = 96
_Filename$ = 104
_Mode$ = 112
_Prot$ = 120
$initVBases$ = 128
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	8b 45 40	 mov	 eax, DWORD PTR $T1[rbp]
  0000d	83 e0 01	 and	 eax, 1
  00010	85 c0		 test	 eax, eax
  00012	74 15		 je	 SHORT $LN6@dtor$0
  00014	83 65 40 fe	 and	 DWORD PTR $T1[rbp], -2
  00018	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN6@dtor$0:
  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
tv187 = 72
tv171 = 72
this$ = 96
_Filename$ = 104
_Mode$ = 112
_Prot$ = 120
$initVBases$ = 128
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	48 83 c1 10	 add	 rcx, 16
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00018	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
tv187 = 72
tv171 = 72
this$ = 96
_Filename$ = 104
_Mode$ = 112
_Prot$ = 120
$initVBases$ = 128
?dtor$2@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	48 83 c1 08	 add	 rcx, 8
  00012	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$2@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@thread@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z
_TEXT	SEGMENT
this$ = 80
_Fx$ = 88
<_Ax_0>$ = 96
??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@thread@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z PROC ; std::thread::thread<void (__cdecl&)(Logger *),Logger * &,0>, COMDAT

; 86   :     _NODISCARD_CTOR_THREAD explicit thread(_Fn&& _Fx, _Args&&... _Ax) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 87   :         _Start(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

  00025	4c 8b 45 60	 mov	 r8, QWORD PTR <_Ax_0>$[rbp]
  00029	48 8b 55 58	 mov	 rdx, QWORD PTR _Fx$[rbp]
  0002d	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00031	e8 00 00 00 00	 call	 ??$_Start@A6AXPEAVLogger@@@ZAEAPEAV1@@thread@std@@AEAAXA6AXPEAVLogger@@@ZAEAPEAV2@@Z ; std::thread::_Start<void (__cdecl&)(Logger *),Logger * &>

; 88   :     }

  00036	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@thread@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z ENDP ; std::thread::thread<void (__cdecl&)(Logger *),Logger * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fl@@YAXXZ
text$yd	SEGMENT
??__Fl@@YAXXZ PROC					; `dynamic atexit destructor for 'l'', COMDAT
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?l@@3VLogger@@A ; l
  00012	e8 00 00 00 00	 call	 ??1Logger@@QEAA@XZ
  00017	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
??__Fl@@YAXXZ ENDP					; `dynamic atexit destructor for 'l''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ??__El@@YAXXZ
text$di	SEGMENT
??__El@@YAXXZ PROC					; `dynamic initializer for 'l'', COMDAT

; 10   : Logger l;

  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?l@@3VLogger@@A ; l
  0001e	e8 00 00 00 00	 call	 ??0Logger@@QEAA@XZ	; Logger::Logger
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__Fl@@YAXXZ ; `dynamic atexit destructor for 'l''
  0002a	e8 00 00 00 00	 call	 atexit
  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??__El@@YAXXZ ENDP					; `dynamic initializer for 'l''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1Logger@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1Logger@@QEAA@XZ PROC					; Logger::~Logger, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 83 c0 08	 add	 rax, 8
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ ; std::list<log_,std::allocator<log_> >::~list<log_,std::allocator<log_> >
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??1Logger@@QEAA@XZ ENDP					; Logger::~Logger
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unlinknode@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
this$ = 80
_Pnode$ = 88
?_Unlinknode@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@@Z PROC ; std::_List_val<std::_List_simple_types<log_> >::_Unlinknode, COMDAT

; 393  :     _Nodeptr _Unlinknode(_Nodeptr _Pnode) noexcept { // unlink node at _Where from the list

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 394  :         _Orphan_ptr2(_Pnode);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Pnode$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXPEAU?$_List_node@Ulog_@@PEAX@2@@Z ; std::_List_val<std::_List_simple_types<log_> >::_Orphan_ptr2

; 395  :         _Pnode->_Prev->_Next = _Pnode->_Next;

  0002d	48 8b 45 58	 mov	 rax, QWORD PTR _Pnode$[rbp]
  00031	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00035	48 8b 4d 58	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  00039	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 396  :         _Pnode->_Next->_Prev = _Pnode->_Prev;

  0003f	48 8b 45 58	 mov	 rax, QWORD PTR _Pnode$[rbp]
  00043	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00046	48 8b 4d 58	 mov	 rcx, QWORD PTR _Pnode$[rbp]
  0004a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0004e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 397  :         --_Mysize;

  00052	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00056	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005a	48 ff c8	 dec	 rax
  0005d	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00061	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 398  :         return _Pnode;

  00065	48 8b 45 58	 mov	 rax, QWORD PTR _Pnode$[rbp]

; 399  :     }

  00069	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0006d	5d		 pop	 rbp
  0006e	c3		 ret	 0
?_Unlinknode@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<log_> >::_Unlinknode
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
_Pnext$ = 8
_Head$ = 16
_Pnextnext$1 = 24
this$ = 112
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<log_> >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);

  0001e	ba 03 00 00 00	 mov	 edx, 3
  00023	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;

  0002d	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 83 c0 08	 add	 rax, 8
  00038	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 380  :         const auto _Head          = _Myhead;

  0003c	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 89 45 10	 mov	 QWORD PTR _Head$[rbp], rax
$LN2@Orphan_non:

; 381  :         while (*_Pnext) {

  00048	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0004c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00050	74 48		 je	 SHORT $LN3@Orphan_non

; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

  00052	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 83 c0 08	 add	 rax, 8
  0005d	48 89 45 18	 mov	 QWORD PTR _Pnextnext$1[rbp], rax

; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on

  00061	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 8b 4d 10	 mov	 rcx, QWORD PTR _Head$[rbp]
  0006c	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00070	75 0a		 jne	 SHORT $LN4@Orphan_non

; 384  :                 _Pnext = _Pnextnext;

  00072	48 8b 45 18	 mov	 rax, QWORD PTR _Pnextnext$1[rbp]
  00076	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 385  :             } else { // orphan the iterator

  0007a	eb 1c		 jmp	 SHORT $LN5@Orphan_non
$LN4@Orphan_non:

; 386  :                 (*_Pnext)->_Myproxy = nullptr;

  0007c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00080	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00083	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 387  :                 *_Pnext             = *_Pnextnext;

  0008a	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0008e	48 8b 4d 18	 mov	 rcx, QWORD PTR _Pnextnext$1[rbp]
  00092	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00095	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Orphan_non:

; 388  :             }
; 389  :         }

  00098	eb ae		 jmp	 SHORT $LN2@Orphan_non
$LN3@Orphan_non:

; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

  0009a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000a4	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a8	5d		 pop	 rbp
  000a9	c3		 ret	 0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<log_> >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXPEAU?$_List_node@Ulog_@@PEAX@2@@Z
_TEXT	SEGMENT
_Lock$ = 0
_Pnext$ = 8
_Head$ = 16
_Pnextnext$1 = 24
_Pnextptr$2 = 32
this$ = 128
_Ptr$ = 136
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXPEAU?$_List_node@Ulog_@@PEAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<log_> >::_Orphan_ptr2, COMDAT

; 355  :     void _Orphan_ptr2(_Nodeptr _Ptr) noexcept { // orphan iterators with specified node pointers

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 356  : #if _ITERATOR_DEBUG_LEVEL == 2
; 357  :         _Lockit _Lock(_LOCK_DEBUG);

  00023	ba 03 00 00 00	 mov	 edx, 3
  00028	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 358  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;

  00032	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 83 c0 08	 add	 rax, 8
  00040	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 359  :         const auto _Head          = _Myhead;

  00044	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004f	48 89 45 10	 mov	 QWORD PTR _Head$[rbp], rax
$LN2@Orphan_ptr:

; 360  :         while (*_Pnext) {

  00053	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00057	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0005b	74 5d		 je	 SHORT $LN3@Orphan_ptr

; 361  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

  0005d	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00061	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00064	48 83 c0 08	 add	 rax, 8
  00068	48 89 45 18	 mov	 QWORD PTR _Pnextnext$1[rbp], rax

; 362  :             const auto _Pnextptr          = static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr;

  0006c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00070	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00073	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00077	48 89 45 20	 mov	 QWORD PTR _Pnextptr$2[rbp], rax

; 363  :             if (_Pnextptr == _Head || _Pnextptr != _Ptr) {

  0007b	48 8b 45 10	 mov	 rax, QWORD PTR _Head$[rbp]
  0007f	48 39 45 20	 cmp	 QWORD PTR _Pnextptr$2[rbp], rax
  00083	74 0d		 je	 SHORT $LN6@Orphan_ptr
  00085	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR _Ptr$[rbp]
  0008c	48 39 45 20	 cmp	 QWORD PTR _Pnextptr$2[rbp], rax
  00090	74 0a		 je	 SHORT $LN4@Orphan_ptr
$LN6@Orphan_ptr:

; 364  :                 // iterator is end() or doesn't point at the one we are orphaning, move on
; 365  :                 _Pnext = _Pnextnext;

  00092	48 8b 45 18	 mov	 rax, QWORD PTR _Pnextnext$1[rbp]
  00096	48 89 45 08	 mov	 QWORD PTR _Pnext$[rbp], rax

; 366  :             } else { // orphan the iterator

  0009a	eb 1c		 jmp	 SHORT $LN5@Orphan_ptr
$LN4@Orphan_ptr:

; 367  :                 (*_Pnext)->_Myproxy = nullptr;

  0009c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  000a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a3	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 368  :                 *_Pnext             = *_Pnextnext;

  000aa	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$[rbp]
  000ae	48 8b 4d 18	 mov	 rcx, QWORD PTR _Pnextnext$1[rbp]
  000b2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b5	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Orphan_ptr:

; 369  :             }
; 370  :         }

  000b8	eb 99		 jmp	 SHORT $LN2@Orphan_ptr
$LN3@Orphan_ptr:

; 371  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 372  :         (void) _Ptr;
; 373  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 374  :     }

  000ba	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000c4	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000c8	5d		 pop	 rbp
  000c9	c3		 ret	 0
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXPEAU?$_List_node@Ulog_@@PEAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<log_> >::_Orphan_ptr2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<log_> >::_List_val<std::_List_simple_types<log_> >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QEAA@XZ ; std::_Container_base12::_Container_base12
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<log_> >::_List_val<std::_List_simple_types<log_> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ PROC ; std::list<log_,std::allocator<log_> >::_Getal, COMDAT

; 1850 :     const _Alnode& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1851 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Get_first

; 1852 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ENDP ; std::list<log_,std::allocator<log_> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ PROC ; std::list<log_,std::allocator<log_> >::_Getal, COMDAT

; 1846 :     _Alnode& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1847 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Get_first

; 1848 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ENDP ; std::list<log_,std::allocator<log_> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S7$ = 8
_Proxy$ = 16
_Al$ = 32
_Newhead$ = 40
this$ = 128
?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ PROC ; std::list<log_,std::allocator<log_> >::_Alloc_sentinel_and_proxy, COMDAT

; 1831 :     void _Alloc_sentinel_and_proxy() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1832 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  0001e	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  0002a	48 8b d0	 mov	 rdx, rax
  0002d	48 8d 4d 08	 lea	 rcx, QWORD PTR $S7$[rbp]
  00031	e8 00 00 00 00	 call	 ??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<log_,void *> >
  00036	48 8d 45 08	 lea	 rax, QWORD PTR $S7$[rbp]
  0003a	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 1833 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  0003e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00045	4c 8b c0	 mov	 r8, rax
  00048	48 8b 55 00	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  0004c	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00050	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00055	90		 npad	 1

; 1834 :         auto& _Al     = _Getal();

  00056	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005d	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  00062	48 89 45 20	 mov	 QWORD PTR _Al$[rbp], rax

; 1835 :         auto _Newhead = _Al.allocate(1);

  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	48 8b 4d 20	 mov	 rcx, QWORD PTR _Al$[rbp]
  0006f	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ; std::allocator<std::_List_node<log_,void *> >::allocate
  00074	48 89 45 28	 mov	 QWORD PTR _Newhead$[rbp], rax

; 1836 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00078	48 8b 45 28	 mov	 rax, QWORD PTR _Newhead$[rbp]
  0007c	48 8d 55 28	 lea	 rdx, QWORD PTR _Newhead$[rbp]
  00080	48 8b c8	 mov	 rcx, rax
  00083	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>

; 1837 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  00088	48 8b 45 28	 mov	 rax, QWORD PTR _Newhead$[rbp]
  0008c	48 83 c0 08	 add	 rax, 8
  00090	48 8d 55 28	 lea	 rdx, QWORD PTR _Newhead$[rbp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEAU?$_List_node@Ulog_@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@Ulog_@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<log_,void *> *,std::_List_node<log_,void *> * &>

; 1838 :         _Mypair._Myval2._Myhead = _Newhead;

  0009c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	48 8b 4d 28	 mov	 rcx, QWORD PTR _Newhead$[rbp]
  000a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1839 :         _Proxy._Release();

  000ab	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000af	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  000b4	90		 npad	 1

; 1840 :     }

  000b5	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000b9	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000be	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000c2	5d		 pop	 rbp
  000c3	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ ENDP ; std::list<log_,std::allocator<log_> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Alproxy$ = 0
$S7$ = 8
_Proxy$ = 16
_Al$ = 32
_Newhead$ = 40
this$ = 128
?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ@4HA PROC ; `std::list<log_,std::allocator<log_> >::_Alloc_sentinel_and_proxy'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ@4HA ENDP ; `std::list<log_,std::allocator<log_> >::_Alloc_sentinel_and_proxy'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Tidy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Al$ = 0
_My_data$ = 8
this$ = 96
?_Tidy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ PROC ; std::list<log_,std::allocator<log_> >::_Tidy, COMDAT

; 1496 :     void _Tidy() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1497 :         auto& _Al      = _Getal();

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  00024	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00028	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax

; 1499 :         _My_data._Orphan_all();

  00030	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 1500 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00039	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0003d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00041	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00045	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Free_non_head<std::allocator<std::_List_node<log_,void *> > >

; 1501 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0004a	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0004e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00052	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00056	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Freenode0<std::allocator<std::_List_node<log_,void *> > >

; 1502 :     }

  0005b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?_Tidy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ ENDP ; std::list<log_,std::allocator<log_> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?clear@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 0
tv75 = 72
tv73 = 80
this$ = 112
?clear@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXXZ PROC ; std::list<log_,std::allocator<log_> >::clear, COMDAT

; 1486 :     void clear() noexcept { // erase all

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1487 :         auto& _My_data = _Mypair._Myval2;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 1488 :         _My_data._Orphan_non_end();

  00026	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<log_> >::_Orphan_non_end

; 1489 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0002f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  0003b	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0003f	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  00044	48 89 45 50	 mov	 QWORD PTR tv73[rbp], rax
  00048	48 8b 55 48	 mov	 rdx, QWORD PTR tv75[rbp]
  0004c	48 8b 4d 50	 mov	 rcx, QWORD PTR tv73[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Free_non_head<std::allocator<std::_List_node<log_,void *> > >

; 1490 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00055	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00059	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005d	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00061	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00065	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1491 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00068	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0006c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00070	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00074	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00078	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1492 :         _My_data._Mysize        = 0;

  0007c	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00080	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1493 :     }

  00088	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0008c	5d		 pop	 rbp
  0008d	c3		 ret	 0
?clear@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXXZ ENDP ; std::list<log_,std::allocator<log_> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
_Predecessor$ = 0
_Head$ = 8
_Lock$1 = 16
_Marked$2 = 24
_Pnext$3 = 32
_Pnextnext$4 = 40
_Al$ = 48
_Erasures$ = 56
_Next$5 = 64
this$ = 160
_First$ = 168
_Last$ = 176
?_Unchecked_erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::list<log_,std::allocator<log_> >::_Unchecked_erase, COMDAT

; 1436 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept { // erase [_First, _Last)

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1437 :         if (_First == _Last) {

  00028	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0002f	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  00036	75 0c		 jne	 SHORT $LN10@Unchecked_

; 1438 :             return _Last;

  00038	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  0003f	e9 9d 01 00 00	 jmp	 $LN1@Unchecked_
$LN10@Unchecked_:

; 1439 :         }
; 1440 : 
; 1441 :         const auto _Predecessor = _First->_Prev;

  00044	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  0004b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004f	48 89 45 00	 mov	 QWORD PTR _Predecessor$[rbp], rax

; 1442 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1443 :         const auto _Head = _Mypair._Myval2._Myhead;

  00053	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005e	48 89 45 08	 mov	 QWORD PTR _Head$[rbp], rax

; 1444 :         if (_First == _Head->_Next && _Last == _Head) { // orphan all non-end iterators

  00062	48 8b 45 08	 mov	 rax, QWORD PTR _Head$[rbp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  00070	75 21		 jne	 SHORT $LN11@Unchecked_
  00072	48 8b 45 08	 mov	 rax, QWORD PTR _Head$[rbp]
  00076	48 39 85 b0 00
	00 00		 cmp	 QWORD PTR _Last$[rbp], rax
  0007d	75 14		 jne	 SHORT $LN11@Unchecked_

; 1445 :             _Mypair._Myval2._Orphan_non_end();

  0007f	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00086	48 8b c8	 mov	 rcx, rax
  00089	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<log_> >::_Orphan_non_end

; 1446 :         } else { // orphan erased iterators

  0008e	e9 b1 00 00 00	 jmp	 $LN12@Unchecked_
$LN11@Unchecked_:

; 1447 :             _Lockit _Lock(_LOCK_DEBUG);

  00093	ba 03 00 00 00	 mov	 edx, 3
  00098	48 8d 4d 10	 lea	 rcx, QWORD PTR _Lock$1[rbp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1448 :             for (auto _Marked = _First; _Marked != _Last; _Marked = _Marked->_Next) { // mark erased nodes

  000a2	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  000a9	48 89 45 18	 mov	 QWORD PTR _Marked$2[rbp], rax
  000ad	eb 0b		 jmp	 SHORT $LN4@Unchecked_
$LN2@Unchecked_:
  000af	48 8b 45 18	 mov	 rax, QWORD PTR _Marked$2[rbp]
  000b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b6	48 89 45 18	 mov	 QWORD PTR _Marked$2[rbp], rax
$LN4@Unchecked_:
  000ba	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  000c1	48 39 45 18	 cmp	 QWORD PTR _Marked$2[rbp], rax
  000c5	74 0e		 je	 SHORT $LN3@Unchecked_

; 1449 :                 _Marked->_Prev = nullptr;

  000c7	48 8b 45 18	 mov	 rax, QWORD PTR _Marked$2[rbp]
  000cb	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1450 :             }

  000d3	eb da		 jmp	 SHORT $LN2@Unchecked_
$LN3@Unchecked_:

; 1451 : 
; 1452 :             _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

  000d5	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000df	48 83 c0 08	 add	 rax, 8
  000e3	48 89 45 20	 mov	 QWORD PTR _Pnext$3[rbp], rax
$LN5@Unchecked_:

; 1453 :             while (*_Pnext) {

  000e7	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  000eb	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000ef	74 49		 je	 SHORT $LN6@Unchecked_

; 1454 :                 _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

  000f1	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  000f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f8	48 83 c0 08	 add	 rax, 8
  000fc	48 89 45 28	 mov	 QWORD PTR _Pnextnext$4[rbp], rax

; 1455 :                 if (static_cast<const_iterator&>(**_Pnext)._Ptr->_Prev) { // node still has a _Prev, skip

  00100	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  00104	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00107	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00110	74 0a		 je	 SHORT $LN13@Unchecked_

; 1456 :                     _Pnext = _Pnextnext;

  00112	48 8b 45 28	 mov	 rax, QWORD PTR _Pnextnext$4[rbp]
  00116	48 89 45 20	 mov	 QWORD PTR _Pnext$3[rbp], rax

; 1457 :                 } else { // orphan the iterator

  0011a	eb 1c		 jmp	 SHORT $LN14@Unchecked_
$LN13@Unchecked_:

; 1458 :                     (*_Pnext)->_Myproxy = nullptr;

  0011c	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  00120	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00123	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1459 :                     *_Pnext             = *_Pnextnext;

  0012a	48 8b 45 20	 mov	 rax, QWORD PTR _Pnext$3[rbp]
  0012e	48 8b 4d 28	 mov	 rcx, QWORD PTR _Pnextnext$4[rbp]
  00132	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00135	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN14@Unchecked_:

; 1460 :                 }
; 1461 :             }

  00138	eb ad		 jmp	 SHORT $LN5@Unchecked_
$LN6@Unchecked_:

; 1462 : 
; 1463 :             // _Prev pointers not restored because we're about to delete the nodes of which they are a member anyway
; 1464 :         }

  0013a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Lock$1[rbp]
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
$LN12@Unchecked_:

; 1465 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1466 : 
; 1467 :         // snip out the removed range
; 1468 :         _Predecessor->_Next = _Last;

  00144	48 8b 45 00	 mov	 rax, QWORD PTR _Predecessor$[rbp]
  00148	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR _Last$[rbp]
  0014f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1469 :         _Last->_Prev        = _Predecessor;

  00152	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  00159	48 8b 4d 00	 mov	 rcx, QWORD PTR _Predecessor$[rbp]
  0015d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1470 : 
; 1471 :         // count and deallocate the removed nodes
; 1472 :         auto& _Al           = _Getal();

  00161	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00168	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  0016d	48 89 45 30	 mov	 QWORD PTR _Al$[rbp], rax

; 1473 :         size_type _Erasures = 0;

  00171	48 c7 45 38 00
	00 00 00	 mov	 QWORD PTR _Erasures$[rbp], 0
$LN9@Unchecked_:

; 1474 :         do {
; 1475 :             const auto _Next = _First->_Next;

  00179	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _First$[rbp]
  00180	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00183	48 89 45 40	 mov	 QWORD PTR _Next$5[rbp], rax

; 1476 :             _Node::_Freenode(_Al, _First);

  00187	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _First$[rbp]
  0018e	48 8b 4d 30	 mov	 rcx, QWORD PTR _Al$[rbp]
  00192	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Freenode<std::allocator<std::_List_node<log_,void *> > >

; 1477 :             _First = _Next;

  00197	48 8b 45 40	 mov	 rax, QWORD PTR _Next$5[rbp]
  0019b	48 89 85 a8 00
	00 00		 mov	 QWORD PTR _First$[rbp], rax

; 1478 :             ++_Erasures;

  001a2	48 8b 45 38	 mov	 rax, QWORD PTR _Erasures$[rbp]
  001a6	48 ff c0	 inc	 rax
  001a9	48 89 45 38	 mov	 QWORD PTR _Erasures$[rbp], rax

; 1479 :         } while (_First != _Last);

  001ad	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
  001b4	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _First$[rbp], rax
  001bb	75 bc		 jne	 SHORT $LN9@Unchecked_

; 1480 : 
; 1481 :         _Mypair._Myval2._Mysize -= _Erasures;

  001bd	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001c4	48 8b 4d 38	 mov	 rcx, QWORD PTR _Erasures$[rbp]
  001c8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001cc	48 2b c1	 sub	 rax, rcx
  001cf	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001d6	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1482 :         return _Last;

  001da	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Last$[rbp]
$LN1@Unchecked_:

; 1483 :     }

  001e1	48 8d a5 90 00
	00 00		 lea	 rsp, QWORD PTR [rbp+144]
  001e8	5d		 pop	 rbp
  001e9	c3		 ret	 0
?_Unchecked_erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::list<log_,std::allocator<log_> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Result$ = 0
tv145 = 72
tv70 = 72
tv153 = 80
tv151 = 88
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
?erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@@Z PROC ; std::list<log_,std::allocator<log_> >::erase, COMDAT

; 1409 :     iterator erase(const const_iterator _Where) noexcept /* strengthened */ {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@erase:

; 1410 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1411 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "list erase iterator outside range");

  00028	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR _Where$[rbp]
  0002f	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00034	48 89 45 48	 mov	 QWORD PTR tv70[rbp], rax
  00038	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<log_> > >
  00041	48 8b 4d 48	 mov	 rcx, QWORD PTR tv70[rbp]
  00045	48 3b c8	 cmp	 rcx, rax
  00048	75 02		 jne	 SHORT $LN7@erase
  0004a	eb 6b		 jmp	 SHORT $LN9@erase
$LN7@erase:
  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CC@KEJJOMBH@list?5erase?5iterator?5outside?5ran@
  00053	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0005f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00064	45 33 c9	 xor	 r9d, r9d
  00067	41 b8 83 05 00
	00		 mov	 r8d, 1411		; 00000583H
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FN@EEGLACMD@C?3?2Program?5Files?2Microsoft?5Visu@
  00074	b9 02 00 00 00	 mov	 ecx, 2
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  0007f	83 f8 01	 cmp	 eax, 1
  00082	75 03		 jne	 SHORT $LN11@erase
  00084	cc		 int	 3
  00085	33 c0		 xor	 eax, eax
$LN11@erase:
  00087	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00090	41 b9 83 05 00
	00		 mov	 r9d, 1411		; 00000583H
  00096	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1LK@GCOFKPID@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@FHIDKIBN@?$AA?$CC?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe@
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 95		 jne	 SHORT $LN7@erase
$LN9@erase:
  000b7	33 c0		 xor	 eax, eax
  000b9	85 c0		 test	 eax, eax
  000bb	0f 85 67 ff ff
	ff		 jne	 $LN4@erase

; 1412 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1413 :         const auto _Result = _Where._Ptr->_Next;

  000c1	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Where$[rbp]
  000c8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cf	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax

; 1414 :         _Node::_Freenode(_Getal(), _Mypair._Myval2._Unlinknode(_Where._Ptr));

  000d3	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000d7	48 89 45 48	 mov	 QWORD PTR tv145[rbp], rax
  000db	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Where$[rbp]
  000e2	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000e6	48 8b 4d 48	 mov	 rcx, QWORD PTR tv145[rbp]
  000ea	e8 00 00 00 00	 call	 ?_Unlinknode@?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@PEAU32@@Z ; std::_List_val<std::_List_simple_types<log_> >::_Unlinknode
  000ef	48 89 45 50	 mov	 QWORD PTR tv153[rbp], rax
  000f3	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  000f7	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  000fc	48 89 45 58	 mov	 QWORD PTR tv151[rbp], rax
  00100	48 8b 55 50	 mov	 rdx, QWORD PTR tv153[rbp]
  00104	48 8b 4d 58	 mov	 rcx, QWORD PTR tv151[rbp]
  00108	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@?$_List_node@Ulog_@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<log_,void *>::_Freenode<std::allocator<std::_List_node<log_,void *> > >

; 1415 :         return _Make_iter(_Result);

  0010d	4c 8b 45 00	 mov	 r8, QWORD PTR _Result$[rbp]
  00111	48 8b 55 78	 mov	 rdx, QWORD PTR __$ReturnUdt$[rbp]
  00115	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00119	e8 00 00 00 00	 call	 ?_Make_iter@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@PEAU?$_List_node@Ulog_@@PEAX@2@@Z ; std::list<log_,std::allocator<log_> >::_Make_iter
  0011e	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR _Where$[rbp]
  00125	e8 00 00 00 00	 call	 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
  0012a	48 8b 45 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1416 :     }

  0012e	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00132	5d		 pop	 rbp
  00133	c3		 ret	 0
?erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@@Z ENDP ; std::list<log_,std::allocator<log_> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z
_TEXT	SEGMENT
this$ = 80
_Val$ = 88
?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z PROC ; std::list<log_,std::allocator<log_> >::push_back, COMDAT

; 1257 :     void push_back(const _Ty& _Val) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1258 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  00020	4c 8b 45 58	 mov	 r8, QWORD PTR _Val$[rbp]
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00030	e8 00 00 00 00	 call	 ??$_Emplace@AEBUlog_@@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@1@QEAU21@AEBUlog_@@@Z ; std::list<log_,std::allocator<log_> >::_Emplace<log_ const &>

; 1259 :     }

  00035	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z ENDP ; std::list<log_,std::allocator<log_> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?empty@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 64
this$ = 96
?empty@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_NXZ PROC ; std::list<log_,std::allocator<log_> >::empty, COMDAT

; 1196 :     _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1197 :         return _Mypair._Myval2._Mysize == 0;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00024	75 09		 jne	 SHORT $LN3@empty
  00026	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv68[rbp], 1
  0002d	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  0002f	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv68[rbp], 0
$LN4@empty:
  00036	0f b6 45 40	 movzx	 eax, BYTE PTR tv68[rbp]

; 1198 :     }

  0003a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
?empty@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_NXZ ENDP ; std::list<log_,std::allocator<log_> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?max_size@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
this$ = 96
?max_size@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_KXZ PROC ; std::list<log_,std::allocator<log_> >::max_size, COMDAT

; 1191 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1192 :         return (_STD min)(

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::max_size
  0002c	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00030	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00035	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00039	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0003d	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00041	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1193 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1194 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?max_size@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_KXZ ENDP ; std::list<log_,std::allocator<log_> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Make_iter@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@PEAU?$_List_node@Ulog_@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
_Where$ = 96
?_Make_iter@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@PEAU?$_List_node@Ulog_@@PEAX@2@@Z PROC ; std::list<log_,std::allocator<log_> >::_Make_iter, COMDAT

; 1120 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1121 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<log_> > const >
  00031	4c 8b c0	 mov	 r8, rax
  00034	48 8b 55 60	 mov	 rdx, QWORD PTR _Where$[rbp]
  00038	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0003c	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
  00041	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1122 :     }

  00045	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
?_Make_iter@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@PEAU?$_List_node@Ulog_@@PEAX@2@@Z ENDP ; std::list<log_,std::allocator<log_> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?_Unchecked_end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::list<log_,std::allocator<log_> >::_Unchecked_end, COMDAT

; 1116 :     _Unchecked_const_iterator _Unchecked_end() const noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1117 :         return _Unchecked_const_iterator(_Mypair._Myval2._Myhead, nullptr);

  00020	45 33 c0	 xor	 r8d, r8d
  00023	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0002b	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0002f	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>
  00034	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1118 :     }

  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?_Unchecked_end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::list<log_,std::allocator<log_> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?_Unchecked_begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?_Unchecked_begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::list<log_,std::allocator<log_> >::_Unchecked_begin, COMDAT

; 1108 :     _Unchecked_const_iterator _Unchecked_begin() const noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1109 :         return _Unchecked_const_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	45 33 c0	 xor	 r8d, r8d
  0002b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002e	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00032	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>
  00037	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1110 :     }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
?_Unchecked_begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::list<log_,std::allocator<log_> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 64
tv76 = 72
this$ = 96
__$ReturnUdt$ = 104
?end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ PROC ; std::list<log_,std::allocator<log_> >::end, COMDAT

; 1096 :     _NODISCARD iterator end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1097 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<log_> > >
  0002c	48 89 45 40	 mov	 QWORD PTR tv78[rbp], rax
  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 89 45 48	 mov	 QWORD PTR tv76[rbp], rax
  0003c	4c 8b 45 40	 mov	 r8, QWORD PTR tv78[rbp]
  00040	48 8b 55 48	 mov	 rdx, QWORD PTR tv76[rbp]
  00044	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00048	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
  0004d	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1098 :     }

  00051	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
?end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ ENDP ; std::list<log_,std::allocator<log_> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ?begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv79 = 64
tv77 = 72
this$ = 96
__$ReturnUdt$ = 104
?begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ PROC ; std::list<log_,std::allocator<log_> >::begin, COMDAT

; 1088 :     _NODISCARD iterator begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1089 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<log_> > >
  0002c	48 89 45 40	 mov	 QWORD PTR tv79[rbp], rax
  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003b	48 89 45 48	 mov	 QWORD PTR tv77[rbp], rax
  0003f	4c 8b 45 40	 mov	 r8, QWORD PTR tv79[rbp]
  00043	48 8b 55 48	 mov	 rdx, QWORD PTR tv77[rbp]
  00047	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0004b	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@Ulog_@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@1@@Z
  00050	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1090 :     }

  00054	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00058	5d		 pop	 rbp
  00059	c3		 ret	 0
?begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ ENDP ; std::list<log_,std::allocator<log_> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??4?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
_Al$ = 0
_Right_al$ = 8
$T1 = 80
$T2 = 88
$T3 = 96
$T4 = 104
this$ = 128
_Right$ = 136
??4?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::list<log_,std::allocator<log_> >::operator=, COMDAT

; 1069 :     list& operator=(const list& _Right) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1070 :         if (this == _STD addressof(_Right)) {

  00023	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  0002a	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@@std@@YAPEBV?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@0@AEBV10@@Z ; std::addressof<std::list<log_,std::allocator<log_> > const >
  0002f	48 39 85 80 00
	00 00		 cmp	 QWORD PTR this$[rbp], rax
  00036	75 09		 jne	 SHORT $LN2@operator

; 1071 :             return *this;

  00038	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003f	eb 76		 jmp	 SHORT $LN1@operator
$LN2@operator:

; 1072 :         }
; 1073 : 
; 1074 :         auto& _Al       = _Getal();

  00041	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00048	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  0004d	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 1075 :         auto& _Right_al = _Right._Getal();

  00051	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  00058	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  0005d	48 89 45 08	 mov	 QWORD PTR _Right_al$[rbp], rax

; 1076 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1077 :             if (_Al != _Right_al) {
; 1078 :                 _Reload_sentinel_and_proxy(_Right);
; 1079 :             }
; 1080 :         } else {
; 1081 :             _Pocca(_Al, _Right_al);

  00061	48 8b 55 08	 mov	 rdx, QWORD PTR _Right_al$[rbp]
  00065	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00069	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<std::_List_node<log_,void *> > >

; 1082 :         }
; 1083 : 
; 1084 :         assign(_Right._Unchecked_begin(), _Right._Unchecked_end());

  0006e	48 8d 55 50	 lea	 rdx, QWORD PTR $T1[rbp]
  00072	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  00079	e8 00 00 00 00	 call	 ?_Unchecked_end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<log_,std::allocator<log_> >::_Unchecked_end
  0007e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00081	48 89 45 68	 mov	 QWORD PTR $T4[rbp], rax
  00085	48 8d 55 58	 lea	 rdx, QWORD PTR $T2[rbp]
  00089	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  00090	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<log_,std::allocator<log_> >::_Unchecked_begin
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	48 89 45 60	 mov	 QWORD PTR $T3[rbp], rax
  0009c	4c 8b 45 68	 mov	 r8, QWORD PTR $T4[rbp]
  000a0	48 8b 55 60	 mov	 rdx, QWORD PTR $T3[rbp]
  000a4	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000ab	e8 00 00 00 00	 call	 ??$assign@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@$0A@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@0@Z ; std::list<log_,std::allocator<log_> >::assign<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,0>

; 1085 :         return *this;

  000b0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
$LN1@operator:

; 1086 :     }

  000b7	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000bb	5d		 pop	 rbp
  000bc	c3		 ret	 0
??4?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::list<log_,std::allocator<log_> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S1$ = 8
this$ = 96
??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ PROC ; std::list<log_,std::allocator<log_> >::~list<log_,std::allocator<log_> >, COMDAT

; 1044 :     ~list() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1045 :         _Tidy();

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Tidy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ ; std::list<log_,std::allocator<log_> >::_Tidy

; 1046 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1047 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00024	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 8d 4d 08	 lea	 rcx, QWORD PTR $S1$[rbp]
  00034	e8 00 00 00 00	 call	 ??$?0U?$_List_node@Ulog_@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<log_,void *> >
  00039	48 8d 45 08	 lea	 rax, QWORD PTR $S1$[rbp]
  0003d	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 1048 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);

  00041	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00048	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  0004c	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 1049 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1050 :     }

  00051	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ ENDP ; std::list<log_,std::allocator<log_> >::~list<log_,std::allocator<log_> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
$T3 = 66
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
tv78 = 104
tv76 = 112
this$ = 144
_Right$ = 152
??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::list<log_,std::allocator<log_> >::list<log_,std::allocator<log_> >, COMDAT

; 866  :         : _Mypair(_One_then_variadic_args_t{}, _Alnode_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00023	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 89 45 68	 mov	 QWORD PTR tv78[rbp], rax
  0002e	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  00035	e8 00 00 00 00	 call	 ?_Getal@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEBAAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::_Getal
  0003a	48 8b d0	 mov	 rdx, rax
  0003d	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00041	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::select_on_container_copy_construction
  00046	48 89 45 70	 mov	 QWORD PTR tv76[rbp], rax
  0004a	0f b6 45 41	 movzx	 eax, BYTE PTR $T2[rbp]
  0004e	88 45 42	 mov	 BYTE PTR $T3[rbp], al
  00051	4c 8b 45 70	 mov	 r8, QWORD PTR tv76[rbp]
  00055	0f b6 55 42	 movzx	 edx, BYTE PTR $T3[rbp]
  00059	48 8b 4d 68	 mov	 rcx, QWORD PTR tv78[rbp]
  0005d	e8 00 00 00 00	 call	 ??$?0V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1><std::allocator<std::_List_node<log_,void *> > >

; 867  :         _Construct_range_unchecked(_Right._Unchecked_begin(), _Right._Unchecked_end());

  00062	48 8d 55 48	 lea	 rdx, QWORD PTR $T4[rbp]
  00066	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  0006d	e8 00 00 00 00	 call	 ?_Unchecked_end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<log_,std::allocator<log_> >::_Unchecked_end
  00072	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00075	48 89 45 60	 mov	 QWORD PTR $T7[rbp], rax
  00079	48 8d 55 50	 lea	 rdx, QWORD PTR $T5[rbp]
  0007d	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  00084	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<log_,std::allocator<log_> >::_Unchecked_begin
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	48 89 45 58	 mov	 QWORD PTR $T6[rbp], rax
  00090	4c 8b 45 60	 mov	 r8, QWORD PTR $T7[rbp]
  00094	48 8b 55 58	 mov	 rdx, QWORD PTR $T6[rbp]
  00098	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009f	e8 00 00 00 00	 call	 ??$_Construct_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::list<log_,std::allocator<log_> >::_Construct_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<log_> >,std::_Iterator_base0> >

; 868  :     }

  000a4	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ab	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  000b2	5d		 pop	 rbp
  000b3	c3		 ret	 0
??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::list<log_,std::allocator<log_> >::list<log_,std::allocator<log_> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\list
;	COMDAT ??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 64
tv69 = 72
this$ = 96
??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ PROC ; std::list<log_,std::allocator<log_> >::list<log_,std::allocator<log_> >, COMDAT

; 798  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__52656974_list
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 89 45 48	 mov	 QWORD PTR tv69[rbp], rax
  00023	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00027	48 8b 4d 48	 mov	 rcx, QWORD PTR tv69[rbp]
  0002b	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1>::_Compressed_pair<std::allocator<std::_List_node<log_,void *> >,std::_List_val<std::_List_simple_types<log_> >,1><>

; 799  :         _Alloc_sentinel_and_proxy();

  00030	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@AEAAXXZ ; std::list<log_,std::allocator<log_> >::_Alloc_sentinel_and_proxy

; 800  :     }

  00039	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ ENDP ; std::list<log_,std::allocator<log_> >::list<log_,std::allocator<log_> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 80
_Al$ = 88
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::select_on_container_copy_construction, COMDAT

; 740  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 741  :         return _Al;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 742  :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 80
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001b	48 b8 33 33 33
	33 33 33 33 03	 mov	 rax, 230584300921369395	; 0333333333333333H

; 738  :     }

  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@QEAU?$_List_node@Ulog_@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@QEAU?$_List_node@Ulog_@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@deallocate

; 709  :             _Al.deallocate(_Ptr, _Count);

  00031	4c 8b 45 60	 mov	 r8, QWORD PTR _Count$[rbp]
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00039	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ; std::allocator<std::_List_node<log_,void *> >::deallocate

; 710  :         } else

  00042	eb 11		 jmp	 SHORT $LN3@deallocate
$LN2@deallocate:

; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00044	48 6b 45 60 50	 imul	 rax, QWORD PTR _Count$[rbp], 80 ; 00000050H
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>
$LN3@deallocate:

; 715  :         }
; 716  :     }

  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@2@QEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<log_,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<log_,void *> >::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z ; std::_Get_size_of_n<80>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAPEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<log_,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@Ulog_@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@Ulog_@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<log_,void *> >::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 6b 45 60 50	 imul	 rax, QWORD PTR _Count$[rbp], 80 ; 00000050H
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bb	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?deallocate@?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@Ulog_@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<log_,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_List_node<log_,void *> >::allocator<std::_List_node<log_,void *> >, COMDAT

; 962  :     constexpr allocator() noexcept {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??0?$allocator@U?$_List_node@Ulog_@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_List_node<log_,void *> >::allocator<std::_List_node<log_,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?wait@Logger@@SAXXZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
?wait@Logger@@SAXXZ PROC				; Logger::wait, COMDAT

; 232  : {

$LN5:
  00000	40 55		 push	 rbp
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@wait:

; 233  : 	while (!inst->logs.empty())

  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  0001e	48 83 c0 08	 add	 rax, 8
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 ?empty@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_NXZ ; std::list<log_,std::allocator<log_> >::empty
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	75 1e		 jne	 SHORT $LN3@wait

; 234  : 	{
; 235  : 		std::this_thread::sleep_for(std::chrono::milliseconds(10));

  00031	c7 45 48 0a 00
	00 00		 mov	 DWORD PTR $T2[rbp], 10
  00038	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  0003c	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00040	e8 00 00 00 00	 call	 ??$?0H$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEBH@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,0>
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >

; 236  : 	}

  0004d	eb c8		 jmp	 SHORT $LN2@wait
$LN3@wait:

; 237  : 
; 238  : }

  0004f	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00053	5d		 pop	 rbp
  00054	c3		 ret	 0
?wait@Logger@@SAXXZ ENDP				; Logger::wait
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z
_TEXT	SEGMENT
temp$ = 0
$T1 = 128
$T2 = 168
$T3 = 176
$T4 = 200
$T5 = 208
$T6 = 232
tv146 = 240
tv138 = 240
tv152 = 248
tv128 = 256
tv154 = 264
tv136 = 272
tv156 = 280
str$ = 304
severenty$ = 312
?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z PROC ; Logger::log, COMDAT

; 171  : {

$LN9:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 172  : 	if (((inst->severity) | (severenty)) != inst->severity)

  00022	48 63 85 38 01
	00 00		 movsxd	 rax, DWORD PTR severenty$[rbp]
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 0b c8	 or	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  00040	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00043	74 11		 je	 SHORT $LN2@log

; 173  : 	{
; 174  : 		return;

  00045	48 8b 8d 30 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  0004c	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00051	e9 20 01 00 00	 jmp	 $LN1@log
$LN2@log:

; 175  : 	}
; 176  : 
; 177  : 	log_ temp;

  00056	48 8d 4d 00	 lea	 rcx, QWORD PTR temp$[rbp]
  0005a	e8 00 00 00 00	 call	 ??0log_@@QEAA@XZ
  0005f	90		 npad	 1

; 178  : 
; 179  : 	temp.severenty = severenty;

  00060	48 63 85 38 01
	00 00		 movsxd	 rax, DWORD PTR severenty$[rbp]
  00067	48 89 45 00	 mov	 QWORD PTR temp$[rbp], rax

; 180  : 	temp.time = time(0);

  0006b	33 c9		 xor	 ecx, ecx
  0006d	e8 00 00 00 00	 call	 time
  00072	48 89 45 30	 mov	 QWORD PTR temp$[rbp+48], rax

; 181  : 	temp.txt = FString(str.begin(), str.end());

  00076	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  0007d	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  00082	48 89 85 f0 00
	00 00		 mov	 QWORD PTR tv138[rbp], rax
  00089	48 8d 85 b0 00
	00 00		 lea	 rax, QWORD PTR $T3[rbp]
  00090	48 89 85 c8 00
	00 00		 mov	 QWORD PTR $T4[rbp], rax
  00097	48 8b 95 c8 00
	00 00		 mov	 rdx, QWORD PTR $T4[rbp]
  0009e	48 8b 8d 30 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  000a5	e8 00 00 00 00	 call	 ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
  000aa	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv152[rbp], rax
  000b1	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR tv152[rbp]
  000b8	48 89 85 00 01
	00 00		 mov	 QWORD PTR tv128[rbp], rax
  000bf	48 8d 85 d0 00
	00 00		 lea	 rax, QWORD PTR $T5[rbp]
  000c6	48 89 85 e8 00
	00 00		 mov	 QWORD PTR $T6[rbp], rax
  000cd	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR $T6[rbp]
  000d4	48 8b 8d 30 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  000db	e8 00 00 00 00	 call	 ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
  000e0	48 89 85 08 01
	00 00		 mov	 QWORD PTR tv154[rbp], rax
  000e7	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR tv154[rbp]
  000ee	48 89 85 10 01
	00 00		 mov	 QWORD PTR tv136[rbp], rax
  000f5	4c 8b 8d f0 00
	00 00		 mov	 r9, QWORD PTR tv138[rbp]
  000fc	4c 8b 85 00 01
	00 00		 mov	 r8, QWORD PTR tv128[rbp]
  00103	48 8b 95 10 01
	00 00		 mov	 rdx, QWORD PTR tv136[rbp]
  0010a	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  00111	e8 00 00 00 00	 call	 ??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>
  00116	48 89 85 18 01
	00 00		 mov	 QWORD PTR tv156[rbp], rax
  0011d	48 8b 95 18 01
	00 00		 mov	 rdx, QWORD PTR tv156[rbp]
  00124	48 8d 4d 08	 lea	 rcx, QWORD PTR temp$[rbp+8]
  00128	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  0012d	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  00134	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 182  : 	temp.isConsole = true;

  00139	c6 45 38 01	 mov	 BYTE PTR temp$[rbp+56], 1

; 183  : 
; 184  : 	inst->logs.push_back(temp);

  0013d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  00144	48 83 c0 08	 add	 rax, 8
  00148	48 89 85 f0 00
	00 00		 mov	 QWORD PTR tv146[rbp], rax
  0014f	48 8d 55 00	 lea	 rdx, QWORD PTR temp$[rbp]
  00153	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR tv146[rbp]
  0015a	e8 00 00 00 00	 call	 ?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z ; std::list<log_,std::allocator<log_> >::push_back
  0015f	90		 npad	 1

; 185  : 
; 186  : 
; 187  : }

  00160	48 8d 4d 00	 lea	 rcx, QWORD PTR temp$[rbp]
  00164	e8 00 00 00 00	 call	 ??1log_@@QEAA@XZ
  00169	90		 npad	 1
  0016a	48 8b 8d 30 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  00171	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN1@log:
  00176	48 8d a5 20 01
	00 00		 lea	 rsp, QWORD PTR [rbp+288]
  0017d	5d		 pop	 rbp
  0017e	c3		 ret	 0
?log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z ENDP ; Logger::log
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
temp$ = 0
$T1 = 128
$T2 = 168
$T3 = 176
$T4 = 200
$T5 = 208
$T6 = 232
tv146 = 240
tv138 = 240
tv152 = 248
tv128 = 256
tv154 = 264
tv136 = 272
tv156 = 280
str$ = 304
severenty$ = 312
?dtor$0@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA PROC ; `Logger::log'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d 30 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA ENDP ; `Logger::log'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
temp$ = 0
$T1 = 128
$T2 = 168
$T3 = 176
$T4 = 200
$T5 = 208
$T6 = 232
tv146 = 240
tv138 = 240
tv152 = 248
tv128 = 256
tv154 = 264
tv136 = 272
tv156 = 280
str$ = 304
severenty$ = 312
?dtor$1@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA PROC ; `Logger::log'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR temp$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1log_@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$1@?0??log@Logger@@SAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4LOGGER_ENUM@@@Z@4HA ENDP ; `Logger::log'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
_TEXT	SEGMENT
lTemp$ = 0
temp$ = 32
this$ = 176
logTxt$ = 184
severinty$ = 192
?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z PROC ; Logger::urgLog, COMDAT

; 191  : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 192  : 	std::list<log_> lTemp = this->logs;

  00028	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 83 c0 08	 add	 rax, 8
  00033	48 8b d0	 mov	 rdx, rax
  00036	48 8d 4d 00	 lea	 rcx, QWORD PTR lTemp$[rbp]
  0003a	e8 00 00 00 00	 call	 ??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@AEBV01@@Z ; std::list<log_,std::allocator<log_> >::list<log_,std::allocator<log_> >
  0003f	90		 npad	 1

; 193  : 
; 194  : 	logs.clear();

  00040	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00047	48 83 c0 08	 add	 rax, 8
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 ?clear@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXXZ ; std::list<log_,std::allocator<log_> >::clear

; 195  : 
; 196  : 	if (((this->severity) | (severinty)) != this->severity)

  00053	48 63 85 c0 00
	00 00		 movsxd	 rax, DWORD PTR severinty$[rbp]
  0005a	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00061	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00064	48 0b c8	 or	 rcx, rax
  00067	48 8b c1	 mov	 rax, rcx
  0006a	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00071	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00074	74 1b		 je	 SHORT $LN2@urgLog

; 197  : 	{
; 198  : 		return;

  00076	48 8d 4d 00	 lea	 rcx, QWORD PTR lTemp$[rbp]
  0007a	e8 00 00 00 00	 call	 ??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ ; std::list<log_,std::allocator<log_> >::~list<log_,std::allocator<log_> >
  0007f	90		 npad	 1
  00080	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR logTxt$[rbp]
  00087	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0008c	e9 89 00 00 00	 jmp	 $LN1@urgLog
$LN2@urgLog:

; 199  : 	}
; 200  : 
; 201  : 	log_ temp;

  00091	48 8d 4d 20	 lea	 rcx, QWORD PTR temp$[rbp]
  00095	e8 00 00 00 00	 call	 ??0log_@@QEAA@XZ
  0009a	90		 npad	 1

; 202  : 	temp.severenty = severinty;

  0009b	48 63 85 c0 00
	00 00		 movsxd	 rax, DWORD PTR severinty$[rbp]
  000a2	48 89 45 20	 mov	 QWORD PTR temp$[rbp], rax

; 203  : 	temp.time = time(0);

  000a6	33 c9		 xor	 ecx, ecx
  000a8	e8 00 00 00 00	 call	 time
  000ad	48 89 45 50	 mov	 QWORD PTR temp$[rbp+48], rax

; 204  : 	temp.txt = logTxt;

  000b1	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR logTxt$[rbp]
  000b8	48 8d 4d 28	 lea	 rcx, QWORD PTR temp$[rbp+8]
  000bc	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 205  : 
; 206  : 	record(temp);

  000c1	48 8d 4d 20	 lea	 rcx, QWORD PTR temp$[rbp]
  000c5	e8 00 00 00 00	 call	 ?record@@YAXAEAUlog_@@@Z ; record

; 207  : 
; 208  : 	logs = lTemp;

  000ca	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000d1	48 83 c0 08	 add	 rax, 8
  000d5	48 8d 55 00	 lea	 rdx, QWORD PTR lTemp$[rbp]
  000d9	48 8b c8	 mov	 rcx, rax
  000dc	e8 00 00 00 00	 call	 ??4?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::list<log_,std::allocator<log_> >::operator=

; 209  : 
; 210  : 	lTemp.clear();

  000e1	48 8d 4d 00	 lea	 rcx, QWORD PTR lTemp$[rbp]
  000e5	e8 00 00 00 00	 call	 ?clear@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXXZ ; std::list<log_,std::allocator<log_> >::clear
  000ea	90		 npad	 1

; 211  : 
; 212  : 	return;

  000eb	48 8d 4d 20	 lea	 rcx, QWORD PTR temp$[rbp]
  000ef	e8 00 00 00 00	 call	 ??1log_@@QEAA@XZ
  000f4	90		 npad	 1
  000f5	48 8d 4d 00	 lea	 rcx, QWORD PTR lTemp$[rbp]
  000f9	e8 00 00 00 00	 call	 ??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ ; std::list<log_,std::allocator<log_> >::~list<log_,std::allocator<log_> >
  000fe	90		 npad	 1
  000ff	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR logTxt$[rbp]
  00106	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0010b	eb 0d		 jmp	 SHORT $LN1@urgLog

; 213  : 
; 214  : }

  0010d	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR logTxt$[rbp]
  00114	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00119	90		 npad	 1
$LN1@urgLog:
  0011a	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  00121	5d		 pop	 rbp
  00122	c3		 ret	 0
?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z ENDP ; Logger::urgLog
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
lTemp$ = 0
temp$ = 32
this$ = 176
logTxt$ = 184
severinty$ = 192
?dtor$0@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA PROC ; `Logger::urgLog'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR logTxt$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA ENDP ; `Logger::urgLog'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
lTemp$ = 0
temp$ = 32
this$ = 176
logTxt$ = 184
severinty$ = 192
?dtor$1@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA PROC ; `Logger::urgLog'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR lTemp$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ ; std::list<log_,std::allocator<log_> >::~list<log_,std::allocator<log_> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$1@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA ENDP ; `Logger::urgLog'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
lTemp$ = 0
temp$ = 32
this$ = 176
logTxt$ = 184
severinty$ = 192
?dtor$2@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA PROC ; `Logger::urgLog'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR temp$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1log_@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$2@?0??urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA ENDP ; `Logger::urgLog'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
_TEXT	SEGMENT
temp$ = 0
tv77 = 128
logTxt$ = 160
severenty$ = 168
?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z PROC ; Logger::exLog, COMDAT

; 217  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 218  : 	log_ temp;

  00022	48 8d 4d 00	 lea	 rcx, QWORD PTR temp$[rbp]
  00026	e8 00 00 00 00	 call	 ??0log_@@QEAA@XZ
  0002b	90		 npad	 1

; 219  : 
; 220  : 	temp.severenty = severenty;

  0002c	48 63 85 a8 00
	00 00		 movsxd	 rax, DWORD PTR severenty$[rbp]
  00033	48 89 45 00	 mov	 QWORD PTR temp$[rbp], rax

; 221  : 	temp.time = time(0);

  00037	33 c9		 xor	 ecx, ecx
  00039	e8 00 00 00 00	 call	 time
  0003e	48 89 45 30	 mov	 QWORD PTR temp$[rbp+48], rax

; 222  : 	temp.txt = logTxt;

  00042	48 8b 95 a0 00
	00 00		 mov	 rdx, QWORD PTR logTxt$[rbp]
  00049	48 8d 4d 08	 lea	 rcx, QWORD PTR temp$[rbp+8]
  0004d	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 223  : 	temp.isConsole = true;

  00052	c6 45 38 01	 mov	 BYTE PTR temp$[rbp+56], 1

; 224  : 
; 225  : 	inst->logs.push_back(temp);

  00056	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  0005d	48 83 c0 08	 add	 rax, 8
  00061	48 89 85 80 00
	00 00		 mov	 QWORD PTR tv77[rbp], rax
  00068	48 8d 55 00	 lea	 rdx, QWORD PTR temp$[rbp]
  0006c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR tv77[rbp]
  00073	e8 00 00 00 00	 call	 ?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z ; std::list<log_,std::allocator<log_> >::push_back
  00078	90		 npad	 1

; 226  : }

  00079	48 8d 4d 00	 lea	 rcx, QWORD PTR temp$[rbp]
  0007d	e8 00 00 00 00	 call	 ??1log_@@QEAA@XZ
  00082	90		 npad	 1
  00083	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR logTxt$[rbp]
  0008a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0008f	48 8d a5 90 00
	00 00		 lea	 rsp, QWORD PTR [rbp+144]
  00096	5d		 pop	 rbp
  00097	c3		 ret	 0
?exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z ENDP ; Logger::exLog
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
temp$ = 0
tv77 = 128
logTxt$ = 160
severenty$ = 168
?dtor$0@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA PROC ; `Logger::exLog'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR logTxt$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA ENDP ; `Logger::exLog'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
temp$ = 0
tv77 = 128
logTxt$ = 160
severenty$ = 168
?dtor$1@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA PROC ; `Logger::exLog'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR temp$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1log_@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$1@?0??exLog@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA ENDP ; `Logger::exLog'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ
_TEXT	SEGMENT
arguments$ = 0
ret$ = 8
$T1 = 120
$T2 = 160
tv94 = 168
tv76 = 168
arg$ = 192
?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ PROC ; Logger::logF, COMDAT

; 154  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	55		 push	 rbp
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 155  : 	va_list arguments;
; 156  : 	FString ret;

  0002d	48 8d 4d 08	 lea	 rcx, QWORD PTR ret$[rbp]
  00031	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00036	90		 npad	 1

; 157  : 
; 158  : 
; 159  : 	for (va_start(arguments, arg); arg != nullptr; arg = va_arg(arguments, FString*))

  00037	48 8d 85 c8 00
	00 00		 lea	 rax, QWORD PTR arg$[rbp+8]
  0003e	48 89 45 00	 mov	 QWORD PTR arguments$[rbp], rax
  00042	eb 4f		 jmp	 SHORT $LN4@logF
$LN2@logF:
  00044	33 c0		 xor	 eax, eax
  00046	85 c0		 test	 eax, eax
  00048	74 20		 je	 SHORT $LN6@logF
  0004a	48 8b 45 00	 mov	 rax, QWORD PTR arguments$[rbp]
  0004e	48 83 c0 08	 add	 rax, 8
  00052	48 89 45 00	 mov	 QWORD PTR arguments$[rbp], rax
  00056	48 8b 45 00	 mov	 rax, QWORD PTR arguments$[rbp]
  0005a	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0005e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00061	48 89 85 a8 00
	00 00		 mov	 QWORD PTR tv76[rbp], rax
  00068	eb 1b		 jmp	 SHORT $LN7@logF
$LN6@logF:
  0006a	48 8b 45 00	 mov	 rax, QWORD PTR arguments$[rbp]
  0006e	48 83 c0 08	 add	 rax, 8
  00072	48 89 45 00	 mov	 QWORD PTR arguments$[rbp], rax
  00076	48 8b 45 00	 mov	 rax, QWORD PTR arguments$[rbp]
  0007a	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0007e	48 89 85 a8 00
	00 00		 mov	 QWORD PTR tv76[rbp], rax
$LN7@logF:
  00085	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR tv76[rbp]
  0008c	48 89 85 c0 00
	00 00		 mov	 QWORD PTR arg$[rbp], rax
$LN4@logF:
  00093	48 83 bd c0 00
	00 00 00	 cmp	 QWORD PTR arg$[rbp], 0
  0009b	74 12		 je	 SHORT $LN3@logF

; 160  : 	{
; 161  : 		ret += *arg;

  0009d	48 8b 95 c0 00
	00 00		 mov	 rdx, QWORD PTR arg$[rbp]
  000a4	48 8d 4d 08	 lea	 rcx, QWORD PTR ret$[rbp]
  000a8	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 162  : 	}

  000ad	eb 95		 jmp	 SHORT $LN2@logF
$LN3@logF:

; 163  : 
; 164  : 	Logger::log(ret);

  000af	48 8d 45 78	 lea	 rax, QWORD PTR $T1[rbp]
  000b3	48 89 85 a0 00
	00 00		 mov	 QWORD PTR $T2[rbp], rax
  000ba	48 8d 55 08	 lea	 rdx, QWORD PTR ret$[rbp]
  000be	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR $T2[rbp]
  000c5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ca	48 89 85 a8 00
	00 00		 mov	 QWORD PTR tv94[rbp], rax
  000d1	ba 01 00 00 00	 mov	 edx, 1
  000d6	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR tv94[rbp]
  000dd	e8 00 00 00 00	 call	 ?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z ; Logger::log

; 165  : 	va_end(arguments);

  000e2	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR arguments$[rbp], 0

; 166  : }

  000ea	48 8d 4d 08	 lea	 rcx, QWORD PTR ret$[rbp]
  000ee	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000f3	48 8d a5 b0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+176]
  000fa	5d		 pop	 rbp
  000fb	c3		 ret	 0
?logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ ENDP ; Logger::logF
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
arguments$ = 0
ret$ = 8
$T1 = 120
$T2 = 160
tv94 = 168
tv76 = 168
arg$ = 192
?dtor$0@?0??logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ@4HA PROC ; `Logger::logF'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 08	 lea	 rcx, QWORD PTR ret$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??logF@Logger@@SAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ZZ@4HA ENDP ; `Logger::logF'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?logF@Logger@@SAXPEBDZZ
_TEXT	SEGMENT
arguments$ = 0
ret$ = 8
$T1 = 120
$T2 = 160
tv94 = 168
tv76 = 168
arg$ = 192
?logF@Logger@@SAXPEBDZZ PROC				; Logger::logF, COMDAT

; 139  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	55		 push	 rbp
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 140  : 	va_list arguments;
; 141  : 	string ret;

  0002d	48 8d 4d 08	 lea	 rcx, QWORD PTR ret$[rbp]
  00031	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00036	90		 npad	 1

; 142  : 	for (va_start(arguments, arg); arg != nullptr; arg = va_arg(arguments, const char*))

  00037	48 8d 85 c8 00
	00 00		 lea	 rax, QWORD PTR arg$[rbp+8]
  0003e	48 89 45 00	 mov	 QWORD PTR arguments$[rbp], rax
  00042	eb 4f		 jmp	 SHORT $LN4@logF
$LN2@logF:
  00044	33 c0		 xor	 eax, eax
  00046	85 c0		 test	 eax, eax
  00048	74 20		 je	 SHORT $LN6@logF
  0004a	48 8b 45 00	 mov	 rax, QWORD PTR arguments$[rbp]
  0004e	48 83 c0 08	 add	 rax, 8
  00052	48 89 45 00	 mov	 QWORD PTR arguments$[rbp], rax
  00056	48 8b 45 00	 mov	 rax, QWORD PTR arguments$[rbp]
  0005a	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0005e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00061	48 89 85 a8 00
	00 00		 mov	 QWORD PTR tv76[rbp], rax
  00068	eb 1b		 jmp	 SHORT $LN7@logF
$LN6@logF:
  0006a	48 8b 45 00	 mov	 rax, QWORD PTR arguments$[rbp]
  0006e	48 83 c0 08	 add	 rax, 8
  00072	48 89 45 00	 mov	 QWORD PTR arguments$[rbp], rax
  00076	48 8b 45 00	 mov	 rax, QWORD PTR arguments$[rbp]
  0007a	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0007e	48 89 85 a8 00
	00 00		 mov	 QWORD PTR tv76[rbp], rax
$LN7@logF:
  00085	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR tv76[rbp]
  0008c	48 89 85 c0 00
	00 00		 mov	 QWORD PTR arg$[rbp], rax
$LN4@logF:
  00093	48 83 bd c0 00
	00 00 00	 cmp	 QWORD PTR arg$[rbp], 0
  0009b	74 12		 je	 SHORT $LN3@logF

; 143  : 	{
; 144  : 		ret += arg;

  0009d	48 8b 95 c0 00
	00 00		 mov	 rdx, QWORD PTR arg$[rbp]
  000a4	48 8d 4d 08	 lea	 rcx, QWORD PTR ret$[rbp]
  000a8	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 145  : 	}

  000ad	eb 95		 jmp	 SHORT $LN2@logF
$LN3@logF:

; 146  : 
; 147  : 	Logger::log(ret);

  000af	48 8d 45 78	 lea	 rax, QWORD PTR $T1[rbp]
  000b3	48 89 85 a0 00
	00 00		 mov	 QWORD PTR $T2[rbp], rax
  000ba	48 8d 55 08	 lea	 rdx, QWORD PTR ret$[rbp]
  000be	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR $T2[rbp]
  000c5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ca	48 89 85 a8 00
	00 00		 mov	 QWORD PTR tv94[rbp], rax
  000d1	ba 01 00 00 00	 mov	 edx, 1
  000d6	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR tv94[rbp]
  000dd	e8 00 00 00 00	 call	 ?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z ; Logger::log

; 148  : 	va_end(arguments);

  000e2	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR arguments$[rbp], 0

; 149  : 
; 150  : 
; 151  : }

  000ea	48 8d 4d 08	 lea	 rcx, QWORD PTR ret$[rbp]
  000ee	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000f3	48 8d a5 b0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+176]
  000fa	5d		 pop	 rbp
  000fb	c3		 ret	 0
?logF@Logger@@SAXPEBDZZ ENDP				; Logger::logF
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
arguments$ = 0
ret$ = 8
$T1 = 120
$T2 = 160
tv94 = 168
tv76 = 168
arg$ = 192
?dtor$0@?0??logF@Logger@@SAXPEBDZZ@4HA PROC		; `Logger::logF'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 08	 lea	 rcx, QWORD PTR ret$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??logF@Logger@@SAXPEBDZZ@4HA ENDP		; `Logger::logF'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z
_TEXT	SEGMENT
temp$ = 0
tv82 = 128
logTxt$ = 160
severenty$ = 168
?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z PROC ; Logger::log, COMDAT

; 121  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 122  : 	if (((inst->severity) | (severenty)) != inst->severity)

  00022	48 63 85 a8 00
	00 00		 movsxd	 rax, DWORD PTR severenty$[rbp]
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 0b c8	 or	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  00040	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00043	74 0e		 je	 SHORT $LN2@log

; 123  : 	{
; 124  : 		return;

  00045	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR logTxt$[rbp]
  0004c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00051	eb 6d		 jmp	 SHORT $LN1@log
$LN2@log:

; 125  : 	}
; 126  : 
; 127  : 	log_ temp;

  00053	48 8d 4d 00	 lea	 rcx, QWORD PTR temp$[rbp]
  00057	e8 00 00 00 00	 call	 ??0log_@@QEAA@XZ
  0005c	90		 npad	 1

; 128  : 
; 129  : 	temp.severenty = severenty;

  0005d	48 63 85 a8 00
	00 00		 movsxd	 rax, DWORD PTR severenty$[rbp]
  00064	48 89 45 00	 mov	 QWORD PTR temp$[rbp], rax

; 130  : 	temp.time = time(0);

  00068	33 c9		 xor	 ecx, ecx
  0006a	e8 00 00 00 00	 call	 time
  0006f	48 89 45 30	 mov	 QWORD PTR temp$[rbp+48], rax

; 131  : 	temp.txt = logTxt;

  00073	48 8b 95 a0 00
	00 00		 mov	 rdx, QWORD PTR logTxt$[rbp]
  0007a	48 8d 4d 08	 lea	 rcx, QWORD PTR temp$[rbp+8]
  0007e	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 132  : 	temp.isConsole = true;

  00083	c6 45 38 01	 mov	 BYTE PTR temp$[rbp+56], 1

; 133  : 
; 134  : 	inst->logs.push_back(temp);

  00087	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  0008e	48 83 c0 08	 add	 rax, 8
  00092	48 89 85 80 00
	00 00		 mov	 QWORD PTR tv82[rbp], rax
  00099	48 8d 55 00	 lea	 rdx, QWORD PTR temp$[rbp]
  0009d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR tv82[rbp]
  000a4	e8 00 00 00 00	 call	 ?push_back@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAAXAEBUlog_@@@Z ; std::list<log_,std::allocator<log_> >::push_back
  000a9	90		 npad	 1

; 135  : 
; 136  : }

  000aa	48 8d 4d 00	 lea	 rcx, QWORD PTR temp$[rbp]
  000ae	e8 00 00 00 00	 call	 ??1log_@@QEAA@XZ
  000b3	90		 npad	 1
  000b4	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR logTxt$[rbp]
  000bb	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@log:
  000c0	48 8d a5 90 00
	00 00		 lea	 rsp, QWORD PTR [rbp+144]
  000c7	5d		 pop	 rbp
  000c8	c3		 ret	 0
?log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z ENDP ; Logger::log
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
temp$ = 0
tv82 = 128
logTxt$ = 160
severenty$ = 168
?dtor$0@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA PROC ; `Logger::log'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR logTxt$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA ENDP ; `Logger::log'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
temp$ = 0
tv82 = 128
logTxt$ = 160
severenty$ = 168
?dtor$1@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA PROC ; `Logger::log'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR temp$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1log_@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$1@?0??log@Logger@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z@4HA ENDP ; `Logger::log'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?Exit@Logger@@SAXXZ
_TEXT	SEGMENT
?Exit@Logger@@SAXXZ PROC				; Logger::Exit, COMDAT

; 37   : {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 38   : 	inst->isWork = false;

  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  0001e	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 39   : }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?Exit@Logger@@SAXXZ ENDP				; Logger::Exit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?Initialize@Logger@@SAX_K@Z
_TEXT	SEGMENT
th$ = 0
$T1 = 80
$T2 = 120
tv89 = 128
tv86 = 136
s$ = 160
?Initialize@Logger@@SAX_K@Z PROC			; Logger::Initialize, COMDAT

; 23   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 24   : 	inst->severity = (s);

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  00025	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR s$[rbp]
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 25   : 	inst->isWork = true;

  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  00036	c6 40 20 01	 mov	 BYTE PTR [rax+32], 1

; 26   : 	std::thread th(logging, inst); th.detach();

  0003a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?inst@Logger@@0PEAV1@EA ; Logger::inst
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?logging@@YAXPEAVLogger@@@Z ; logging
  00048	48 8d 4d 00	 lea	 rcx, QWORD PTR th$[rbp]
  0004c	e8 00 00 00 00	 call	 ??$?0A6AXPEAVLogger@@@ZAEAPEAV0@$0A@@thread@std@@QEAA@A6AXPEAVLogger@@@ZAEAPEAV2@@Z ; std::thread::thread<void (__cdecl&)(Logger *),Logger * &,0>
  00051	90		 npad	 1
  00052	48 8d 4d 00	 lea	 rcx, QWORD PTR th$[rbp]
  00056	e8 00 00 00 00	 call	 ?detach@thread@std@@QEAAXXZ ; std::thread::detach

; 27   : 
; 28   : 	inst->urgLog("The system started successfully", LOGGER_ENUM::LOGGER_INFO);

  0005b	48 8d 45 50	 lea	 rax, QWORD PTR $T1[rbp]
  0005f	48 89 45 78	 mov	 QWORD PTR $T2[rbp], rax
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@CAEGLMPG@The?5system?5started?5successfully@
  0006a	48 8b 4d 78	 mov	 rcx, QWORD PTR $T2[rbp]
  0006e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00073	48 89 85 80 00
	00 00		 mov	 QWORD PTR tv89[rbp], rax
  0007a	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR tv89[rbp]
  00081	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv86[rbp], rax
  00088	41 b8 01 00 00
	00		 mov	 r8d, 1
  0008e	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR tv86[rbp]
  00095	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?inst@Logger@@0PEAV1@EA ; Logger::inst
  0009c	e8 00 00 00 00	 call	 ?urgLog@Logger@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4LOGGER_ENUM@@@Z ; Logger::urgLog
  000a1	90		 npad	 1

; 29   : 
; 30   : 	//inst << FString("s")
; 31   : 
; 32   : 
; 33   : }

  000a2	48 8d 4d 00	 lea	 rcx, QWORD PTR th$[rbp]
  000a6	e8 00 00 00 00	 call	 ??1thread@std@@QEAA@XZ	; std::thread::~thread
  000ab	48 8d a5 90 00
	00 00		 lea	 rsp, QWORD PTR [rbp+144]
  000b2	5d		 pop	 rbp
  000b3	c3		 ret	 0
?Initialize@Logger@@SAX_K@Z ENDP			; Logger::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
th$ = 0
$T1 = 80
$T2 = 120
tv89 = 128
tv86 = 136
s$ = 160
?dtor$0@?0??Initialize@Logger@@SAX_K@Z@4HA PROC		; `Logger::Initialize'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR th$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1thread@std@@QEAA@XZ	; std::thread::~thread
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??Initialize@Logger@@SAX_K@Z@4HA ENDP		; `Logger::Initialize'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.hpp
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.hpp
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ??0Logger@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0Logger@@QEAA@XZ PROC					; Logger::Logger, COMDAT

; 14   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.hpp

; 74   : 	size_t severity = 0;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp

; 14   : {

  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 83 c0 08	 add	 rax, 8
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ??0?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA@XZ ; std::list<log_,std::allocator<log_> >::list<log_,std::allocator<log_> >
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.hpp

; 76   : 	bool isWork = true;

  00036	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003a	c6 40 20 01	 mov	 BYTE PTR [rax+32], 1
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp

; 15   : 	inst = this;

  0003e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00042	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?inst@Logger@@0PEAV1@EA, rax ; Logger::inst

; 16   : }

  00049	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00051	5d		 pop	 rbp
  00052	c3		 ret	 0
??0Logger@@QEAA@XZ ENDP					; Logger::Logger
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?record@@YAXAEAUlog_@@@Z
_TEXT	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?record@@YAXAEAUlog_@@@Z PROC				; record, COMDAT

; 42   : {

$LN30:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec d0 05
	00 00		 sub	 rsp, 1488		; 000005d0H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 43   : 	FString folder = "logs/";

  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MIDDFADP@logs?1@
  00025	48 8d 4d 00	 lea	 rcx, QWORD PTR folder$[rbp]
  00029	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002e	90		 npad	 1

; 44   : 
; 45   : 	tm ltm;
; 46   : 	localtime_s(&ltm, &obj.time);

  0002f	48 8b 85 b0 05
	00 00		 mov	 rax, QWORD PTR obj$[rbp]
  00036	48 83 c0 30	 add	 rax, 48			; 00000030H
  0003a	48 8b d0	 mov	 rdx, rax
  0003d	48 8d 4d 28	 lea	 rcx, QWORD PTR ltm$[rbp]
  00041	e8 00 00 00 00	 call	 localtime_s

; 47   : 
; 48   : 	
; 49   : 
; 50   : 	std::ofstream fout(folder + std::to_string(ltm.tm_year - 100 + 2000) + "-" + std::to_string(ltm.tm_mday) + "-" + std::to_string(ltm.tm_mon + 1) + ".log", std::ios::app);

  00046	8b 45 38	 mov	 eax, DWORD PTR ltm$[rbp+16]
  00049	ff c0		 inc	 eax
  0004b	8b d0		 mov	 edx, eax
  0004d	48 8d 8d 48 02
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  00054	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
  00059	48 89 85 f0 04
	00 00		 mov	 QWORD PTR tv65[rbp], rax
  00060	48 8b 85 f0 04
	00 00		 mov	 rax, QWORD PTR tv65[rbp]
  00067	48 89 85 f8 04
	00 00		 mov	 QWORD PTR tv312[rbp], rax
  0006e	48 8b 85 f8 04
	00 00		 mov	 rax, QWORD PTR tv312[rbp]
  00075	48 89 85 00 05
	00 00		 mov	 QWORD PTR tv163[rbp], rax
  0007c	8b 55 34	 mov	 edx, DWORD PTR ltm$[rbp+12]
  0007f	48 8d 8d 70 02
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  00086	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
  0008b	48 89 85 08 05
	00 00		 mov	 QWORD PTR tv347[rbp], rax
  00092	48 8b 85 08 05
	00 00		 mov	 rax, QWORD PTR tv347[rbp]
  00099	48 89 85 10 05
	00 00		 mov	 QWORD PTR tv314[rbp], rax
  000a0	48 8b 85 10 05
	00 00		 mov	 rax, QWORD PTR tv314[rbp]
  000a7	48 89 85 18 05
	00 00		 mov	 QWORD PTR tv151[rbp], rax
  000ae	8b 45 3c	 mov	 eax, DWORD PTR ltm$[rbp+20]
  000b1	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  000b6	8b d0		 mov	 edx, eax
  000b8	48 8d 8d 98 02
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  000bf	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
  000c4	48 89 85 20 05
	00 00		 mov	 QWORD PTR tv348[rbp], rax
  000cb	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR tv348[rbp]
  000d2	48 89 85 28 05
	00 00		 mov	 QWORD PTR tv316[rbp], rax
  000d9	4c 8b 85 28 05
	00 00		 mov	 r8, QWORD PTR tv316[rbp]
  000e0	48 8d 55 00	 lea	 rdx, QWORD PTR folder$[rbp]
  000e4	48 8d 8d c0 02
	00 00		 lea	 rcx, QWORD PTR $T4[rbp]
  000eb	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000f0	48 89 85 30 05
	00 00		 mov	 QWORD PTR tv349[rbp], rax
  000f7	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR tv349[rbp]
  000fe	48 89 85 38 05
	00 00		 mov	 QWORD PTR tv318[rbp], rax
  00105	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01JOAMLHOP@?9@
  0010c	48 8b 95 38 05
	00 00		 mov	 rdx, QWORD PTR tv318[rbp]
  00113	48 8d 8d e8 02
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  0011a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0011f	48 89 85 40 05
	00 00		 mov	 QWORD PTR tv350[rbp], rax
  00126	48 8b 85 40 05
	00 00		 mov	 rax, QWORD PTR tv350[rbp]
  0012d	48 89 85 48 05
	00 00		 mov	 QWORD PTR tv320[rbp], rax
  00134	48 8b 85 48 05
	00 00		 mov	 rax, QWORD PTR tv320[rbp]
  0013b	48 89 85 50 05
	00 00		 mov	 QWORD PTR tv149[rbp], rax
  00142	4c 8b 85 18 05
	00 00		 mov	 r8, QWORD PTR tv151[rbp]
  00149	48 8b 95 50 05
	00 00		 mov	 rdx, QWORD PTR tv149[rbp]
  00150	48 8d 8d 10 03
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  00157	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0015c	48 89 85 58 05
	00 00		 mov	 QWORD PTR tv351[rbp], rax
  00163	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR tv351[rbp]
  0016a	48 89 85 60 05
	00 00		 mov	 QWORD PTR tv322[rbp], rax
  00171	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01JOAMLHOP@?9@
  00178	48 8b 95 60 05
	00 00		 mov	 rdx, QWORD PTR tv322[rbp]
  0017f	48 8d 8d 38 03
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  00186	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0018b	48 89 85 68 05
	00 00		 mov	 QWORD PTR tv352[rbp], rax
  00192	48 8b 85 68 05
	00 00		 mov	 rax, QWORD PTR tv352[rbp]
  00199	48 89 85 70 05
	00 00		 mov	 QWORD PTR tv324[rbp], rax
  001a0	48 8b 85 70 05
	00 00		 mov	 rax, QWORD PTR tv324[rbp]
  001a7	48 89 85 78 05
	00 00		 mov	 QWORD PTR tv161[rbp], rax
  001ae	4c 8b 85 00 05
	00 00		 mov	 r8, QWORD PTR tv163[rbp]
  001b5	48 8b 95 78 05
	00 00		 mov	 rdx, QWORD PTR tv161[rbp]
  001bc	48 8d 8d 60 03
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  001c3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001c8	48 89 85 80 05
	00 00		 mov	 QWORD PTR tv353[rbp], rax
  001cf	48 8b 85 80 05
	00 00		 mov	 rax, QWORD PTR tv353[rbp]
  001d6	48 89 85 88 05
	00 00		 mov	 QWORD PTR tv326[rbp], rax
  001dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04FPOLKAEB@?4log@
  001e4	48 8b 95 88 05
	00 00		 mov	 rdx, QWORD PTR tv326[rbp]
  001eb	48 8d 8d 88 03
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  001f2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001f7	48 89 85 90 05
	00 00		 mov	 QWORD PTR tv354[rbp], rax
  001fe	48 8b 85 90 05
	00 00		 mov	 rax, QWORD PTR tv354[rbp]
  00205	48 89 85 98 05
	00 00		 mov	 QWORD PTR tv328[rbp], rax
  0020c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00214	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  0021a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00220	48 8b 95 98 05
	00 00		 mov	 rdx, QWORD PTR tv328[rbp]
  00227	48 8d 4d 50	 lea	 rcx, QWORD PTR fout$[rbp]
  0022b	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
  00230	90		 npad	 1
  00231	48 8d 8d 88 03
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00238	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0023d	90		 npad	 1
  0023e	48 8d 8d 60 03
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  00245	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0024a	90		 npad	 1
  0024b	48 8d 8d 38 03
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  00252	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00257	90		 npad	 1
  00258	48 8d 8d 10 03
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  0025f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00264	90		 npad	 1
  00265	48 8d 8d e8 02
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  0026c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00271	90		 npad	 1
  00272	48 8d 8d c0 02
	00 00		 lea	 rcx, QWORD PTR $T4[rbp]
  00279	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0027e	90		 npad	 1
  0027f	48 8d 8d 98 02
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  00286	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0028b	90		 npad	 1
  0028c	48 8d 8d 70 02
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  00293	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00298	90		 npad	 1
  00299	48 8d 8d 48 02
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  002a0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 51   : 
; 52   : 	FString text = "[" + std::to_string(ltm.tm_hour) + ":" + std::to_string(ltm.tm_min) + ":" + std::to_string(ltm.tm_sec) + "] ";

  002a5	8b 55 28	 mov	 edx, DWORD PTR ltm$[rbp]
  002a8	48 8d 8d b0 03
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  002af	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
  002b4	48 89 85 f0 04
	00 00		 mov	 QWORD PTR tv72[rbp], rax
  002bb	48 8b 85 f0 04
	00 00		 mov	 rax, QWORD PTR tv72[rbp]
  002c2	48 89 85 f8 04
	00 00		 mov	 QWORD PTR tv331[rbp], rax
  002c9	48 8b 85 f8 04
	00 00		 mov	 rax, QWORD PTR tv331[rbp]
  002d0	48 89 85 00 05
	00 00		 mov	 QWORD PTR tv256[rbp], rax
  002d7	8b 55 2c	 mov	 edx, DWORD PTR ltm$[rbp+4]
  002da	48 8d 8d d8 03
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  002e1	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
  002e6	48 89 85 08 05
	00 00		 mov	 QWORD PTR tv355[rbp], rax
  002ed	48 8b 85 08 05
	00 00		 mov	 rax, QWORD PTR tv355[rbp]
  002f4	48 89 85 10 05
	00 00		 mov	 QWORD PTR tv333[rbp], rax
  002fb	48 8b 85 10 05
	00 00		 mov	 rax, QWORD PTR tv333[rbp]
  00302	48 89 85 18 05
	00 00		 mov	 QWORD PTR tv212[rbp], rax
  00309	8b 55 30	 mov	 edx, DWORD PTR ltm$[rbp+8]
  0030c	48 8d 8d 00 04
	00 00		 lea	 rcx, QWORD PTR $T12[rbp]
  00313	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
  00318	48 89 85 20 05
	00 00		 mov	 QWORD PTR tv356[rbp], rax
  0031f	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR tv356[rbp]
  00326	48 89 85 28 05
	00 00		 mov	 QWORD PTR tv335[rbp], rax
  0032d	4c 8b 85 28 05
	00 00		 mov	 r8, QWORD PTR tv335[rbp]
  00334	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01OHGJGJJP@?$FL@
  0033b	48 8d 8d 28 04
	00 00		 lea	 rcx, QWORD PTR $T13[rbp]
  00342	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00347	48 89 85 30 05
	00 00		 mov	 QWORD PTR tv357[rbp], rax
  0034e	48 8b 85 30 05
	00 00		 mov	 rax, QWORD PTR tv357[rbp]
  00355	48 89 85 38 05
	00 00		 mov	 QWORD PTR tv337[rbp], rax
  0035c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01JLIPDDHJ@?3@
  00363	48 8b 95 38 05
	00 00		 mov	 rdx, QWORD PTR tv337[rbp]
  0036a	48 8d 8d 50 04
	00 00		 lea	 rcx, QWORD PTR $T14[rbp]
  00371	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00376	48 89 85 40 05
	00 00		 mov	 QWORD PTR tv358[rbp], rax
  0037d	48 8b 85 40 05
	00 00		 mov	 rax, QWORD PTR tv358[rbp]
  00384	48 89 85 48 05
	00 00		 mov	 QWORD PTR tv339[rbp], rax
  0038b	48 8b 85 48 05
	00 00		 mov	 rax, QWORD PTR tv339[rbp]
  00392	48 89 85 50 05
	00 00		 mov	 QWORD PTR tv210[rbp], rax
  00399	4c 8b 85 18 05
	00 00		 mov	 r8, QWORD PTR tv212[rbp]
  003a0	48 8b 95 50 05
	00 00		 mov	 rdx, QWORD PTR tv210[rbp]
  003a7	48 8d 8d 78 04
	00 00		 lea	 rcx, QWORD PTR $T15[rbp]
  003ae	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  003b3	48 89 85 58 05
	00 00		 mov	 QWORD PTR tv359[rbp], rax
  003ba	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR tv359[rbp]
  003c1	48 89 85 60 05
	00 00		 mov	 QWORD PTR tv341[rbp], rax
  003c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01JLIPDDHJ@?3@
  003cf	48 8b 95 60 05
	00 00		 mov	 rdx, QWORD PTR tv341[rbp]
  003d6	48 8d 8d a0 04
	00 00		 lea	 rcx, QWORD PTR $T16[rbp]
  003dd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  003e2	48 89 85 68 05
	00 00		 mov	 QWORD PTR tv360[rbp], rax
  003e9	48 8b 85 68 05
	00 00		 mov	 rax, QWORD PTR tv360[rbp]
  003f0	48 89 85 70 05
	00 00		 mov	 QWORD PTR tv343[rbp], rax
  003f7	48 8b 85 70 05
	00 00		 mov	 rax, QWORD PTR tv343[rbp]
  003fe	48 89 85 78 05
	00 00		 mov	 QWORD PTR tv222[rbp], rax
  00405	4c 8b 85 00 05
	00 00		 mov	 r8, QWORD PTR tv256[rbp]
  0040c	48 8b 95 78 05
	00 00		 mov	 rdx, QWORD PTR tv222[rbp]
  00413	48 8d 8d c8 04
	00 00		 lea	 rcx, QWORD PTR $T17[rbp]
  0041a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0041f	48 89 85 80 05
	00 00		 mov	 QWORD PTR tv361[rbp], rax
  00426	48 8b 85 80 05
	00 00		 mov	 rax, QWORD PTR tv361[rbp]
  0042d	48 89 85 88 05
	00 00		 mov	 QWORD PTR tv345[rbp], rax
  00434	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02PBFOLPKM@?$FN?5@
  0043b	48 8b 95 88 05
	00 00		 mov	 rdx, QWORD PTR tv345[rbp]
  00442	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR text$[rbp]
  00449	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0044e	90		 npad	 1
  0044f	48 8d 8d c8 04
	00 00		 lea	 rcx, QWORD PTR $T17[rbp]
  00456	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0045b	90		 npad	 1
  0045c	48 8d 8d a0 04
	00 00		 lea	 rcx, QWORD PTR $T16[rbp]
  00463	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00468	90		 npad	 1
  00469	48 8d 8d 78 04
	00 00		 lea	 rcx, QWORD PTR $T15[rbp]
  00470	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00475	90		 npad	 1
  00476	48 8d 8d 50 04
	00 00		 lea	 rcx, QWORD PTR $T14[rbp]
  0047d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00482	90		 npad	 1
  00483	48 8d 8d 28 04
	00 00		 lea	 rcx, QWORD PTR $T13[rbp]
  0048a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0048f	90		 npad	 1
  00490	48 8d 8d 00 04
	00 00		 lea	 rcx, QWORD PTR $T12[rbp]
  00497	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0049c	90		 npad	 1
  0049d	48 8d 8d d8 03
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  004a4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004a9	90		 npad	 1
  004aa	48 8d 8d b0 03
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  004b1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 53   : 
; 54   : 	//fout << "[" + std::to_string(ltm.tm_hour) + ":" + std::to_string(ltm.tm_min) + ":" + std::to_string(ltm.tm_sec) + "] ";
; 55   : 
; 56   : 
; 57   : 	//fout << text;
; 58   : 
; 59   : 
; 60   : 	switch (obj.severenty)

  004b6	48 8b 85 b0 05
	00 00		 mov	 rax, QWORD PTR obj$[rbp]
  004bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004c0	48 89 85 f0 04
	00 00		 mov	 QWORD PTR tv263[rbp], rax
  004c7	48 83 bd f0 04
	00 00 01	 cmp	 QWORD PTR tv263[rbp], 1
  004cf	74 40		 je	 SHORT $LN6@record
  004d1	48 83 bd f0 04
	00 00 02	 cmp	 QWORD PTR tv263[rbp], 2
  004d9	74 21		 je	 SHORT $LN5@record
  004db	48 83 bd f0 04
	00 00 04	 cmp	 QWORD PTR tv263[rbp], 4
  004e3	74 02		 je	 SHORT $LN4@record
  004e5	eb 3f		 jmp	 SHORT $LN7@record
$LN4@record:

; 61   : 	{
; 62   : 	case LOGGER_ERROR:
; 63   : 		//fout << "ERROR ";
; 64   : 		text += "ERROR ";

  004e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06EOPONJBP@ERROR?5@
  004ee	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR text$[rbp]
  004f5	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 65   : 		break;

  004fa	eb 3d		 jmp	 SHORT $LN2@record
$LN5@record:

; 66   : 	case LOGGER_WARNING:
; 67   : 		//fout << "WARNIMG";
; 68   : 		text += "WARNIMG ";

  004fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08LHCGJDCA@WARNIMG?5@
  00503	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR text$[rbp]
  0050a	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 69   : 		break;

  0050f	eb 28		 jmp	 SHORT $LN2@record
$LN6@record:

; 70   : 	case LOGGER_INFO:
; 71   : 		//fout << "INFO ";
; 72   : 		text += "INFO ";

  00511	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05NBJEAKGO@INFO?5@
  00518	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR text$[rbp]
  0051f	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 73   : 		break;

  00524	eb 13		 jmp	 SHORT $LN2@record
$LN7@record:

; 74   : 	default:
; 75   : 		//fout << "NULL ";
; 76   : 		text += "NULL ";

  00526	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LGFKMCHI@NULL?5@
  0052d	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR text$[rbp]
  00534	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN2@record:

; 77   : 		break;
; 78   : 	}
; 79   : 
; 80   : 	fout << text << " - " << obj.txt << "\n";

  00539	48 8d 95 60 01
	00 00		 lea	 rdx, QWORD PTR text$[rbp]
  00540	48 8d 4d 50	 lea	 rcx, QWORD PTR fout$[rbp]
  00544	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  00549	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NLJIHOMM@?5?9?5@
  00550	48 8b c8	 mov	 rcx, rax
  00553	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00558	48 8b 8d b0 05
	00 00		 mov	 rcx, QWORD PTR obj$[rbp]
  0055f	48 83 c1 08	 add	 rcx, 8
  00563	48 8b d1	 mov	 rdx, rcx
  00566	48 8b c8	 mov	 rcx, rax
  00569	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  0056e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6@
  00575	48 8b c8	 mov	 rcx, rax
  00578	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 81   : 
; 82   : 	if (obj.isConsole)

  0057d	48 8b 85 b0 05
	00 00		 mov	 rax, QWORD PTR obj$[rbp]
  00584	0f b6 40 38	 movzx	 eax, BYTE PTR [rax+56]
  00588	85 c0		 test	 eax, eax
  0058a	74 57		 je	 SHORT $LN8@record

; 83   : 	{
; 84   : 		/*CommandConsole::Print(text.c_str());
; 85   : 		CommandConsole::Print(" - ");
; 86   : 		CommandConsole::Print(obj.txt.c_str());
; 87   : 		CommandConsole::Print("\n");*/
; 88   : 
; 89   : 		PrintLine(text.c_str(), " - ", obj.txt.c_str(), "\n");

  0058c	48 8b 85 b0 05
	00 00		 mov	 rax, QWORD PTR obj$[rbp]
  00593	48 83 c0 08	 add	 rax, 8
  00597	48 8b c8	 mov	 rcx, rax
  0059a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0059f	48 89 85 f0 04
	00 00		 mov	 QWORD PTR tv307[rbp], rax
  005a6	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR text$[rbp]
  005ad	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  005b2	48 89 85 f8 04
	00 00		 mov	 QWORD PTR tv305[rbp], rax
  005b9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  005c2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01EEMJAFIK@?6@
  005c9	4c 8b 85 f0 04
	00 00		 mov	 r8, QWORD PTR tv307[rbp]
  005d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NLJIHOMM@?5?9?5@
  005d7	48 8b 8d f8 04
	00 00		 mov	 rcx, QWORD PTR tv305[rbp]
  005de	e8 00 00 00 00	 call	 ?Prints@CommandConsole@@SAXPEBDZZ ; CommandConsole::Prints
$LN8@record:

; 90   : 	}
; 91   : 
; 92   : 	fout.close();

  005e3	48 8d 4d 50	 lea	 rcx, QWORD PTR fout$[rbp]
  005e7	e8 00 00 00 00	 call	 ?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close
  005ec	90		 npad	 1

; 93   : 
; 94   : }

  005ed	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR text$[rbp]
  005f4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  005f9	90		 npad	 1
  005fa	48 8d 4d 50	 lea	 rcx, QWORD PTR fout$[rbp]
  005fe	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00603	90		 npad	 1
  00604	48 8d 4d 00	 lea	 rcx, QWORD PTR folder$[rbp]
  00608	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0060d	48 8d a5 a0 05
	00 00		 lea	 rsp, QWORD PTR [rbp+1440]
  00614	5d		 pop	 rbp
  00615	c3		 ret	 0
?record@@YAXAEAUlog_@@@Z ENDP				; record
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$0@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR folder$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$1@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 48 02
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$1@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$2@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 70 02
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$2@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$3@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$3
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 98 02
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$3@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$4@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$4
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d c0 02
	00 00		 lea	 rcx, QWORD PTR $T4[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$4@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$5@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$5
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d e8 02
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$5@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$6@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$6
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 10 03
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$6@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$7@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$7
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 38 03
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$7@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$8@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$8
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 60 03
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$8@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$9@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$9
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 88 03
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$9@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$10
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 4d 50	 lea	 rcx, QWORD PTR fout$[rbp]
  0000e	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$10@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$11@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$11
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d b0 03
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$11@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$12@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$12
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d d8 03
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$12@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$13@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$13
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 00 04
	00 00		 lea	 rcx, QWORD PTR $T12[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$13@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$14@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$14
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 28 04
	00 00		 lea	 rcx, QWORD PTR $T13[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$14@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$15@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$15
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 50 04
	00 00		 lea	 rcx, QWORD PTR $T14[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$15@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$16@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$16
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 78 04
	00 00		 lea	 rcx, QWORD PTR $T15[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$16@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$17@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$17
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d a0 04
	00 00		 lea	 rcx, QWORD PTR $T16[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$17@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$18@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$18
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d c8 04
	00 00		 lea	 rcx, QWORD PTR $T17[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$18@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
folder$ = 0
ltm$ = 40
fout$ = 80
text$ = 352
$T1 = 584
$T2 = 624
$T3 = 664
$T4 = 704
$T5 = 744
$T6 = 784
$T7 = 824
$T8 = 864
$T9 = 904
$T10 = 944
$T11 = 984
$T12 = 1024
$T13 = 1064
$T14 = 1104
$T15 = 1144
$T16 = 1184
$T17 = 1224
tv307 = 1264
tv263 = 1264
tv72 = 1264
tv65 = 1264
tv331 = 1272
tv312 = 1272
tv305 = 1272
tv256 = 1280
tv163 = 1280
tv355 = 1288
tv347 = 1288
tv333 = 1296
tv314 = 1296
tv212 = 1304
tv151 = 1304
tv356 = 1312
tv348 = 1312
tv335 = 1320
tv316 = 1320
tv357 = 1328
tv349 = 1328
tv337 = 1336
tv318 = 1336
tv358 = 1344
tv350 = 1344
tv339 = 1352
tv320 = 1352
tv210 = 1360
tv149 = 1360
tv359 = 1368
tv351 = 1368
tv341 = 1376
tv322 = 1376
tv360 = 1384
tv352 = 1384
tv343 = 1392
tv324 = 1392
tv222 = 1400
tv161 = 1400
tv361 = 1408
tv353 = 1408
tv345 = 1416
tv326 = 1416
tv354 = 1424
tv328 = 1432
obj$ = 1456
?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA PROC		; `record'::`1'::dtor$19
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  0000a	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR text$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$19@?0??record@@YAXAEAUlog_@@@Z@4HA ENDP		; `record'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?logging@@YAXPEAVLogger@@@Z
_TEXT	SEGMENT
it$1 = 0
$T2 = 88
$T3 = 96
$T4 = 120
$T5 = 144
$T6 = 152
$T7 = 176
$T8 = 184
tv138 = 192
tv93 = 192
tv77 = 192
tv166 = 200
tv163 = 200
obj$ = 224
?logging@@YAXPEAVLogger@@@Z PROC			; logging, COMDAT

; 98   : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@logging:

; 99   : 	while (obj->isWork)

  0001e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR obj$[rbp]
  00025	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 40 01 00
	00		 je	 $LN3@logging
$LN4@logging:

; 100  : 	{
; 101  : 		while (!obj->logs.empty())

  00031	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR obj$[rbp]
  00038	48 83 c0 08	 add	 rax, 8
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 ?empty@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEBA_NXZ ; std::list<log_,std::allocator<log_> >::empty
  00044	0f b6 c0	 movzx	 eax, al
  00047	85 c0		 test	 eax, eax
  00049	0f 85 f8 00 00
	00		 jne	 $LN5@logging

; 102  : 		{
; 103  : 			auto it = obj->logs.begin();

  0004f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR obj$[rbp]
  00056	48 83 c0 08	 add	 rax, 8
  0005a	48 89 85 c0 00
	00 00		 mov	 QWORD PTR tv77[rbp], rax
  00061	48 8d 55 00	 lea	 rdx, QWORD PTR it$1[rbp]
  00065	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv77[rbp]
  0006c	e8 00 00 00 00	 call	 ?begin@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::begin
  00071	90		 npad	 1

; 104  : 
; 105  : 			if (it == obj->logs.end())

  00072	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR obj$[rbp]
  00079	48 83 c0 08	 add	 rax, 8
  0007d	48 89 85 c0 00
	00 00		 mov	 QWORD PTR tv93[rbp], rax
  00084	48 8d 55 60	 lea	 rdx, QWORD PTR $T3[rbp]
  00088	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv93[rbp]
  0008f	e8 00 00 00 00	 call	 ?end@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@XZ ; std::list<log_,std::allocator<log_> >::end
  00094	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv163[rbp], rax
  0009b	48 8b 95 c8 00
	00 00		 mov	 rdx, QWORD PTR tv163[rbp]
  000a2	48 8d 4d 00	 lea	 rcx, QWORD PTR it$1[rbp]
  000a6	e8 00 00 00 00	 call	 ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator==
  000ab	88 45 58	 mov	 BYTE PTR $T2[rbp], al
  000ae	48 8d 4d 60	 lea	 rcx, QWORD PTR $T3[rbp]
  000b2	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
  000b7	0f b6 45 58	 movzx	 eax, BYTE PTR $T2[rbp]
  000bb	85 c0		 test	 eax, eax
  000bd	74 0e		 je	 SHORT $LN6@logging

; 106  : 				continue;

  000bf	48 8d 4d 00	 lea	 rcx, QWORD PTR it$1[rbp]
  000c3	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
  000c8	e9 64 ff ff ff	 jmp	 $LN4@logging
$LN6@logging:

; 107  : 
; 108  : 			record(*it);

  000cd	48 8d 4d 00	 lea	 rcx, QWORD PTR it$1[rbp]
  000d1	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEBAAEAUlog_@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<log_> > >::operator*
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 ?record@@YAXAEAUlog_@@@Z ; record

; 109  : 
; 110  : 			//std::cout << it->txt;
; 111  : 			obj->logs.erase(it);

  000de	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR obj$[rbp]
  000e5	48 83 c0 08	 add	 rax, 8
  000e9	48 89 85 c0 00
	00 00		 mov	 QWORD PTR tv138[rbp], rax
  000f0	48 8d 45 78	 lea	 rax, QWORD PTR $T4[rbp]
  000f4	48 89 85 90 00
	00 00		 mov	 QWORD PTR $T5[rbp], rax
  000fb	48 8d 55 00	 lea	 rdx, QWORD PTR it$1[rbp]
  000ff	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR $T5[rbp]
  00106	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@AEBV01@@Z
  0010b	48 89 85 c8 00
	00 00		 mov	 QWORD PTR tv166[rbp], rax
  00112	4c 8b 85 c8 00
	00 00		 mov	 r8, QWORD PTR tv166[rbp]
  00119	48 8d 95 98 00
	00 00		 lea	 rdx, QWORD PTR $T6[rbp]
  00120	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv138[rbp]
  00127	e8 00 00 00 00	 call	 ?erase@?$list@Ulog_@@V?$allocator@Ulog_@@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@2@@Z ; std::list<log_,std::allocator<log_> >::erase
  0012c	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  00133	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
  00138	90		 npad	 1

; 112  : 		}

  00139	48 8d 4d 00	 lea	 rcx, QWORD PTR it$1[rbp]
  0013d	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
  00142	e9 ea fe ff ff	 jmp	 $LN4@logging
$LN5@logging:

; 113  : 
; 114  : 		std::this_thread::sleep_for(std::chrono::microseconds(1000));

  00147	c7 85 b8 00 00
	00 e8 03 00 00	 mov	 DWORD PTR $T8[rbp], 1000 ; 000003e8H
  00151	48 8d 95 b8 00
	00 00		 lea	 rdx, QWORD PTR $T8[rbp]
  00158	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  0015f	e8 00 00 00 00	 call	 ??$?0H$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEBH@Z ; std::chrono::duration<__int64,std::ratio<1,1000000> >::duration<__int64,std::ratio<1,1000000> ><int,0>
  00164	48 8b c8	 mov	 rcx, rax
  00167	e8 00 00 00 00	 call	 ??$sleep_for@_JU?$ratio@$00$0PECEA@@std@@@this_thread@std@@YAXAEBV?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000000> >

; 115  : 	}

  0016c	e9 ad fe ff ff	 jmp	 $LN2@logging
$LN3@logging:

; 116  : 
; 117  : 
; 118  : }

  00171	48 8d a5 d0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+208]
  00178	5d		 pop	 rbp
  00179	c3		 ret	 0
?logging@@YAXPEAVLogger@@@Z ENDP			; logging
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
it$1 = 0
$T2 = 88
$T3 = 96
$T4 = 120
$T5 = 144
$T6 = 152
$T7 = 176
$T8 = 184
tv138 = 192
tv93 = 192
tv77 = 192
tv166 = 200
tv163 = 200
obj$ = 224
?dtor$0@?0??logging@@YAXPEAVLogger@@@Z@4HA PROC		; `logging'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR it$1[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@Ulog_@@@std@@@std@@@std@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??logging@@YAXPEAVLogger@@@Z@4HA ENDP		; `logging'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Glog_@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Glog_@@QEAAPEAXI@Z PROC				; log_::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1log_@@QEAA@XZ
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Glog_@@QEAAPEAXI@Z ENDP				; log_::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4log_@@QEAAAEAU0@AEBU0@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??4log_@@QEAAAEAU0@AEBU0@@Z PROC			; log_::operator=, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00018	48 8b 4d 58	 mov	 rcx, QWORD PTR __that$[rbp]
  0001c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00022	48 8b 45 58	 mov	 rax, QWORD PTR __that$[rbp]
  00026	48 83 c0 08	 add	 rax, 8
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	48 83 c1 08	 add	 rcx, 8
  00032	48 8b d0	 mov	 rdx, rax
  00035	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  0003a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 8b 4d 58	 mov	 rcx, QWORD PTR __that$[rbp]
  00042	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00046	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
  0004a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 8b 4d 58	 mov	 rcx, QWORD PTR __that$[rbp]
  00052	0f b6 49 38	 movzx	 ecx, BYTE PTR [rcx+56]
  00056	88 48 38	 mov	 BYTE PTR [rax+56], cl
  00059	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0005d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
??4log_@@QEAAAEAU0@AEBU0@@Z ENDP			; log_::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0log_@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
tv72 = 64
this$ = 96
__that$ = 104
??0log_@@QEAA@AEBU0@@Z PROC				; log_::log_, COMDAT
$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00018	48 8b 4d 68	 mov	 rcx, QWORD PTR __that$[rbp]
  0001c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00022	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00026	48 83 c0 08	 add	 rax, 8
  0002a	48 89 45 40	 mov	 QWORD PTR tv72[rbp], rax
  0002e	48 8b 45 68	 mov	 rax, QWORD PTR __that$[rbp]
  00032	48 83 c0 08	 add	 rax, 8
  00036	48 8b d0	 mov	 rdx, rax
  00039	48 8b 4d 40	 mov	 rcx, QWORD PTR tv72[rbp]
  0003d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00042	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00046	48 8b 4d 68	 mov	 rcx, QWORD PTR __that$[rbp]
  0004a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0004e	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
  00052	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00056	48 8b 4d 68	 mov	 rcx, QWORD PTR __that$[rbp]
  0005a	0f b6 49 38	 movzx	 ecx, BYTE PTR [rcx+56]
  0005e	88 48 38	 mov	 BYTE PTR [rax+56], cl
  00061	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00065	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
??0log_@@QEAA@AEBU0@@Z ENDP				; log_::log_
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1log_@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1log_@@QEAA@XZ PROC					; log_::~log_, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 83 c0 08	 add	 rax, 8
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??1log_@@QEAA@XZ ENDP					; log_::~log_
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0log_@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0log_@@QEAA@XZ PROC					; log_::log_, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 83 c0 08	 add	 rax, 8
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00023	c6 40 38 00	 mov	 BYTE PTR [rax+56], 0
  00027	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002f	5d		 pop	 rbp
  00030	c3		 ret	 0
??0log_@@QEAA@XZ ENDP					; log_::log_
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ?detach@thread@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 80
this$ = 128
?detach@thread@std@@QEAAXXZ PROC			; std::thread::detach, COMDAT

; 134  :     void detach() {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 135  :         if (!joinable()) {

  00020	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00027	e8 00 00 00 00	 call	 ?joinable@thread@std@@QEBA_NXZ ; std::thread::joinable
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	85 c0		 test	 eax, eax
  00031	75 0a		 jne	 SHORT $LN2@detach

; 136  :             _Throw_Cpp_error(_INVALID_ARGUMENT);

  00033	b9 01 00 00 00	 mov	 ecx, 1
  00038	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN2@detach:

; 137  :         }
; 138  : 
; 139  :         if (_Thrd_detach(_Thr) != _Thrd_result::_Success) {

  0003d	48 8d 45 50	 lea	 rax, QWORD PTR $T2[rbp]
  00041	48 8b f8	 mov	 rdi, rax
  00044	48 8b b5 80 00
	00 00		 mov	 rsi, QWORD PTR this$[rbp]
  0004b	b9 10 00 00 00	 mov	 ecx, 16
  00050	f3 a4		 rep movsb
  00052	48 8d 4d 50	 lea	 rcx, QWORD PTR $T2[rbp]
  00056	e8 00 00 00 00	 call	 _Thrd_detach
  0005b	85 c0		 test	 eax, eax
  0005d	74 0a		 je	 SHORT $LN3@detach

; 140  :             _Throw_Cpp_error(_INVALID_ARGUMENT);

  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN3@detach:

; 141  :         }
; 142  : 
; 143  :         _Thr = {};

  00069	48 8d 45 40	 lea	 rax, QWORD PTR $T1[rbp]
  0006d	48 8b f8	 mov	 rdi, rax
  00070	33 c0		 xor	 eax, eax
  00072	b9 10 00 00 00	 mov	 ecx, 16
  00077	f3 aa		 rep stosb
  00079	48 8d 45 40	 lea	 rax, QWORD PTR $T1[rbp]
  0007d	48 8b bd 80 00
	00 00		 mov	 rdi, QWORD PTR this$[rbp]
  00084	48 8b f0	 mov	 rsi, rax
  00087	b9 10 00 00 00	 mov	 ecx, 16
  0008c	f3 a4		 rep movsb
$LN4@detach:

; 144  :     }

  0008e	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00092	5f		 pop	 rdi
  00093	5e		 pop	 rsi
  00094	5d		 pop	 rbp
  00095	c3		 ret	 0
?detach@thread@std@@QEAAXXZ ENDP			; std::thread::detach
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ?joinable@thread@std@@QEBA_NXZ
_TEXT	SEGMENT
tv67 = 64
this$ = 96
?joinable@thread@std@@QEBA_NXZ PROC			; std::thread::joinable, COMDAT

; 114  :     _NODISCARD bool joinable() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 115  :         return _Thr._Id != 0;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00023	74 09		 je	 SHORT $LN3@joinable
  00025	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv67[rbp], 1
  0002c	eb 07		 jmp	 SHORT $LN4@joinable
$LN3@joinable:
  0002e	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv67[rbp], 0
$LN4@joinable:
  00035	0f b6 45 40	 movzx	 eax, BYTE PTR tv67[rbp]

; 116  :     }

  00039	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
?joinable@thread@std@@QEBA_NXZ ENDP			; std::thread::joinable
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\thread
;	COMDAT ??1thread@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1thread@std@@QEAA@XZ PROC				; std::thread::~thread, COMDAT

; 90   :     ~thread() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3EB9CFA8_thread
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 91   :         if (joinable()) {

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?joinable@thread@std@@QEBA_NXZ ; std::thread::joinable
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	74 06		 je	 SHORT $LN3@thread

; 92   :             _STD terminate();

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_terminate
$LN3@thread:

; 93   :         }
; 94   :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
??1thread@std@@QEAA@XZ ENDP				; std::thread::~thread
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ
_TEXT	SEGMENT
this$ = 80
?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::count, COMDAT

; 108  :         _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 109  :             return _MyRep;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [rax]

; 110  :         }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBANXZ ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 80
?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count, COMDAT

; 108  :         _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 109  :             return _MyRep;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 110  :         }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 80
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::count, COMDAT

; 108  :         _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 109  :             return _MyRep;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 110  :         }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0_JU?$ratio@$00$00@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$00@std@@@12@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Dur$ = 104
??$?0_JU?$ratio@$00$00@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$00@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,0>, COMDAT

; 106  :             : _MyRep(_CHRONO duration_cast<duration>(_Dur).count()) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 55 68	 mov	 rdx, QWORD PTR _Dur$[rbp]
  00024	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00028	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,0>
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00035	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax
  0003c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
??$?0_JU?$ratio@$00$00@std@@$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
_Num_is_one$ = 0
_Den_is_one$ = 1
$T1 = 72
$T2 = 80
$T3 = 88
$T4 = 96
__$ReturnUdt$ = 128
_Dur$ = 136
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,0>, COMDAT

; 421  :         is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 422  :         // convert duration to another duration; truncate
; 423  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 424  : 
; 425  :         using _ToRep = typename _To::rep;
; 426  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 427  : 
; 428  :         constexpr bool _Num_is_one = _CF::num == 1;

  00023	c6 45 00 01	 mov	 BYTE PTR _Num_is_one$[rbp], 1

; 429  :         constexpr bool _Den_is_one = _CF::den == 1;

  00027	c6 45 01 00	 mov	 BYTE PTR _Den_is_one$[rbp], 0

; 430  : 
; 431  :         if (_Den_is_one) {

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	74 60		 je	 SHORT $LN2@duration_c

; 432  :             if (_Num_is_one) {

  00031	33 c0		 xor	 eax, eax
  00033	83 f8 01	 cmp	 eax, 1
  00036	74 2e		 je	 SHORT $LN4@duration_c

; 433  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00038	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0003f	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00044	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00048	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0004c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00053	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,0>
  00058	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0005f	e9 9a 00 00 00	 jmp	 $LN1@duration_c

; 434  :             } else {

  00064	eb 29		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 435  :                 return static_cast<_To>(

  00066	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0006d	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00072	48 89 45 50	 mov	 QWORD PTR $T2[rbp], rax
  00076	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  0007a	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00081	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,0>
  00086	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0008d	eb 6f		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 436  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 437  :             }
; 438  :         } else {

  0008f	eb 6d		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 439  :             if (_Num_is_one) {

  00091	33 c0		 xor	 eax, eax
  00093	83 f8 01	 cmp	 eax, 1
  00096	74 35		 je	 SHORT $LN6@duration_c

; 440  :                 return static_cast<_To>(

  00098	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  0009f	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000a4	48 99		 cdq
  000a6	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  000ab	48 f7 f9	 idiv	 rcx
  000ae	48 89 45 58	 mov	 QWORD PTR $T3[rbp], rax
  000b2	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000b6	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000bd	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,0>
  000c2	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000c9	eb 33		 jmp	 SHORT $LN1@duration_c

; 441  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 442  :             } else {

  000cb	eb 31		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 443  :                 return static_cast<_To>(static_cast<_ToRep>(

  000cd	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Dur$[rbp]
  000d4	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000d9	48 99		 cdq
  000db	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  000e0	48 f7 f9	 idiv	 rcx
  000e3	48 89 45 60	 mov	 QWORD PTR $T4[rbp], rax
  000e7	48 8d 55 60	 lea	 rdx, QWORD PTR $T4[rbp]
  000eb	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000f2	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,0>
  000f7	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@duration_c:

; 444  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 445  :             }
; 446  :         }
; 447  :     }

  000fe	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00102	5d		 pop	 rbp
  00103	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ
_TEXT	SEGMENT
this$ = 80
?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ PROC ; std::chrono::duration<double,std::ratio<1,1> >::count, COMDAT

; 108  :         _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 109  :             return _MyRep;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [rax]

; 110  :         }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QEBANXZ ENDP ; std::chrono::duration<double,std::ratio<1,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 80
_Val$ = 88
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>, COMDAT

; 98   :             : _MyRep(static_cast<_Rep>(_Val)) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Val$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??Y?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAAAEAV012@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 80
_Dur$ = 88
??Y?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAAAEAV012@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::operator+=, COMDAT

; 231  :         _CONSTEXPR17 time_point& operator+=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 232  :             _MyDur += _Dur;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 55 58	 mov	 rdx, QWORD PTR _Dur$[rbp]
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=

; 233  :             return *this;

  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 234  :         }

  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??Y?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAAAEAV012@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT

; 210  :         _NODISCARD constexpr _Duration time_since_epoch() const noexcept(is_arithmetic_v<rep>) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 211  :             return _MyDur;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 212  :         }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 80
_Other$ = 88
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 202  :         constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) // strengthened

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 203  :             : _MyDur(_Other) {}

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Other$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=, COMDAT

; 145  :         _CONSTEXPR17 duration& operator-=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 146  :             _MyRep -= _Right._MyRep;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 2b c1	 sub	 rax, rcx
  00031	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00035	48 89 01	 mov	 QWORD PTR [rcx], rax

; 147  :             return *this;

  00038	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 148  :         }

  0003c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00040	5d		 pop	 rbp
  00041	c3		 ret	 0
??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=, COMDAT

; 140  :         _CONSTEXPR17 duration& operator+=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 141  :             _MyRep += _Right._MyRep;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  0002b	48 03 01	 add	 rax, QWORD PTR [rcx]
  0002e	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00032	48 89 01	 mov	 QWORD PTR [rcx], rax

; 142  :             return *this;

  00035	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 143  :         }

  00039	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 80
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT

; 108  :         _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 109  :             return _MyRep;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 110  :         }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
_Freq$ = 0
_Ctr$ = 8
_TenMHz$ = 16
_TwentyFourMHz$ = 24
_Multiplier$1 = 32
_Whole$2 = 40
_Part$3 = 48
_Whole$4 = 56
_Part$5 = 64
$T6 = 136
$T7 = 144
$T8 = 152
$T9 = 160
$T10 = 168
$T11 = 176
__$ReturnUdt$ = 208
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT

; 678  :         _NODISCARD static time_point now() noexcept { // get current time

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 679  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  0001e	e8 00 00 00 00	 call	 _Query_perf_frequency
  00023	48 89 45 00	 mov	 QWORD PTR _Freq$[rbp], rax

; 680  :             const long long _Ctr  = _Query_perf_counter();

  00027	e8 00 00 00 00	 call	 _Query_perf_counter
  0002c	48 89 45 08	 mov	 QWORD PTR _Ctr$[rbp], rax

; 681  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 682  :             // The compiler recognizes the constants for frequency and time period and uses shifts and
; 683  :             // multiplies instead of divides to calculate the nanosecond value.
; 684  :             constexpr long long _TenMHz        = 10'000'000;

  00030	48 c7 45 10 80
	96 98 00	 mov	 QWORD PTR _TenMHz$[rbp], 10000000 ; 00989680H

; 685  :             constexpr long long _TwentyFourMHz = 24'000'000;

  00038	48 c7 45 18 00
	36 6e 01	 mov	 QWORD PTR _TwentyFourMHz$[rbp], 24000000 ; 016e3600H

; 686  :             // clang-format off
; 687  :             if (_Freq == _TenMHz) _LIKELY_X86_X64 {

  00040	48 81 7d 00 80
	96 98 00	 cmp	 QWORD PTR _Freq$[rbp], 10000000 ; 00989680H
  00048	75 47		 jne	 SHORT $LN2@now

; 688  :                 // 10 MHz is a very common QPC frequency on modern x86/x64 PCs. Optimizing for
; 689  :                 // this specific frequency can double the performance of this function by
; 690  :                 // avoiding the expensive frequency conversion path.
; 691  :                 static_assert(period::den % _TenMHz == 0, "It should never fail.");
; 692  :                 constexpr long long _Multiplier = period::den / _TenMHz;

  0004a	48 c7 45 20 64
	00 00 00	 mov	 QWORD PTR _Multiplier$1[rbp], 100 ; 00000064H

; 693  :                 return time_point(duration(_Ctr * _Multiplier));

  00052	48 6b 45 08 64	 imul	 rax, QWORD PTR _Ctr$[rbp], 100 ; 00000064H
  00057	48 89 85 90 00
	00 00		 mov	 QWORD PTR $T7[rbp], rax
  0005e	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR $T7[rbp]
  00065	48 8d 8d 88 00
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  0006c	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00071	48 8b d0	 mov	 rdx, rax
  00074	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0007b	e8 00 00 00 00	 call	 ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  00080	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00087	e9 05 01 00 00	 jmp	 $LN1@now
  0008c	e9 00 01 00 00	 jmp	 $LN1@now
$LN2@now:

; 694  :             } else if (_Freq == _TwentyFourMHz) _LIKELY_ARM_ARM64 {

  00091	48 81 7d 00 00
	36 6e 01	 cmp	 QWORD PTR _Freq$[rbp], 24000000 ; 016e3600H
  00099	0f 85 81 00 00
	00		 jne	 $LN4@now

; 695  :                 // 24 MHz is a common frequency on ARM/ARM64, including cases where it emulates x86/x64.
; 696  :                 const long long _Whole = (_Ctr / _TwentyFourMHz) * period::den;

  0009f	48 8b 45 08	 mov	 rax, QWORD PTR _Ctr$[rbp]
  000a3	48 99		 cdq
  000a5	b9 00 36 6e 01	 mov	 ecx, 24000000		; 016e3600H
  000aa	48 f7 f9	 idiv	 rcx
  000ad	48 69 c0 00 ca
	9a 3b		 imul	 rax, rax, 1000000000	; 3b9aca00H
  000b4	48 89 45 28	 mov	 QWORD PTR _Whole$2[rbp], rax

; 697  :                 const long long _Part  = (_Ctr % _TwentyFourMHz) * period::den / _TwentyFourMHz;

  000b8	48 8b 45 08	 mov	 rax, QWORD PTR _Ctr$[rbp]
  000bc	48 99		 cdq
  000be	b9 00 36 6e 01	 mov	 ecx, 24000000		; 016e3600H
  000c3	48 f7 f9	 idiv	 rcx
  000c6	48 8b c2	 mov	 rax, rdx
  000c9	48 69 c0 00 ca
	9a 3b		 imul	 rax, rax, 1000000000	; 3b9aca00H
  000d0	48 99		 cdq
  000d2	b9 00 36 6e 01	 mov	 ecx, 24000000		; 016e3600H
  000d7	48 f7 f9	 idiv	 rcx
  000da	48 89 45 30	 mov	 QWORD PTR _Part$3[rbp], rax

; 698  :                 return time_point(duration(_Whole + _Part));

  000de	48 8b 45 30	 mov	 rax, QWORD PTR _Part$3[rbp]
  000e2	48 8b 4d 28	 mov	 rcx, QWORD PTR _Whole$2[rbp]
  000e6	48 03 c8	 add	 rcx, rax
  000e9	48 8b c1	 mov	 rax, rcx
  000ec	48 89 85 a0 00
	00 00		 mov	 QWORD PTR $T9[rbp], rax
  000f3	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR $T9[rbp]
  000fa	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  00101	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00106	48 8b d0	 mov	 rdx, rax
  00109	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00110	e8 00 00 00 00	 call	 ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  00115	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0011c	eb 73		 jmp	 SHORT $LN1@now

; 699  :             } else {

  0011e	eb 71		 jmp	 SHORT $LN1@now
$LN4@now:

; 700  :                 // Instead of just having "(_Ctr * period::den) / _Freq",
; 701  :                 // the algorithm below prevents overflow when _Ctr is sufficiently large.
; 702  :                 // It assumes that _Freq * period::den does not overflow, which is currently true for nano period.
; 703  :                 // It is not realistic for _Ctr to accumulate to large values from zero with this assumption,
; 704  :                 // but the initial value of _Ctr could be large.
; 705  :                 const long long _Whole = (_Ctr / _Freq) * period::den;

  00120	48 8b 45 08	 mov	 rax, QWORD PTR _Ctr$[rbp]
  00124	48 99		 cdq
  00126	48 f7 7d 00	 idiv	 QWORD PTR _Freq$[rbp]
  0012a	48 69 c0 00 ca
	9a 3b		 imul	 rax, rax, 1000000000	; 3b9aca00H
  00131	48 89 45 38	 mov	 QWORD PTR _Whole$4[rbp], rax

; 706  :                 const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  00135	48 8b 45 08	 mov	 rax, QWORD PTR _Ctr$[rbp]
  00139	48 99		 cdq
  0013b	48 f7 7d 00	 idiv	 QWORD PTR _Freq$[rbp]
  0013f	48 8b c2	 mov	 rax, rdx
  00142	48 69 c0 00 ca
	9a 3b		 imul	 rax, rax, 1000000000	; 3b9aca00H
  00149	48 99		 cdq
  0014b	48 f7 7d 00	 idiv	 QWORD PTR _Freq$[rbp]
  0014f	48 89 45 40	 mov	 QWORD PTR _Part$5[rbp], rax

; 707  :                 return time_point(duration(_Whole + _Part));

  00153	48 8b 45 40	 mov	 rax, QWORD PTR _Part$5[rbp]
  00157	48 8b 4d 38	 mov	 rcx, QWORD PTR _Whole$4[rbp]
  0015b	48 03 c8	 add	 rcx, rax
  0015e	48 8b c1	 mov	 rax, rcx
  00161	48 89 85 b0 00
	00 00		 mov	 QWORD PTR $T11[rbp], rax
  00168	48 8d 95 b0 00
	00 00		 lea	 rdx, QWORD PTR $T11[rbp]
  0016f	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  00176	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  0017b	48 8b d0	 mov	 rdx, rax
  0017e	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00185	e8 00 00 00 00	 call	 ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  0018a	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@now:

; 708  :             }
; 709  :             // clang-format on
; 710  :         }

  00191	48 8d a5 c0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+192]
  00198	5d		 pop	 rbp
  00199	c3		 ret	 0
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 80
_Val$ = 88
??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,0>, COMDAT

; 98   :             : _MyRep(static_cast<_Rep>(_Val)) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Val$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 80
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::count, COMDAT

; 108  :         _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 109  :             return _MyRep;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 110  :         }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 80
_Val$ = 88
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>, COMDAT

; 98   :             : _MyRep(static_cast<_Rep>(_Val)) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Val$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002e	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 80
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count, COMDAT

; 108  :         _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E71D1BFE___msvc_chrono@hpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 109  :             return _MyRep;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 110  :         }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
_TEXT	SEGMENT
tv69 = 64
_Byte$ = 96
_File$ = 104
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 139  : inline bool _Ungetc(const char& _Byte, FILE* _File) { // put back a char element to a C stream

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 140  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Byte$[rbp]
  00024	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00027	48 8b 55 68	 mov	 rdx, QWORD PTR _File$[rbp]
  0002b	8b c8		 mov	 ecx, eax
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  00033	83 f8 ff	 cmp	 eax, -1
  00036	74 09		 je	 SHORT $LN3@Ungetc
  00038	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv69[rbp], 1
  0003f	eb 07		 jmp	 SHORT $LN4@Ungetc
$LN3@Ungetc:
  00041	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv69[rbp], 0
$LN4@Ungetc:
  00048	0f b6 45 40	 movzx	 eax, BYTE PTR tv69[rbp]

; 141  : }

  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
_TEXT	SEGMENT
tv69 = 64
_Byte$ = 96
_File$ = 104
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 117  : inline bool _Fputc(char _Byte, FILE* _File) { // put a char element to a C stream

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	55		 push	 rbp
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 118  :     return _CSTD fputc(_Byte, _File) != EOF;

  0001f	0f be 45 60	 movsx	 eax, BYTE PTR _Byte$[rbp]
  00023	48 8b 55 68	 mov	 rdx, QWORD PTR _File$[rbp]
  00027	8b c8		 mov	 ecx, eax
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc
  0002f	83 f8 ff	 cmp	 eax, -1
  00032	74 09		 je	 SHORT $LN3@Fputc
  00034	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv69[rbp], 1
  0003b	eb 07		 jmp	 SHORT $LN4@Fputc
$LN3@Fputc:
  0003d	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv69[rbp], 0
$LN4@Fputc:
  00044	0f b6 45 40	 movzx	 eax, BYTE PTR tv69[rbp]

; 119  : }

  00048	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\__msvc_filebuf.hpp
;	COMDAT ??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Meta$ = 0
_Byte$ = 96
_File$ = 104
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 77   : inline bool _Fgetc(char& _Byte, FILE* _File) { // get a char element from a C stream

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C0945C43___msvc_filebuf@hpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 78   :     int _Meta;
; 79   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

  00020	48 8b 4d 68	 mov	 rcx, QWORD PTR _File$[rbp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  0002a	89 45 00	 mov	 DWORD PTR _Meta$[rbp], eax
  0002d	83 7d 00 ff	 cmp	 DWORD PTR _Meta$[rbp], -1
  00031	75 06		 jne	 SHORT $LN2@Fgetc

; 80   :         return false;

  00033	32 c0		 xor	 al, al
  00035	eb 0e		 jmp	 SHORT $LN1@Fgetc

; 81   :     } else { // got one, convert to char

  00037	eb 0c		 jmp	 SHORT $LN3@Fgetc
$LN2@Fgetc:

; 82   :         _Byte = static_cast<char>(_Meta);

  00039	48 8b 45 60	 mov	 rax, QWORD PTR _Byte$[rbp]
  0003d	0f b6 4d 00	 movzx	 ecx, BYTE PTR _Meta$[rbp]
  00041	88 08		 mov	 BYTE PTR [rax], cl

; 83   :         return true;

  00043	b0 01		 mov	 al, 1
$LN3@Fgetc:
$LN1@Fgetc:

; 84   :     }
; 85   : }

  00045	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1148 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1149 :     // check that [_First, _Last) forms an iterator range
; 1150 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1151 :         _Verify_range(_First, _Last);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Last$[rbp]
  00024	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00027	48 8b 45 50	 mov	 rax, QWORD PTR _First$[rbp]
  0002b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002e	e8 00 00 00 00	 call	 ??$_Verify_range@D@std@@YAXQEBD0@Z ; std::_Verify_range<char>

; 1152 :     }
; 1153 : }

  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
_TEXT	SEGMENT
_Facptr$ = 0
_Ptr0$ = 8
tv71 = 80
this$ = 112
_Id$ = 120
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z PROC	; std::locale::_Getfacet, COMDAT

; 380  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__CC18A947_xlocale
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 381  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00023	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002f	48 39 45 78	 cmp	 QWORD PTR _Id$[rbp], rax
  00033	73 1a		 jae	 SHORT $LN6@Getfacet
  00035	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00041	48 8b 4d 78	 mov	 rcx, QWORD PTR _Id$[rbp]
  00045	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00049	48 89 45 50	 mov	 QWORD PTR tv71[rbp], rax
  0004d	eb 08		 jmp	 SHORT $LN7@Getfacet
$LN6@Getfacet:
  0004f	48 c7 45 50 00
	00 00 00	 mov	 QWORD PTR tv71[rbp], 0
$LN7@Getfacet:
  00057	48 8b 45 50	 mov	 rax, QWORD PTR tv71[rbp]
  0005b	48 89 45 00	 mov	 QWORD PTR _Facptr$[rbp], rax

; 382  :         if (_Facptr || !_Ptr->_Xparent) {

  0005f	48 83 7d 00 00	 cmp	 QWORD PTR _Facptr$[rbp], 0
  00064	75 10		 jne	 SHORT $LN3@Getfacet
  00066	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0006a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006e	0f b6 40 24	 movzx	 eax, BYTE PTR [rax+36]
  00072	85 c0		 test	 eax, eax
  00074	75 06		 jne	 SHORT $LN2@Getfacet
$LN3@Getfacet:

; 383  :             return _Facptr; // found facet or not transparent

  00076	48 8b 45 00	 mov	 rax, QWORD PTR _Facptr$[rbp]
  0007a	eb 2b		 jmp	 SHORT $LN1@Getfacet
$LN2@Getfacet:

; 384  :         }
; 385  : 
; 386  :         // look in current locale
; 387  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  0007c	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00081	48 89 45 08	 mov	 QWORD PTR _Ptr0$[rbp], rax

; 388  :         if (_Id < _Ptr0->_Facetcount) {

  00085	48 8b 45 08	 mov	 rax, QWORD PTR _Ptr0$[rbp]
  00089	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008d	48 39 45 78	 cmp	 QWORD PTR _Id$[rbp], rax
  00091	73 12		 jae	 SHORT $LN4@Getfacet

; 389  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  00093	48 8b 45 08	 mov	 rax, QWORD PTR _Ptr0$[rbp]
  00097	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009b	48 8b 4d 78	 mov	 rcx, QWORD PTR _Id$[rbp]
  0009f	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000a3	eb 02		 jmp	 SHORT $LN1@Getfacet
$LN4@Getfacet:

; 390  :         }
; 391  : 
; 392  :         return nullptr; // no entry in current locale

  000a5	33 c0		 xor	 eax, eax
$LN1@Getfacet:

; 393  :     }

  000a7	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000ab	5d		 pop	 rbp
  000ac	c3		 ret	 0
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ENDP	; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xlocale
;	COMDAT ??1locale@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 64
tv85 = 72
tv86 = 80
this$ = 112
??1locale@std@@QEAA@XZ PROC				; std::locale::~locale, COMDAT

; 357  :     ~locale() noexcept {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__CC18A947_xlocale
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 358  :         if (_Ptr) {

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00027	74 49		 je	 SHORT $LN2@locale

; 359  :             delete _Ptr->_Decref();

  00029	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00031	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00035	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	ff 50 10	 call	 QWORD PTR [rax+16]
  0003f	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00043	48 83 7d 40 00	 cmp	 QWORD PTR $T1[rbp], 0
  00048	74 20		 je	 SHORT $LN4@locale
  0004a	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  0004e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00051	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00054	48 89 45 48	 mov	 QWORD PTR tv85[rbp], rax
  00058	ba 01 00 00 00	 mov	 edx, 1
  0005d	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00061	ff 55 48	 call	 QWORD PTR tv85[rbp]
  00064	48 89 45 50	 mov	 QWORD PTR tv86[rbp], rax
  00068	eb 08		 jmp	 SHORT $LN2@locale
$LN4@locale:
  0006a	48 c7 45 50 00
	00 00 00	 mov	 QWORD PTR tv86[rbp], 0
$LN2@locale:

; 360  :         }
; 361  :     }

  00072	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
??1locale@std@@QEAA@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 64
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 66   : [[noreturn]] inline void _Throw_bad_cast() {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00009	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C7EDFCD9_typeinfo
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 67   :     _THROW(bad_cast{});

  0001a	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0001e	e8 00 00 00 00	 call	 ??0bad_cast@std@@QEAA@XZ ; std::bad_cast::bad_cast
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
  0002a	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0002e	e8 00 00 00 00	 call	 _CxxThrowException
$LN2@Throw_bad_:

; 68   : }

  00033	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_cast@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gbad_cast@std@@UEAAPEAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1bad_cast@std@@UEAA@XZ
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gbad_cast@std@@UEAAPEAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_cast@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0bad_cast@std@@QEAA@AEBV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@AEBV01@@Z ; std::exception::exception
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_cast@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??0bad_cast@std@@QEAA@AEBV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_cast@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1bad_cast@std@@UEAA@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1bad_cast@std@@UEAA@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0bad_cast@std@@QEAA@XZ PROC				; std::bad_cast::bad_cast, COMDAT

; 153  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__93AC6E75_vcruntime_typeinfo@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 152  :         : exception("bad cast", 1)

  0001b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast@
  00028	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002c	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@QEBDH@Z ; std::exception::exception

; 153  :     {

  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_cast@std@@6B@
  0003c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 154  :     }

  0003f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00043	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
??0bad_cast@std@@QEAA@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\time.h
;	COMDAT localtime_s
_TEXT	SEGMENT
_Tm$ = 80
_Time$ = 88
localtime_s PROC					; COMDAT

; 616  :             {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0A9237D2_time@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 617  :                 return _localtime64_s(_Tm, _Time);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Time$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR _Tm$[rbp]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64_s

; 618  :             }

  0002e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
localtime_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\time.h
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 80
time	PROC						; COMDAT

; 551  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0A9237D2_time@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 552  :             return _time64(_Time);

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR _Time$[rbp]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 553  :         }

  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\string
;	COMDAT ??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
_TEXT	SEGMENT
_Buff$ = 0
_Buff_end$ = 24
_RNext$ = 32
_UVal$ = 40
$T1 = 108
$T2 = 112
__$ReturnUdt$ = 144
_Val$ = 152
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z PROC ; std::_Integral_to_string<char,int>, COMDAT

; 473  : _NODISCARD basic_string<_Elem> _Integral_to_string(const _Ty _Val) {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	c7 45 70 00 00
	00 00		 mov	 DWORD PTR $T2[rbp], 0
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__91273182_string
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 474  :     // convert _Val to string
; 475  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 476  :     using _UTy = make_unsigned_t<_Ty>;
; 477  :     _Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 478  :     _Elem* const _Buff_end = _STD end(_Buff);

  00029	48 8d 4d 00	 lea	 rcx, QWORD PTR _Buff$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ; std::end<char,21>
  00032	48 89 45 18	 mov	 QWORD PTR _Buff_end$[rbp], rax

; 479  :     _Elem* _RNext          = _Buff_end;

  00036	48 8b 45 18	 mov	 rax, QWORD PTR _Buff_end$[rbp]
  0003a	48 89 45 20	 mov	 QWORD PTR _RNext$[rbp], rax

; 480  :     const auto _UVal       = static_cast<_UTy>(_Val);

  0003e	8b 85 98 00 00
	00		 mov	 eax, DWORD PTR _Val$[rbp]
  00044	89 45 28	 mov	 DWORD PTR _UVal$[rbp], eax

; 481  :     if (_Val < 0) {

  00047	83 bd 98 00 00
	00 00		 cmp	 DWORD PTR _Val$[rbp], 0
  0004e	7d 28		 jge	 SHORT $LN2@Integral_t

; 482  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);

  00050	33 c0		 xor	 eax, eax
  00052	2b 45 28	 sub	 eax, DWORD PTR _UVal$[rbp]
  00055	8b d0		 mov	 edx, eax
  00057	48 8b 4d 20	 mov	 rcx, QWORD PTR _RNext$[rbp]
  0005b	e8 00 00 00 00	 call	 ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
  00060	48 89 45 20	 mov	 QWORD PTR _RNext$[rbp], rax

; 483  :         *--_RNext = '-';

  00064	48 8b 45 20	 mov	 rax, QWORD PTR _RNext$[rbp]
  00068	48 ff c8	 dec	 rax
  0006b	48 89 45 20	 mov	 QWORD PTR _RNext$[rbp], rax
  0006f	48 8b 45 20	 mov	 rax, QWORD PTR _RNext$[rbp]
  00073	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH

; 484  :     } else {

  00076	eb 10		 jmp	 SHORT $LN3@Integral_t
$LN2@Integral_t:

; 485  :         _RNext = _UIntegral_to_buff(_RNext, _UVal);

  00078	8b 55 28	 mov	 edx, DWORD PTR _UVal$[rbp]
  0007b	48 8b 4d 20	 mov	 rcx, QWORD PTR _RNext$[rbp]
  0007f	e8 00 00 00 00	 call	 ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
  00084	48 89 45 20	 mov	 QWORD PTR _RNext$[rbp], rax
$LN3@Integral_t:

; 486  :     }
; 487  : 
; 488  :     return basic_string<_Elem>(_RNext, _Buff_end);

  00088	48 8d 4d 6c	 lea	 rcx, QWORD PTR $T1[rbp]
  0008c	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  00091	4c 8b c8	 mov	 r9, rax
  00094	4c 8b 45 18	 mov	 r8, QWORD PTR _Buff_end$[rbp]
  00098	48 8b 55 20	 mov	 rdx, QWORD PTR _RNext$[rbp]
  0009c	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000a3	e8 00 00 00 00	 call	 ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
  000a8	8b 45 70	 mov	 eax, DWORD PTR $T2[rbp]
  000ab	83 c8 01	 or	 eax, 1
  000ae	89 45 70	 mov	 DWORD PTR $T2[rbp], eax
  000b1	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 489  : }

  000b8	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ENDP ; std::_Integral_to_string<char,int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
$T1 = 64
__$ReturnUdt$ = 96
_Val$ = 104
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::to_string, COMDAT

; 503  : _EXPORT_STD _NODISCARD inline string to_string(int _Val) {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	c7 45 40 00 00
	00 00		 mov	 DWORD PTR $T1[rbp], 0
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__91273182_string
  00021	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 504  :     return _Integral_to_string<char>(_Val);

  00026	8b 55 68	 mov	 edx, DWORD PTR _Val$[rbp]
  00029	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
  00032	8b 45 40	 mov	 eax, DWORD PTR $T1[rbp]
  00035	83 c8 01	 or	 eax, 1
  00038	89 45 40	 mov	 DWORD PTR $T1[rbp], eax
  0003b	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 505  : }

  0003f	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00043	5d		 pop	 rbp
  00044	c3		 ret	 0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 4874 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4875 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first

; 4876 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 0
_Ptr$1 = 8
_Al$2 = 16
$T3 = 88
this$ = 112
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT

; 4846 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4847 :         auto& _My_data = _Mypair._Myval2;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 4848 :         _My_data._Orphan_all();

  00026	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 4849 :         if (_My_data._Large_string_engaged()) {

  0002f	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00033	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
  00038	0f b6 c0	 movzx	 eax, al
  0003b	85 c0		 test	 eax, eax
  0003d	74 4d		 je	 SHORT $LN2@Tidy_deall

; 4850 :             _ASAN_STRING_REMOVE(*this);
; 4851 :             const pointer _Ptr = _My_data._Bx._Ptr;

  0003f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00043	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00047	48 89 45 08	 mov	 QWORD PTR _Ptr$1[rbp], rax

; 4852 :             auto& _Al          = _Getal();

  0004b	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0004f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00054	48 89 45 10	 mov	 QWORD PTR _Al$2[rbp], rax

; 4853 :             _Destroy_in_place(_My_data._Bx._Ptr);

  00058	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0005c	48 83 c0 08	 add	 rax, 8
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z ; std::_Destroy_in_place<wchar_t *>

; 4854 :             _My_data._Activate_SSO_buffer();

  00068	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0006c	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer

; 4855 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00071	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00075	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00079	48 ff c0	 inc	 rax
  0007c	4c 8b c0	 mov	 r8, rax
  0007f	48 8b 55 08	 mov	 rdx, QWORD PTR _Ptr$1[rbp]
  00083	48 8b 4d 10	 mov	 rcx, QWORD PTR _Al$2[rbp]
  00087	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN2@Tidy_deall:

; 4856 :         }
; 4857 : 
; 4858 :         _My_data._Mysize = 0;

  0008c	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00090	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4859 :         _My_data._Myres  = _BUF_SIZE - 1;

  00098	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0009c	48 c7 40 20 07
	00 00 00	 mov	 QWORD PTR [rax+32], 7

; 4860 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4861 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000a4	33 c0		 xor	 eax, eax
  000a6	66 89 45 58	 mov	 WORD PTR $T3[rbp], ax
  000aa	b8 02 00 00 00	 mov	 eax, 2
  000af	48 6b c0 00	 imul	 rax, rax, 0
  000b3	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  000b7	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000bc	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000c0	48 8b c8	 mov	 rcx, rax
  000c3	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign
  000c8	90		 npad	 1

; 4862 :     }

  000c9	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000cd	5d		 pop	 rbp
  000ce	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv90 = 64
tv88 = 72
this$ = 96
__$ReturnUdt$ = 104
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end, COMDAT

; 3937 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3938 :         return iterator(

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
  0002c	48 89 45 40	 mov	 QWORD PTR tv90[rbp], rax
  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 ??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z ; std::_Refancy<wchar_t *,0>
  00044	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00048	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0004c	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00050	48 89 45 48	 mov	 QWORD PTR tv88[rbp], rax
  00054	4c 8b 45 40	 mov	 r8, QWORD PTR tv90[rbp]
  00058	48 8b 55 48	 mov	 rdx, QWORD PTR tv88[rbp]
  0005c	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00060	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z
  00065	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 3939 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3940 :             _STD addressof(_Mypair._Myval2));
; 3941 :     }

  00069	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006d	5d		 pop	 rbp
  0006e	c3		 ret	 0
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv85 = 64
tv83 = 72
this$ = 96
__$ReturnUdt$ = 104
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin, COMDAT

; 3929 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3930 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
  0002c	48 89 45 40	 mov	 QWORD PTR tv85[rbp], rax
  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 ??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z ; std::_Refancy<wchar_t *,0>
  00044	48 89 45 48	 mov	 QWORD PTR tv83[rbp], rax
  00048	4c 8b 45 40	 mov	 r8, QWORD PTR tv85[rbp]
  0004c	48 8b 55 48	 mov	 rdx, QWORD PTR tv83[rbp]
  00050	48 8b 4d 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00054	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base12@1@@Z
  00059	48 8b 45 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 3931 :     }

  0005d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S5$ = 8
_To_delete$ = 16
this$ = 112
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 3128 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3129 :         _Tidy_deallocate();

  0001e	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00022	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 3130 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3131 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00027	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8d 4d 08	 lea	 rcx, QWORD PTR $S5$[rbp]
  00037	e8 00 00 00 00	 call	 ??$?0_W@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><wchar_t>
  0003c	48 8d 45 08	 lea	 rax, QWORD PTR $S5$[rbp]
  00040	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 3132 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

  00044	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 89 45 10	 mov	 QWORD PTR _To_delete$[rbp], rax

; 3133 :         _Mypair._Myval2._Myproxy = nullptr;

  0004f	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00053	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3134 :         _Delete_plain_internal(_Alproxy, _To_delete);

  0005a	48 8b 55 10	 mov	 rdx, QWORD PTR _To_delete$[rbp]
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  00062	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 3135 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3136 :     }

  00067	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
  00073	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00077	5d		 pop	 rbp
  00078	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 83 c0 08	 add	 rax, 8
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT

; 2284 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Idx$1 = 0
this$ = 96
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer, COMDAT

; 2246 :     constexpr void _Activate_SSO_buffer() noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2247 :         // start the lifetime of the array elements
; 2248 : #if _HAS_CXX20
; 2249 :         if (_STD is_constant_evaluated()) {

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 2d		 je	 SHORT $LN5@Activate_S

; 2250 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {

  00027	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Idx$1[rbp], 0
  0002f	eb 0b		 jmp	 SHORT $LN4@Activate_S
$LN2@Activate_S:
  00031	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  00035	48 ff c0	 inc	 rax
  00038	48 89 45 00	 mov	 QWORD PTR _Idx$1[rbp], rax
$LN4@Activate_S:
  0003c	48 83 7d 00 08	 cmp	 QWORD PTR _Idx$1[rbp], 8
  00041	73 11		 jae	 SHORT $LN5@Activate_S

; 2251 :                 _Bx._Buf[_Idx] = value_type();

  00043	33 c0		 xor	 eax, eax
  00045	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00049	48 8b 55 00	 mov	 rdx, QWORD PTR _Idx$1[rbp]
  0004d	66 89 44 51 08	 mov	 WORD PTR [rcx+rdx*2+8], ax

; 2252 :             }

  00052	eb dd		 jmp	 SHORT $LN2@Activate_S
$LN5@Activate_S:

; 2253 :         }
; 2254 : #endif // _HAS_CXX20
; 2255 :     }

  00054	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00058	5d		 pop	 rbp
  00059	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 64
this$ = 96
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT

; 2242 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2243 :         return _BUF_SIZE <= _Myres;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 20 08	 cmp	 QWORD PTR [rax+32], 8
  00024	72 09		 jb	 SHORT $LN3@Large_stri
  00026	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv66[rbp], 1
  0002d	eb 07		 jmp	 SHORT $LN4@Large_stri
$LN3@Large_stri:
  0002f	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv66[rbp], 0
$LN4@Large_stri:
  00036	0f b6 45 40	 movzx	 eax, BYTE PTR tv66[rbp]

; 2244 :     }

  0003a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
_Result$ = 0
this$ = 96
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 2224 :     _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2225 :         value_type* _Result = _Bx._Buf;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 c0 08	 add	 rax, 8
  00023	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax

; 2226 :         if (_Large_string_engaged()) {

  00027	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	74 11		 je	 SHORT $LN2@Myptr

; 2227 :             _Result = _Unfancy(_Bx._Ptr);

  00037	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003f	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z ; std::_Unfancy<wchar_t>
  00044	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax
$LN2@Myptr:

; 2228 :         }
; 2229 : 
; 2230 :         return _Result;

  00048	48 8b 45 00	 mov	 rax, QWORD PTR _Result$[rbp]

; 2231 :     }

  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 8b 45 60	 mov	 rax, QWORD PTR _Count$[rbp]
  000ae	48 d1 e0	 shl	 rax, 1
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b8	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bd	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000c1	5d		 pop	 rbp
  000c2	c3		 ret	 0
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4878 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4879 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4880 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4874 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4875 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4876 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 64
this$ = 96
_Right$ = 104
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 4870 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4871 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 40	 mov	 QWORD PTR tv79[rbp], rax
  00028	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 4d 40	 mov	 rcx, QWORD PTR tv79[rbp]
  00033	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators

; 4872 :     }

  00038	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 0
_Ptr$1 = 8
_Al$2 = 16
$T3 = 88
this$ = 112
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 4846 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4847 :         auto& _My_data = _Mypair._Myval2;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 4848 :         _My_data._Orphan_all();

  00026	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 4849 :         if (_My_data._Large_string_engaged()) {

  0002f	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00033	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00038	0f b6 c0	 movzx	 eax, al
  0003b	85 c0		 test	 eax, eax
  0003d	74 4d		 je	 SHORT $LN2@Tidy_deall

; 4850 :             _ASAN_STRING_REMOVE(*this);
; 4851 :             const pointer _Ptr = _My_data._Bx._Ptr;

  0003f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00043	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00047	48 89 45 08	 mov	 QWORD PTR _Ptr$1[rbp], rax

; 4852 :             auto& _Al          = _Getal();

  0004b	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0004f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00054	48 89 45 10	 mov	 QWORD PTR _Al$2[rbp], rax

; 4853 :             _Destroy_in_place(_My_data._Bx._Ptr);

  00058	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0005c	48 83 c0 08	 add	 rax, 8
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>

; 4854 :             _My_data._Activate_SSO_buffer();

  00068	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0006c	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 4855 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00071	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00075	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00079	48 ff c0	 inc	 rax
  0007c	4c 8b c0	 mov	 r8, rax
  0007f	48 8b 55 08	 mov	 rdx, QWORD PTR _Ptr$1[rbp]
  00083	48 8b 4d 10	 mov	 rcx, QWORD PTR _Al$2[rbp]
  00087	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 4856 :         }
; 4857 : 
; 4858 :         _My_data._Mysize = 0;

  0008c	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00090	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4859 :         _My_data._Myres  = _BUF_SIZE - 1;

  00098	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0009c	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 4860 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4861 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000a4	c6 45 58 00	 mov	 BYTE PTR $T3[rbp], 0
  000a8	b8 01 00 00 00	 mov	 eax, 1
  000ad	48 6b c0 00	 imul	 rax, rax, 0
  000b1	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  000b5	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000ba	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000be	48 8b c8	 mov	 rcx, rax
  000c1	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
  000c6	90		 npad	 1

; 4862 :     }

  000c7	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000cb	5d		 pop	 rbp
  000cc	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 0
$T1 = 72
this$ = 96
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT

; 4835 :     _CONSTEXPR20 void _Tidy_init() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4836 :         // initialize basic_string data members
; 4837 :         auto& _My_data   = _Mypair._Myval2;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 4838 :         _My_data._Mysize = 0;

  00023	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00027	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4839 :         _My_data._Myres  = _BUF_SIZE - 1;

  0002f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00033	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 4840 :         _My_data._Activate_SSO_buffer();

  0003b	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0003f	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 4841 : 
; 4842 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4843 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00044	c6 45 48 00	 mov	 BYTE PTR $T1[rbp], 0
  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	48 6b c0 00	 imul	 rax, rax, 0
  00051	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00055	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0005a	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0005e	48 8b c8	 mov	 rcx, rax
  00061	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4844 :     }

  00066	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 64
tv74 = 72
this$ = 96
_Requested$ = 104
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4739 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4740 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00020	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00024	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00029	48 89 45 40	 mov	 QWORD PTR tv76[rbp], rax
  0002d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00035	48 89 45 48	 mov	 QWORD PTR tv74[rbp], rax
  00039	4c 8b 45 40	 mov	 r8, QWORD PTR tv76[rbp]
  0003d	48 8b 55 48	 mov	 rdx, QWORD PTR tv74[rbp]
  00041	48 8b 4d 68	 mov	 rcx, QWORD PTR _Requested$[rbp]
  00045	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 4741 :     }

  0004a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 0
$T1 = 72
_Requested$ = 96
_Old$ = 104
_Max$ = 112
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4726 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4727 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00025	48 8b 45 60	 mov	 rax, QWORD PTR _Requested$[rbp]
  00029	48 83 c8 0f	 or	 rax, 15
  0002d	48 89 45 00	 mov	 QWORD PTR _Masked$[rbp], rax

; 4728 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00031	48 8b 45 70	 mov	 rax, QWORD PTR _Max$[rbp]
  00035	48 39 45 00	 cmp	 QWORD PTR _Masked$[rbp], rax
  00039	76 06		 jbe	 SHORT $LN2@Calculate_

; 4729 :             return _Max;

  0003b	48 8b 45 70	 mov	 rax, QWORD PTR _Max$[rbp]
  0003f	eb 50		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4730 :         }
; 4731 : 
; 4732 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00041	33 d2		 xor	 edx, edx
  00043	48 8b 45 68	 mov	 rax, QWORD PTR _Old$[rbp]
  00047	b9 02 00 00 00	 mov	 ecx, 2
  0004c	48 f7 f1	 div	 rcx
  0004f	48 8b 4d 70	 mov	 rcx, QWORD PTR _Max$[rbp]
  00053	48 2b c8	 sub	 rcx, rax
  00056	48 8b c1	 mov	 rax, rcx
  00059	48 39 45 68	 cmp	 QWORD PTR _Old$[rbp], rax
  0005d	76 06		 jbe	 SHORT $LN3@Calculate_

; 4733 :             return _Max;

  0005f	48 8b 45 70	 mov	 rax, QWORD PTR _Max$[rbp]
  00063	eb 2c		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4734 :         }
; 4735 : 
; 4736 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00065	33 d2		 xor	 edx, edx
  00067	48 8b 45 68	 mov	 rax, QWORD PTR _Old$[rbp]
  0006b	b9 02 00 00 00	 mov	 ecx, 2
  00070	48 f7 f1	 div	 rcx
  00073	48 8b 4d 68	 mov	 rcx, QWORD PTR _Old$[rbp]
  00077	48 03 c8	 add	 rcx, rax
  0007a	48 8b c1	 mov	 rax, rcx
  0007d	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00081	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  00085	48 8d 4d 00	 lea	 rcx, QWORD PTR _Masked$[rbp]
  00089	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  0008e	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN1@Calculate_:

; 4737 :     }

  00091	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00095	5d		 pop	 rbp
  00096	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_Alloc_max$ = 0
_Storage_max$ = 8
$T1 = 80
$T2 = 88
$T3 = 96
this$ = 128
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 4141 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4142 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  0001e	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  00032	48 89 45 00	 mov	 QWORD PTR _Alloc_max$[rbp], rax

; 4143 :         const size_type _Storage_max = // can always store small string

  00036	48 c7 45 50 10
	00 00 00	 mov	 QWORD PTR $T1[rbp], 16
  0003e	48 8d 55 50	 lea	 rdx, QWORD PTR $T1[rbp]
  00042	48 8d 4d 00	 lea	 rcx, QWORD PTR _Alloc_max$[rbp]
  00046	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  0004b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004e	48 89 45 08	 mov	 QWORD PTR _Storage_max$[rbp], rax

; 4144 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4145 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00052	48 8b 45 08	 mov	 rax, QWORD PTR _Storage_max$[rbp]
  00056	48 ff c8	 dec	 rax
  00059	48 89 45 58	 mov	 QWORD PTR $T2[rbp], rax
  0005d	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00062	48 89 45 60	 mov	 QWORD PTR $T3[rbp], rax
  00066	48 8d 55 58	 lea	 rdx, QWORD PTR $T2[rbp]
  0006a	48 8d 4d 60	 lea	 rcx, QWORD PTR $T3[rbp]
  0006e	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00073	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 4146 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4147 :         );
; 4148 :     }

  00076	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  0007a	5d		 pop	 rbp
  0007b	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 80
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 4137 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4138 :         return _Mypair._Myval2._Mysize;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]

; 4139 :     }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 80
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 4128 :     _NODISCARD _CONSTEXPR20 _Ret_z_ _Elem* data() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4129 :         return _Mypair._Myval2._Myptr();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4130 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 80
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 4123 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4124 :         return _Mypair._Myval2._Myptr();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4125 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 80
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 4119 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4120 :         return _Mypair._Myval2._Myptr();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4121 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ
_TEXT	SEGMENT
this$ = 80
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front, COMDAT

; 4087 :     _NODISCARD _CONSTEXPR20 reference front() noexcept /* strengthened */ {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@front:

; 4088 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4089 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00024	74 02		 je	 SHORT $LN7@front
  00026	eb 6b		 jmp	 SHORT $LN9@front
$LN7@front:
  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BP@PFIPNLNI@front?$CI?$CJ?5called?5on?5empty?5string@
  0002f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0003b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00040	45 33 c9	 xor	 r9d, r9d
  00043	41 b8 f9 0f 00
	00		 mov	 r8d, 4089		; 00000ff9H
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@
  00050	b9 02 00 00 00	 mov	 ecx, 2
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  0005b	83 f8 01	 cmp	 eax, 1
  0005e	75 03		 jne	 SHORT $LN11@front
  00060	cc		 int	 3
  00061	33 c0		 xor	 eax, eax
$LN11@front:
  00063	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0006c	41 b9 f9 0f 00
	00		 mov	 r9d, 4089		; 00000ff9H
  00072	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@DINNLDHA@?$AA?$CC?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd@
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	75 95		 jne	 SHORT $LN7@front
$LN9@front:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 82		 jne	 SHORT $LN4@front

; 4090 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4091 : 
; 4092 :         return _Mypair._Myval2._Myptr()[0];

  00099	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  000a5	b9 01 00 00 00	 mov	 ecx, 1
  000aa	48 6b c9 00	 imul	 rcx, rcx, 0
  000ae	48 03 c1	 add	 rax, rcx

; 4093 :     }

  000b1	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000b5	5d		 pop	 rbp
  000b6	c3		 ret	 0
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
_TEXT	SEGMENT
_Old_size$ = 0
_Ptr$1 = 8
$T2 = 80
$T3 = 81
this$ = 112
_Ch$ = 120
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT

; 4058 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

$LN4:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4059 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00022	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00026	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002a	48 89 45 00	 mov	 QWORD PTR _Old_size$[rbp], rax

; 4060 :         if (_Old_size < _Mypair._Myval2._Myres) {

  0002e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00036	48 39 45 00	 cmp	 QWORD PTR _Old_size$[rbp], rax
  0003a	73 58		 jae	 SHORT $LN2@push_back

; 4061 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4062 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0003c	48 8b 45 00	 mov	 rax, QWORD PTR _Old_size$[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00047	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4063 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  0004b	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00057	48 89 45 08	 mov	 QWORD PTR _Ptr$1[rbp], rax

; 4064 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  0005b	48 8b 45 00	 mov	 rax, QWORD PTR _Old_size$[rbp]
  0005f	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr$1[rbp]
  00063	48 03 c8	 add	 rcx, rax
  00066	48 8b c1	 mov	 rax, rcx
  00069	48 8d 55 78	 lea	 rdx, QWORD PTR _Ch$[rbp]
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4065 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00075	c6 45 50 00	 mov	 BYTE PTR $T2[rbp], 0
  00079	48 8b 45 08	 mov	 rax, QWORD PTR _Ptr$1[rbp]
  0007d	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  00081	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  00086	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4066 :             return;

  00092	eb 18		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 4067 :         }
; 4068 : 
; 4069 :         _Reallocate_grow_by(

  00094	44 0f b6 4d 78	 movzx	 r9d, BYTE PTR _Ch$[rbp]
  00099	44 0f b6 45 51	 movzx	 r8d, BYTE PTR $T3[rbp]
  0009e	ba 01 00 00 00	 mov	 edx, 1
  000a3	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  000a7	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN1@push_back:

; 4070 :             1,
; 4071 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 4072 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4073 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 4074 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4075 :             },
; 4076 :             _Ch);
; 4077 :     }

  000ac	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000b0	5d		 pop	 rbp
  000b1	c3		 ret	 0
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
_TEXT	SEGMENT
tv69 = 64
this$ = 96
_Off$ = 104
_Count$ = 112
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 3658 :     _CONSTEXPR20 basic_string& erase(const size_type _Off, const size_type _Count) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3659 :         // erase elements [_Off, _Off + _Count)
; 3660 :         _Mypair._Myval2._Check_offset(_Off);

  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  0002d	48 8b 55 68	 mov	 rdx, QWORD PTR _Off$[rbp]
  00031	48 8b 4d 40	 mov	 rcx, QWORD PTR tv69[rbp]
  00035	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 3661 :         return _Erase_noexcept(_Off, _Count);

  0003a	4c 8b 45 70	 mov	 r8, QWORD PTR _Count$[rbp]
  0003e	48 8b 55 68	 mov	 rdx, QWORD PTR _Off$[rbp]
  00042	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00046	e8 00 00 00 00	 call	 ?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept

; 3662 :     }

  0004b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z
_TEXT	SEGMENT
_Old_size$ = 0
_My_ptr$ = 8
_Erase_at$ = 16
_New_size$ = 24
tv71 = 96
this$ = 128
_Off$ = 136
_Count$ = 144
?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept, COMDAT

; 3645 :     _CONSTEXPR20 basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3646 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);

  00028	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 89 45 60	 mov	 QWORD PTR tv71[rbp], rax
  00033	4c 8b 85 90 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  0003a	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR _Off$[rbp]
  00041	48 8b 4d 60	 mov	 rcx, QWORD PTR tv71[rbp]
  00045	e8 00 00 00 00	 call	 ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
  0004a	48 89 85 90 00
	00 00		 mov	 QWORD PTR _Count$[rbp], rax

; 3647 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00051	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0005c	48 89 45 00	 mov	 QWORD PTR _Old_size$[rbp], rax

; 3648 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();

  00060	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0006f	48 89 45 08	 mov	 QWORD PTR _My_ptr$[rbp], rax

; 3649 :         _Elem* const _Erase_at    = _My_ptr + _Off;

  00073	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR _Off$[rbp]
  0007a	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_ptr$[rbp]
  0007e	48 03 c8	 add	 rcx, rax
  00081	48 8b c1	 mov	 rax, rcx
  00084	48 89 45 10	 mov	 QWORD PTR _Erase_at$[rbp], rax

; 3650 :         const size_type _New_size = _Old_size - _Count;

  00088	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  0008f	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  00093	48 2b c8	 sub	 rcx, rax
  00096	48 8b c1	 mov	 rax, rcx
  00099	48 89 45 18	 mov	 QWORD PTR _New_size$[rbp], rax

; 3651 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0009d	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR _Off$[rbp]
  000a4	48 8b 4d 18	 mov	 rcx, QWORD PTR _New_size$[rbp]
  000a8	48 2b c8	 sub	 rcx, rax
  000ab	48 8b c1	 mov	 rax, rcx
  000ae	48 ff c0	 inc	 rax
  000b1	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  000b8	48 8b 55 10	 mov	 rdx, QWORD PTR _Erase_at$[rbp]
  000bc	48 03 d1	 add	 rdx, rcx
  000bf	48 8b ca	 mov	 rcx, rdx
  000c2	4c 8b c0	 mov	 r8, rax
  000c5	48 8b d1	 mov	 rdx, rcx
  000c8	48 8b 4d 10	 mov	 rcx, QWORD PTR _Erase_at$[rbp]
  000cc	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 3652 :         _ASAN_STRING_MODIFY(*this, _Old_size, _New_size);
; 3653 :         _Mypair._Myval2._Mysize = _New_size;

  000d1	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000d8	48 8b 4d 18	 mov	 rcx, QWORD PTR _New_size$[rbp]
  000dc	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 3654 :         return *this;

  000e0	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]

; 3655 :     }

  000e7	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000eb	5d		 pop	 rbp
  000ec	c3		 ret	 0
?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
_TEXT	SEGMENT
this$ = 80
_Off$ = 88
_Ptr$ = 96
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 3547 :     _CONSTEXPR20 basic_string& insert(const size_type _Off, _In_z_ const _Elem* const _Ptr) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3548 :         // insert [_Ptr, <null>) at _Off
; 3549 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00025	48 8b 4d 60	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00029	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ??$_Convert_size@_K_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64,unsigned __int64>
  00036	4c 8b c8	 mov	 r9, rax
  00039	4c 8b 45 60	 mov	 r8, QWORD PTR _Ptr$[rbp]
  0003d	48 8b 55 58	 mov	 rdx, QWORD PTR _Off$[rbp]
  00041	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00045	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 3550 :     }

  0004a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
_TEXT	SEGMENT
_Old_size$ = 0
_Check_overlap$ = 8
_Old_ptr$1 = 16
_Insert_at$2 = 24
_Ptr_shifted_after$3 = 32
$T4 = 104
tv81 = 105
tv146 = 112
tv69 = 112
this$ = 144
_Off$ = 152
_Ptr$ = 160
_Count$ = 168
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 3499 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  0001c	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3500 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 3501 :         _Mypair._Myval2._Check_offset(_Off);

  0002d	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 89 45 70	 mov	 QWORD PTR tv69[rbp], rax
  00038	48 8b 95 98 00
	00 00		 mov	 rdx, QWORD PTR _Off$[rbp]
  0003f	48 8b 4d 70	 mov	 rcx, QWORD PTR tv69[rbp]
  00043	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 3502 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00048	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00053	48 89 45 00	 mov	 QWORD PTR _Old_size$[rbp], rax

; 3503 : 
; 3504 :         // We can't check for overlapping ranges when constant evaluated since comparison of pointers into string
; 3505 :         // literals is unspecified, so always reallocate and copy to the new buffer if constant evaluated.
; 3506 : #if _HAS_CXX20
; 3507 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();

  00057	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  00062	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00066	48 2b c1	 sub	 rax, rcx
  00069	48 39 85 a8 00
	00 00		 cmp	 QWORD PTR _Count$[rbp], rax
  00070	77 12		 ja	 SHORT $LN9@insert
  00072	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00077	0f b6 c0	 movzx	 eax, al
  0007a	85 c0		 test	 eax, eax
  0007c	75 06		 jne	 SHORT $LN9@insert
  0007e	c6 45 69 01	 mov	 BYTE PTR tv81[rbp], 1
  00082	eb 04		 jmp	 SHORT $LN10@insert
$LN9@insert:
  00084	c6 45 69 00	 mov	 BYTE PTR tv81[rbp], 0
$LN10@insert:
  00088	0f b6 45 69	 movzx	 eax, BYTE PTR tv81[rbp]
  0008c	88 45 08	 mov	 BYTE PTR _Check_overlap$[rbp], al

; 3508 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 3509 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
; 3510 : #endif // _HAS_CXX20
; 3511 : 
; 3512 :         if (_Check_overlap) {

  0008f	0f b6 45 08	 movzx	 eax, BYTE PTR _Check_overlap$[rbp]
  00093	85 c0		 test	 eax, eax
  00095	0f 84 49 01 00
	00		 je	 $LN2@insert

; 3513 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3514 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0009b	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  000a2	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  000a6	48 03 c8	 add	 rcx, rax
  000a9	48 8b c1	 mov	 rax, rcx
  000ac	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b3	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 3515 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  000b7	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000be	48 8b c8	 mov	 rcx, rax
  000c1	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  000c6	48 89 45 10	 mov	 QWORD PTR _Old_ptr$1[rbp], rax

; 3516 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  000ca	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Off$[rbp]
  000d1	48 8b 4d 10	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  000d5	48 03 c8	 add	 rcx, rax
  000d8	48 8b c1	 mov	 rax, rcx
  000db	48 89 45 18	 mov	 QWORD PTR _Insert_at$2[rbp], rax

; 3517 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 3518 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 3519 :             size_type _Ptr_shifted_after;
; 3520 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {

  000df	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  000e6	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000ed	48 03 c8	 add	 rcx, rax
  000f0	48 8b c1	 mov	 rax, rcx
  000f3	48 3b 45 18	 cmp	 rax, QWORD PTR _Insert_at$2[rbp]
  000f7	76 17		 jbe	 SHORT $LN5@insert
  000f9	48 8b 45 00	 mov	 rax, QWORD PTR _Old_size$[rbp]
  000fd	48 8b 4d 10	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  00101	48 03 c8	 add	 rcx, rax
  00104	48 8b c1	 mov	 rax, rcx
  00107	48 39 85 a0 00
	00 00		 cmp	 QWORD PTR _Ptr$[rbp], rax
  0010e	76 0d		 jbe	 SHORT $LN3@insert
$LN5@insert:

; 3521 :                 // inserted content is before the shifted region, or does not alias
; 3522 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  00110	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  00117	48 89 45 20	 mov	 QWORD PTR _Ptr_shifted_after$3[rbp], rax
  0011b	eb 2c		 jmp	 SHORT $LN4@insert
$LN3@insert:

; 3523 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

  0011d	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ptr$[rbp]
  00124	48 39 45 18	 cmp	 QWORD PTR _Insert_at$2[rbp], rax
  00128	77 0a		 ja	 SHORT $LN6@insert

; 3524 :                 _Ptr_shifted_after = 0;

  0012a	48 c7 45 20 00
	00 00 00	 mov	 QWORD PTR _Ptr_shifted_after$3[rbp], 0

; 3525 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

  00132	eb 15		 jmp	 SHORT $LN7@insert
$LN6@insert:

; 3526 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00134	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ptr$[rbp]
  0013b	48 8b 4d 18	 mov	 rcx, QWORD PTR _Insert_at$2[rbp]
  0013f	48 2b c8	 sub	 rcx, rax
  00142	48 8b c1	 mov	 rax, rcx
  00145	48 89 45 20	 mov	 QWORD PTR _Ptr_shifted_after$3[rbp], rax
$LN7@insert:
$LN4@insert:

; 3527 :             }
; 3528 : 
; 3529 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00149	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR _Off$[rbp]
  00150	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  00154	48 2b c8	 sub	 rcx, rax
  00157	48 8b c1	 mov	 rax, rcx
  0015a	48 ff c0	 inc	 rax
  0015d	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  00164	48 8b 55 18	 mov	 rdx, QWORD PTR _Insert_at$2[rbp]
  00168	48 03 d1	 add	 rdx, rcx
  0016b	48 8b ca	 mov	 rcx, rdx
  0016e	4c 8b c0	 mov	 r8, rax
  00171	48 8b 55 18	 mov	 rdx, QWORD PTR _Insert_at$2[rbp]
  00175	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 3530 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);

  0017a	4c 8b 45 20	 mov	 r8, QWORD PTR _Ptr_shifted_after$3[rbp]
  0017e	48 8b 95 a0 00
	00 00		 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00185	48 8b 4d 18	 mov	 rcx, QWORD PTR _Insert_at$2[rbp]
  00189	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3531 :             _Traits::copy(

  0018e	48 8b 45 20	 mov	 rax, QWORD PTR _Ptr_shifted_after$3[rbp]
  00192	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  00199	48 2b c8	 sub	 rcx, rax
  0019c	48 8b c1	 mov	 rax, rcx
  0019f	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  001a6	48 8b 95 a0 00
	00 00		 mov	 rdx, QWORD PTR _Ptr$[rbp]
  001ad	48 03 d1	 add	 rdx, rcx
  001b0	48 8b ca	 mov	 rcx, rdx
  001b3	48 03 4d 20	 add	 rcx, QWORD PTR _Ptr_shifted_after$3[rbp]
  001b7	48 8b 55 20	 mov	 rdx, QWORD PTR _Ptr_shifted_after$3[rbp]
  001bb	4c 8b 45 18	 mov	 r8, QWORD PTR _Insert_at$2[rbp]
  001bf	4c 03 c2	 add	 r8, rdx
  001c2	49 8b d0	 mov	 rdx, r8
  001c5	48 89 55 70	 mov	 QWORD PTR tv146[rbp], rdx
  001c9	4c 8b c0	 mov	 r8, rax
  001cc	48 8b d1	 mov	 rdx, rcx
  001cf	48 8b 45 70	 mov	 rax, QWORD PTR tv146[rbp]
  001d3	48 8b c8	 mov	 rcx, rax
  001d6	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3532 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3533 :             return *this;

  001db	48 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001e2	eb 37		 jmp	 SHORT $LN1@insert
$LN2@insert:

; 3534 :         }
; 3535 : 
; 3536 :         return _Reallocate_grow_by(

  001e4	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  001eb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f0	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Ptr$[rbp]
  001f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fc	4c 8b 8d 98 00
	00 00		 mov	 r9, QWORD PTR _Off$[rbp]
  00203	44 0f b6 45 68	 movzx	 r8d, BYTE PTR $T4[rbp]
  00208	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _Count$[rbp]
  0020f	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00216	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>
$LN1@insert:

; 3537 :             _Count,
; 3538 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3539 :                 const _Elem* const _Ptr, const size_type _Count) {
; 3540 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3541 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3542 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3543 :             },
; 3544 :             _Off, _Ptr, _Count);
; 3545 :     }

  0021b	48 8d a5 80 00
	00 00		 lea	 rsp, QWORD PTR [rbp+128]
  00222	5d		 pop	 rbp
  00223	c3		 ret	 0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
_TEXT	SEGMENT
tv79 = 64
tv77 = 72
this$ = 96
_Off$ = 104
_Right$ = 112
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 3468 :     _CONSTEXPR20 basic_string& insert(const size_type _Off, const basic_string& _Right) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3469 :         // insert _Right at _Off
; 3470 :         return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00025	48 8b 45 70	 mov	 rax, QWORD PTR _Right$[rbp]
  00029	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002d	48 89 45 40	 mov	 QWORD PTR tv79[rbp], rax
  00031	48 8b 45 70	 mov	 rax, QWORD PTR _Right$[rbp]
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0003d	48 89 45 48	 mov	 QWORD PTR tv77[rbp], rax
  00041	4c 8b 4d 40	 mov	 r9, QWORD PTR tv79[rbp]
  00045	4c 8b 45 48	 mov	 r8, QWORD PTR tv77[rbp]
  00049	48 8b 55 68	 mov	 rdx, QWORD PTR _Off$[rbp]
  0004d	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00051	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 3471 :     }

  00056	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005a	5d		 pop	 rbp
  0005b	c3		 ret	 0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
_Old_ptr$1 = 0
$T2 = 72
$T3 = 73
this$ = 96
_Ptr$ = 104
_Count$ = 112
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 3386 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3387 :         // assign [_Ptr, _Ptr + _Count)
; 3388 :         if (_Count <= _Mypair._Myval2._Myres) {

  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0002d	48 39 45 70	 cmp	 QWORD PTR _Count$[rbp], rax
  00031	77 51		 ja	 SHORT $LN2@assign

; 3389 :             _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _Count);
; 3390 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00033	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00037	48 8b c8	 mov	 rcx, rax
  0003a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0003f	48 89 45 00	 mov	 QWORD PTR _Old_ptr$1[rbp], rax

; 3391 :             _Mypair._Myval2._Mysize = _Count;

  00043	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00047	48 8b 4d 70	 mov	 rcx, QWORD PTR _Count$[rbp]
  0004b	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 3392 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  0004f	4c 8b 45 70	 mov	 r8, QWORD PTR _Count$[rbp]
  00053	48 8b 55 68	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00057	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  0005b	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 3393 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00060	c6 45 48 00	 mov	 BYTE PTR $T2[rbp], 0
  00064	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  00068	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  0006c	48 03 c8	 add	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3394 :             return *this;

  0007e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00082	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3395 :         }
; 3396 : 
; 3397 :         return _Reallocate_for(

  00084	4c 8b 4d 68	 mov	 r9, QWORD PTR _Ptr$[rbp]
  00088	44 0f b6 45 49	 movzx	 r8d, BYTE PTR $T3[rbp]
  0008d	48 8b 55 70	 mov	 rdx, QWORD PTR _Count$[rbp]
  00091	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00095	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
$LN1@assign:

; 3398 :             _Count,
; 3399 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3400 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3401 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3402 :             },
; 3403 :             _Ptr);
; 3404 :     }

  0009a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0009e	5d		 pop	 rbp
  0009f	c3		 ret	 0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 3303 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3304 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00024	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Convert_size@_K_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64,unsigned __int64>
  00031	4c 8b c0	 mov	 r8, rax
  00034	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00038	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3305 :     }

  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
_Old_size$ = 0
_Old_ptr$1 = 8
$T2 = 80
$T3 = 81
this$ = 112
_Ptr$ = 120
_Count$ = 128
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 3280 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3281 :         // append [_Ptr, _Ptr + _Count)
; 3282 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00028	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00030	48 89 45 00	 mov	 QWORD PTR _Old_size$[rbp], rax

; 3283 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00034	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  0003c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00040	48 2b c1	 sub	 rax, rcx
  00043	48 39 85 80 00
	00 00		 cmp	 QWORD PTR _Count$[rbp], rax
  0004a	77 7b		 ja	 SHORT $LN2@append

; 3284 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3285 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0004c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  00053	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  00057	48 03 c8	 add	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00061	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 3286 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00065	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00069	48 8b c8	 mov	 rcx, rax
  0006c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00071	48 89 45 08	 mov	 QWORD PTR _Old_ptr$1[rbp], rax

; 3287 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00075	48 8b 45 00	 mov	 rax, QWORD PTR _Old_size$[rbp]
  00079	48 8b 4d 08	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  0007d	48 03 c8	 add	 rcx, rax
  00080	48 8b c1	 mov	 rax, rcx
  00083	4c 8b 85 80 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  0008a	48 8b 55 78	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 3288 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00096	c6 45 50 00	 mov	 BYTE PTR $T2[rbp], 0
  0009a	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  000a1	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_size$[rbp]
  000a5	48 03 c8	 add	 rcx, rax
  000a8	48 8b c1	 mov	 rax, rcx
  000ab	48 8b 4d 08	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  000af	48 03 c8	 add	 rcx, rax
  000b2	48 8b c1	 mov	 rax, rcx
  000b5	48 8d 55 50	 lea	 rdx, QWORD PTR $T2[rbp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3289 :             return *this;

  000c1	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  000c5	eb 25		 jmp	 SHORT $LN1@append
$LN2@append:

; 3290 :         }
; 3291 : 
; 3292 :         return _Reallocate_grow_by(

  000c7	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  000ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d3	4c 8b 4d 78	 mov	 r9, QWORD PTR _Ptr$[rbp]
  000d7	44 0f b6 45 51	 movzx	 r8d, BYTE PTR $T3[rbp]
  000dc	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Count$[rbp]
  000e3	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  000e7	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN1@append:

; 3293 :             _Count,
; 3294 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3295 :                 const size_type _Count) {
; 3296 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3297 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3298 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3299 :             },
; 3300 :             _Ptr, _Count);
; 3301 :     }

  000ec	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000f0	5d		 pop	 rbp
  000f1	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
tv78 = 64
tv76 = 72
this$ = 96
_Right$ = 104
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 3252 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3253 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00024	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00028	48 89 45 40	 mov	 QWORD PTR tv78[rbp], rax
  0002c	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00030	48 8b c8	 mov	 rcx, rax
  00033	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00038	48 89 45 48	 mov	 QWORD PTR tv76[rbp], rax
  0003c	4c 8b 45 40	 mov	 r8, QWORD PTR tv78[rbp]
  00040	48 8b 55 48	 mov	 rdx, QWORD PTR tv76[rbp]
  00044	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00048	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3254 :     }

  0004d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00051	5d		 pop	 rbp
  00052	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 3243 :     _CONSTEXPR20 basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3244 :         return append(_Ptr);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3245 :     }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 3232 :     _CONSTEXPR20 basic_string& operator+=(const basic_string& _Right) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3233 :         return append(_Right);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3234 :     }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
_Al$ = 0
_Right_al$ = 8
tv87 = 80
tv85 = 88
this$ = 112
_Right$ = 120
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 3165 :     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3166 :         if (this == _STD addressof(_Right)) {

  00023	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  00027	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
  0002c	48 39 45 70	 cmp	 QWORD PTR this$[rbp], rax
  00030	75 06		 jne	 SHORT $LN2@operator

; 3167 :             return *this;

  00032	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00036	eb 58		 jmp	 SHORT $LN1@operator
$LN2@operator:

; 3168 :         }
; 3169 : 
; 3170 :         auto& _Al             = _Getal();

  00038	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00041	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 3171 :         const auto& _Right_al = _Right._Getal();

  00045	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  00049	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0004e	48 89 45 08	 mov	 QWORD PTR _Right_al$[rbp], rax

; 3172 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3173 :             if (_Al != _Right_al) {
; 3174 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3175 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3176 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3177 : 
; 3178 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3179 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3180 :                     auto _New_capacity       = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3181 :                     auto _Right_al_non_const = _Right_al;
; 3182 :                     ++_New_capacity;
; 3183 :                     const auto _New_ptr = _Allocate_at_least_helper(_Right_al_non_const, _New_capacity); // throws
; 3184 :                     --_New_capacity;
; 3185 : 
; 3186 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 3187 : 
; 3188 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3189 :                     _Tidy_deallocate();
; 3190 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3191 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3192 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3193 :                 } else {
; 3194 :                     _Copy_assign_val_from_small(_Right);
; 3195 :                 }
; 3196 : 
; 3197 :                 _Pocca(_Al, _Right_al);
; 3198 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3199 :                 return *this;
; 3200 :             }
; 3201 :         }
; 3202 : 
; 3203 :         _Pocca(_Al, _Right_al);

  00052	48 8b 55 08	 mov	 rdx, QWORD PTR _Right_al$[rbp]
  00056	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  0005a	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >

; 3204 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0005f	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  00063	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00067	48 89 45 50	 mov	 QWORD PTR tv87[rbp], rax
  0006b	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00077	48 89 45 58	 mov	 QWORD PTR tv85[rbp], rax
  0007b	4c 8b 45 50	 mov	 r8, QWORD PTR tv87[rbp]
  0007f	48 8b 55 58	 mov	 rdx, QWORD PTR tv85[rbp]
  00083	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00087	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3205 :         return *this;

  0008c	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
$LN1@operator:

; 3206 :     }

  00090	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00094	5d		 pop	 rbp
  00095	c3		 ret	 0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S6$ = 8
_To_delete$ = 16
this$ = 112
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3128 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3129 :         _Tidy_deallocate();

  0001e	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00022	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3130 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3131 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00027	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8d 4d 08	 lea	 rcx, QWORD PTR $S6$[rbp]
  00037	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0003c	48 8d 45 08	 lea	 rax, QWORD PTR $S6$[rbp]
  00040	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 3132 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

  00044	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 89 45 10	 mov	 QWORD PTR _To_delete$[rbp], rax

; 3133 :         _Mypair._Myval2._Myproxy = nullptr;

  0004f	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00053	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3134 :         _Delete_plain_internal(_Alproxy, _To_delete);

  0005a	48 8b 55 10	 mov	 rdx, QWORD PTR _To_delete$[rbp]
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  00062	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 3135 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3136 :     }

  00067	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00073	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00077	5d		 pop	 rbp
  00078	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
_My_data$ = 0
_Right_data$ = 8
tv140 = 80
this$ = 112
_Right$ = 120
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 3012 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3013 :         // assign by stealing _Right's buffer
; 3014 :         // pre: this != &_Right
; 3015 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3016 :         // pre: *this owns no memory, iterators orphaned
; 3017 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3018 :         auto& _My_data    = _Mypair._Myval2;

  00023	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 3019 :         auto& _Right_data = _Right._Mypair._Myval2;

  0002b	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  0002f	48 89 45 08	 mov	 QWORD PTR _Right_data$[rbp], rax

; 3020 : 
; 3021 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3022 :         if constexpr (_Can_memcpy_val) {
; 3023 : #if _HAS_CXX20
; 3024 :             if (!_STD is_constant_evaluated())

  00033	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00038	0f b6 c0	 movzx	 eax, al
  0003b	85 c0		 test	 eax, eax
  0003d	75 43		 jne	 SHORT $LN2@Take_conte

; 3025 : #endif // _HAS_CXX20
; 3026 :             {
; 3027 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3028 :                 if (_Right_data._Large_string_engaged()) {

  0003f	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00043	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	74 0f		 je	 SHORT $LN3@Take_conte

; 3029 :                     // take ownership of _Right's iterators along with its buffer
; 3030 :                     _Swap_proxy_and_iterators(_Right);

  0004f	48 8b 55 78	 mov	 rdx, QWORD PTR _Right$[rbp]
  00053	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00057	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 3031 :                 } else {

  0005c	eb 09		 jmp	 SHORT $LN4@Take_conte
$LN3@Take_conte:

; 3032 :                     _Right_data._Orphan_all();

  0005e	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00062	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
$LN4@Take_conte:

; 3033 :                 }
; 3034 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3035 : 
; 3036 :                 _Memcpy_val_from(_Right);

  00067	48 8b 55 78	 mov	 rdx, QWORD PTR _Right$[rbp]
  0006b	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0006f	e8 00 00 00 00	 call	 ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 3037 :                 _Right._Tidy_init();

  00074	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  00078	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 3038 :                 return;

  0007d	e9 af 00 00 00	 jmp	 $LN1@Take_conte
$LN2@Take_conte:

; 3039 :             }
; 3040 :         }
; 3041 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3042 : 
; 3043 :         if (_Right_data._Large_string_engaged()) { // steal buffer

  00082	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00086	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0008b	0f b6 c0	 movzx	 eax, al
  0008e	85 c0		 test	 eax, eax
  00090	74 33		 je	 SHORT $LN5@Take_conte

; 3044 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

  00092	48 8b 45 08	 mov	 rax, QWORD PTR _Right_data$[rbp]
  00096	48 83 c0 08	 add	 rax, 8
  0009a	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0009e	48 83 c1 08	 add	 rcx, 8
  000a2	48 8b d0	 mov	 rdx, rax
  000a5	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>

; 3045 :             _Right_data._Bx._Ptr = nullptr;

  000aa	48 8b 45 08	 mov	 rax, QWORD PTR _Right_data$[rbp]
  000ae	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 3046 :             _Swap_proxy_and_iterators(_Right);

  000b6	48 8b 55 78	 mov	 rdx, QWORD PTR _Right$[rbp]
  000ba	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  000be	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 3047 :         } else { // copy small string buffer

  000c3	eb 43		 jmp	 SHORT $LN6@Take_conte
$LN5@Take_conte:

; 3048 :             _My_data._Activate_SSO_buffer();

  000c5	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  000c9	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 3049 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

  000ce	48 8b 45 08	 mov	 rax, QWORD PTR _Right_data$[rbp]
  000d2	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d6	48 ff c0	 inc	 rax
  000d9	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  000dd	48 83 c1 08	 add	 rcx, 8
  000e1	48 8b 55 00	 mov	 rdx, QWORD PTR _My_data$[rbp]
  000e5	48 83 c2 08	 add	 rdx, 8
  000e9	48 89 55 50	 mov	 QWORD PTR tv140[rbp], rdx
  000ed	4c 8b c0	 mov	 r8, rax
  000f0	48 8b d1	 mov	 rdx, rcx
  000f3	48 8b 45 50	 mov	 rax, QWORD PTR tv140[rbp]
  000f7	48 8b c8	 mov	 rcx, rax
  000fa	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3050 :             _Right_data._Orphan_all();

  000ff	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00103	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
$LN6@Take_conte:

; 3051 :         }
; 3052 : 
; 3053 :         _My_data._Myres  = _Right_data._Myres;

  00108	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0010c	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00110	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00114	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 3054 :         _My_data._Mysize = _Right_data._Mysize;

  00118	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0011c	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00120	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00124	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 3055 : 
; 3056 :         _Right._Tidy_init();

  00128	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  0012c	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
$LN1@Take_conte:

; 3057 :     }

  00131	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00135	5d		 pop	 rbp
  00136	c3		 ret	 0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
_My_data_mem$ = 0
_Right_data_mem$ = 8
this$ = 96
_Right$ = 104
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT

; 3003 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3004 :         _STL_INTERNAL_CHECK(_Can_memcpy_val);
; 3005 :         const auto _My_data_mem =

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0002c	48 83 c0 08	 add	 rax, 8
  00030	48 89 45 00	 mov	 QWORD PTR _My_data_mem$[rbp], rax

; 3006 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3007 :         const auto _Right_data_mem =

  00034	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
  00040	48 83 c0 08	 add	 rax, 8
  00044	48 89 45 08	 mov	 QWORD PTR _Right_data_mem$[rbp], rax

; 3008 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3009 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00048	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0004e	48 8b 55 08	 mov	 rdx, QWORD PTR _Right_data_mem$[rbp]
  00052	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data_mem$[rbp]
  00056	e8 00 00 00 00	 call	 memcpy

; 3010 :     }

  0005b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
_Al$ = 0
_Right_al$ = 8
_Pocma_val$ = 16
this$ = 112
_Right$ = 120
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2970 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2971 :         if (this == _STD addressof(_Right)) {

  00023	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  00027	e8 00 00 00 00	 call	 ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0002c	48 39 45 70	 cmp	 QWORD PTR this$[rbp], rax
  00030	75 06		 jne	 SHORT $LN2@operator

; 2972 :             return *this;

  00032	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00036	eb 48		 jmp	 SHORT $LN1@operator
$LN2@operator:

; 2973 :         }
; 2974 : 
; 2975 :         auto& _Al                 = _Getal();

  00038	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00041	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 2976 :         auto& _Right_al           = _Right._Getal();

  00045	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  00049	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0004e	48 89 45 08	 mov	 QWORD PTR _Right_al$[rbp], rax

; 2977 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;

  00052	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _Pocma_val$[rbp], 0

; 2978 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 2979 :             if (_Al != _Right_al) {
; 2980 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2981 :                 _Mypair._Myval2._Orphan_all();
; 2982 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 2983 :             }
; 2984 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 2985 :             if (_Al != _Right_al) {
; 2986 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2987 :                 return *this;
; 2988 :             }
; 2989 :         }
; 2990 : 
; 2991 :         _Tidy_deallocate();

  00059	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0005d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2992 :         _Pocma(_Al, _Right_al);

  00062	48 8b 55 08	 mov	 rdx, QWORD PTR _Right_al$[rbp]
  00066	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  0006a	e8 00 00 00 00	 call	 ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >

; 2993 :         _Take_contents(_Right);

  0006f	48 8b 55 78	 mov	 rdx, QWORD PTR _Right$[rbp]
  00073	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00077	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2994 :         return *this;

  0007c	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
$LN1@operator:

; 2995 :     }

  00080	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00084	5d		 pop	 rbp
  00085	c3		 ret	 0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
_TEXT	SEGMENT
_My_data$ = 0
_Left_data$ = 8
_Right_data$ = 16
_Left_size$ = 24
_Right_size$ = 32
_Left_capacity$ = 40
_Right_capacity$ = 48
_New_size$ = 56
_Fits_in_left$ = 64
_Ptr$1 = 72
_Fits_in_right$ = 80
_Ptr$2 = 88
_Max$ = 96
_New_capacity$ = 104
_Alproxy$ = 112
$S17$ = 120
_Proxy$ = 128
_Fancyptr$ = 144
_Ptr$ = 152
$T3 = 224
$T4 = 225
$T5 = 226
$T6 = 227
tv162 = 228
tv133 = 228
tv257 = 232
tv242 = 232
tv173 = 232
tv153 = 232
tv75 = 232
tv240 = 240
tv171 = 240
tv73 = 240
this$ = 272
__formal$ = 280
_Left$ = 288
_Right$ = 296
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2820 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

$LN13:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  0001b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0002c	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	48 89 85 e8 00
	00 00		 mov	 QWORD PTR tv75[rbp], rax
  0003a	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR _Left$[rbp]
  00041	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00046	48 89 85 f0 00
	00 00		 mov	 QWORD PTR tv73[rbp], rax
  0004d	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR $T3[rbp]
  00054	88 85 e1 00 00
	00		 mov	 BYTE PTR $T4[rbp], al
  0005a	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR tv73[rbp]
  00061	0f b6 95 e1 00
	00 00		 movzx	 edx, BYTE PTR $T4[rbp]
  00068	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR tv75[rbp]
  0006f	e8 00 00 00 00	 call	 ??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
  00074	90		 npad	 1

; 2821 :         auto& _My_data    = _Mypair._Myval2;

  00075	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007c	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 2822 :         auto& _Left_data  = _Left._Mypair._Myval2;

  00080	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR _Left$[rbp]
  00087	48 89 45 08	 mov	 QWORD PTR _Left_data$[rbp], rax

; 2823 :         auto& _Right_data = _Right._Mypair._Myval2;

  0008b	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR _Right$[rbp]
  00092	48 89 45 10	 mov	 QWORD PTR _Right_data$[rbp], rax

; 2824 :         _Left_data._Orphan_all();

  00096	48 8b 4d 08	 mov	 rcx, QWORD PTR _Left_data$[rbp]
  0009a	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 2825 :         _Right_data._Orphan_all();

  0009f	48 8b 4d 10	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  000a3	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 2826 :         const auto _Left_size  = _Left_data._Mysize;

  000a8	48 8b 45 08	 mov	 rax, QWORD PTR _Left_data$[rbp]
  000ac	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000b0	48 89 45 18	 mov	 QWORD PTR _Left_size$[rbp], rax

; 2827 :         const auto _Right_size = _Right_data._Mysize;

  000b4	48 8b 45 10	 mov	 rax, QWORD PTR _Right_data$[rbp]
  000b8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000bc	48 89 45 20	 mov	 QWORD PTR _Right_size$[rbp], rax

; 2828 : 
; 2829 :         const auto _Left_capacity  = _Left_data._Myres;

  000c0	48 8b 45 08	 mov	 rax, QWORD PTR _Left_data$[rbp]
  000c4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c8	48 89 45 28	 mov	 QWORD PTR _Left_capacity$[rbp], rax

; 2830 :         const auto _Right_capacity = _Right_data._Myres;

  000cc	48 8b 45 10	 mov	 rax, QWORD PTR _Right_data$[rbp]
  000d0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000d4	48 89 45 30	 mov	 QWORD PTR _Right_capacity$[rbp], rax

; 2831 :         // overflow is OK due to max_size() checks:
; 2832 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);

  000d8	48 8b 45 20	 mov	 rax, QWORD PTR _Right_size$[rbp]
  000dc	48 8b 4d 18	 mov	 rcx, QWORD PTR _Left_size$[rbp]
  000e0	48 03 c8	 add	 rcx, rax
  000e3	48 8b c1	 mov	 rax, rcx
  000e6	48 89 45 38	 mov	 QWORD PTR _New_size$[rbp], rax

; 2833 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;

  000ea	48 8b 45 18	 mov	 rax, QWORD PTR _Left_size$[rbp]
  000ee	48 8b 4d 28	 mov	 rcx, QWORD PTR _Left_capacity$[rbp]
  000f2	48 2b c8	 sub	 rcx, rax
  000f5	48 8b c1	 mov	 rax, rcx
  000f8	48 39 45 20	 cmp	 QWORD PTR _Right_size$[rbp], rax
  000fc	77 09		 ja	 SHORT $LN6@basic_stri
  000fe	c6 85 e4 00 00
	00 01		 mov	 BYTE PTR tv133[rbp], 1
  00105	eb 07		 jmp	 SHORT $LN7@basic_stri
$LN6@basic_stri:
  00107	c6 85 e4 00 00
	00 00		 mov	 BYTE PTR tv133[rbp], 0
$LN7@basic_stri:
  0010e	0f b6 85 e4 00
	00 00		 movzx	 eax, BYTE PTR tv133[rbp]
  00115	88 45 40	 mov	 BYTE PTR _Fits_in_left$[rbp], al

; 2834 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {

  00118	0f b6 45 40	 movzx	 eax, BYTE PTR _Fits_in_left$[rbp]
  0011c	85 c0		 test	 eax, eax
  0011e	0f 84 9d 00 00
	00		 je	 $LN2@basic_stri
  00124	48 8b 45 28	 mov	 rax, QWORD PTR _Left_capacity$[rbp]
  00128	48 39 45 30	 cmp	 QWORD PTR _Right_capacity$[rbp], rax
  0012c	0f 87 8f 00 00
	00		 ja	 $LN2@basic_stri

; 2835 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2836 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block

  00132	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00139	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0013e	48 8b d0	 mov	 rdx, rax
  00141	48 8d 8d e2 00
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  00148	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0014d	48 8b d0	 mov	 rdx, rax
  00150	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00154	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2837 :             _Take_contents(_Left);

  00159	48 8b 95 20 01
	00 00		 mov	 rdx, QWORD PTR _Left$[rbp]
  00160	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00167	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2838 :             const auto _Ptr = _My_data._Myptr();

  0016c	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00170	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00175	48 89 45 48	 mov	 QWORD PTR _Ptr$1[rbp], rax

; 2839 :             _ASAN_STRING_MODIFY(*this, _Left_size, _New_size);
; 2840 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  00179	48 8b 45 20	 mov	 rax, QWORD PTR _Right_size$[rbp]
  0017d	48 ff c0	 inc	 rax
  00180	48 89 85 e8 00
	00 00		 mov	 QWORD PTR tv153[rbp], rax
  00187	48 8b 4d 10	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  0018b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00190	48 8b 4d 18	 mov	 rcx, QWORD PTR _Left_size$[rbp]
  00194	48 8b 55 48	 mov	 rdx, QWORD PTR _Ptr$1[rbp]
  00198	48 03 d1	 add	 rdx, rcx
  0019b	48 8b ca	 mov	 rcx, rdx
  0019e	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR tv153[rbp]
  001a5	4c 8b c2	 mov	 r8, rdx
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2841 :             _My_data._Mysize = _New_size;

  001b0	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  001b4	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_size$[rbp]
  001b8	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2842 :             return;

  001bc	e9 a3 02 00 00	 jmp	 $LN1@basic_stri
$LN2@basic_stri:

; 2843 :         }
; 2844 : 
; 2845 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;

  001c1	48 8b 45 20	 mov	 rax, QWORD PTR _Right_size$[rbp]
  001c5	48 8b 4d 30	 mov	 rcx, QWORD PTR _Right_capacity$[rbp]
  001c9	48 2b c8	 sub	 rcx, rax
  001cc	48 8b c1	 mov	 rax, rcx
  001cf	48 39 45 18	 cmp	 QWORD PTR _Left_size$[rbp], rax
  001d3	77 09		 ja	 SHORT $LN8@basic_stri
  001d5	c6 85 e4 00 00
	00 01		 mov	 BYTE PTR tv162[rbp], 1
  001dc	eb 07		 jmp	 SHORT $LN9@basic_stri
$LN8@basic_stri:
  001de	c6 85 e4 00 00
	00 00		 mov	 BYTE PTR tv162[rbp], 0
$LN9@basic_stri:
  001e5	0f b6 85 e4 00
	00 00		 movzx	 eax, BYTE PTR tv162[rbp]
  001ec	88 45 50	 mov	 BYTE PTR _Fits_in_right$[rbp], al

; 2846 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {

  001ef	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  001f6	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  001fb	48 89 85 e8 00
	00 00		 mov	 QWORD PTR tv173[rbp], rax
  00202	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00209	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0020e	48 89 85 f0 00
	00 00		 mov	 QWORD PTR tv171[rbp], rax
  00215	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR tv173[rbp]
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR tv171[rbp]
  00223	e8 00 00 00 00	 call	 ??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z ; std::_Allocators_equal<std::allocator<char> >
  00228	0f b6 c0	 movzx	 eax, al
  0022b	85 c0		 test	 eax, eax
  0022d	0f 84 a2 00 00
	00		 je	 $LN3@basic_stri
  00233	0f b6 45 50	 movzx	 eax, BYTE PTR _Fits_in_right$[rbp]
  00237	85 c0		 test	 eax, eax
  00239	0f 84 96 00 00
	00		 je	 $LN3@basic_stri

; 2847 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2848 :             // At this point, we have tested:
; 2849 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2850 :             // therefore: (by De Morgan's Laws)
; 2851 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2852 :             // therefore: (by the distributive property)
; 2853 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2854 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2855 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_string_engaged()
; 2856 :             _STL_INTERNAL_CHECK(_Right_data._Large_string_engaged());
; 2857 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block

  0023f	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00246	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0024b	48 8b d0	 mov	 rdx, rax
  0024e	48 8d 8d e3 00
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  00255	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0025a	48 8b d0	 mov	 rdx, rax
  0025d	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00261	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2858 :             _Take_contents(_Right);

  00266	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR _Right$[rbp]
  0026d	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00274	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2859 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);

  00279	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0027d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00281	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00286	48 89 45 58	 mov	 QWORD PTR _Ptr$2[rbp], rax

; 2860 :             _ASAN_STRING_MODIFY(*this, _Right_size, _New_size);
; 2861 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);

  0028a	48 8b 45 20	 mov	 rax, QWORD PTR _Right_size$[rbp]
  0028e	48 ff c0	 inc	 rax
  00291	48 8b 4d 18	 mov	 rcx, QWORD PTR _Left_size$[rbp]
  00295	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$2[rbp]
  00299	48 03 d1	 add	 rdx, rcx
  0029c	48 8b ca	 mov	 rcx, rdx
  0029f	4c 8b c0	 mov	 r8, rax
  002a2	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$2[rbp]
  002a6	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 2862 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);

  002ab	48 8b 4d 08	 mov	 rcx, QWORD PTR _Left_data$[rbp]
  002af	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  002b4	4c 8b 45 18	 mov	 r8, QWORD PTR _Left_size$[rbp]
  002b8	48 8b d0	 mov	 rdx, rax
  002bb	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$2[rbp]
  002bf	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2863 :             _My_data._Mysize = _New_size;

  002c4	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  002c8	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_size$[rbp]
  002cc	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2864 :             return;

  002d0	e9 8f 01 00 00	 jmp	 $LN1@basic_stri
$LN3@basic_stri:

; 2865 :         }
; 2866 : 
; 2867 :         // can't use either buffer, reallocate
; 2868 :         const auto _Max = max_size();

  002d5	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  002dc	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  002e1	48 89 45 60	 mov	 QWORD PTR _Max$[rbp], rax

; 2869 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK

  002e5	48 8b 45 18	 mov	 rax, QWORD PTR _Left_size$[rbp]
  002e9	48 8b 4d 60	 mov	 rcx, QWORD PTR _Max$[rbp]
  002ed	48 2b c8	 sub	 rcx, rax
  002f0	48 8b c1	 mov	 rax, rcx
  002f3	48 3b 45 20	 cmp	 rax, QWORD PTR _Right_size$[rbp]
  002f7	73 05		 jae	 SHORT $LN4@basic_stri

; 2870 :             _Xlen_string();

  002f9	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN4@basic_stri:

; 2871 :         }
; 2872 : 
; 2873 :         auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);

  002fe	4c 8b 45 60	 mov	 r8, QWORD PTR _Max$[rbp]
  00302	ba 0f 00 00 00	 mov	 edx, 15
  00307	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_size$[rbp]
  0030b	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00310	48 89 45 68	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2874 :         auto&& _Alproxy    = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00314	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0031b	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00320	48 8b d0	 mov	 rdx, rax
  00323	48 8d 4d 78	 lea	 rcx, QWORD PTR $S17$[rbp]
  00327	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0032c	48 8d 45 78	 lea	 rax, QWORD PTR $S17$[rbp]
  00330	48 89 45 70	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 2875 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws

  00334	4c 8b 45 00	 mov	 r8, QWORD PTR _My_data$[rbp]
  00338	48 8b 55 70	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  0033c	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00343	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00348	90		 npad	 1

; 2876 :         ++_New_capacity;

  00349	48 8b 45 68	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  0034d	48 ff c0	 inc	 rax
  00350	48 89 45 68	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2877 :         const pointer _Fancyptr = _Allocate_at_least_helper(_Getal(), _New_capacity); // throws

  00354	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0035b	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00360	48 8d 55 68	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  00364	48 8b c8	 mov	 rcx, rax
  00367	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  0036c	48 89 85 90 00
	00 00		 mov	 QWORD PTR _Fancyptr$[rbp], rax

; 2878 :         --_New_capacity;

  00373	48 8b 45 68	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00377	48 ff c8	 dec	 rax
  0037a	48 89 45 68	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2879 :         // nothrow hereafter
; 2880 :         _Start_element_lifetimes(_Unfancy(_Fancyptr), _New_capacity + 1);

  0037e	48 8b 45 68	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00382	48 ff c0	 inc	 rax
  00385	48 89 85 e8 00
	00 00		 mov	 QWORD PTR tv242[rbp], rax
  0038c	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Fancyptr$[rbp]
  00393	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00398	48 89 85 f0 00
	00 00		 mov	 QWORD PTR tv240[rbp], rax
  0039f	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR tv242[rbp]
  003a6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR tv240[rbp]
  003ad	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 2881 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  003b2	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  003b6	48 83 c0 08	 add	 rax, 8
  003ba	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR _Fancyptr$[rbp]
  003c1	48 8b c8	 mov	 rcx, rax
  003c4	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2882 :         _My_data._Mysize = _New_size;

  003c9	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  003cd	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_size$[rbp]
  003d1	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2883 :         _My_data._Myres  = _New_capacity;

  003d5	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  003d9	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  003dd	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2884 :         const auto _Ptr  = _Unfancy(_Fancyptr);

  003e1	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR _Fancyptr$[rbp]
  003e8	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  003ed	48 89 85 98 00
	00 00		 mov	 QWORD PTR _Ptr$[rbp], rax

; 2885 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);

  003f4	48 8b 4d 08	 mov	 rcx, QWORD PTR _Left_data$[rbp]
  003f8	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  003fd	4c 8b 45 18	 mov	 r8, QWORD PTR _Left_size$[rbp]
  00401	48 8b d0	 mov	 rdx, rax
  00404	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0040b	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2886 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  00410	48 8b 45 20	 mov	 rax, QWORD PTR _Right_size$[rbp]
  00414	48 ff c0	 inc	 rax
  00417	48 89 85 e8 00
	00 00		 mov	 QWORD PTR tv257[rbp], rax
  0041e	48 8b 4d 10	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00422	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00427	48 8b 4d 18	 mov	 rcx, QWORD PTR _Left_size$[rbp]
  0042b	48 8b 95 98 00
	00 00		 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00432	48 03 d1	 add	 rdx, rcx
  00435	48 8b ca	 mov	 rcx, rdx
  00438	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR tv257[rbp]
  0043f	4c 8b c2	 mov	 r8, rdx
  00442	48 8b d0	 mov	 rdx, rax
  00445	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2887 :         _ASAN_STRING_CREATE(*this);
; 2888 :         _Proxy._Release();

  0044a	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00451	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  00456	90		 npad	 1

; 2889 :     }

  00457	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0045e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00463	90		 npad	 1
$LN1@basic_stri:
  00464	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0046b	48 8d a5 00 01
	00 00		 lea	 rsp, QWORD PTR [rbp+256]
  00472	5d		 pop	 rbp
  00473	c3		 ret	 0
$LN12@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 0
_Left_data$ = 8
_Right_data$ = 16
_Left_size$ = 24
_Right_size$ = 32
_Left_capacity$ = 40
_Right_capacity$ = 48
_New_size$ = 56
_Fits_in_left$ = 64
_Ptr$1 = 72
_Fits_in_right$ = 80
_Ptr$2 = 88
_Max$ = 96
_New_capacity$ = 104
_Alproxy$ = 112
$S17$ = 120
_Proxy$ = 128
_Fancyptr$ = 144
_Ptr$ = 152
$T3 = 224
$T4 = 225
$T5 = 226
$T6 = 227
tv162 = 228
tv133 = 228
tv257 = 232
tv242 = 232
tv173 = 232
tv153 = 232
tv75 = 232
tv240 = 240
tv171 = 240
tv73 = 240
this$ = 272
__formal$ = 280
_Left$ = 288
_Right$ = 296
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 0
_Left_data$ = 8
_Right_data$ = 16
_Left_size$ = 24
_Right_size$ = 32
_Left_capacity$ = 40
_Right_capacity$ = 48
_New_size$ = 56
_Fits_in_left$ = 64
_Ptr$1 = 72
_Fits_in_right$ = 80
_Ptr$2 = 88
_Max$ = 96
_New_capacity$ = 104
_Alproxy$ = 112
$S17$ = 120
_Proxy$ = 128
_Fancyptr$ = 144
_Ptr$ = 152
$T3 = 224
$T4 = 225
$T5 = 226
$T6 = 227
tv162 = 228
tv133 = 228
tv257 = 232
tv242 = 232
tv173 = 232
tv153 = 232
tv75 = 232
tv240 = 240
tv171 = 240
tv73 = 240
this$ = 272
__formal$ = 280
_Left$ = 288
_Right$ = 296
?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR _Proxy$[rbp]
  00011	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
$T3 = 66
tv92 = 72
tv75 = 72
tv73 = 80
this$ = 112
_Right$ = 120
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2764 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00023	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  0002b	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  0002f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00034	48 89 45 50	 mov	 QWORD PTR tv73[rbp], rax
  00038	0f b6 45 40	 movzx	 eax, BYTE PTR $T1[rbp]
  0003c	88 45 41	 mov	 BYTE PTR $T2[rbp], al
  0003f	4c 8b 45 50	 mov	 r8, QWORD PTR tv73[rbp]
  00043	0f b6 55 41	 movzx	 edx, BYTE PTR $T2[rbp]
  00047	48 8b 4d 48	 mov	 rcx, QWORD PTR tv75[rbp]
  0004b	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >

; 2765 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00050	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00054	48 89 45 48	 mov	 QWORD PTR tv92[rbp], rax
  00058	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0005c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00061	48 8b d0	 mov	 rdx, rax
  00064	48 8d 4d 42	 lea	 rcx, QWORD PTR $T3[rbp]
  00068	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 4d 48	 mov	 rcx, QWORD PTR tv92[rbp]
  00074	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2766 :         _Take_contents(_Right);

  00079	48 8b 55 78	 mov	 rdx, QWORD PTR _Right$[rbp]
  0007d	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00081	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2767 :     }

  00086	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0008a	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0008e	5d		 pop	 rbp
  0008f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z
_TEXT	SEGMENT
_Idx$1 = 0
_Ptr$ = 96
_Size$ = 104
?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes, COMDAT

; 2591 :     static constexpr void _Start_element_lifetimes(_Elem* const _Ptr, const size_type _Size) {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2592 :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 2593 :         // but likely more impactful to throughput.
; 2594 : #if _HAS_CXX20
; 2595 :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 37		 je	 SHORT $LN5@Start_elem

; 2596 :             for (size_type _Idx = 0; _Idx < _Size; ++_Idx) {

  0002c	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Idx$1[rbp], 0
  00034	eb 0b		 jmp	 SHORT $LN4@Start_elem
$LN2@Start_elem:
  00036	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  0003a	48 ff c0	 inc	 rax
  0003d	48 89 45 00	 mov	 QWORD PTR _Idx$1[rbp], rax
$LN4@Start_elem:
  00041	48 8b 45 68	 mov	 rax, QWORD PTR _Size$[rbp]
  00045	48 39 45 00	 cmp	 QWORD PTR _Idx$1[rbp], rax
  00049	73 18		 jae	 SHORT $LN3@Start_elem

; 2597 :                 _STD construct_at(_Ptr + _Idx);

  0004b	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  0004f	48 8b 4d 60	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00053	48 03 c8	 add	 rcx, rax
  00056	48 8b c1	 mov	 rax, rcx
  00059	48 8b c8	 mov	 rcx, rax
  0005c	e8 00 00 00 00	 call	 ??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z ; std::construct_at<char,0>

; 2598 :             }

  00061	eb d3		 jmp	 SHORT $LN2@Start_elem
$LN3@Start_elem:
$LN5@Start_elem:

; 2599 :         }
; 2600 : #else // ^^^ C++20-or-later / pre-C++20 vvv
; 2601 :         (void) _Ptr;
; 2602 :         (void) _Size;
; 2603 : #endif // _HAS_CXX20
; 2604 :     }

  00063	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00067	5d		 pop	 rbp
  00068	c3		 ret	 0
?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 64
tv69 = 72
this$ = 96
_Ptr$ = 104
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2538 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 48	 mov	 QWORD PTR tv69[rbp], rax
  00028	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  0002c	48 8b 4d 48	 mov	 rcx, QWORD PTR tv69[rbp]
  00030	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  00035	90		 npad	 1

; 2539 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0003a	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ??$_Convert_size@_K_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64,unsigned __int64>
  00047	4c 8b c0	 mov	 r8, rax
  0004a	48 8b 55 68	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  0004e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00052	e8 00 00 00 00	 call	 ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
  00057	90		 npad	 1

; 2540 :     }

  00058	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0005c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
tv69 = 72
this$ = 96
_Ptr$ = 104
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
$T3 = 66
tv94 = 72
tv78 = 72
tv92 = 80
tv76 = 80
this$ = 112
_Right$ = 120
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2490 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00023	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 89 45 48	 mov	 QWORD PTR tv78[rbp], rax
  0002b	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  0002f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00034	48 8b d0	 mov	 rdx, rax
  00037	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0003b	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
  00040	48 89 45 50	 mov	 QWORD PTR tv76[rbp], rax
  00044	0f b6 45 41	 movzx	 eax, BYTE PTR $T2[rbp]
  00048	88 45 42	 mov	 BYTE PTR $T3[rbp], al
  0004b	4c 8b 45 50	 mov	 r8, QWORD PTR tv76[rbp]
  0004f	0f b6 55 42	 movzx	 edx, BYTE PTR $T3[rbp]
  00053	48 8b 4d 48	 mov	 rcx, QWORD PTR tv78[rbp]
  00057	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
  0005c	90		 npad	 1

; 2491 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0005d	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  00061	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00065	48 89 45 48	 mov	 QWORD PTR tv94[rbp], rax
  00069	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00075	48 89 45 50	 mov	 QWORD PTR tv92[rbp], rax
  00079	4c 8b 45 48	 mov	 r8, QWORD PTR tv94[rbp]
  0007d	48 8b 55 50	 mov	 rdx, QWORD PTR tv92[rbp]
  00081	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00085	e8 00 00 00 00	 call	 ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
  0008a	90		 npad	 1

; 2492 :     }

  0008b	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0008f	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00093	5d		 pop	 rbp
  00094	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 65
$T3 = 66
tv94 = 72
tv78 = 72
tv92 = 80
tv76 = 80
this$ = 112
_Right$ = 120
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
tv86 = 72
tv69 = 72
this$ = 96
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2479 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 89 45 48	 mov	 QWORD PTR tv69[rbp], rax
  00023	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00027	48 8b 4d 48	 mov	 rcx, QWORD PTR tv69[rbp]
  0002b	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2480 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 89 45 48	 mov	 QWORD PTR tv86[rbp], rax
  00038	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00041	48 8b d0	 mov	 rdx, rax
  00044	48 8d 4d 41	 lea	 rcx, QWORD PTR $T2[rbp]
  00048	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0004d	48 8b d0	 mov	 rdx, rax
  00050	48 8b 4d 48	 mov	 rcx, QWORD PTR tv86[rbp]
  00054	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2481 :         _Tidy_init();

  00059	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0005d	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2482 :     }

  00062	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00066	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 83 c0 08	 add	 rax, 8
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 2284 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 96
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 2283 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00017	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00020	48 8b 7d 60	 mov	 rdi, QWORD PTR this$[rbp]
  00024	33 c0		 xor	 eax, eax
  00026	b9 10 00 00 00	 mov	 ecx, 16
  0002b	f3 aa		 rep stosb
  0002d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8d 65 48	 lea	 rsp, QWORD PTR [rbp+72]
  00035	5f		 pop	 rdi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Off$ = 104
_Size$ = 112
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT

; 2275 :     _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2276 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2277 :         return (_STD min)(_Size, _Mysize - _Off);

  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 4d 68	 mov	 rcx, QWORD PTR _Off$[rbp]
  0002d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00031	48 2b c1	 sub	 rax, rcx
  00034	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00038	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0003c	48 8d 4d 70	 lea	 rcx, QWORD PTR _Size$[rbp]
  00040	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 2278 :     }

  00048	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2271 :     [[noreturn]] static void _Xran() {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2272 :         _Xout_of_range("invalid string position");

  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  0001e	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 2273 :     }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Off$ = 88
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 2257 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2258 :         // checks whether _Off is in the bounds of [0, size()]
; 2259 :         if (_Mysize < _Off) {

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Off$[rbp]
  00028	48 39 48 18	 cmp	 QWORD PTR [rax+24], rcx
  0002c	73 05		 jae	 SHORT $LN2@Check_offs

; 2260 :             _Xran();

  0002e	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN2@Check_offs:
$LN3@Check_offs:

; 2261 :         }
; 2262 :     }

  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Idx$1 = 0
this$ = 96
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 2246 :     constexpr void _Activate_SSO_buffer() noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2247 :         // start the lifetime of the array elements
; 2248 : #if _HAS_CXX20
; 2249 :         if (_STD is_constant_evaluated()) {

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 30		 je	 SHORT $LN5@Activate_S

; 2250 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {

  00027	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Idx$1[rbp], 0
  0002f	eb 0b		 jmp	 SHORT $LN4@Activate_S
$LN2@Activate_S:
  00031	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  00035	48 ff c0	 inc	 rax
  00038	48 89 45 00	 mov	 QWORD PTR _Idx$1[rbp], rax
$LN4@Activate_S:
  0003c	48 83 7d 00 10	 cmp	 QWORD PTR _Idx$1[rbp], 16
  00041	73 14		 jae	 SHORT $LN5@Activate_S

; 2251 :                 _Bx._Buf[_Idx] = value_type();

  00043	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  00047	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0004b	48 03 c8	 add	 rcx, rax
  0004e	48 8b c1	 mov	 rax, rcx
  00051	c6 40 08 00	 mov	 BYTE PTR [rax+8], 0

; 2252 :             }

  00055	eb da		 jmp	 SHORT $LN2@Activate_S
$LN5@Activate_S:

; 2253 :         }
; 2254 : #endif // _HAS_CXX20
; 2255 :     }

  00057	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005b	5d		 pop	 rbp
  0005c	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 64
this$ = 96
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT

; 2242 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2243 :         return _BUF_SIZE <= _Myres;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 20 10	 cmp	 QWORD PTR [rax+32], 16
  00024	72 09		 jb	 SHORT $LN3@Large_stri
  00026	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv66[rbp], 1
  0002d	eb 07		 jmp	 SHORT $LN4@Large_stri
$LN3@Large_stri:
  0002f	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv66[rbp], 0
$LN4@Large_stri:
  00036	0f b6 45 40	 movzx	 eax, BYTE PTR tv66[rbp]

; 2244 :     }

  0003a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 0
this$ = 96
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2233 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2234 :         const value_type* _Result = _Bx._Buf;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 c0 08	 add	 rax, 8
  00023	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax

; 2235 :         if (_Large_string_engaged()) {

  00027	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	74 11		 je	 SHORT $LN2@Myptr

; 2236 :             _Result = _Unfancy(_Bx._Ptr);

  00037	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003f	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00044	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax
$LN2@Myptr:

; 2237 :         }
; 2238 : 
; 2239 :         return _Result;

  00048	48 8b 45 00	 mov	 rax, QWORD PTR _Result$[rbp]

; 2240 :     }

  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 0
this$ = 96
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2224 :     _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2225 :         value_type* _Result = _Bx._Buf;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 c0 08	 add	 rax, 8
  00023	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax

; 2226 :         if (_Large_string_engaged()) {

  00027	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	74 11		 je	 SHORT $LN2@Myptr

; 2227 :             _Result = _Unfancy(_Bx._Ptr);

  00037	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003f	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00044	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax
$LN2@Myptr:

; 2228 :         }
; 2229 : 
; 2230 :         return _Result;

  00048	48 8b 45 00	 mov	 rax, QWORD PTR _Result$[rbp]

; 2231 :     }

  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 2213 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QEAA@XZ ; std::_Container_base12::_Container_base12
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 83 c0 08	 add	 rax, 8
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2214 : 
; 2215 :     // length of internal buffer, [1, 16]:
; 2216 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2217 :     // roundup mask for allocated buffers, [0, 15]:
; 2218 :     static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
; 2219 :                                            : sizeof(value_type) <= 2 ? 7
; 2220 :                                            : sizeof(value_type) <= 4 ? 3
; 2221 :                                            : sizeof(value_type) <= 8 ? 1
; 2222 :                                                                      : 0;
; 2223 : 
; 2224 :     _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2225 :         value_type* _Result = _Bx._Buf;
; 2226 :         if (_Large_string_engaged()) {
; 2227 :             _Result = _Unfancy(_Bx._Ptr);
; 2228 :         }
; 2229 : 
; 2230 :         return _Result;
; 2231 :     }
; 2232 : 
; 2233 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2234 :         const value_type* _Result = _Bx._Buf;
; 2235 :         if (_Large_string_engaged()) {
; 2236 :             _Result = _Unfancy(_Bx._Ptr);
; 2237 :         }
; 2238 : 
; 2239 :         return _Result;
; 2240 :     }
; 2241 : 
; 2242 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {
; 2243 :         return _BUF_SIZE <= _Myres;
; 2244 :     }
; 2245 : 
; 2246 :     constexpr void _Activate_SSO_buffer() noexcept {
; 2247 :         // start the lifetime of the array elements
; 2248 : #if _HAS_CXX20
; 2249 :         if (_STD is_constant_evaluated()) {
; 2250 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2251 :                 _Bx._Buf[_Idx] = value_type();
; 2252 :             }
; 2253 :         }
; 2254 : #endif // _HAS_CXX20
; 2255 :     }
; 2256 : 
; 2257 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2258 :         // checks whether _Off is in the bounds of [0, size()]
; 2259 :         if (_Mysize < _Off) {
; 2260 :             _Xran();
; 2261 :         }
; 2262 :     }
; 2263 : 
; 2264 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2265 :         // checks whether _Off is in the bounds of [0, size())
; 2266 :         if (_Mysize <= _Off) {
; 2267 :             _Xran();
; 2268 :         }
; 2269 :     }
; 2270 : 
; 2271 :     [[noreturn]] static void _Xran() {
; 2272 :         _Xout_of_range("invalid string position");
; 2273 :     }
; 2274 : 
; 2275 :     _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2276 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2277 :         return (_STD min)(_Size, _Mysize - _Off);
; 2278 :     }
; 2279 : 
; 2280 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2281 :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 2282 :         // renaming `_String_val` (and fixing the visualizer).
; 2283 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 2284 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2285 : 
; 2286 :         value_type _Buf[_BUF_SIZE];
; 2287 :         pointer _Ptr;
; 2288 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2289 :     };
; 2290 :     _Bxty _Bx;
; 2291 : 
; 2292 :     size_type _Mysize = 0; // current length of string

  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 2293 :     size_type _Myres  = 0; // current storage reserved for string

  00040	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00044	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 2213 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  0004c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 80
_Al$ = 88
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 740  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 741  :         return _Al;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 742  :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 80
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1

; 738  :     }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YA_K_K@Z ; std::_Get_size_of_n<1>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 8b 55 60	 mov	 rdx, QWORD PTR _Count$[rbp]
  000ae	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b2	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000b7	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bb	5d		 pop	 rbp
  000bc	c3		 ret	 0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 962  :     constexpr allocator() noexcept {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2310 : [[noreturn]] inline void _Xlen_string() {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2311 :     _Xlength_error("string too long");

  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
  0001e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2312 : }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 472  :     _NODISCARD static constexpr int_type eof() noexcept {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 473  :         return static_cast<int_type>(EOF);

  00017	b8 ff ff ff ff	 mov	 eax, -1

; 474  :     }

  0001c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00020	5d		 pop	 rbp
  00021	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z
_TEXT	SEGMENT
tv69 = 64
tv68 = 68
_Meta$ = 96
?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z PROC	; std::_Narrow_char_traits<char,int>::not_eof, COMDAT

; 468  :     _NODISCARD static constexpr int_type not_eof(const int_type _Meta) noexcept {

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00009	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 469  :         return _Meta != eof() ? _Meta : !eof();

  0001a	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0001f	39 45 60	 cmp	 DWORD PTR _Meta$[rbp], eax
  00022	74 08		 je	 SHORT $LN5@not_eof
  00024	8b 45 60	 mov	 eax, DWORD PTR _Meta$[rbp]
  00027	89 45 40	 mov	 DWORD PTR tv69[rbp], eax
  0002a	eb 1f		 jmp	 SHORT $LN6@not_eof
$LN5@not_eof:
  0002c	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00031	85 c0		 test	 eax, eax
  00033	75 09		 jne	 SHORT $LN3@not_eof
  00035	c7 45 44 01 00
	00 00		 mov	 DWORD PTR tv68[rbp], 1
  0003c	eb 07		 jmp	 SHORT $LN4@not_eof
$LN3@not_eof:
  0003e	c7 45 44 00 00
	00 00		 mov	 DWORD PTR tv68[rbp], 0
$LN4@not_eof:
  00045	8b 45 44	 mov	 eax, DWORD PTR tv68[rbp]
  00048	89 45 40	 mov	 DWORD PTR tv69[rbp], eax
$LN6@not_eof:
  0004b	8b 45 40	 mov	 eax, DWORD PTR tv69[rbp]

; 470  :     }

  0004e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z ENDP	; std::_Narrow_char_traits<char,int>::not_eof
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
tv65 = 64
_Left$ = 96
_Right$ = 104
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 464  :     _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 465  :         return _Left == _Right;

  0001e	8b 45 68	 mov	 eax, DWORD PTR _Right$[rbp]
  00021	39 45 60	 cmp	 DWORD PTR _Left$[rbp], eax
  00024	75 09		 jne	 SHORT $LN3@eq_int_typ
  00026	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv65[rbp], 1
  0002d	eb 07		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  0002f	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv65[rbp], 0
$LN4@eq_int_typ:
  00036	0f b6 45 40	 movzx	 eax, BYTE PTR tv65[rbp]

; 466  :     }

  0003a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z
_TEXT	SEGMENT
_Ch$ = 80
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z PROC	; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 460  :     _NODISCARD static constexpr int_type to_int_type(const _Elem _Ch) noexcept {

$LN3:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	55		 push	 rbp
  00005	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00009	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 461  :         return static_cast<unsigned char>(_Ch);

  0001a	0f b6 45 50	 movzx	 eax, BYTE PTR _Ch$[rbp]

; 462  :     }

  0001e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00022	5d		 pop	 rbp
  00023	c3		 ret	 0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ENDP	; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z
_TEXT	SEGMENT
_Meta$ = 80
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z PROC	; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 456  :     _NODISCARD static constexpr _Elem to_char_type(const int_type _Meta) noexcept {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00009	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 457  :         return static_cast<_Elem>(_Meta);

  0001a	0f b6 45 50	 movzx	 eax, BYTE PTR _Meta$[rbp]

; 458  :     }

  0001e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00022	5d		 pop	 rbp
  00023	c3		 ret	 0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ENDP	; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 439  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 440  : #if _HAS_CXX20
; 441  :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0f		 je	 SHORT $LN2@assign

; 442  :             return _Primary_char_traits::assign(_Left, _Right);

  0002c	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00030	48 8b 4d 50	 mov	 rcx, QWORD PTR _Left$[rbp]
  00034	e8 00 00 00 00	 call	 ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Char_traits<char,int>::assign
  00039	eb 0d		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 443  :         }
; 444  : #endif // _HAS_CXX20
; 445  :         _Left = _Right;

  0003b	48 8b 45 50	 mov	 rax, QWORD PTR _Left$[rbp]
  0003f	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  00043	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00046	88 08		 mov	 BYTE PTR [rax], cl
$LN1@assign:

; 446  :     }

  00048	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 64
tv69 = 72
_First$ = 96
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 386  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 387  :         // find length of null-terminated string
; 388  : #if _HAS_CXX17
; 389  : #ifdef __cpp_char8_t
; 390  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 391  : #if _HAS_U8_INTRINSICS
; 392  :             return __builtin_u8strlen(_First);
; 393  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 394  :             return _Primary_char_traits::length(_First);
; 395  : #endif // _HAS_U8_INTRINSICS
; 396  :         } else
; 397  : #endif // __cpp_char8_t
; 398  :         {
; 399  :             return __builtin_strlen(_First);

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR _First$[rbp]
  0001f	48 89 45 40	 mov	 QWORD PTR tv68[rbp], rax
  00023	48 c7 45 48 ff
	ff ff ff	 mov	 QWORD PTR tv69[rbp], -1
$LL3@length:
  0002b	48 ff 45 48	 inc	 QWORD PTR tv69[rbp]
  0002f	48 8b 45 40	 mov	 rax, QWORD PTR tv68[rbp]
  00033	48 8b 4d 48	 mov	 rcx, QWORD PTR tv69[rbp]
  00037	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  0003b	75 ee		 jne	 SHORT $LL3@length
  0003d	48 8b 45 48	 mov	 rax, QWORD PTR tv69[rbp]

; 400  :         }
; 401  : #else // _HAS_CXX17
; 402  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 403  : #endif // _HAS_CXX17
; 404  :     }

  00041	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 181  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 182  : #if _HAS_CXX20
; 183  :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@assign

; 184  :             _STD construct_at(_STD addressof(_Left), _Right);

  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR _Left$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPEADAEAD@Z ; std::addressof<char>
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z ; std::construct_at<char,char const &,0>

; 185  :         } else

  00041	eb 0d		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 186  : #endif // _HAS_CXX20
; 187  :         {
; 188  :             _Left = _Right;

  00043	48 8b 45 50	 mov	 rax, QWORD PTR _Left$[rbp]
  00047	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  0004b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0004e	88 08		 mov	 BYTE PTR [rax], cl
$LN3@assign:

; 189  :         }
; 190  :     }

  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_Loop_forward$1 = 0
_Src$2 = 8
_Idx$3 = 16
_Idx$4 = 24
_First1$ = 112
_First2$ = 120
_Count$ = 128
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 80   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 81   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 82   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 83   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 84   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 85   : #if _HAS_CXX20
; 86   :         if (_STD is_constant_evaluated()) {

  00028	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002d	0f b6 c0	 movzx	 eax, al
  00030	85 c0		 test	 eax, eax
  00032	0f 84 db 00 00
	00		 je	 $LN11@move

; 87   :             // dest: [_First1, _First1 + _Count)
; 88   :             // src: [_First2, _First2 + _Count)
; 89   :             // We need to handle overlapping ranges.
; 90   :             // If _First1 is in the src range, we need a backward loop.
; 91   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 92   : 
; 93   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 94   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 95   :             bool _Loop_forward = true;

  00038	c6 45 00 01	 mov	 BYTE PTR _Loop_forward$1[rbp], 1

; 96   : 
; 97   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {

  0003c	48 8b 45 78	 mov	 rax, QWORD PTR _First2$[rbp]
  00040	48 89 45 08	 mov	 QWORD PTR _Src$2[rbp], rax
  00044	eb 0b		 jmp	 SHORT $LN4@move
$LN2@move:
  00046	48 8b 45 08	 mov	 rax, QWORD PTR _Src$2[rbp]
  0004a	48 ff c0	 inc	 rax
  0004d	48 89 45 08	 mov	 QWORD PTR _Src$2[rbp], rax
$LN4@move:
  00051	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  00058	48 8b 4d 78	 mov	 rcx, QWORD PTR _First2$[rbp]
  0005c	48 03 c8	 add	 rcx, rax
  0005f	48 8b c1	 mov	 rax, rcx
  00062	48 39 45 08	 cmp	 QWORD PTR _Src$2[rbp], rax
  00066	74 12		 je	 SHORT $LN3@move

; 98   :                 if (_First1 == _Src) {

  00068	48 8b 45 08	 mov	 rax, QWORD PTR _Src$2[rbp]
  0006c	48 39 45 70	 cmp	 QWORD PTR _First1$[rbp], rax
  00070	75 06		 jne	 SHORT $LN12@move

; 99   :                     _Loop_forward = false;

  00072	c6 45 00 00	 mov	 BYTE PTR _Loop_forward$1[rbp], 0

; 100  :                     break;

  00076	eb 02		 jmp	 SHORT $LN3@move
$LN12@move:

; 101  :                 }
; 102  :             }

  00078	eb cc		 jmp	 SHORT $LN2@move
$LN3@move:

; 103  : 
; 104  :             if (_Loop_forward) {

  0007a	0f b6 45 00	 movzx	 eax, BYTE PTR _Loop_forward$1[rbp]
  0007e	85 c0		 test	 eax, eax
  00080	74 47		 je	 SHORT $LN13@move

; 105  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {

  00082	48 c7 45 10 00
	00 00 00	 mov	 QWORD PTR _Idx$3[rbp], 0
  0008a	eb 0b		 jmp	 SHORT $LN7@move
$LN5@move:
  0008c	48 8b 45 10	 mov	 rax, QWORD PTR _Idx$3[rbp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 45 10	 mov	 QWORD PTR _Idx$3[rbp], rax
$LN7@move:
  00097	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  0009e	48 39 45 10	 cmp	 QWORD PTR _Idx$3[rbp], rax
  000a2	74 23		 je	 SHORT $LN6@move

; 106  :                     _First1[_Idx] = _First2[_Idx];

  000a4	48 8b 45 10	 mov	 rax, QWORD PTR _Idx$3[rbp]
  000a8	48 8b 4d 70	 mov	 rcx, QWORD PTR _First1$[rbp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 8b 4d 10	 mov	 rcx, QWORD PTR _Idx$3[rbp]
  000b6	48 8b 55 78	 mov	 rdx, QWORD PTR _First2$[rbp]
  000ba	48 03 d1	 add	 rdx, rcx
  000bd	48 8b ca	 mov	 rcx, rdx
  000c0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000c3	88 08		 mov	 BYTE PTR [rax], cl

; 107  :                 }

  000c5	eb c5		 jmp	 SHORT $LN5@move
$LN6@move:

; 108  :             } else {

  000c7	eb 44		 jmp	 SHORT $LN14@move
$LN13@move:

; 109  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {

  000c9	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  000d0	48 89 45 18	 mov	 QWORD PTR _Idx$4[rbp], rax
  000d4	eb 0b		 jmp	 SHORT $LN10@move
$LN8@move:
  000d6	48 8b 45 18	 mov	 rax, QWORD PTR _Idx$4[rbp]
  000da	48 ff c8	 dec	 rax
  000dd	48 89 45 18	 mov	 QWORD PTR _Idx$4[rbp], rax
$LN10@move:
  000e1	48 83 7d 18 00	 cmp	 QWORD PTR _Idx$4[rbp], 0
  000e6	74 25		 je	 SHORT $LN14@move

; 110  :                     _First1[_Idx - 1] = _First2[_Idx - 1];

  000e8	48 8b 45 18	 mov	 rax, QWORD PTR _Idx$4[rbp]
  000ec	48 8b 4d 70	 mov	 rcx, QWORD PTR _First1$[rbp]
  000f0	48 03 c8	 add	 rcx, rax
  000f3	48 8b c1	 mov	 rax, rcx
  000f6	48 8b 4d 18	 mov	 rcx, QWORD PTR _Idx$4[rbp]
  000fa	48 8b 55 78	 mov	 rdx, QWORD PTR _First2$[rbp]
  000fe	48 03 d1	 add	 rdx, rcx
  00101	48 8b ca	 mov	 rcx, rdx
  00104	0f b6 49 ff	 movzx	 ecx, BYTE PTR [rcx-1]
  00108	88 48 ff	 mov	 BYTE PTR [rax-1], cl

; 111  :                 }

  0010b	eb c9		 jmp	 SHORT $LN8@move
$LN14@move:

; 112  :             }
; 113  : 
; 114  :             return _First1;

  0010d	48 8b 45 70	 mov	 rax, QWORD PTR _First1$[rbp]
  00111	eb 18		 jmp	 SHORT $LN1@move
$LN11@move:

; 115  :         }
; 116  : #endif // _HAS_CXX20
; 117  : 
; 118  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00113	4c 8b 85 80 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  0011a	48 8b 55 78	 mov	 rdx, QWORD PTR _First2$[rbp]
  0011e	48 8b 4d 70	 mov	 rcx, QWORD PTR _First1$[rbp]
  00122	e8 00 00 00 00	 call	 memmove

; 119  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 120  : 
; 121  :         return _First1;

  00127	48 8b 45 70	 mov	 rax, QWORD PTR _First1$[rbp]
$LN1@move:

; 122  :     }

  0012b	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0012f	5d		 pop	 rbp
  00130	c3		 ret	 0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_Idx$1 = 0
_First1$ = 96
_First2$ = 104
_Count$ = 112
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 49   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 50   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 51   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 52   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 53   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 54   : #if _HAS_CXX20
; 55   :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 48		 je	 SHORT $LN5@copy

; 56   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 57   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {

  00031	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Idx$1[rbp], 0
  00039	eb 0b		 jmp	 SHORT $LN4@copy
$LN2@copy:
  0003b	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  0003f	48 ff c0	 inc	 rax
  00042	48 89 45 00	 mov	 QWORD PTR _Idx$1[rbp], rax
$LN4@copy:
  00046	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  0004a	48 39 45 00	 cmp	 QWORD PTR _Idx$1[rbp], rax
  0004e	74 23		 je	 SHORT $LN3@copy

; 58   :                 _First1[_Idx] = _First2[_Idx];

  00050	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  00054	48 8b 4d 60	 mov	 rcx, QWORD PTR _First1$[rbp]
  00058	48 03 c8	 add	 rcx, rax
  0005b	48 8b c1	 mov	 rax, rcx
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Idx$1[rbp]
  00062	48 8b 55 68	 mov	 rdx, QWORD PTR _First2$[rbp]
  00066	48 03 d1	 add	 rdx, rcx
  00069	48 8b ca	 mov	 rcx, rdx
  0006c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006f	88 08		 mov	 BYTE PTR [rax], cl

; 59   :             }

  00071	eb c8		 jmp	 SHORT $LN2@copy
$LN3@copy:

; 60   : 
; 61   :             return _First1;

  00073	48 8b 45 60	 mov	 rax, QWORD PTR _First1$[rbp]
  00077	eb 15		 jmp	 SHORT $LN1@copy
$LN5@copy:

; 62   :         }
; 63   : #endif // _HAS_CXX20
; 64   : 
; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00079	4c 8b 45 70	 mov	 r8, QWORD PTR _Count$[rbp]
  0007d	48 8b 55 68	 mov	 rdx, QWORD PTR _First2$[rbp]
  00081	48 8b 4d 60	 mov	 rcx, QWORD PTR _First1$[rbp]
  00085	e8 00 00 00 00	 call	 memcpy

; 66   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 67   : 
; 68   :         return _First1;

  0008a	48 8b 45 60	 mov	 rax, QWORD PTR _First1$[rbp]
$LN1@copy:

; 69   :     }

  0008e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00092	5d		 pop	 rbp
  00093	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 295  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 296  : #if _HAS_CXX20
; 297  :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0f		 je	 SHORT $LN2@assign

; 298  :             return _Primary_char_traits::assign(_Left, _Right);

  0002c	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00030	48 8b 4d 50	 mov	 rcx, QWORD PTR _Left$[rbp]
  00034	e8 00 00 00 00	 call	 ?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z ; std::_Char_traits<wchar_t,unsigned short>::assign
  00039	eb 0e		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 299  :         }
; 300  : #endif // _HAS_CXX20
; 301  :         _Left = _Right;

  0003b	48 8b 45 50	 mov	 rax, QWORD PTR _Left$[rbp]
  0003f	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  00043	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00046	66 89 08	 mov	 WORD PTR [rax], cx
$LN1@assign:

; 302  :     }

  00049	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z PROC	; std::_Char_traits<wchar_t,unsigned short>::assign, COMDAT

; 181  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 182  : #if _HAS_CXX20
; 183  :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@assign

; 184  :             _STD construct_at(_STD addressof(_Left), _Right);

  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR _Left$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@_W@std@@YAPEA_WAEA_W@Z ; std::addressof<wchar_t>
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z ; std::construct_at<wchar_t,wchar_t const &,0>

; 185  :         } else

  00041	eb 0e		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 186  : #endif // _HAS_CXX20
; 187  :         {
; 188  :             _Left = _Right;

  00043	48 8b 45 50	 mov	 rax, QWORD PTR _Left$[rbp]
  00047	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  0004b	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0004e	66 89 08	 mov	 WORD PTR [rax], cx
$LN3@assign:

; 189  :         }
; 190  :     }

  00051	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z ENDP	; std::_Char_traits<wchar_t,unsigned short>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>

; 252  :     } else

  00041	eb 2a		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 10 00 00 00	 mov	 ecx, 16
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00061	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00064	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00068	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00071	5d		 pop	 rbp
  00072	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0_Basic_container_proxy_ptr12@std@@IEAA@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT

; 1453 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1446 :     _Container_proxy* _Ptr = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1453 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
??0_Basic_container_proxy_ptr12@std@@IEAA@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ PROC ; std::_Basic_container_proxy_ptr12::_Release, COMDAT

; 1448 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1449 :         _Ptr = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1450 :     }

  00026	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ENDP ; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ PROC ; std::_Iterator_base12::_Orphan_me_locked_v3, COMDAT

; 1362 :     void _Orphan_me_locked_v3() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1363 :         _Lockit _Lock(_LOCK_DEBUG);

  0001b	ba 03 00 00 00	 mov	 edx, 3
  00020	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1364 :         _Orphan_me_unlocked_v3();

  0002a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1365 :     }

  00033	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ ENDP ; std::_Iterator_base12::_Orphan_me_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$ = 0
this$ = 96
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ PROC ; std::_Iterator_base12::_Orphan_me_unlocked_v3, COMDAT

; 1346 :     _CONSTEXPR20 void _Orphan_me_unlocked_v3() noexcept {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1347 :         if (!_Myproxy) { // already orphaned

  0001e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00026	75 05		 jne	 SHORT $LN10@Orphan_me_

; 1348 :             return;

  00028	e9 ce 00 00 00	 jmp	 $LN1@Orphan_me_
$LN10@Orphan_me_:

; 1349 :         }
; 1350 : 
; 1351 :         // adopted, remove self from list
; 1352 :         _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;

  0002d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 83 c0 08	 add	 rax, 8
  00038	48 89 45 00	 mov	 QWORD PTR _Pnext$[rbp], rax
$LN2@Orphan_me_:

; 1353 :         while (*_Pnext && *_Pnext != this) {

  0003c	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00040	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00044	74 1e		 je	 SHORT $LN6@Orphan_me_
  00046	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0004a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0004e	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00051	74 11		 je	 SHORT $LN6@Orphan_me_

; 1354 :             _Pnext = &(*_Pnext)->_Mynextiter;

  00053	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00057	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005a	48 83 c0 08	 add	 rax, 8
  0005e	48 89 45 00	 mov	 QWORD PTR _Pnext$[rbp], rax

; 1355 :         }

  00062	eb d8		 jmp	 SHORT $LN2@Orphan_me_
$LN6@Orphan_me_:

; 1356 : 
; 1357 :         _STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");

  00064	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00068	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006c	74 02		 je	 SHORT $LN9@Orphan_me_
  0006e	eb 6b		 jmp	 SHORT $LN12@Orphan_me_
$LN9@Orphan_me_:
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
  00077	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	45 33 c9	 xor	 r9d, r9d
  0008b	41 b8 4d 05 00
	00		 mov	 r8d, 1357		; 0000054dH
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  00098	b9 02 00 00 00	 mov	 ecx, 2
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  000a3	83 f8 01	 cmp	 eax, 1
  000a6	75 03		 jne	 SHORT $LN14@Orphan_me_
  000a8	cc		 int	 3
  000a9	33 c0		 xor	 eax, eax
$LN14@Orphan_me_:
  000ab	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000b4	41 b9 4d 05 00
	00		 mov	 r9d, 1357		; 0000054dH
  000ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000d5	33 c0		 xor	 eax, eax
  000d7	85 c0		 test	 eax, eax
  000d9	75 95		 jne	 SHORT $LN9@Orphan_me_
$LN12@Orphan_me_:
  000db	33 c0		 xor	 eax, eax
  000dd	85 c0		 test	 eax, eax
  000df	75 83		 jne	 SHORT $LN6@Orphan_me_

; 1358 :         *_Pnext  = _Mynextiter;

  000e1	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  000e5	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  000e9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ed	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1359 :         _Myproxy = nullptr;

  000f0	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  000f4	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN1@Orphan_me_:

; 1360 :     }

  000fb	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000ff	5d		 pop	 rbp
  00100	c3		 ret	 0
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ENDP ; std::_Iterator_base12::_Orphan_me_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
_Parent$ = 104
?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_locked, COMDAT

; 1341 :     void _Adopt_locked(const _Container_base12* _Parent) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1342 :         _Lockit _Lock(_LOCK_DEBUG);

  00020	ba 03 00 00 00	 mov	 edx, 3
  00025	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1343 :         _Adopt_unlocked(_Parent);

  0002f	48 8b 55 68	 mov	 rdx, QWORD PTR _Parent$[rbp]
  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1344 :     }

  0003c	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00046	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_locked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
_Parent_proxy$ = 0
this$ = 96
_Parent$ = 104
?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_unlocked, COMDAT

; 1324 :     _CONSTEXPR20 void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1325 :         if (!_Parent) {

  00020	48 83 7d 68 00	 cmp	 QWORD PTR _Parent$[rbp], 0
  00025	75 0b		 jne	 SHORT $LN2@Adopt_unlo

; 1326 :             _Orphan_me_unlocked_v3();

  00027	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1327 :             return;

  00030	eb 52		 jmp	 SHORT $LN1@Adopt_unlo
$LN2@Adopt_unlo:

; 1328 :         }
; 1329 : 
; 1330 :         _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  00032	48 8b 45 68	 mov	 rax, QWORD PTR _Parent$[rbp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 89 45 00	 mov	 QWORD PTR _Parent_proxy$[rbp], rax

; 1331 :         if (_Myproxy != _Parent_proxy) { // change parentage

  0003d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00041	48 8b 4d 00	 mov	 rcx, QWORD PTR _Parent_proxy$[rbp]
  00045	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00048	74 3a		 je	 SHORT $LN1@Adopt_unlo

; 1332 :             if (_Myproxy) { // adopted, remove self from list

  0004a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00052	74 09		 je	 SHORT $LN4@Adopt_unlo

; 1333 :                 _Orphan_me_unlocked_v3();

  00054	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00058	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN4@Adopt_unlo:

; 1334 :             }
; 1335 :             _Mynextiter                 = _Parent_proxy->_Myfirstiter;

  0005d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00061	48 8b 4d 00	 mov	 rcx, QWORD PTR _Parent_proxy$[rbp]
  00065	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00069	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1336 :             _Parent_proxy->_Myfirstiter = this;

  0006d	48 8b 45 00	 mov	 rax, QWORD PTR _Parent_proxy$[rbp]
  00071	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00075	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1337 :             _Myproxy                    = _Parent_proxy;

  00079	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0007d	48 8b 4d 00	 mov	 rcx, QWORD PTR _Parent_proxy$[rbp]
  00081	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@Adopt_unlo:

; 1338 :         }
; 1339 :     }

  00084	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00088	5d		 pop	 rbp
  00089	c3		 ret	 0
?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
_Right$ = 104
?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z PROC ; std::_Iterator_base12::_Assign_locked, COMDAT

; 1319 :     void _Assign_locked(const _Iterator_base12& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1320 :         _Lockit _Lock(_LOCK_DEBUG);

  00020	ba 03 00 00 00	 mov	 edx, 3
  00025	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1321 :         _Assign_unlocked(_Right);

  0002f	48 8b 55 68	 mov	 rdx, QWORD PTR _Right$[rbp]
  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_unlocked

; 1322 :     }

  0003c	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00046	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z ENDP ; std::_Iterator_base12::_Assign_locked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z PROC ; std::_Iterator_base12::_Assign_unlocked, COMDAT

; 1307 :     _CONSTEXPR20 void _Assign_unlocked(const _Iterator_base12& _Right) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1308 :         if (_Myproxy == _Right._Myproxy) {

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	75 02		 jne	 SHORT $LN2@Assign_unl

; 1309 :             return;

  00030	eb 28		 jmp	 SHORT $LN1@Assign_unl
$LN2@Assign_unl:

; 1310 :         }
; 1311 : 
; 1312 :         if (_Right._Myproxy) {

  00032	48 8b 45 58	 mov	 rax, QWORD PTR _Right$[rbp]
  00036	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003a	74 15		 je	 SHORT $LN3@Assign_unl

; 1313 :             _Adopt_unlocked(_Right._Myproxy->_Mycont);

  0003c	48 8b 45 58	 mov	 rax, QWORD PTR _Right$[rbp]
  00040	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00043	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00046	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0004a	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1314 :         } else { // becoming invalid, disown current parent

  0004f	eb 09		 jmp	 SHORT $LN1@Assign_unl
$LN3@Assign_unl:

; 1315 :             _Orphan_me_unlocked_v3();

  00051	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00055	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN1@Assign_unl:

; 1316 :         }
; 1317 :     }

  0005a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z ENDP ; std::_Iterator_base12::_Assign_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = 64
this$ = 96
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT

; 1296 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1297 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 10		 je	 SHORT $LN3@Getcont
  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 89 45 40	 mov	 QWORD PTR tv68[rbp], rax
  00033	eb 08		 jmp	 SHORT $LN4@Getcont
$LN3@Getcont:
  00035	48 c7 45 40 00
	00 00 00	 mov	 QWORD PTR tv68[rbp], 0
$LN4@Getcont:
  0003d	48 8b 45 40	 mov	 rax, QWORD PTR tv68[rbp]

; 1298 :     }

  00041	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
this$ = 80
_Parent$ = 88
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT

; 1276 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1277 : #if _HAS_CXX20
; 1278 :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0f		 je	 SHORT $LN2@Adopt

; 1279 :             _Adopt_unlocked(_Parent);

  0002c	48 8b 55 58	 mov	 rdx, QWORD PTR _Parent$[rbp]
  00030	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1280 :         } else

  00039	eb 0d		 jmp	 SHORT $LN3@Adopt
$LN2@Adopt:

; 1281 : #endif // _HAS_CXX20
; 1282 :         {
; 1283 :             _Adopt_locked(_Parent);

  0003b	48 8b 55 58	 mov	 rdx, QWORD PTR _Parent$[rbp]
  0003f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00043	e8 00 00 00 00	 call	 ?_Adopt_locked@_Iterator_base12@std@@AEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
$LN3@Adopt:

; 1284 :         }
; 1285 :     }

  00048	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT

; 1265 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1266 : #if _HAS_CXX20
; 1267 :         if (_STD is_constant_evaluated()) {

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 0b		 je	 SHORT $LN2@Iterator_b

; 1268 :             _Orphan_me_unlocked_v3();

  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1269 :         } else

  00030	eb 09		 jmp	 SHORT $LN3@Iterator_b
$LN2@Iterator_b:

; 1270 : #endif // _HAS_CXX20
; 1271 :         {
; 1272 :             _Orphan_me_locked_v3();

  00032	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00036	e8 00 00 00 00	 call	 ?_Orphan_me_locked_v3@_Iterator_base12@std@@AEAAXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
$LN3@Iterator_b:

; 1273 :         }
; 1274 :     }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??1_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z PROC	; std::_Iterator_base12::operator=, COMDAT

; 1248 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1249 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1250 : #if _HAS_CXX20
; 1251 :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0f		 je	 SHORT $LN2@operator

; 1252 :             _Assign_unlocked(_Right);

  0002c	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00030	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Assign_unlocked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_unlocked

; 1253 :         } else

  00039	eb 0d		 jmp	 SHORT $LN3@operator
$LN2@operator:

; 1254 : #endif // _HAS_CXX20
; 1255 :         {
; 1256 :             _Assign_locked(_Right);

  0003b	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  0003f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00043	e8 00 00 00 00	 call	 ?_Assign_locked@_Iterator_base12@std@@AEAAXAEBU12@@Z ; std::_Iterator_base12::_Assign_locked
$LN3@operator:

; 1257 :         }
; 1258 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1259 :         _Myproxy = _Right._Myproxy;
; 1260 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1261 :         return *this;

  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1262 :     }

  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z ENDP	; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
??0_Iterator_base12@std@@QEAA@AEBU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT

; 1244 :     _CONSTEXPR20 _Iterator_base12(const _Iterator_base12& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1247 : 
; 1248 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1249 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1250 : #if _HAS_CXX20
; 1251 :         if (_STD is_constant_evaluated()) {
; 1252 :             _Assign_unlocked(_Right);
; 1253 :         } else
; 1254 : #endif // _HAS_CXX20
; 1255 :         {
; 1256 :             _Assign_locked(_Right);
; 1257 :         }
; 1258 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1259 :         _Myproxy = _Right._Myproxy;
; 1260 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1261 :         return *this;
; 1262 :     }
; 1263 : 
; 1264 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1265 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {
; 1266 : #if _HAS_CXX20
; 1267 :         if (_STD is_constant_evaluated()) {
; 1268 :             _Orphan_me_unlocked_v3();
; 1269 :         } else
; 1270 : #endif // _HAS_CXX20
; 1271 :         {
; 1272 :             _Orphan_me_locked_v3();
; 1273 :         }
; 1274 :     }
; 1275 : 
; 1276 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1277 : #if _HAS_CXX20
; 1278 :         if (_STD is_constant_evaluated()) {
; 1279 :             _Adopt_unlocked(_Parent);
; 1280 :         } else
; 1281 : #endif // _HAS_CXX20
; 1282 :         {
; 1283 :             _Adopt_locked(_Parent);
; 1284 :         }
; 1285 :     }
; 1286 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1287 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1288 :         if (_Parent) { // have a parent, do adoption
; 1289 :             _Myproxy = _Parent->_Myproxy;
; 1290 :         } else { // no future parent, just disown current parent
; 1291 :             _Myproxy = nullptr;
; 1292 :         }
; 1293 :     }
; 1294 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1295 : 
; 1296 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {
; 1297 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1298 :     }
; 1299 : 
; 1300 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1301 : 
; 1302 :     mutable _Container_proxy* _Myproxy    = nullptr;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1303 :     mutable _Iterator_base12* _Mynextiter = nullptr;

  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1245 :         *this = _Right;

  00037	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  0003b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0003f	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z ; std::_Iterator_base12::operator=

; 1246 :     }

  00044	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00048	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
??0_Iterator_base12@std@@QEAA@AEBU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT

; 1242 :     _CONSTEXPR20 _Iterator_base12() noexcept = default; // construct orphaned iterator

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1243 : 
; 1244 :     _CONSTEXPR20 _Iterator_base12(const _Iterator_base12& _Right) noexcept {
; 1245 :         *this = _Right;
; 1246 :     }
; 1247 : 
; 1248 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1249 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1250 : #if _HAS_CXX20
; 1251 :         if (_STD is_constant_evaluated()) {
; 1252 :             _Assign_unlocked(_Right);
; 1253 :         } else
; 1254 : #endif // _HAS_CXX20
; 1255 :         {
; 1256 :             _Assign_locked(_Right);
; 1257 :         }
; 1258 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1259 :         _Myproxy = _Right._Myproxy;
; 1260 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1261 :         return *this;
; 1262 :     }
; 1263 : 
; 1264 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1265 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {
; 1266 : #if _HAS_CXX20
; 1267 :         if (_STD is_constant_evaluated()) {
; 1268 :             _Orphan_me_unlocked_v3();
; 1269 :         } else
; 1270 : #endif // _HAS_CXX20
; 1271 :         {
; 1272 :             _Orphan_me_locked_v3();
; 1273 :         }
; 1274 :     }
; 1275 : 
; 1276 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1277 : #if _HAS_CXX20
; 1278 :         if (_STD is_constant_evaluated()) {
; 1279 :             _Adopt_unlocked(_Parent);
; 1280 :         } else
; 1281 : #endif // _HAS_CXX20
; 1282 :         {
; 1283 :             _Adopt_locked(_Parent);
; 1284 :         }
; 1285 :     }
; 1286 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1287 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1288 :         if (_Parent) { // have a parent, do adoption
; 1289 :             _Myproxy = _Parent->_Myproxy;
; 1290 :         } else { // no future parent, just disown current parent
; 1291 :             _Myproxy = nullptr;
; 1292 :         }
; 1293 :     }
; 1294 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1295 : 
; 1296 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {
; 1297 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1298 :     }
; 1299 : 
; 1300 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1301 : 
; 1302 :     mutable _Container_proxy* _Myproxy    = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1303 :     mutable _Iterator_base12* _Mynextiter = nullptr;

  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1242 :     _CONSTEXPR20 _Iterator_base12() noexcept = default; // construct orphaned iterator

  00032	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
??0_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
_Right$ = 104
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_locked, COMDAT

; 1234 :     void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1235 :         _Lockit _Lock(_LOCK_DEBUG);

  00020	ba 03 00 00 00	 mov	 edx, 3
  00025	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1236 :         _Swap_proxy_and_iterators_unlocked(_Right);

  0002f	48 8b 55 68	 mov	 rdx, QWORD PTR _Right$[rbp]
  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked

; 1237 :     }

  0003c	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00046	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_locked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT

; 1229 :     void _Orphan_all_locked_v3() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1230 :         _Lockit _Lock(_LOCK_DEBUG);

  0001b	ba 03 00 00 00	 mov	 edx, 3
  00020	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1231 :         _Orphan_all_unlocked_v3();

  0002a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1232 :     }

  00033	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z
_TEXT	SEGMENT
_Temp$ = 0
this$ = 96
_Right$ = 104
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked, COMDAT

; 1393 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1394 :     _Container_proxy* _Temp = _Myproxy;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Temp$[rbp], rax

; 1395 :     _Myproxy                = _Right._Myproxy;

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1396 :     _Right._Myproxy         = _Temp;

  00039	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  0003d	48 8b 4d 00	 mov	 rcx, QWORD PTR _Temp$[rbp]
  00041	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1397 : 
; 1398 :     if (_Myproxy) {

  00044	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00048	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004c	74 0e		 je	 SHORT $LN2@Swap_proxy

; 1399 :         _Myproxy->_Mycont = this;

  0004e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@Swap_proxy:

; 1400 :     }
; 1401 : 
; 1402 :     if (_Right._Myproxy) {

  0005c	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00060	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00064	74 0e		 je	 SHORT $LN3@Swap_proxy

; 1403 :         _Right._Myproxy->_Mycont = &_Right;

  00066	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006d	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00071	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Swap_proxy:

; 1404 :     }
; 1405 : }

  00074	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00078	5d		 pop	 rbp
  00079	c3		 ret	 0
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$1 = 0
$T2 = 72
this$ = 96
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT

; 1369 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1370 :     if (!_Myproxy) { // no proxy, already done

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	75 02		 jne	 SHORT $LN5@Orphan_all

; 1371 :         return;

  00025	eb 45		 jmp	 SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1372 :     }
; 1373 : 
; 1374 :     // proxy allocated, drain it
; 1375 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

  00027	48 c7 45 48 00
	00 00 00	 mov	 QWORD PTR $T2[rbp], 0
  0002f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 83 c0 08	 add	 rax, 8
  0003a	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
  00046	48 89 45 00	 mov	 QWORD PTR _Pnext$1[rbp], rax
  0004a	eb 0c		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0004c	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00050	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00054	48 89 45 00	 mov	 QWORD PTR _Pnext$1[rbp], rax
$LN4@Orphan_all:
  00058	48 83 7d 00 00	 cmp	 QWORD PTR _Pnext$1[rbp], 0
  0005d	74 0d		 je	 SHORT $LN1@Orphan_all

; 1376 :         _Pnext->_Myproxy = nullptr;

  0005f	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00063	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1377 :     }

  0006a	eb e0		 jmp	 SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 1378 : }

  0006c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators, COMDAT

; 1407 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1408 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1409 : #if _HAS_CXX20
; 1410 :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0f		 je	 SHORT $LN2@Swap_proxy

; 1411 :         _Swap_proxy_and_iterators_unlocked(_Right);

  0002c	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00030	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked

; 1412 :     } else

  00039	eb 0d		 jmp	 SHORT $LN3@Swap_proxy
$LN2@Swap_proxy:

; 1413 : #endif // _HAS_CXX20
; 1414 :     {
; 1415 :         _Swap_proxy_and_iterators_locked(_Right);

  0003b	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  0003f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00043	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
$LN3@Swap_proxy:

; 1416 :     }
; 1417 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1418 :     _Swap_proxy_and_iterators_unlocked(_Right);
; 1419 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1420 : }

  00048	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 1380 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1381 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1382 : #if _HAS_CXX20
; 1383 :     if (_STD is_constant_evaluated()) {

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 0b		 je	 SHORT $LN2@Orphan_all

; 1384 :         _Orphan_all_unlocked_v3();

  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1385 :     } else

  00030	eb 09		 jmp	 SHORT $LN3@Orphan_all
$LN2@Orphan_all:

; 1386 : #endif // _HAS_CXX20
; 1387 :     {
; 1388 :         _Orphan_all_locked_v3();

  00032	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00036	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN3@Orphan_all:

; 1389 :     }
; 1390 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1391 : }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT

; 1198 :     _CONSTEXPR20 _Container_base12() noexcept = default;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1199 : 
; 1200 :     _Container_base12(const _Container_base12&)            = delete;
; 1201 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1202 : 
; 1203 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1204 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1205 : 
; 1206 :     template <class _Alloc>
; 1207 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1208 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1209 :         _Construct_in_place(*_New_proxy, this);
; 1210 :         _Myproxy            = _New_proxy;
; 1211 :         _New_proxy->_Mycont = this;
; 1212 :     }
; 1213 : 
; 1214 :     template <class _Alloc>
; 1215 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1216 :         // pre: no iterators refer to the existing proxy
; 1217 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1218 :         _Construct_in_place(*_New_proxy, this);
; 1219 :         _New_proxy->_Mycont = this;
; 1220 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1221 :     }
; 1222 : 
; 1223 :     _Container_proxy* _Myproxy = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1198 :     _CONSTEXPR20 _Container_base12() noexcept = default;

  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
??0_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 80
_Mycont_$ = 88
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT

; 1190 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Mycont_$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1191 : 
; 1192 :     const _Container_base12* _Mycont       = nullptr;
; 1193 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1190 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1179 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr_user$ = 0
_Ptr_container$ = 8
_Min_back_shift$ = 16
_Back_shift$ = 24
_Ptr$ = 112
_Bytes$ = 120
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 154  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 155  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 156  :     _Bytes += _Non_user_size;

  00023	48 8b 45 78	 mov	 rax, QWORD PTR _Bytes$[rbp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  0002e	48 8b 4d 78	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00032	48 89 01	 mov	 QWORD PTR [rcx], rax

; 157  : 
; 158  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00035	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 45 00	 mov	 QWORD PTR _Ptr_user$[rbp], rax

; 159  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00040	b8 08 00 00 00	 mov	 eax, 8
  00045	48 6b c0 ff	 imul	 rax, rax, -1
  00049	48 8b 4d 00	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  0004d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00051	48 89 45 08	 mov	 QWORD PTR _Ptr_container$[rbp], rax
$LN4@Adjust_man:

; 160  : 
; 161  :     // If the following asserts, it likely means that we are performing
; 162  :     // an aligned delete on memory coming from an unaligned allocation.
; 163  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00055	b8 08 00 00 00	 mov	 eax, 8
  0005a	48 6b c0 fe	 imul	 rax, rax, -2
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  00062	48 ba fa fa fa
	fa fa fa fa fa	 mov	 rdx, -361700864190383366 ; fafafafafafafafaH
  0006c	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00070	75 02		 jne	 SHORT $LN14@Adjust_man
  00072	eb 77		 jmp	 SHORT $LN15@Adjust_man
$LN14@Adjust_man:
$LN7@Adjust_man:
  00074	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  0007a	83 c0 09	 add	 eax, 9
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  00084	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00090	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00095	45 33 c9	 xor	 r9d, r9d
  00098	44 8b c0	 mov	 r8d, eax
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  000a2	b9 02 00 00 00	 mov	 ecx, 2
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 03		 jne	 SHORT $LN19@Adjust_man
  000b2	cc		 int	 3
  000b3	33 c0		 xor	 eax, eax
$LN19@Adjust_man:
  000b5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  000bb	83 c0 09	 add	 eax, 9
  000be	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000c7	44 8b c8	 mov	 r9d, eax
  000ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000e5	33 c0		 xor	 eax, eax
  000e7	85 c0		 test	 eax, eax
  000e9	75 89		 jne	 SHORT $LN7@Adjust_man
$LN15@Adjust_man:
  000eb	33 c0		 xor	 eax, eax
  000ed	85 c0		 test	 eax, eax
  000ef	0f 85 60 ff ff
	ff		 jne	 $LN4@Adjust_man

; 164  : 
; 165  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 166  :     // in range [_Min_back_shift, _Non_user_size]
; 167  : #ifdef _DEBUG
; 168  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000f5	48 c7 45 10 10
	00 00 00	 mov	 QWORD PTR _Min_back_shift$[rbp], 16

; 169  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 170  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 171  : #endif // _DEBUG
; 172  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fd	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00101	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  00105	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00108	48 2b c1	 sub	 rax, rcx
  0010b	48 89 45 18	 mov	 QWORD PTR _Back_shift$[rbp], rax
$LN10@Adjust_man:

; 173  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010f	48 83 7d 18 10	 cmp	 QWORD PTR _Back_shift$[rbp], 16
  00114	72 09		 jb	 SHORT $LN16@Adjust_man
  00116	48 83 7d 18 2f	 cmp	 QWORD PTR _Back_shift$[rbp], 47 ; 0000002fH
  0011b	77 02		 ja	 SHORT $LN16@Adjust_man
  0011d	eb 77		 jmp	 SHORT $LN17@Adjust_man
$LN16@Adjust_man:
$LN13@Adjust_man:
  0011f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00125	83 c0 13	 add	 eax, 19
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  0012f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0013b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00140	45 33 c9	 xor	 r9d, r9d
  00143	44 8b c0	 mov	 r8d, eax
  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0014d	b9 02 00 00 00	 mov	 ecx, 2
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00158	83 f8 01	 cmp	 eax, 1
  0015b	75 03		 jne	 SHORT $LN20@Adjust_man
  0015d	cc		 int	 3
  0015e	33 c0		 xor	 eax, eax
$LN20@Adjust_man:
  00160	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00166	83 c0 13	 add	 eax, 19
  00169	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00172	44 8b c8	 mov	 r9d, eax
  00175	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00190	33 c0		 xor	 eax, eax
  00192	85 c0		 test	 eax, eax
  00194	75 89		 jne	 SHORT $LN13@Adjust_man
$LN17@Adjust_man:
  00196	33 c0		 xor	 eax, eax
  00198	85 c0		 test	 eax, eax
  0019a	0f 85 6f ff ff
	ff		 jne	 $LN10@Adjust_man

; 174  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001a0	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  001a4	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  001a8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 175  : }

  001ab	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  001af	5d		 pop	 rbp
  001b0	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 80
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 85   :         void* _Allocate(const size_t _Bytes) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 86   :         return ::operator new(_Bytes);

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 87   :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\compare
;	COMDAT ??Nstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z
_TEXT	SEGMENT
tv66 = 64
_Val$ = 96
__formal$ = 104
??Nstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z PROC	; std::operator<=, COMDAT

; 203  :     _NODISCARD_FRIEND constexpr bool operator<=(const strong_ordering _Val, _Literal_zero) noexcept {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	55		 push	 rbp
  00009	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C3788713_compare
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 204  :         return _Val._Value <= 0;

  0001e	0f be 45 60	 movsx	 eax, BYTE PTR _Val$[rbp]
  00022	85 c0		 test	 eax, eax
  00024	7f 09		 jg	 SHORT $LN3@operator
  00026	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv66[rbp], 1
  0002d	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002f	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv66[rbp], 0
$LN4@operator:
  00036	0f b6 45 40	 movzx	 eax, BYTE PTR tv66[rbp]

; 205  :     }

  0003a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
??Nstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ENDP	; std::operator<=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\compare
;	COMDAT ??Ostd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z
_TEXT	SEGMENT
tv66 = 64
_Val$ = 96
__formal$ = 104
??Ostd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z PROC	; std::operator>, COMDAT

; 199  :     _NODISCARD_FRIEND constexpr bool operator>(const strong_ordering _Val, _Literal_zero) noexcept {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	55		 push	 rbp
  00009	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C3788713_compare
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 200  :         return _Val._Value > 0;

  0001e	0f be 45 60	 movsx	 eax, BYTE PTR _Val$[rbp]
  00022	85 c0		 test	 eax, eax
  00024	7e 09		 jle	 SHORT $LN3@operator
  00026	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv66[rbp], 1
  0002d	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002f	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv66[rbp], 0
$LN4@operator:
  00036	0f b6 45 40	 movzx	 eax, BYTE PTR tv66[rbp]

; 201  :     }

  0003a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
??Ostd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ENDP	; std::operator>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\compare
;	COMDAT ??Mstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z
_TEXT	SEGMENT
tv66 = 64
_Val$ = 96
__formal$ = 104
??Mstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z PROC	; std::operator<, COMDAT

; 195  :     _NODISCARD_FRIEND constexpr bool operator<(const strong_ordering _Val, _Literal_zero) noexcept {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	55		 push	 rbp
  00009	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C3788713_compare
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 196  :         return _Val._Value < 0;

  0001e	0f be 45 60	 movsx	 eax, BYTE PTR _Val$[rbp]
  00022	85 c0		 test	 eax, eax
  00024	7d 09		 jge	 SHORT $LN3@operator
  00026	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv66[rbp], 1
  0002d	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002f	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv66[rbp], 0
$LN4@operator:
  00036	0f b6 45 40	 movzx	 eax, BYTE PTR tv66[rbp]

; 197  :     }

  0003a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
??Mstd@@YA_NUstrong_ordering@0@U_Literal_zero@0@@Z ENDP	; std::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\compare
;	COMDAT ??Mstd@@YA_NUpartial_ordering@0@U_Literal_zero@0@@Z
_TEXT	SEGMENT
tv66 = 64
_Val$ = 96
__formal$ = 104
??Mstd@@YA_NUpartial_ordering@0@U_Literal_zero@0@@Z PROC ; std::operator<, COMDAT

; 59   :     _NODISCARD_FRIEND constexpr bool operator<(const partial_ordering _Val, _Literal_zero) noexcept {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	55		 push	 rbp
  00009	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C3788713_compare
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 60   :         return _Val._Value == static_cast<_Compare_t>(_Compare_ord::less);

  0001e	0f be 45 60	 movsx	 eax, BYTE PTR _Val$[rbp]
  00022	83 f8 ff	 cmp	 eax, -1
  00025	75 09		 jne	 SHORT $LN3@operator
  00027	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv66[rbp], 1
  0002e	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00030	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv66[rbp], 0
$LN4@operator:
  00037	0f b6 45 40	 movzx	 eax, BYTE PTR tv66[rbp]

; 61   :     }

  0003b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??Mstd@@YA_NUpartial_ordering@0@U_Literal_zero@0@@Z ENDP ; std::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 64
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 330  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00009	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2DED1E19_exception
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 331  :     _THROW(bad_array_new_length{});

  0001a	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0001e	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QEAA@XZ ; std::bad_array_new_length::bad_array_new_length
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
  0002a	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0002e	e8 00 00 00 00	 call	 _CxxThrowException
$LN2@Throw_bad_:

; 332  : }

  00033	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UEAA@XZ
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QEAA@AEBV01@@Z
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 141  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 140  :         : bad_alloc("bad array new length")

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AEAA@QEBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 142  :     }

  00039	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@AEBV01@@Z ; std::exception::exception
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 80
_Message$ = 88
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 129  :         : exception(_Message, 1)

  00020	41 b8 01 00 00
	00		 mov	 r8d, 1
  00026	48 8b 55 58	 mov	 rdx, QWORD PTR _Message$[rbp]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@QEBDH@Z ; std::exception::exception

; 130  :     {

  00033	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  0003e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 131  :     }

  00041	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 64
this$ = 96
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 94   :     {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00024	74 0e		 je	 SHORT $LN3@what
  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002e	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  00032	eb 0b		 jmp	 SHORT $LN4@what
$LN3@what:
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
  0003b	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
$LN4@what:
  0003f	48 8b 45 40	 mov	 rax, QWORD PTR tv69[rbp]

; 96   :     }

  00043	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00026	48 89 08	 mov	 QWORD PTR [rax], rcx

; 90   :         __std_exception_destroy(&_Data);

  00029	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 83 c0 08	 add	 rax, 8
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 __std_exception_destroy

; 91   :     }

  00039	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 96
_Other$ = 104
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  0001c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00021	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   :         : _Data()

  0002f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 83 c0 08	 add	 rax, 8
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 10 00 00 00	 mov	 ecx, 16
  00041	f3 aa		 rep stosb

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00043	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00047	48 83 c0 08	 add	 rax, 8
  0004b	48 8b 4d 68	 mov	 rcx, QWORD PTR _Other$[rbp]
  0004f	48 83 c1 08	 add	 rcx, 8
  00053	48 8b d0	 mov	 rdx, rax
  00056	e8 00 00 00 00	 call	 __std_exception_copy

; 74   :     }

  0005b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0005f	48 8d 65 48	 lea	 rsp, QWORD PTR [rbp+72]
  00063	5f		 pop	 rdi
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 96
_Message$ = 104
__formal$ = 112
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00015	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00021	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00031	48 89 08	 mov	 QWORD PTR [rax], rcx

; 65   :         : _Data()

  00034	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 83 c0 08	 add	 rax, 8
  0003c	48 8b f8	 mov	 rdi, rax
  0003f	33 c0		 xor	 eax, eax
  00041	b9 10 00 00 00	 mov	 ecx, 16
  00046	f3 aa		 rep stosb

; 67   :         _Data._What = _Message;

  00048	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8b 4d 68	 mov	 rcx, QWORD PTR _Message$[rbp]
  00050	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 68   :     }

  00054	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8d 65 48	 lea	 rsp, QWORD PTR [rbp+72]
  0005c	5f		 pop	 rdi
  0005d	5d		 pop	 rbp
  0005e	c3		 ret	 0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 635  :     _NODISCARD static constexpr long long(max)() noexcept {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__595ABB90_limits
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 636  :         return LLONG_MAX;

  00017	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH

; 637  :     }

  00021	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 178  : _EXPORT_STD _NODISCARD constexpr bool is_constant_evaluated() noexcept {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9A2CA802_xtr1common
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 179  :     return __builtin_is_constant_evaluated();

  00017	32 c0		 xor	 al, al

; 180  : }

  00019	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 80
_Where$ = 88
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 168  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__84C50014_vcruntime_new@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 169  :         (void)_Size;
; 170  :         return _Where;

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Where$[rbp]

; 171  :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z
_TEXT	SEGMENT
__formal$ = 80
__formal$ = 88
__formal$ = 96
?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z
_TEXT	SEGMENT
__formal$ = 80
__formal$ = 88
?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 80
__formal$ = 88
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Logging\Logger.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 80
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C263CAF0_Logger@cpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
