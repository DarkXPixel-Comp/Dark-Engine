; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33030.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?_inst@Application@@0PEAV1@EA			; Application::_inst
_BSS	SEGMENT
?_inst@Application@@0PEAV1@EA DQ 01H DUP (?)		; Application::_inst
_BSS	ENDS
msvcjmc	SEGMENT
__B51A3A23_Core@h DB 01H
__0ED14FEE_winpackagefamily@h DB 01H
__F92EF742_winapifamily@h DB 01H
__22E515EB_sdkddkver@h DB 01H
__4A250794_concurrencysal@h DB 01H
__64794009_sal@h DB 01H
__A3E7195B_vadefs@h DB 01H
__978626E5_vcruntime@h DB 01H
__73193115_excpt@h DB 01H
__EF35C9F2_stdarg@h DB 01H
__29F49F40_specstrings_undef@h DB 01H
__D0F42932_specstrings_strict@h DB 01H
__F00405FD_sdv_driverspecs@h DB 01H
__173E09CA_driverspecs@h DB 01H
__9A452361_specstrings@h DB 01H
__1B0272D9_corecrt@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__1EC467ED_ctype@h DB 01H
__98517906_kernelspecs@h DB 01H
__D3497022_basetsd@h DB 01H
__61CC25A1_errno@h DB 01H
__4CB5F942_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__7FCB5136_guiddef@h DB 01H
__FF8A9E11_pshpack4@h DB 01H
__D5438902_poppack@h DB 01H
__FB07E2A3_pshpack2@h DB 01H
__F6906775_pshpack8@h DB 01H
__F9415CFA_pshpack1@h DB 01H
__E58C6F1C_apiset@h DB 01H
__A5C52262_ktmtypes@h DB 01H
__FBBA8F9D_winnt@h DB 01H
__A32D3D2C_minwindef@h DB 01H
__7D798299_windef@h DB 01H
__9AE108E9_apisetcconv@h DB 01H
__9CE53D2C_minwinbase@h DB 01H
__5D0AA210_apiquery2@h DB 01H
__4DD4E726_processenv@h DB 01H
__3575CC96_fileapi@h DB 01H
__8EA220E6_fileapifromapp@h DB 01H
__BF9B31FE_debugapi@h DB 01H
__C3AFE134_utilapiset@h DB 01H
__76F69E51_handleapi@h DB 01H
__7E63D784_errhandlingapi@h DB 01H
__FFA7003C_fibersapi@h DB 01H
__8971CECF_namedpipeapi@h DB 01H
__46C9D8A6_profileapi@h DB 01H
__98D4F0A3_heapapi@h DB 01H
__50EF2A88_ioapiset@h DB 01H
__92EA1464_synchapi@h DB 01H
__A53D8AED_interlockedapi@h DB 01H
__B506CAAF_processthreadsapi@h DB 01H
__FF735694_sysinfoapi@h DB 01H
__29589789_memoryapi@h DB 01H
__E9C7A663_enclaveapi@h DB 01H
__D035F9F7_threadpoollegacyapiset@h DB 01H
__C899130C_threadpoolapiset@h DB 01H
__E0441EE7_jobapi@h DB 01H
__CEF86838_jobapi2@h DB 01H
__35AC6B9A_wow64apiset@h DB 01H
__C8AE41A5_libloaderapi@h DB 01H
__CC9E232D_securitybaseapi@h DB 01H
__C9D0C9B8_namespaceapi@h DB 01H
__30FF9CAD_systemtopologyapi@h DB 01H
__4D358795_processtopologyapi@h DB 01H
__40446D10_securityappcontainer@h DB 01H
__3A952EDF_realtimeapiset@h DB 01H
__F4865F4B_winerror@h DB 01H
__53C1BD93_timezoneapi@h DB 01H
__1FFBEDBF_winbase@h DB 01H
__43D3FA34_wingdi@h DB 01H
__D24A7391_tvout@h DB 01H
__7713A6C8_winuser@h DB 01H
__0B345F71_datetimeapi@h DB 01H
__9AC6960C_winnls@h DB 01H
__973A40A8_stringapiset@h DB 01H
__CC46FEE2_wincontypes@h DB 01H
__97D70BE1_consoleapi@h DB 01H
__27EC5E18_consoleapi2@h DB 01H
__262E342F_consoleapi3@h DB 01H
__641DCD70_wincon@h DB 01H
__5A96C7A7_verrsrc@h DB 01H
__B69C6FF2_winver@h DB 01H
__7AEB8C37_reason@h DB 01H
__59F1A8A9_winreg@h DB 01H
__EE0E2B7F_wnnc@h DB 01H
__DCDB7054_winnetwk@h DB 01H
__EDC72EEB_cderr@h DB 01H
__95F9199D_dde@h DB 01H
__66427627_ddeml@h DB 01H
__957C29A0_dlgs@h DB 01H
__12EA15AF_lzexpand@h DB 01H
__62131F15_mmsyscom@h DB 01H
__47E68D49_mciapi@h DB 01H
__5D7DD356_mmiscapi@h DB 01H
__7223D2EF_mmiscapi2@h DB 01H
__A330DBB3_playsoundapi@h DB 01H
__601B366F_mmeapi@h DB 01H
__1134ADD5_timeapi@h DB 01H
__93F2265A_joystickapi@h DB 01H
__DF6EB4E3_mmsystem@h DB 01H
__BD641FCB_nb30@h DB 01H
__DF8704F0_rpcdcep@h DB 01H
__5C6CA7BB_rpcdce@h DB 01H
__853533C4_rpcnsi@h DB 01H
__2D2406C3_rpcnterr@h DB 01H
__64521D71_rpcasync@h DB 01H
__AADCBA08_rpc@h DB 01H
__19E26CFF_shellapi@h DB 01H
__1E9F31D3_winperf@h DB 01H
__832A4112_inaddr@h DB 01H
__32C6F875_winsock@h DB 01H
__7953A3F8_bcrypt@h DB 01H
__E4169492_ncrypt@h DB 01H
__AF3DDDC3_dpapi@h DB 01H
__D1E23BF2_wincrypt@h DB 01H
__82AB4779_winefs@h DB 01H
__1FE431C9_rpcnsip@h DB 01H
__2B741F2D_rpcsal@h DB 01H
__92623256_rpcndr@h DB 01H
__9C18532E_wtypesbase@h DB 01H
__EA2E1D6D_wtypes@h DB 01H
__7DDD9F45_winioctl@h DB 01H
__E550A843_winsmcrd@h DB 01H
__9809C1BA_winscard@h DB 01H
__EA174FA4_prsht@h DB 01H
__0E1BD114_winspool@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__659C5902_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__30B1AFDA_unknwnbase@h DB 01H
__328C1996_objidlbase@h DB 01H
__C4E06B6A_cguid@h DB 01H
__434718C5_combaseapi@h DB 01H
__DE6FDEF1_unknwn@h DB 01H
__CCE0BACC_objidl@h DB 01H
__8C7011E5_oaidl@h DB 01H
__2E0B7863_propidlbase@h DB 01H
__BF4CF2EC_coml2api@h DB 01H
__6D897344_oleidl@h DB 01H
__1129FC2C_servprov@h DB 01H
__757952E4_msxml@h DB 01H
__B1191D53_urlmon@h DB 01H
__404D1A47_propidl@h DB 01H
__A1C63593_objbase@h DB 01H
__C1B0A9CB_oleauto@h DB 01H
__24EAF61F_ole2@h DB 01H
__2B1843DA_commdlg@h DB 01H
__81DDEDE3_stralign@h DB 01H
__2134D1B4_winsvc@h DB 01H
__11C07376_mcx@h DB 01H
__577CE3E7_ime_cmodes@h DB 01H
__1E72C31E_imm@h DB 01H
__63AA7AF5_Windows@h DB 01H
__735B63F8_xkeycheck@h DB 01H
__142C9C9C_yvals_core@h DB 01H
__84C50014_vcruntime_new@h DB 01H
__7A6EC116_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__E5B2708F_crtdefs@h DB 01H
__61229A4B_use_ansi@h DB 01H
__8C2D0B1D_yvals@h DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__4CF83D73_cstdio DB 01H
__76FF1542_cstring DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__8ECB7138_corecrt_share@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__D673EB20_cwchar DB 01H
__9A2CA802_xtr1common DB 01H
__95B36E16_iosfwd DB 01H
__DBEA773D_stdint@h DB 01H
__87335CDF_cstdint DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__3A6DBDA2_cstdlib DB 01H
__B9985323_float@h DB 01H
__3FBCF6F4_cfloat DB 01H
__BE829F50_climits DB 01H
__51ADDFC3_intrin0@inl@h DB 01H
__FC9FC984_intrin0@h DB 01H
__595ABB90_limits DB 01H
__9FA6670F_cstddef DB 01H
__3DF2A533_type_traits DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__35BB339F_eh@h DB 01H
__7280C444_vcruntime_exception@h DB 01H
__2DED1E19_exception DB 01H
__A5D71DBC_new DB 01H
__27E192CF_xatomic@h DB 01H
__50E371A7_initializer_list DB 01H
__339AE60A_concepts DB 01H
__C3788713_compare DB 01H
__0D603829_utility DB 01H
__874288EA___msvc_iter_core@hpp DB 01H
__B7320FC0_xutility DB 01H
__A0E057FF_tuple DB 01H
__67F55BEA_xmemory DB 01H
__A0A2F5C0_xpolymorphic_allocator@h DB 01H
__C671E263___msvc_sanitizer_annotate_container@hpp DB 01H
__1326DD76_xstring DB 01H
__4333DAD4_cctype DB 01H
__91273182_string DB 01H
__F3EA4CCC___msvc_bit_utils@hpp DB 01H
__14F7CB70_vector DB 01H
__FBEF5BAE_Array@h DB 01H
__9024636E_DarkString@h DB 01H
__C7215CCD_algorithm DB 01H
__103905FF_Application@h DB 01H
__92B9F28F_CommandLine@h DB 01H
__9021FEEF_Application@cpp DB 01H
msvcjmc	ENDS
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QEAA@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
PUBLIC	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IEAA@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0FCMDParameter@@QEAA@XZ			; FCMDParameter::FCMDParameter
PUBLIC	??1FCMDParameter@@QEAA@XZ			; FCMDParameter::~FCMDParameter
PUBLIC	??0FCMDParameter@@QEAA@AEBU0@@Z			; FCMDParameter::FCMDParameter
PUBLIC	??0FCMDParameter@@QEAA@$$QEAU0@@Z		; FCMDParameter::FCMDParameter
PUBLIC	??_GFCMDParameter@@QEAAPEAXI@Z			; FCMDParameter::`scalar deleting destructor'
PUBLIC	??0Application@@QEAA@XZ				; Application::Application
PUBLIC	??1Application@@QEAA@XZ				; Application::~Application
PUBLIC	?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Application::Initialize
PUBLIC	?ParseCmdLine@Application@@QEAAXXZ		; Application::ParseCmdLine
PUBLIC	?CheckParameterCmdLine@Application@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@Z ; Application::CheckParameterCmdLine
PUBLIC	??0?$allocator@UFCMDParameter@@@std@@QEAA@XZ	; std::allocator<FCMDParameter>::allocator<FCMDParameter>
PUBLIC	?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z ; std::allocator<FCMDParameter>::deallocate
PUBLIC	?allocate@?$allocator@UFCMDParameter@@@std@@QEAAPEAUFCMDParameter@@_K@Z ; std::allocator<FCMDParameter>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SA_KAEBV?$allocator@UFCMDParameter@@@2@@Z ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::max_size
PUBLIC	??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::vector<FCMDParameter,std::allocator<FCMDParameter> >
PUBLIC	??1?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::~vector<FCMDParameter,std::allocator<FCMDParameter> >
PUBLIC	?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::push_back
PUBLIC	?max_size@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::max_size
PUBLIC	?capacity@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::capacity
PUBLIC	?_Calculate_growth@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBA_K_K@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXQEAUFCMDParameter@@_K1@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Change_array
PUBLIC	?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Tidy
PUBLIC	?_Xlength@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@CAXXZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Xlength
PUBLIC	?_Orphan_range_unlocked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
PUBLIC	?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAAEBV?$allocator@UFCMDParameter@@@2@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<FCMDParameter> >::_Vector_val<std::_Simple_types<FCMDParameter> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFCMDParameter@@@2@XZ ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Get_first
PUBLIC	??$strncat_s@$0EA@@@YAHAEAY0EA@DPEBD_K@Z	; strncat_s<64>
PUBLIC	??$_Emplace_one_at_back@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_one_at_back<FCMDParameter const &>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0UFCMDParameter@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UFCMDParameter@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><FCMDParameter>
PUBLIC	??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1><>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ; std::_Destroy_range<std::allocator<FCMDParameter> >
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z	; std::construct_at<char,char const &,0>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
PUBLIC	??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z ; std::_Unfancy<FCMDParameter>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_back_with_unused_capacity<FCMDParameter const &>
PUBLIC	??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_reallocate<FCMDParameter const &>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$destroy@UFCMDParameter@@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@@Z ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::destroy<FCMDParameter>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &,0>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z	; std::construct_at<char,0>
PUBLIC	??$construct@UFCMDParameter@@AEBU1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@AEBU3@@Z ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::construct<FCMDParameter,FCMDParameter const &>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<FCMDParameter> >
PUBLIC	??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ; std::_Uninitialized_move<FCMDParameter *,std::allocator<FCMDParameter> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &,0>
PUBLIC	??$destroy_at@UFCMDParameter@@@std@@YAXQEAUFCMDParameter@@@Z ; std::destroy_at<FCMDParameter>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$construct_at@UFCMDParameter@@AEBU1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@AEBU1@@Z ; std::construct_at<FCMDParameter,FCMDParameter const &,0>
PUBLIC	??$_Get_unwrapped@AEBQEAUFCMDParameter@@@std@@YA?A_TAEBQEAUFCMDParameter@@@Z ; std::_Get_unwrapped<FCMDParameter * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@PEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Uninitialized_backout_al<std::allocator<FCMDParameter> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::~_Uninitialized_backout_al<std::allocator<FCMDParameter> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAPEAUFCMDParameter@@XZ ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Release
PUBLIC	??$_Emplace_back@UFCMDParameter@@@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAX$$QEAUFCMDParameter@@@Z ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Emplace_back<FCMDParameter>
PUBLIC	??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z		; std::_Get_size_of_n<80>
PUBLIC	??$construct@UFCMDParameter@@U1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@$$QEAU3@@Z ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::construct<FCMDParameter,FCMDParameter>
PUBLIC	??$construct_at@UFCMDParameter@@U1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@$$QEAU1@@Z ; std::construct_at<FCMDParameter,FCMDParameter,0>
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	?app@@3VApplication@@A				; app
PUBLIC	??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	__imp__invalid_parameter:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	__imp_strncat_s:PROC
EXTRN	strlen:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	_CxxThrowException:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
_BSS	SEGMENT
?app@@3VApplication@@A DB 060H DUP (?)			; app
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??2@YAPEAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??2@YAPEAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_constant_evaluated@std@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?is_constant_evaluated@std@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max@?$numeric_limits@_J@std@@SA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?max@?$numeric_limits@_J@std@@SA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN21
	DD	imagerel $LN21+433
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_base12@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0_Container_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+114
	DD	imagerel $unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z DD imagerel $LN5
	DD	imagerel $LN5+122
	DD	imagerel $unwind$?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+115
	DD	imagerel $unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+148
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN16
	DD	imagerel $LN16+305
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+86
	DD	imagerel $unwind$?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+71
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$allocator@D@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??0?$allocator@D@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN13
	DD	imagerel $LN13+189
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+93
	DD	imagerel $unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+149
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+105
	DD	imagerel $unwind$?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+144
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN8
	DD	imagerel $LN8+311
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+150
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+160
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD imagerel $LN12
	DD	imagerel $LN12+187
	DD	imagerel $unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+151
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+205
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FCMDParameter@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??0FCMDParameter@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1FCMDParameter@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??1FCMDParameter@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FCMDParameter@@QEAA@AEBU0@@Z DD imagerel $LN5
	DD	imagerel $LN5+88
	DD	imagerel $unwind$??0FCMDParameter@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0FCMDParameter@@QEAA@AEBU0@@Z@4HA DD imagerel ?dtor$0@?0???0FCMDParameter@@QEAA@AEBU0@@Z@4HA
	DD	imagerel ?dtor$0@?0???0FCMDParameter@@QEAA@AEBU0@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???0FCMDParameter@@QEAA@AEBU0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FCMDParameter@@QEAA@$$QEAU0@@Z DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??0FCMDParameter@@QEAA@$$QEAU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GFCMDParameter@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??_GFCMDParameter@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Application@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+80
	DD	imagerel $unwind$??0Application@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Application@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??1Application@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+120
	DD	imagerel $unwind$?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA DD imagerel ?dtor$0@?0??Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA
	DD	imagerel ?dtor$0@?0??Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ParseCmdLine@Application@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+923
	DD	imagerel $unwind$?ParseCmdLine@Application@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??ParseCmdLine@Application@@QEAAXXZ@4HA DD imagerel ?dtor$0@?0??ParseCmdLine@Application@@QEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??ParseCmdLine@Application@@QEAAXXZ@4HA+25
	DD	imagerel $unwind$?dtor$0@?0??ParseCmdLine@Application@@QEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckParameterCmdLine@Application@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$?CheckParameterCmdLine@Application@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$allocator@UFCMDParameter@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??0?$allocator@UFCMDParameter@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+193
	DD	imagerel $unwind$?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UFCMDParameter@@@std@@QEAAPEAUFCMDParameter@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@UFCMDParameter@@@std@@QEAAPEAUFCMDParameter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SA_KAEBV?$allocator@UFCMDParameter@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SA_KAEBV?$allocator@UFCMDParameter@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$??1?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?max_size@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?capacity@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+151
	DD	imagerel $unwind$?_Calculate_growth@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXQEAUFCMDParameter@@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+272
	DD	imagerel $unwind$?_Change_array@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXQEAUFCMDParameter@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+220
	DD	imagerel $unwind$?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?_Xlength@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_range_unlocked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z DD imagerel $LN8
	DD	imagerel $LN8+162
	DD	imagerel $unwind$?_Orphan_range_unlocked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z@4HA DD imagerel ?dtor$0@?0??_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z@4HA
	DD	imagerel ?dtor$0@?0??_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z@4HA+26
	DD	imagerel $unwind$?dtor$0@?0??_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_range@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$?_Orphan_range@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAAEBV?$allocator@UFCMDParameter@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAAEBV?$allocator@UFCMDParameter@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??0?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFCMDParameter@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFCMDParameter@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFCMDParameter@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFCMDParameter@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eapp@@YAXXZ DD imagerel ??__Eapp@@YAXXZ
	DD	imagerel ??__Eapp@@YAXXZ+53
	DD	imagerel $unwind$??__Eapp@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fapp@@YAXXZ DD imagerel ??__Fapp@@YAXXZ
	DD	imagerel ??__Fapp@@YAXXZ+29
	DD	imagerel $unwind$??__Fapp@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$strncat_s@$0EA@@@YAHAEAY0EA@DPEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??$strncat_s@$0EA@@@YAHAEAY0EA@DPEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z DD imagerel $LN4
	DD	imagerel $LN4+110
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+193
	DD	imagerel $unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0UFCMDParameter@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UFCMDParameter@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0UFCMDParameter@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UFCMDParameter@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+471
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+90
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_size@_K_K@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Convert_size@_K_K@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+377
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@D@std@@YAPEADPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Unfancy@D@std@@YAPEADPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@D@std@@YAPEADAEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@D@std@@YAPEADAEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z DD imagerel $LN3
	DD	imagerel $LN3+175
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z DD imagerel $LN13
	DD	imagerel $LN13+485
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z@4HA+72
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@UFCMDParameter@@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$destroy@UFCMDParameter@@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+86
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UFCMDParameter@@AEBU1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@AEBU3@@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$construct@UFCMDParameter@@AEBU1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@AEBU3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+172
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@UFCMDParameter@@@std@@YAXQEAUFCMDParameter@@@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??$destroy_at@UFCMDParameter@@@std@@YAXQEAUFCMDParameter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN13
	DD	imagerel $LN13+266
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UFCMDParameter@@AEBU1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@AEBU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$construct_at@UFCMDParameter@@AEBU1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@AEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEBQEAUFCMDParameter@@@std@@YA?A_TAEBQEAUFCMDParameter@@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Get_unwrapped@AEBQEAUFCMDParameter@@@std@@YA?A_TAEBQEAUFCMDParameter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@PEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??0?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@PEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAPEAUFCMDParameter@@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?_Release@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAPEAUFCMDParameter@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@UFCMDParameter@@@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAX$$QEAUFCMDParameter@@@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$??$_Emplace_back@UFCMDParameter@@@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAX$$QEAUFCMDParameter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UFCMDParameter@@U1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@$$QEAU3@@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??$construct@UFCMDParameter@@U1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@$$QEAU3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UFCMDParameter@@U1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@$$QEAU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$construct_at@UFCMDParameter@@U1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@$$QEAU1@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?app$initializer$@@3P6AXXZEA DQ FLAT:??__Eapp@@YAXXZ	; app$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38'
	DB	'.33030\include\xstring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ DB 'string subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H, 'o', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H, '3', 00H
	DB	'8', 00H, '.', 00H, '3', 00H, '3', 00H, '0', 00H, '3', 00H, '0'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e', 00H, 'm'
	DB	00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program Fi'
	DB	'les\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.'
	DB	'33030\include\xmemory', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA DD 09aH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UFCMDParameter@@U1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@$$QEAU1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UFCMDParameter@@U1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@$$QEAU3@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@UFCMDParameter@@@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAX$$QEAUFCMDParameter@@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAPEAUFCMDParameter@@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@PEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@1@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEBQEAUFCMDParameter@@@std@@YA?A_TAEBQEAUFCMDParameter@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UFCMDParameter@@AEBU1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@AEBU1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 035041201H
	DD	010d3312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@UFCMDParameter@@@std@@YAXQEAUFCMDParameter@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z DB 06H
	DB	00H
	DB	00H
	DB	0caH
	DB	02H
	DB	'h'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z DD 025042111H
	DD	011c2321H
	DD	050150012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@0@AEA_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UFCMDParameter@@AEBU1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@AEBU3@@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z DD 025041001H
	DD	0e20b2310H
	DD	050067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@UFCMDParameter@@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z DB 06H
	DB	00H
	DB	00H
	DB	0f5H, 03H
	DB	02H
	DB	0d9H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z DD 025041c19H
	DD	0117231cH
	DD	050100018H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@D@std@@YAPEADAEAD@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 025031419H
	DD	0b20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@D@std@@YAPEADPEAD@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD 025042101H
	DD	011c2321H
	DD	050150012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_size@_K_K@std@@YA_K_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z DD 025031919H
	DD	0b2142319H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	011H, 02H
	DB	02H
	DB	098H
	DB	00H
	DB	01cH
	DB	02H
	DB	09dH, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
	DD	imagerel $ip2state$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 025041c11H
	DD	0117231cH
	DD	050100016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0UFCMDParameter@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UFCMDParameter@@@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$strncat_s@$0EA@@@YAHAEAY0EA@DPEBD_K@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fapp@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eapp@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFCMDParameter@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFCMDParameter@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAAEBV?$allocator@UFCMDParameter@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_range@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z DB 06H
	DB	00H
	DB	00H
	DB	'j'
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z
	DD	imagerel $ip2state$?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z DD 025031911H
	DD	0d2142319H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_range_unlocked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@CAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ DD 025041219H
	DD	010d2312H
	DD	050060012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXQEAUFCMDParameter@@_K1@Z DD 025042101H
	DD	011c2321H
	DD	050150012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBA_K_K@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SA_KAEBV?$allocator@UFCMDParameter@@@2@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UFCMDParameter@@@std@@QEAAPEAUFCMDParameter@@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$allocator@UFCMDParameter@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckParameterCmdLine@Application@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??ParseCmdLine@Application@@QEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ParseCmdLine@Application@@QEAAXXZ DB 012H
	DB	00H
	DB	00H
	DB	'Q', 02H
	DB	02H
	DB	095H, 04H
	DB	00H
	DB	01cH
	DB	02H
	DB	0b0H
	DB	00H
	DB	01cH
	DB	02H
	DB	0c6H
	DB	00H
	DB	01cH
	DB	02H
	DB	095H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ParseCmdLine@Application@@QEAAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ParseCmdLine@Application@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ParseCmdLine@Application@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?ParseCmdLine@Application@@QEAAXXZ
	DD	imagerel $ip2state$?ParseCmdLine@Application@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ParseCmdLine@Application@@QEAAXXZ DD 025051311H
	DD	010e2313H
	DD	070070023H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ParseCmdLine@Application@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	096H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	DD	imagerel $ip2state$?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 025031e11H
	DD	0b219231eH
	DD	05015H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Application@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Application@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GFCMDParameter@@QEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FCMDParameter@@QEAA@$$QEAU0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0FCMDParameter@@QEAA@AEBU0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0FCMDParameter@@QEAA@AEBU0@@Z DB 06H
	DB	00H
	DB	00H
	DB	'Z'
	DB	02H
	DB	'B'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0FCMDParameter@@QEAA@AEBU0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0FCMDParameter@@QEAA@AEBU0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0FCMDParameter@@QEAA@AEBU0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0FCMDParameter@@QEAA@AEBU0@@Z
	DD	imagerel $ip2state$??0FCMDParameter@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FCMDParameter@@QEAA@AEBU0@@Z DD 025031411H
	DD	0d20f2314H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0FCMDParameter@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1FCMDParameter@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FCMDParameter@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 025031219H
	DD	0f20d2312H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD 035031401H
	DD	0d20f3314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 060H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 025031719H
	DD	0f2122317H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	0baH
	DB	02H
	DB	'\'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 025031711H
	DD	0f2122317H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 025030f19H
	DD	0d20a230fH
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025041001H
	DD	0c20b2310H
	DD	050067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 035031901H
	DD	0d2143319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$allocator@D@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_base12@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 035041701H
	DD	01123317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 025030e01H
	DD	0f209230eH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 025041501H
	DD	0c2102315H
	DD	0500b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 025041a01H
	DD	0c215231aH
	DD	050107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max@?$numeric_limits@_J@std@@SA_JXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_constant_evaluated@std@@YA_NXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??2@YAPEAX_KPEAX@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@UFCMDParameter@@U1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@$$QEAU1@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@UFCMDParameter@@U1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@$$QEAU1@@Z PROC ; std::construct_at<FCMDParameter,FCMDParameter,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00036	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003a	e8 00 00 00 00	 call	 ??0FCMDParameter@@QEAA@$$QEAU0@@Z

; 243  : }

  0003f	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00043	5d		 pop	 rbp
  00044	c3		 ret	 0
??$construct_at@UFCMDParameter@@U1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@$$QEAU1@@Z ENDP ; std::construct_at<FCMDParameter,FCMDParameter,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$construct@UFCMDParameter@@U1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@$$QEAU3@@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@UFCMDParameter@@U1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@$$QEAU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::construct<FCMDParameter,FCMDParameter>, COMDAT

; 719  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 720  : #if _HAS_CXX20
; 721  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00025	48 8b 55 60	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$construct_at@UFCMDParameter@@U1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@$$QEAU1@@Z ; std::construct_at<FCMDParameter,FCMDParameter,0>

; 722  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 723  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 724  : #endif // ^^^ !_HAS_CXX20 ^^^
; 725  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$construct@UFCMDParameter@@U1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@$$QEAU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::construct<FCMDParameter,FCMDParameter>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Max_possible$1 = 8
_Count$ = 96
??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<80>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 01	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	48 b8 33 33 33
	33 33 33 33 03	 mov	 rax, 230584300921369395	; 0333333333333333H
  00029	48 89 45 08	 mov	 QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

  0002d	48 b8 33 33 33
	33 33 33 33 03	 mov	 rax, 230584300921369395	; 0333333333333333H
  00037	48 39 45 60	 cmp	 QWORD PTR _Count$[rbp], rax
  0003b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

  0003d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  00042	48 6b 45 60 50	 imul	 rax, QWORD PTR _Count$[rbp], 80 ; 00000050H
$LN3@Get_size_o:

; 75   : }

  00047	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<80>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Emplace_back@UFCMDParameter@@@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAX$$QEAUFCMDParameter@@@Z
_TEXT	SEGMENT
tv74 = 64
tv72 = 72
this$ = 96
<_Vals_0>$ = 104
??$_Emplace_back@UFCMDParameter@@@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAX$$QEAUFCMDParameter@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Emplace_back<FCMDParameter>, COMDAT

; 1800 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1801 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00028	e8 00 00 00 00	 call	 ??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z ; std::_Unfancy<FCMDParameter>
  0002d	48 89 45 40	 mov	 QWORD PTR tv74[rbp], rax
  00031	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00039	48 89 45 48	 mov	 QWORD PTR tv72[rbp], rax
  0003d	4c 8b 45 68	 mov	 r8, QWORD PTR <_Vals_0>$[rbp]
  00041	48 8b 55 40	 mov	 rdx, QWORD PTR tv74[rbp]
  00045	48 8b 4d 48	 mov	 rcx, QWORD PTR tv72[rbp]
  00049	e8 00 00 00 00	 call	 ??$construct@UFCMDParameter@@U1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@$$QEAU3@@Z ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::construct<FCMDParameter,FCMDParameter>

; 1802 :         ++_Last;

  0004e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00052	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00056	48 83 c0 50	 add	 rax, 80			; 00000050H
  0005a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0005e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1803 :     }

  00062	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00066	5d		 pop	 rbp
  00067	c3		 ret	 0
??$_Emplace_back@UFCMDParameter@@@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAX$$QEAUFCMDParameter@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Emplace_back<FCMDParameter>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAPEAUFCMDParameter@@XZ
_TEXT	SEGMENT
this$ = 80
?_Release@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAPEAUFCMDParameter@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Release, COMDAT

; 1805 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1806 :         _First = _Last;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00027	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1807 :         return _Last;

  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1808 :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAPEAUFCMDParameter@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::~_Uninitialized_backout_al<std::allocator<FCMDParameter> >, COMDAT

; 1795 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1796 :         _Destroy_range(_First, _Last, _Al);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  00023	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00032	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ; std::_Destroy_range<std::allocator<FCMDParameter> >

; 1797 :     }

  00037	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003b	5d		 pop	 rbp
  0003c	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::~_Uninitialized_backout_al<std::allocator<FCMDParameter> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@PEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@1@@Z
_TEXT	SEGMENT
this$ = 80
_Dest$ = 88
_Al_$ = 96
??0?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@PEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Uninitialized_backout_al<std::allocator<FCMDParameter> >, COMDAT

; 1790 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Dest$[rbp]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 4d 58	 mov	 rcx, QWORD PTR _Dest$[rbp]
  00038	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 4d 60	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00044	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??0?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@PEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Uninitialized_backout_al<std::allocator<FCMDParameter> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUFCMDParameter@@@std@@YA?A_TAEBQEAUFCMDParameter@@@Z
_TEXT	SEGMENT
_It$ = 80
??$_Get_unwrapped@AEBQEAUFCMDParameter@@@std@@YA?A_TAEBQEAUFCMDParameter@@@Z PROC ; std::_Get_unwrapped<FCMDParameter * const &>, COMDAT

; 1171 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1172 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1173 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1174 :         return _It + 0;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _It$[rbp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1175 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1176 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1177 :     } else {
; 1178 :         return static_cast<_Iter&&>(_It);
; 1179 :     }
; 1180 : }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
??$_Get_unwrapped@AEBQEAUFCMDParameter@@@std@@YA?A_TAEBQEAUFCMDParameter@@@Z ENDP ; std::_Get_unwrapped<FCMDParameter * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@UFCMDParameter@@AEBU1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@AEBU1@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@UFCMDParameter@@AEBU1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@AEBU1@@Z PROC ; std::construct_at<FCMDParameter,FCMDParameter const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00036	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003a	e8 00 00 00 00	 call	 ??0FCMDParameter@@QEAA@AEBU0@@Z

; 243  : }

  0003f	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00043	5d		 pop	 rbp
  00044	c3		 ret	 0
??$construct_at@UFCMDParameter@@AEBU1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@AEBU1@@Z ENDP ; std::construct_at<FCMDParameter,FCMDParameter const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 96
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 00	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 0

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 69   :         if (_Count > _Max_possible) {
; 70   :             _Throw_bad_array_new_length(); // multiply overflow
; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  0001f	48 8b 45 60	 mov	 rax, QWORD PTR _Count$[rbp]

; 75   : }

  00023	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Block_size$ = 0
_Ptr_container$ = 8
_Ptr$ = 16
_Bytes$ = 112
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 136  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 137  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 138  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR _Bytes$[rbp]
  00022	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  00026	48 89 45 00	 mov	 QWORD PTR _Block_size$[rbp], rax

; 139  :     if (_Block_size <= _Bytes) {

  0002a	48 8b 45 70	 mov	 rax, QWORD PTR _Bytes$[rbp]
  0002e	48 39 45 00	 cmp	 QWORD PTR _Block_size$[rbp], rax
  00032	77 05		 ja	 SHORT $LN8@Allocate_m

; 140  :         _Throw_bad_array_new_length(); // add overflow

  00034	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 141  :     }
; 142  : 
; 143  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00039	48 8b 4d 00	 mov	 rcx, QWORD PTR _Block_size$[rbp]
  0003d	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  00042	48 89 45 08	 mov	 QWORD PTR _Ptr_container$[rbp], rax
$LN4@Allocate_m:

; 144  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00046	48 83 7d 08 00	 cmp	 QWORD PTR _Ptr_container$[rbp], 0
  0004b	74 02		 je	 SHORT $LN9@Allocate_m
  0004d	eb 6b		 jmp	 SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  00056	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00062	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00067	45 33 c9	 xor	 r9d, r9d
  0006a	41 b8 90 00 00
	00		 mov	 r8d, 144		; 00000090H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  00077	b9 02 00 00 00	 mov	 ecx, 2
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00082	83 f8 01	 cmp	 eax, 1
  00085	75 03		 jne	 SHORT $LN12@Allocate_m
  00087	cc		 int	 3
  00088	33 c0		 xor	 eax, eax
$LN12@Allocate_m:
  0008a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00093	41 b9 90 00 00
	00		 mov	 r9d, 144		; 00000090H
  00099	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	75 95		 jne	 SHORT $LN7@Allocate_m
$LN10@Allocate_m:
  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	75 86		 jne	 SHORT $LN4@Allocate_m

; 145  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000c0	48 8b 45 08	 mov	 rax, QWORD PTR _Ptr_container$[rbp]
  000c4	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  000c8	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H
  000cc	48 89 45 10	 mov	 QWORD PTR _Ptr$[rbp], rax

; 146  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000d0	b8 08 00 00 00	 mov	 eax, 8
  000d5	48 6b c0 ff	 imul	 rax, rax, -1
  000d9	48 8b 4d 10	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000dd	48 8b 55 08	 mov	 rdx, QWORD PTR _Ptr_container$[rbp]
  000e1	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 147  : 
; 148  : #ifdef _DEBUG
; 149  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000e5	b8 08 00 00 00	 mov	 eax, 8
  000ea	48 6b c0 fe	 imul	 rax, rax, -2
  000ee	48 8b 4d 10	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000f2	48 ba fa fa fa
	fa fa fa fa fa	 mov	 rdx, -361700864190383366 ; fafafafafafafafaH
  000fc	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 150  : #endif // _DEBUG
; 151  :     return _Ptr;

  00100	48 8b 45 10	 mov	 rax, QWORD PTR _Ptr$[rbp]
$LN11@Allocate_m:

; 152  : }

  00104	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00108	5d		 pop	 rbp
  00109	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy_at@UFCMDParameter@@@std@@YAXQEAUFCMDParameter@@@Z
_TEXT	SEGMENT
_Location$ = 80
??$destroy_at@UFCMDParameter@@@std@@YAXQEAUFCMDParameter@@@Z PROC ; std::destroy_at<FCMDParameter>, COMDAT

; 313  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 314  : #if _HAS_CXX20
; 315  :     if constexpr (is_array_v<_Ty>) {
; 316  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 317  :     } else
; 318  : #endif // _HAS_CXX20
; 319  :     {
; 320  :         _Location->~_Ty();

  0001b	33 d2		 xor	 edx, edx
  0001d	48 8b 4d 50	 mov	 rcx, QWORD PTR _Location$[rbp]
  00021	e8 00 00 00 00	 call	 ??_GFCMDParameter@@QEAAPEAXI@Z

; 321  :     }
; 322  : }

  00026	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??$destroy_at@UFCMDParameter@@@std@@YAXQEAUFCMDParameter@@@Z ENDP ; std::destroy_at<FCMDParameter>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@deallocate

; 709  :             _Al.deallocate(_Ptr, _Count);

  00031	4c 8b 45 60	 mov	 r8, QWORD PTR _Count$[rbp]
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00039	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate

; 710  :         } else

  00042	eb 11		 jmp	 SHORT $LN3@deallocate
$LN2@deallocate:

; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00044	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00050	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>
$LN3@deallocate:

; 715  :         }
; 716  :     }

  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Backout$ = 16
$T1 = 104
_First$ = 128
_Last$ = 136
_Dest$ = 144
_Al$ = 152
??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z PROC ; std::_Uninitialized_move<FCMDParameter *,std::allocator<FCMDParameter> >, COMDAT

; 1926 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1927 :     // move [_First, _Last) to raw _Dest, using _Al
; 1928 :     // note: only called internally from elsewhere in the STL
; 1929 :     using _Ptrval     = typename _Alloc::value_type*;
; 1930 :     auto _UFirst      = _Get_unwrapped(_First);

  0002d	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR _First$[rbp]
  00034	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAUFCMDParameter@@@std@@YA?A_TAEBQEAUFCMDParameter@@@Z ; std::_Get_unwrapped<FCMDParameter * const &>
  00039	48 89 45 00	 mov	 QWORD PTR _UFirst$[rbp], rax

; 1931 :     const auto _ULast = _Get_unwrapped(_Last);

  0003d	48 8d 8d 88 00
	00 00		 lea	 rcx, QWORD PTR _Last$[rbp]
  00044	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAUFCMDParameter@@@std@@YA?A_TAEBQEAUFCMDParameter@@@Z ; std::_Get_unwrapped<FCMDParameter * const &>
  00049	48 89 45 08	 mov	 QWORD PTR _ULast$[rbp], rax

; 1932 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1933 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1934 : #if _HAS_CXX20
; 1935 :         if (!_STD is_constant_evaluated())
; 1936 : #endif // _HAS_CXX20
; 1937 :         {
; 1938 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1939 :             return _Dest + (_ULast - _UFirst);
; 1940 :         }
; 1941 :     }
; 1942 : 
; 1943 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  0004d	4c 8b 85 98 00
	00 00		 mov	 r8, QWORD PTR _Al$[rbp]
  00054	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR _Dest$[rbp]
  0005b	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$[rbp]
  0005f	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@PEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Uninitialized_backout_al<std::allocator<FCMDParameter> >
  00064	90		 npad	 1

; 1944 :     for (; _UFirst != _ULast; ++_UFirst) {

  00065	eb 0c		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00067	48 8b 45 00	 mov	 rax, QWORD PTR _UFirst$[rbp]
  0006b	48 83 c0 50	 add	 rax, 80			; 00000050H
  0006f	48 89 45 00	 mov	 QWORD PTR _UFirst$[rbp], rax
$LN4@Uninitiali:
  00073	48 8b 45 08	 mov	 rax, QWORD PTR _ULast$[rbp]
  00077	48 39 45 00	 cmp	 QWORD PTR _UFirst$[rbp], rax
  0007b	74 0f		 je	 SHORT $LN3@Uninitiali

; 1945 :         _Backout._Emplace_back(_STD move(*_UFirst));

  0007d	48 8b 55 00	 mov	 rdx, QWORD PTR _UFirst$[rbp]
  00081	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$[rbp]
  00085	e8 00 00 00 00	 call	 ??$_Emplace_back@UFCMDParameter@@@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAX$$QEAUFCMDParameter@@@Z ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Emplace_back<FCMDParameter>

; 1946 :     }

  0008a	eb db		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1947 : 
; 1948 :     return _Backout._Release();

  0008c	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$[rbp]
  00090	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAPEAUFCMDParameter@@XZ ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::_Release
  00095	48 89 45 68	 mov	 QWORD PTR $T1[rbp], rax
  00099	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$[rbp]
  0009d	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::~_Uninitialized_backout_al<std::allocator<FCMDParameter> >
  000a2	48 8b 45 68	 mov	 rax, QWORD PTR $T1[rbp]

; 1949 : }

  000a6	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000aa	5d		 pop	 rbp
  000ab	c3		 ret	 0
??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ENDP ; std::_Uninitialized_move<FCMDParameter *,std::allocator<FCMDParameter> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 0
_ULast$ = 8
_Backout$ = 16
$T1 = 104
_First$ = 128
_Last$ = 136
_Dest$ = 144
_Al$ = 152
?dtor$0@?0???$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<FCMDParameter *,std::allocator<FCMDParameter> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR _Backout$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<FCMDParameter> >::~_Uninitialized_backout_al<std::allocator<FCMDParameter> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<FCMDParameter *,std::allocator<FCMDParameter> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Count$ = 88
??$_Allocate_at_least_helper@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<FCMDParameter> >, COMDAT

; 2198 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2199 : #if _HAS_CXX23
; 2200 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2201 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2202 :         _Count                  = _Allocated;
; 2203 :         return _Ptr;
; 2204 :     } else
; 2205 : #endif // _HAS_CXX23
; 2206 :     {
; 2207 :         return _Al.allocate(_Count);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Count$[rbp]
  00024	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002b	e8 00 00 00 00	 call	 ?allocate@?$allocator@UFCMDParameter@@@std@@QEAAPEAUFCMDParameter@@_K@Z ; std::allocator<FCMDParameter>::allocate

; 2208 :     }
; 2209 : }

  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<FCMDParameter> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$construct@UFCMDParameter@@AEBU1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@AEBU3@@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@UFCMDParameter@@AEBU1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@AEBU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::construct<FCMDParameter,FCMDParameter const &>, COMDAT

; 719  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 720  : #if _HAS_CXX20
; 721  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00025	48 8b 55 60	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00029	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0002d	e8 00 00 00 00	 call	 ??$construct_at@UFCMDParameter@@AEBU1@$0A@@std@@YAPEAUFCMDParameter@@QEAU1@AEBU1@@Z ; std::construct_at<FCMDParameter,FCMDParameter const &,0>

; 722  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 723  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 724  : #endif // ^^^ !_HAS_CXX20 ^^^
; 725  :     }

  00032	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??$construct@UFCMDParameter@@AEBU1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@AEBU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::construct<FCMDParameter,FCMDParameter const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
_Location$ = 112
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z PROC		; std::construct_at<char,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  00017	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  0001c	48 c7 45 40 01
	00 00 00	 mov	 QWORD PTR $T1[rbp], 1
  00024	48 8b 55 70	 mov	 rdx, QWORD PTR _Location$[rbp]
  00028	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0002c	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00031	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00035	48 8b 7d 48	 mov	 rdi, QWORD PTR $T2[rbp]
  00039	33 c0		 xor	 eax, eax
  0003b	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003f	f3 aa		 rep stosb
  00041	48 8b 45 48	 mov	 rax, QWORD PTR $T2[rbp]

; 243  : }

  00045	48 8d 65 58	 lea	 rsp, QWORD PTR [rbp+88]
  00049	5f		 pop	 rdi
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z ENDP		; std::construct_at<char,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
$T1 = 64
tv65 = 72
_Left$ = 96
_Right$ = 104
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 98   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 99   :     // return smaller of _Left and _Right
; 100  :     return _Right < _Left ? _Right : _Left;

  00020	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00024	48 8b 4d 60	 mov	 rcx, QWORD PTR _Left$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	73 0a		 jae	 SHORT $LN3@min
  00030	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00034	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
  00038	eb 08		 jmp	 SHORT $LN4@min
$LN3@min:
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR _Left$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
$LN4@min:
  00042	48 8b 45 48	 mov	 rax, QWORD PTR tv65[rbp]
  00046	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0004a	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 101  : }

  0004e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 80
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 230  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 231  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 232  : #if defined(_M_IX86) || defined(_M_X64)
; 233  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 234  :     if (!_STD is_constant_evaluated())

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	75 15		 jne	 SHORT $LN2@Allocate

; 235  : #endif // _HAS_CXX20
; 236  :     {
; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00027	48 81 7d 50 00
	10 00 00	 cmp	 QWORD PTR _Bytes$[rbp], 4096 ; 00001000H
  0002f	72 0b		 jb	 SHORT $LN3@Allocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00031	48 8b 4d 50	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00035	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0003a	eb 14		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:
$LN2@Allocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  0003c	48 83 7d 50 00	 cmp	 QWORD PTR _Bytes$[rbp], 0
  00041	74 0b		 je	 SHORT $LN4@Allocate

; 244  :         return _Traits::_Allocate(_Bytes);

  00043	48 8b 4d 50	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00047	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  0004c	eb 02		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  0004e	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 248  : }

  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Max_possible$1 = 8
_Count$ = 96
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 64   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 65   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 00 01	 mov	 BYTE PTR _Overflow_is_possible$[rbp], 1

; 66   : 
; 67   :     if constexpr (_Overflow_is_possible) {
; 68   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00029	48 89 45 08	 mov	 QWORD PTR _Max_possible$1[rbp], rax

; 69   :         if (_Count > _Max_possible) {

  0002d	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00037	48 39 45 60	 cmp	 QWORD PTR _Count$[rbp], rax
  0003b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 70   :             _Throw_bad_array_new_length(); // multiply overflow

  0003d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 71   :         }
; 72   :     }
; 73   : 
; 74   :     return _Count * _Ty_size;

  00042	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
$LN3@Get_size_o:

; 75   : }

  00047	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z PROC ; std::construct_at<char *,char * &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 08 00 00 00	 mov	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00040	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00044	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ENDP ; std::construct_at<char *,char * &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$destroy@UFCMDParameter@@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@@Z
_TEXT	SEGMENT
__formal$ = 80
_Ptr$ = 88
??$destroy@UFCMDParameter@@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@@Z PROC ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::destroy<FCMDParameter>, COMDAT

; 728  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 729  : #if _HAS_CXX20
; 730  :         _STD destroy_at(_Ptr);

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00024	e8 00 00 00 00	 call	 ??$destroy_at@UFCMDParameter@@@std@@YAXQEAUFCMDParameter@@@Z ; std::destroy_at<FCMDParameter>

; 731  : #else // _HAS_CXX20
; 732  :         _Ptr->~_Uty();
; 733  : #endif // _HAS_CXX20
; 734  :     }

  00029	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
??$destroy@UFCMDParameter@@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::destroy<FCMDParameter>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 80
_Count$ = 88
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2198 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2199 : #if _HAS_CXX23
; 2200 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2201 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2202 :         _Count                  = _Allocated;
; 2203 :         return _Ptr;
; 2204 :     } else
; 2205 : #endif // _HAS_CXX23
; 2206 :     {
; 2207 :         return _Al.allocate(_Count);

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Count$[rbp]
  00024	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002b	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2208 :     }
; 2209 : }

  00030	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT

; 1483 :     _CONSTEXPR20 ~_Container_proxy_ptr12() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1484 :         if (_Ptr) {

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	74 14		 je	 SHORT $LN2@Container_

; 1485 :             _Delete_plain_internal(_Al, _Ptr);

  00025	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00030	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00034	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
$LN2@Container_:

; 1486 :         }
; 1487 :     }

  00039	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_Al_$ = 104
_Mycont$ = 112
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT

; 1469 :     _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00029	e8 00 00 00 00	 call	 ??0_Basic_container_proxy_ptr12@std@@IEAA@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
  0002e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00032	48 8b 4d 68	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00036	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1470 :         // create a new _Container_proxy pointing at _Mycont
; 1471 :         _Ptr = _Unfancy(_Al_.allocate(1));

  0003a	ba 01 00 00 00	 mov	 edx, 1
  0003f	48 8b 4d 68	 mov	 rcx, QWORD PTR _Al_$[rbp]
  00043	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00050	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00054	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1472 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  00057	48 8b 4d 70	 mov	 rcx, QWORD PTR _Mycont$[rbp]
  0005b	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ; std::addressof<std::_Container_base12>
  00060	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00064	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00068	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0006c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006f	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>

; 1473 :         _Mycont._Myproxy = _Ptr;

  00074	48 8b 45 70	 mov	 rax, QWORD PTR _Mycont$[rbp]
  00078	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0007c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1474 :     }

  00082	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00086	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0008a	5d		 pop	 rbp
  0008b	c3		 ret	 0
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
_TEXT	SEGMENT
_Ptr$ = 80
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Ptr$[rbp]

; 37   : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1123 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1124 :     // deallocate a plain pointer using an allocator
; 1125 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1126 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1127 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00020	41 b8 01 00 00
	00		 mov	 r8d, 1
  00026	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  00033	90		 npad	 1

; 1128 :     } else {
; 1129 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1130 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1131 :     }
; 1132 : }

  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z
_TEXT	SEGMENT
_Al$ = 0
_My_data$ = 8
_Myfirst$ = 16
_Mylast$ = 24
_Whereoff$ = 32
_Oldsize$ = 40
_Newsize$ = 48
_Newcapacity$ = 56
_Newvec$ = 64
_Constructed_last$ = 72
_Constructed_first$ = 80
this$ = 176
_Whereptr$ = 184
<_Val_0>$ = 192
??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_reallocate<FCMDParameter const &>, COMDAT

; 811  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 812  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 813  :         _Alty& _Al        = _Getal();

  00028	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
  00034	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 814  :         auto& _My_data    = _Mypair._Myval2;

  00038	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003f	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax

; 815  :         pointer& _Myfirst = _My_data._Myfirst;

  00043	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00047	48 83 c0 08	 add	 rax, 8
  0004b	48 89 45 10	 mov	 QWORD PTR _Myfirst$[rbp], rax

; 816  :         pointer& _Mylast  = _My_data._Mylast;

  0004f	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00053	48 83 c0 10	 add	 rax, 16
  00057	48 89 45 18	 mov	 QWORD PTR _Mylast$[rbp], rax

; 817  : 
; 818  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 819  : 
; 820  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0005b	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR _Whereptr$[rbp]
  00069	48 2b c8	 sub	 rcx, rax
  0006c	48 8b c1	 mov	 rax, rcx
  0006f	48 99		 cdq
  00071	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00076	48 f7 f9	 idiv	 rcx
  00079	48 89 45 20	 mov	 QWORD PTR _Whereoff$[rbp], rax

; 821  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0007d	48 8b 45 18	 mov	 rax, QWORD PTR _Mylast$[rbp]
  00081	48 8b 4d 10	 mov	 rcx, QWORD PTR _Myfirst$[rbp]
  00085	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 2b c1	 sub	 rax, rcx
  0008e	48 99		 cdq
  00090	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00095	48 f7 f9	 idiv	 rcx
  00098	48 89 45 28	 mov	 QWORD PTR _Oldsize$[rbp], rax

; 822  : 
; 823  :         if (_Oldsize == max_size()) {

  0009c	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a3	e8 00 00 00 00	 call	 ?max_size@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::max_size
  000a8	48 39 45 28	 cmp	 QWORD PTR _Oldsize$[rbp], rax
  000ac	75 05		 jne	 SHORT $LN2@Emplace_re

; 824  :             _Xlength();

  000ae	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@CAXXZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Xlength
$LN2@Emplace_re:

; 825  :         }
; 826  : 
; 827  :         const size_type _Newsize = _Oldsize + 1;

  000b3	48 8b 45 28	 mov	 rax, QWORD PTR _Oldsize$[rbp]
  000b7	48 ff c0	 inc	 rax
  000ba	48 89 45 30	 mov	 QWORD PTR _Newsize$[rbp], rax

; 828  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

  000be	48 8b 55 30	 mov	 rdx, QWORD PTR _Newsize$[rbp]
  000c2	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c9	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBA_K_K@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Calculate_growth
  000ce	48 89 45 38	 mov	 QWORD PTR _Newcapacity$[rbp], rax

; 829  : 
; 830  :         const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);

  000d2	48 8d 55 38	 lea	 rdx, QWORD PTR _Newcapacity$[rbp]
  000d6	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  000da	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@AEAV?$allocator@UFCMDParameter@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<FCMDParameter> >
  000df	48 89 45 40	 mov	 QWORD PTR _Newvec$[rbp], rax

; 831  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000e3	48 6b 45 20 50	 imul	 rax, QWORD PTR _Whereoff$[rbp], 80 ; 00000050H
  000e8	48 8b 4d 40	 mov	 rcx, QWORD PTR _Newvec$[rbp]
  000ec	48 8d 44 01 50	 lea	 rax, QWORD PTR [rcx+rax+80]
  000f1	48 89 45 48	 mov	 QWORD PTR _Constructed_last$[rbp], rax

; 832  :         pointer _Constructed_first      = _Constructed_last;

  000f5	48 8b 45 48	 mov	 rax, QWORD PTR _Constructed_last$[rbp]
  000f9	48 89 45 50	 mov	 QWORD PTR _Constructed_first$[rbp], rax

; 833  : 
; 834  :         _TRY_BEGIN
; 835  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000fd	48 6b 45 20 50	 imul	 rax, QWORD PTR _Whereoff$[rbp], 80 ; 00000050H
  00102	48 8b 4d 40	 mov	 rcx, QWORD PTR _Newvec$[rbp]
  00106	48 03 c8	 add	 rcx, rax
  00109	48 8b c1	 mov	 rax, rcx
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 ??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z ; std::_Unfancy<FCMDParameter>
  00114	4c 8b 85 c0 00
	00 00		 mov	 r8, QWORD PTR <_Val_0>$[rbp]
  0011b	48 8b d0	 mov	 rdx, rax
  0011e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  00122	e8 00 00 00 00	 call	 ??$construct@UFCMDParameter@@AEBU1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@AEBU3@@Z ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::construct<FCMDParameter,FCMDParameter const &>

; 836  :         _Constructed_first = _Newvec + _Whereoff;

  00127	48 6b 45 20 50	 imul	 rax, QWORD PTR _Whereoff$[rbp], 80 ; 00000050H
  0012c	48 8b 4d 40	 mov	 rcx, QWORD PTR _Newvec$[rbp]
  00130	48 03 c8	 add	 rcx, rax
  00133	48 8b c1	 mov	 rax, rcx
  00136	48 89 45 50	 mov	 QWORD PTR _Constructed_first$[rbp], rax

; 837  : 
; 838  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0013a	48 8b 45 18	 mov	 rax, QWORD PTR _Mylast$[rbp]
  0013e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00141	48 39 85 b8 00
	00 00		 cmp	 QWORD PTR _Whereptr$[rbp], rax
  00148	75 1d		 jne	 SHORT $LN4@Emplace_re

; 839  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 840  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

  0014a	4c 8b 4d 00	 mov	 r9, QWORD PTR _Al$[rbp]
  0014e	4c 8b 45 40	 mov	 r8, QWORD PTR _Newvec$[rbp]
  00152	48 8b 45 18	 mov	 rax, QWORD PTR _Mylast$[rbp]
  00156	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00159	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  0015d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00160	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ; std::_Uninitialized_move<FCMDParameter *,std::allocator<FCMDParameter> >

; 841  :             } else {
; 842  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 843  :             }
; 844  :         } else { // provide basic guarantee

  00165	eb 4c		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 845  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

  00167	4c 8b 4d 00	 mov	 r9, QWORD PTR _Al$[rbp]
  0016b	4c 8b 45 40	 mov	 r8, QWORD PTR _Newvec$[rbp]
  0016f	48 8b 95 b8 00
	00 00		 mov	 rdx, QWORD PTR _Whereptr$[rbp]
  00176	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  0017a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0017d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ; std::_Uninitialized_move<FCMDParameter *,std::allocator<FCMDParameter> >

; 846  :             _Constructed_first = _Newvec;

  00182	48 8b 45 40	 mov	 rax, QWORD PTR _Newvec$[rbp]
  00186	48 89 45 50	 mov	 QWORD PTR _Constructed_first$[rbp], rax

; 847  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  0018a	48 6b 45 20 50	 imul	 rax, QWORD PTR _Whereoff$[rbp], 80 ; 00000050H
  0018f	48 8b 4d 40	 mov	 rcx, QWORD PTR _Newvec$[rbp]
  00193	48 8d 44 01 50	 lea	 rax, QWORD PTR [rcx+rax+80]
  00198	4c 8b 4d 00	 mov	 r9, QWORD PTR _Al$[rbp]
  0019c	4c 8b c0	 mov	 r8, rax
  0019f	48 8b 45 18	 mov	 rax, QWORD PTR _Mylast$[rbp]
  001a3	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001a6	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR _Whereptr$[rbp]
  001ad	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAUFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@YAPEAUFCMDParameter@@QEAU1@0PEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ; std::_Uninitialized_move<FCMDParameter *,std::allocator<FCMDParameter> >
  001b2	90		 npad	 1
$LN5@Emplace_re:
  001b3	eb 00		 jmp	 SHORT $LN9@Emplace_re
$LN10@Emplace_re:
$LN9@Emplace_re:

; 848  :         }
; 849  :         _CATCH_ALL
; 850  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 851  :         _Al.deallocate(_Newvec, _Newcapacity);
; 852  :         _RERAISE;
; 853  :         _CATCH_END
; 854  : 
; 855  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001b5	4c 8b 4d 38	 mov	 r9, QWORD PTR _Newcapacity$[rbp]
  001b9	4c 8b 45 30	 mov	 r8, QWORD PTR _Newsize$[rbp]
  001bd	48 8b 55 40	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  001c1	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c8	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXQEAUFCMDParameter@@_K1@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Change_array

; 856  :         return _Newvec + _Whereoff;

  001cd	48 6b 45 20 50	 imul	 rax, QWORD PTR _Whereoff$[rbp], 80 ; 00000050H
  001d2	48 8b 4d 40	 mov	 rcx, QWORD PTR _Newvec$[rbp]
  001d6	48 03 c8	 add	 rcx, rax
  001d9	48 8b c1	 mov	 rax, rcx

; 857  :     }

  001dc	48 8d a5 a0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+160]
  001e3	5d		 pop	 rbp
  001e4	c3		 ret	 0
$LN11@Emplace_re:
??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_reallocate<FCMDParameter const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Al$ = 0
_My_data$ = 8
_Myfirst$ = 16
_Mylast$ = 24
_Whereoff$ = 32
_Oldsize$ = 40
_Newsize$ = 48
_Newcapacity$ = 56
_Newvec$ = 64
_Constructed_last$ = 72
_Constructed_first$ = 80
this$ = 176
_Whereptr$ = 184
<_Val_0>$ = 192
?catch$0@?0???$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z@4HA PROC ; `std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_reallocate<FCMDParameter const &>'::`1'::catch$0

; 849  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
__catch$??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z$0:

; 850  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  0000e	4c 8b 45 00	 mov	 r8, QWORD PTR _Al$[rbp]
  00012	48 8b 55 48	 mov	 rdx, QWORD PTR _Constructed_last$[rbp]
  00016	48 8b 4d 50	 mov	 rcx, QWORD PTR _Constructed_first$[rbp]
  0001a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ; std::_Destroy_range<std::allocator<FCMDParameter> >

; 851  :         _Al.deallocate(_Newvec, _Newcapacity);

  0001f	4c 8b 45 38	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00023	48 8b 55 40	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  00027	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z ; std::allocator<FCMDParameter>::deallocate

; 852  :         _RERAISE;

  00030	33 d2		 xor	 edx, edx
  00032	33 c9		 xor	 ecx, ecx
  00034	e8 00 00 00 00	 call	 _CxxThrowException
  00039	90		 npad	 1

; 853  :         _CATCH_END

  0003a	48 8d 05 00 00
	00 00		 lea	 rax, $LN10@catch$0
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
  00047	cc		 int	 3
?catch$0@?0???$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z@4HA ENDP ; `std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_reallocate<FCMDParameter const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z
_TEXT	SEGMENT
_My_data$ = 0
_Mylast$ = 8
_Result$ = 16
tv77 = 88
tv75 = 96
this$ = 128
<_Val_0>$ = 136
??$_Emplace_back_with_unused_capacity@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_back_with_unused_capacity<FCMDParameter const &>, COMDAT

; 788  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 789  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 790  :         auto& _My_data   = _Mypair._Myval2;

  00023	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 791  :         pointer& _Mylast = _My_data._Mylast;

  0002e	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00032	48 83 c0 10	 add	 rax, 16
  00036	48 89 45 08	 mov	 QWORD PTR _Mylast$[rbp], rax

; 792  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 793  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 794  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 795  :             _ASAN_VECTOR_MODIFY(1);
; 796  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);
; 797  :         } else {
; 798  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 799  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0003a	48 8b 45 08	 mov	 rax, QWORD PTR _Mylast$[rbp]
  0003e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00041	e8 00 00 00 00	 call	 ??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z ; std::_Unfancy<FCMDParameter>
  00046	48 89 45 58	 mov	 QWORD PTR tv77[rbp], rax
  0004a	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
  00056	48 89 45 60	 mov	 QWORD PTR tv75[rbp], rax
  0005a	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR <_Val_0>$[rbp]
  00061	48 8b 55 58	 mov	 rdx, QWORD PTR tv77[rbp]
  00065	48 8b 4d 60	 mov	 rcx, QWORD PTR tv75[rbp]
  00069	e8 00 00 00 00	 call	 ??$construct@UFCMDParameter@@AEBU1@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@AEBU3@@Z ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::construct<FCMDParameter,FCMDParameter const &>

; 800  :             _ASAN_VECTOR_RELEASE_GUARD;
; 801  :         }
; 802  : 
; 803  :         _Orphan_range(_Mylast, _Mylast);

  0006e	48 8b 45 08	 mov	 rax, QWORD PTR _Mylast$[rbp]
  00072	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00075	48 8b 45 08	 mov	 rax, QWORD PTR _Mylast$[rbp]
  00079	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0007c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00083	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range

; 804  :         _Ty& _Result = *_Mylast;

  00088	48 8b 45 08	 mov	 rax, QWORD PTR _Mylast$[rbp]
  0008c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008f	48 89 45 10	 mov	 QWORD PTR _Result$[rbp], rax

; 805  :         ++_Mylast;

  00093	48 8b 45 08	 mov	 rax, QWORD PTR _Mylast$[rbp]
  00097	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009a	48 83 c0 50	 add	 rax, 80			; 00000050H
  0009e	48 8b 4d 08	 mov	 rcx, QWORD PTR _Mylast$[rbp]
  000a2	48 89 01	 mov	 QWORD PTR [rcx], rax

; 806  : 
; 807  :         return _Result;

  000a5	48 8b 45 10	 mov	 rax, QWORD PTR _Result$[rbp]

; 808  :     }

  000a9	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000ad	5d		 pop	 rbp
  000ae	c3		 ret	 0
??$_Emplace_back_with_unused_capacity@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_back_with_unused_capacity<FCMDParameter const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z
_TEXT	SEGMENT
_Ptr$ = 80
??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z PROC ; std::_Unfancy<FCMDParameter>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Ptr$[rbp]

; 37   : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z ENDP ; std::_Unfancy<FCMDParameter>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 10 00 00 00	 mov	 ecx, 16
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00036	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00039	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  0003d	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 243  : }

  00042	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00046	5d		 pop	 rbp
  00047	c3		 ret	 0
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z
_TEXT	SEGMENT
$T1 = 64
_Location$ = 96
<_Args_0>$ = 104
??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z PROC	; std::construct_at<char,char const &,0>, COMDAT

; 241  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 242  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00020	48 8b 55 60	 mov	 rdx, QWORD PTR _Location$[rbp]
  00024	b9 01 00 00 00	 mov	 ecx, 1
  00029	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0002e	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00032	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00036	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  0003a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0003d	88 08		 mov	 BYTE PTR [rax], cl
  0003f	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 243  : }

  00043	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z ENDP	; std::construct_at<char,char const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 80
_Bytes$ = 88
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 251  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0b		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 256  :     } else

  00035	eb 25		 jmp	 SHORT $LN3@Deallocate
$LN2@Deallocate:

; 257  : #endif // _HAS_CXX20
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00037	48 81 7d 58 00
	10 00 00	 cmp	 QWORD PTR _Bytes$[rbp], 4096 ; 00001000H
  0003f	72 0d		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00041	48 8d 55 58	 lea	 rdx, QWORD PTR _Bytes$[rbp]
  00045	48 8d 4d 50	 lea	 rcx, QWORD PTR _Ptr$[rbp]
  00049	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0004e	48 8b 55 58	 mov	 rdx, QWORD PTR _Bytes$[rbp]
  00052	48 8b 4d 50	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00056	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0005b	90		 npad	 1
$LN3@Deallocate:

; 265  :     }
; 266  : }

  0005c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
$T1 = 64
tv65 = 72
_Left$ = 96
_Right$ = 104
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Left$[rbp]
  00024	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0002e	73 0a		 jae	 SHORT $LN3@max
  00030	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00034	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
  00038	eb 08		 jmp	 SHORT $LN4@max
$LN3@max:
  0003a	48 8b 45 60	 mov	 rax, QWORD PTR _Left$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR tv65[rbp], rax
$LN4@max:
  00042	48 8b 45 48	 mov	 rax, QWORD PTR tv65[rbp]
  00046	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0004a	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]

; 78   : }

  0004e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 80
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   :     return _Ptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Ptr$[rbp]

; 37   : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &,0>

; 252  :     } else

  00041	eb 28		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 40	 mov	 rax, QWORD PTR $T1[rbp]
  00061	48 8b 4d 68	 mov	 rcx, QWORD PTR <_Args_0>$[rbp]
  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00068	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
_TEXT	SEGMENT
_Old_capacity$ = 0
_New_capacity$ = 8
_Al$ = 16
_New_ptr$ = 24
tv88 = 96
tv86 = 104
this$ = 128
_New_size$ = 136
_Fn$ = 144
<_Args_0>$ = 152
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>, COMDAT

; 4744 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4745 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4746 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4747 :         if (_New_size > max_size()) {

  0002d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00039	48 39 85 88 00
	00 00		 cmp	 QWORD PTR _New_size$[rbp], rax
  00040	76 05		 jbe	 SHORT $LN2@Reallocate

; 4748 :             _Xlen_string(); // result too long

  00042	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4749 :         }
; 4750 : 
; 4751 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00047	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00052	48 89 45 00	 mov	 QWORD PTR _Old_capacity$[rbp], rax

; 4752 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00056	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR _New_size$[rbp]
  0005d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00064	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00069	48 89 45 08	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4753 :         auto& _Al                     = _Getal();

  0006d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00074	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00079	48 89 45 10	 mov	 QWORD PTR _Al$[rbp], rax

; 4754 :         ++_New_capacity;

  0007d	48 8b 45 08	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00081	48 ff c0	 inc	 rax
  00084	48 89 45 08	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4755 :         const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  00088	48 8d 55 08	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  0008c	48 8b 4d 10	 mov	 rcx, QWORD PTR _Al$[rbp]
  00090	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  00095	48 89 45 18	 mov	 QWORD PTR _New_ptr$[rbp], rax

; 4756 :         --_New_capacity;

  00099	48 8b 45 08	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  0009d	48 ff c8	 dec	 rax
  000a0	48 89 45 08	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 4757 : 
; 4758 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  000a4	48 8b 45 08	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  000a8	48 ff c0	 inc	 rax
  000ab	48 89 45 60	 mov	 QWORD PTR tv88[rbp], rax
  000af	48 8b 4d 18	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  000b3	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  000b8	48 89 45 68	 mov	 QWORD PTR tv86[rbp], rax
  000bc	48 8b 55 60	 mov	 rdx, QWORD PTR tv88[rbp]
  000c0	48 8b 4d 68	 mov	 rcx, QWORD PTR tv86[rbp]
  000c4	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 4759 :         _Mypair._Myval2._Orphan_all();

  000c9	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 4760 :         _ASAN_STRING_REMOVE(*this);
; 4761 :         _Mypair._Myval2._Mysize = _New_size;

  000d8	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000df	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _New_size$[rbp]
  000e6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4762 :         _Mypair._Myval2._Myres  = _New_capacity;

  000ea	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000f1	48 8b 4d 08	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  000f5	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4763 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  000f9	48 8b 4d 18	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  000fd	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00102	4c 8b 8d 98 00
	00 00		 mov	 r9, QWORD PTR <_Args_0>$[rbp]
  00109	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR _New_size$[rbp]
  00110	48 8b d0	 mov	 rdx, rax
  00113	48 8d 8d 90 00
	00 00		 lea	 rcx, QWORD PTR _Fn$[rbp]
  0011a	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()

; 4764 :         if (_BUF_SIZE <= _Old_capacity) {

  0011f	48 83 7d 00 10	 cmp	 QWORD PTR _Old_capacity$[rbp], 16
  00124	72 2f		 jb	 SHORT $LN3@Reallocate

; 4765 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00126	48 8b 45 00	 mov	 rax, QWORD PTR _Old_capacity$[rbp]
  0012a	48 ff c0	 inc	 rax
  0012d	4c 8b c0	 mov	 r8, rax
  00130	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00137	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0013b	48 8b 4d 10	 mov	 rcx, QWORD PTR _Al$[rbp]
  0013f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4766 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  00144	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0014b	48 8b 4d 18	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  0014f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 4767 :         } else {

  00153	eb 17		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4768 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00155	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0015c	48 83 c0 08	 add	 rax, 8
  00160	48 8d 55 18	 lea	 rdx, QWORD PTR _New_ptr$[rbp]
  00164	48 8b c8	 mov	 rcx, rax
  00167	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4769 :         }
; 4770 : 
; 4771 :         _ASAN_STRING_CREATE(*this);
; 4772 :         return *this;

  0016c	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
$LN5@Reallocate:

; 4773 :     }

  00173	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  00177	5d		 pop	 rbp
  00178	c3		 ret	 0
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
_New_ptr$ = 104
_Count$ = 112
_Ptr$ = 120
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator(), COMDAT

; 3399 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3400 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  0002a	4c 8b 45 70	 mov	 r8, QWORD PTR _Count$[rbp]
  0002e	48 8b 55 78	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00032	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00036	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3401 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0003b	c6 45 40 00	 mov	 BYTE PTR $T1[rbp], 0
  0003f	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  00043	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  00047	48 03 c8	 add	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3402 :             },

  00059	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005d	5d		 pop	 rbp
  0005e	c3		 ret	 0
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 80
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1108 :     sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1109 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1110 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1111 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1112 : 
; 1113 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1114 :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 1115 :             _Xlength_error("size is too long for _Size_type");
; 1116 :         }
; 1117 :     }
; 1118 : 
; 1119 :     return static_cast<_Size_type>(_Len);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Len$[rbp]

; 1120 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 80
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 303  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 304  :     if constexpr (is_array_v<_Ty>) {
; 305  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 306  :     } else {
; 307  :         _Obj.~_Ty();
; 308  :     }
; 309  : }

  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
_Al$ = 96
??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z PROC ; std::_Destroy_range<std::allocator<FCMDParameter> >, COMDAT

; 1086 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1087 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1088 :     using _Ty = typename _Alloc::value_type;
; 1089 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1090 :         for (; _First != _Last; ++_First) {

  00025	eb 0c		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00027	48 8b 45 50	 mov	 rax, QWORD PTR _First$[rbp]
  0002b	48 83 c0 50	 add	 rax, 80			; 00000050H
  0002f	48 89 45 50	 mov	 QWORD PTR _First$[rbp], rax
$LN4@Destroy_ra:
  00033	48 8b 45 58	 mov	 rax, QWORD PTR _Last$[rbp]
  00037	48 39 45 50	 cmp	 QWORD PTR _First$[rbp], rax
  0003b	74 17		 je	 SHORT $LN3@Destroy_ra

; 1091 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

  0003d	48 8b 4d 50	 mov	 rcx, QWORD PTR _First$[rbp]
  00041	e8 00 00 00 00	 call	 ??$_Unfancy@UFCMDParameter@@@std@@YAPEAUFCMDParameter@@PEAU1@@Z ; std::_Unfancy<FCMDParameter>
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 4d 60	 mov	 rcx, QWORD PTR _Al$[rbp]
  0004d	e8 00 00 00 00	 call	 ??$destroy@UFCMDParameter@@@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SAXAEAV?$allocator@UFCMDParameter@@@1@QEAUFCMDParameter@@@Z ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::destroy<FCMDParameter>

; 1092 :         }

  00052	eb d3		 jmp	 SHORT $LN2@Destroy_ra
$LN3@Destroy_ra:

; 1093 :     }
; 1094 : }

  00054	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00058	5d		 pop	 rbp
  00059	c3		 ret	 0
??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<FCMDParameter> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S14$ = 24
_Proxy$ = 32
_New_capacity$ = 48
_New_ptr$ = 56
tv152 = 128
tv148 = 128
tv146 = 136
this$ = 160
_Arg$ = 168
_Count$ = 176
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 2609 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2610 :         auto& _My_data = _Mypair._Myval2;

  00028	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 2611 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2612 : 
; 2613 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2614 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2615 :         } else {
; 2616 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2617 :         }
; 2618 : 
; 2619 :         if (_Count > max_size()) {

  00033	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003a	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0003f	48 39 85 b0 00
	00 00		 cmp	 QWORD PTR _Count$[rbp], rax
  00046	76 05		 jbe	 SHORT $LN2@Construct

; 2620 :             _Xlen_string(); // result too long

  00048	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2621 :         }
; 2622 : 
; 2623 :         auto& _Al       = _Getal();

  0004d	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00054	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00059	48 89 45 08	 mov	 QWORD PTR _Al$[rbp], rax

; 2624 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0005d	48 8b 55 08	 mov	 rdx, QWORD PTR _Al$[rbp]
  00061	48 8d 4d 18	 lea	 rcx, QWORD PTR $S14$[rbp]
  00065	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0006a	48 8d 45 18	 lea	 rax, QWORD PTR $S14$[rbp]
  0006e	48 89 45 10	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 2625 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00072	4c 8b 45 00	 mov	 r8, QWORD PTR _My_data$[rbp]
  00076	48 8b 55 10	 mov	 rdx, QWORD PTR _Alproxy$[rbp]
  0007a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0007e	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00083	90		 npad	 1

; 2626 : 
; 2627 :         if (_Count < _BUF_SIZE) {

  00084	48 83 bd b0 00
	00 00 10	 cmp	 QWORD PTR _Count$[rbp], 16
  0008c	73 50		 jae	 SHORT $LN3@Construct

; 2628 :             _My_data._Mysize = _Count;

  0008e	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00092	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  00099	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2629 :             _My_data._Myres  = _BUF_SIZE - 1;

  0009d	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000a1	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 2630 : 
; 2631 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2632 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2633 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2634 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2635 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2636 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2637 :             } else { // _Strat == _Construct_strategy::_From_string
; 2638 : #ifdef _INSERT_STRING_ANNOTATION
; 2639 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2640 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2641 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

  000a9	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000ad	48 83 c0 08	 add	 rax, 8
  000b1	41 b8 10 00 00
	00		 mov	 r8d, 16
  000b7	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _Arg$[rbp]
  000be	48 8b c8	 mov	 rcx, rax
  000c1	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2642 : #endif // !_INSERT_STRING_ANNOTATION
; 2643 :             }
; 2644 : 
; 2645 :             _Proxy._Release();

  000c6	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000ca	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  000cf	90		 npad	 1

; 2646 :             return;

  000d0	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  000d4	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000d9	e9 f0 00 00 00	 jmp	 $LN4@Construct
$LN3@Construct:

; 2647 :         }
; 2648 : 
; 2649 :         _My_data._Myres         = _BUF_SIZE - 1;

  000de	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  000e2	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 2650 :         size_type _New_capacity = _Calculate_growth(_Count);

  000ea	48 8b 95 b0 00
	00 00		 mov	 rdx, QWORD PTR _Count$[rbp]
  000f1	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f8	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  000fd	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2651 :         ++_New_capacity;

  00101	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00105	48 ff c0	 inc	 rax
  00108	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2652 :         const pointer _New_ptr = _Allocate_at_least_helper(_Al, _New_capacity); // throws

  0010c	48 8d 55 30	 lea	 rdx, QWORD PTR _New_capacity$[rbp]
  00110	48 8b 4d 08	 mov	 rcx, QWORD PTR _Al$[rbp]
  00114	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  00119	48 89 45 38	 mov	 QWORD PTR _New_ptr$[rbp], rax

; 2653 :         --_New_capacity;

  0011d	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00121	48 ff c8	 dec	 rax
  00124	48 89 45 30	 mov	 QWORD PTR _New_capacity$[rbp], rax

; 2654 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00128	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0012c	48 83 c0 08	 add	 rax, 8
  00130	48 8d 55 38	 lea	 rdx, QWORD PTR _New_ptr$[rbp]
  00134	48 8b c8	 mov	 rcx, rax
  00137	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2655 : 
; 2656 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

  0013c	48 8b 45 30	 mov	 rax, QWORD PTR _New_capacity$[rbp]
  00140	48 ff c0	 inc	 rax
  00143	48 89 85 80 00
	00 00		 mov	 QWORD PTR tv148[rbp], rax
  0014a	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  0014e	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00153	48 89 85 88 00
	00 00		 mov	 QWORD PTR tv146[rbp], rax
  0015a	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR tv148[rbp]
  00161	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR tv146[rbp]
  00168	e8 00 00 00 00	 call	 ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes

; 2657 : 
; 2658 :         _My_data._Mysize = _Count;

  0016d	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00171	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR _Count$[rbp]
  00178	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2659 :         _My_data._Myres  = _New_capacity;

  0017c	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00180	48 8b 4d 30	 mov	 rcx, QWORD PTR _New_capacity$[rbp]
  00184	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2660 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2661 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2662 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2663 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2664 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2665 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2666 :         } else { // _Strat == _Construct_strategy::_From_string
; 2667 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  00188	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  0018f	48 ff c0	 inc	 rax
  00192	48 89 85 80 00
	00 00		 mov	 QWORD PTR tv152[rbp], rax
  00199	48 8b 4d 38	 mov	 rcx, QWORD PTR _New_ptr$[rbp]
  0019d	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  001a2	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR tv152[rbp]
  001a9	4c 8b c1	 mov	 r8, rcx
  001ac	48 8b 95 a8 00
	00 00		 mov	 rdx, QWORD PTR _Arg$[rbp]
  001b3	48 8b c8	 mov	 rcx, rax
  001b6	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2668 :         }
; 2669 : 
; 2670 :         _ASAN_STRING_CREATE(*this);
; 2671 :         _Proxy._Release();

  001bb	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  001bf	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
  001c4	90		 npad	 1

; 2672 :     }

  001c5	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  001c9	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
$LN4@Construct:
  001ce	48 8d a5 90 00
	00 00		 lea	 rsp, QWORD PTR [rbp+144]
  001d5	5d		 pop	 rbp
  001d6	c3		 ret	 0
$LN6@Construct:
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 0
_Al$ = 8
_Alproxy$ = 16
$S14$ = 24
_Proxy$ = 32
_New_capacity$ = 48
_New_ptr$ = 56
tv152 = 128
tv148 = 128
tv146 = 136
this$ = 160
_Arg$ = 168
_Count$ = 176
?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 20	 lea	 rcx, QWORD PTR _Proxy$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  00028	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
_Val1$ = 96
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1524 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1063 : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1064 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1065 :         _Left = _Right;
; 1066 :     }
; 1067 : }

  00020	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
_New_proxy$ = 0
$T1 = 72
this$ = 96
_Al$ = 104
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT

; 1207 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1208 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  00020	ba 01 00 00 00	 mov	 edx, 1
  00025	48 8b 4d 68	 mov	 rcx, QWORD PTR _Al$[rbp]
  00029	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00036	48 89 45 00	 mov	 QWORD PTR _New_proxy$[rbp], rax

; 1209 :         _Construct_in_place(*_New_proxy, this);

  0003a	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00042	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  00046	48 8b 4d 00	 mov	 rcx, QWORD PTR _New_proxy$[rbp]
  0004a	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>

; 1210 :         _Myproxy            = _New_proxy;

  0004f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00053	48 8b 4d 00	 mov	 rcx, QWORD PTR _New_proxy$[rbp]
  00057	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1211 :         _New_proxy->_Mycont = this;

  0005a	48 8b 45 00	 mov	 rax, QWORD PTR _New_proxy$[rbp]
  0005e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00062	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1212 :     }

  00065	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0$$V@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1><>, COMDAT

; 1519 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00023	e8 00 00 00 00	 call	 ??0?$allocator@UFCMDParameter@@@std@@QEAA@XZ ; std::allocator<FCMDParameter>::allocator<FCMDParameter>
  00028	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<FCMDParameter> >::_Vector_val<std::_Simple_types<FCMDParameter> >
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 80
_Ptr$ = 88
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1135 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1136 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1137 :     using _Ty = typename _Alloc::value_type;
; 1138 :     _Ptr->~_Ty();
; 1139 :     _Deallocate_plain(_Al, _Ptr);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR _Al$[rbp]
  00028	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >

; 1140 : }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??$?0UFCMDParameter@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UFCMDParameter@@@1@@Z
_TEXT	SEGMENT
this$ = 80
__formal$ = 88
??$?0UFCMDParameter@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UFCMDParameter@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><FCMDParameter>, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??$?0UFCMDParameter@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UFCMDParameter@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><FCMDParameter>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ; std::_Get_size_of_n<16>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 6b 45 60 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bb	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z
_TEXT	SEGMENT
_My_data$ = 0
_Mylast$ = 8
this$ = 96
<_Val_0>$ = 104
??$_Emplace_one_at_back@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_one_at_back<FCMDParameter const &>, COMDAT

; 775  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 776  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 777  :         auto& _My_data   = _Mypair._Myval2;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 778  :         pointer& _Mylast = _My_data._Mylast;

  00028	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0002c	48 83 c0 10	 add	 rax, 16
  00030	48 89 45 08	 mov	 QWORD PTR _Mylast$[rbp], rax

; 779  : 
; 780  :         if (_Mylast != _My_data._Myend) {

  00034	48 8b 45 08	 mov	 rax, QWORD PTR _Mylast$[rbp]
  00038	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0003c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00040	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00043	74 0f		 je	 SHORT $LN2@Emplace_on

; 781  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00045	48 8b 55 68	 mov	 rdx, QWORD PTR <_Val_0>$[rbp]
  00049	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0004d	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_back_with_unused_capacity<FCMDParameter const &>
  00052	eb 14		 jmp	 SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 782  :         }
; 783  : 
; 784  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00054	4c 8b 45 68	 mov	 r8, QWORD PTR <_Val_0>$[rbp]
  00058	48 8b 45 08	 mov	 rax, QWORD PTR _Mylast$[rbp]
  0005c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0005f	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00063	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAPEAUFCMDParameter@@QEAU2@AEBU2@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_reallocate<FCMDParameter const &>
$LN1@Emplace_on:

; 785  :     }

  00068	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006c	5d		 pop	 rbp
  0006d	c3		 ret	 0
??$_Emplace_one_at_back@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_one_at_back<FCMDParameter const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\string.h
;	COMDAT ??$strncat_s@$0EA@@@YAHAEAY0EA@DPEBD_K@Z
_TEXT	SEGMENT
_Destination$ = 80
_Source$ = 88
_Count$ = 96
??$strncat_s@$0EA@@@YAHAEAY0EA@DPEBD_K@Z PROC		; strncat_s<64>, COMDAT

; 260  :     )

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__E8295E1E_string@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 255  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

  00025	4c 8b 4d 60	 mov	 r9, QWORD PTR _Count$[rbp]
  00029	4c 8b 45 58	 mov	 r8, QWORD PTR _Source$[rbp]
  0002d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00032	48 8b 4d 50	 mov	 rcx, QWORD PTR _Destination$[rbp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat_s
  0003c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00040	5d		 pop	 rbp
  00041	c3		 ret	 0
??$strncat_s@$0EA@@@YAHAEAY0EA@DPEBD_K@Z ENDP		; strncat_s<64>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fapp@@YAXXZ
text$yd	SEGMENT
??__Fapp@@YAXXZ PROC					; `dynamic atexit destructor for 'app'', COMDAT
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?app@@3VApplication@@A ; app
  00012	e8 00 00 00 00	 call	 ??1Application@@QEAA@XZ	; Application::~Application
  00017	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
??__Fapp@@YAXXZ ENDP					; `dynamic atexit destructor for 'app''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Application\Application.cpp
;	COMDAT ??__Eapp@@YAXXZ
text$di	SEGMENT
??__Eapp@@YAXXZ PROC					; `dynamic initializer for 'app'', COMDAT

; 6    : Application app;

  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9021FEEF_Application@cpp
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?app@@3VApplication@@A ; app
  0001e	e8 00 00 00 00	 call	 ??0Application@@QEAA@XZ	; Application::Application
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__Fapp@@YAXXZ ; `dynamic atexit destructor for 'app''
  0002a	e8 00 00 00 00	 call	 atexit
  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??__Eapp@@YAXXZ ENDP					; `dynamic initializer for 'app''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFCMDParameter@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFCMDParameter@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFCMDParameter@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFCMDParameter@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFCMDParameter@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<FCMDParameter> >::_Vector_val<std::_Simple_types<FCMDParameter> >, COMDAT

; 397  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QEAA@XZ ; std::_Container_base12::_Container_base12
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00030	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0003c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00040	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<FCMDParameter> >::_Vector_val<std::_Simple_types<FCMDParameter> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAAEBV?$allocator@UFCMDParameter@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAAEBV?$allocator@UFCMDParameter@@@2@XZ PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal, COMDAT

; 2193 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2194 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFCMDParameter@@@2@XZ ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Get_first

; 2195 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAAEBV?$allocator@UFCMDParameter@@@2@XZ ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal, COMDAT

; 2189 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2190 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Get_first

; 2191 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?_Orphan_range@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Last$ = 96
?_Orphan_range@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range, COMDAT

; 2174 :     _CONSTEXPR20 void _Orphan_range(pointer _First, pointer _Last) const {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2175 :         // orphan iterators within specified (inclusive) range
; 2176 : #if _HAS_CXX20
; 2177 :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@Orphan_ran

; 2178 :             _Orphan_range_unlocked(_First, _Last);

  00031	4c 8b 45 60	 mov	 r8, QWORD PTR _Last$[rbp]
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _First$[rbp]
  00039	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0003d	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_unlocked

; 2179 :         } else

  00042	eb 11		 jmp	 SHORT $LN3@Orphan_ran
$LN2@Orphan_ran:

; 2180 : #endif // _HAS_CXX20
; 2181 :         {
; 2182 :             _Orphan_range_locked(_First, _Last);

  00044	4c 8b 45 60	 mov	 r8, QWORD PTR _Last$[rbp]
  00048	48 8b 55 58	 mov	 rdx, QWORD PTR _First$[rbp]
  0004c	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00050	e8 00 00 00 00	 call	 ?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_locked
$LN3@Orphan_ran:

; 2183 :         }
; 2184 :     }

  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?_Orphan_range@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
_First$ = 104
_Last$ = 112
?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_locked, COMDAT

; 2169 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2170 :         _Lockit _Lock(_LOCK_DEBUG);

  00025	ba 03 00 00 00	 mov	 edx, 3
  0002a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00034	90		 npad	 1

; 2171 :         _Orphan_range_unlocked(_First, _Last);

  00035	4c 8b 45 70	 mov	 r8, QWORD PTR _Last$[rbp]
  00039	48 8b 55 68	 mov	 rdx, QWORD PTR _First$[rbp]
  0003d	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00041	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_unlocked
  00046	90		 npad	 1

; 2172 :     }

  00047	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00051	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
?_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_locked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
_Lock$ = 0
this$ = 96
_First$ = 104
_Last$ = 112
?dtor$0@?0??_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z@4HA PROC ; `std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_locked'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00014	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00018	5d		 pop	 rbp
  00019	c3		 ret	 0
?dtor$0@?0??_Orphan_range_locked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z@4HA ENDP ; `std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_locked'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z
_TEXT	SEGMENT
_Pnext$ = 0
_Pnextptr$1 = 8
_Temp$2 = 16
this$ = 112
_First$ = 120
_Last$ = 128
?_Orphan_range_unlocked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_unlocked, COMDAT

; 2155 :     _CONSTEXPR20 void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2156 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

  00028	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 83 c0 08	 add	 rax, 8
  00033	48 89 45 00	 mov	 QWORD PTR _Pnext$[rbp], rax
$LN2@Orphan_ran:

; 2157 :         while (*_Pnext) {

  00037	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0003b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003f	74 5b		 je	 SHORT $LN3@Orphan_ran

; 2158 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

  00041	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004c	48 89 45 08	 mov	 QWORD PTR _Pnextptr$1[rbp], rax

; 2159 :             const auto _Temp     = *_Pnext;

  00050	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  00054	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00057	48 89 45 10	 mov	 QWORD PTR _Temp$2[rbp], rax

; 2160 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

  0005b	48 8b 45 78	 mov	 rax, QWORD PTR _First$[rbp]
  0005f	48 39 45 08	 cmp	 QWORD PTR _Pnextptr$1[rbp], rax
  00063	72 0d		 jb	 SHORT $LN6@Orphan_ran
  00065	48 8b 45 08	 mov	 rax, QWORD PTR _Pnextptr$1[rbp]
  00069	48 39 85 80 00
	00 00		 cmp	 QWORD PTR _Last$[rbp], rax
  00070	73 0e		 jae	 SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 2161 :                 _Pnext = &_Temp->_Mynextiter;

  00072	48 8b 45 10	 mov	 rax, QWORD PTR _Temp$2[rbp]
  00076	48 83 c0 08	 add	 rax, 8
  0007a	48 89 45 00	 mov	 QWORD PTR _Pnext$[rbp], rax

; 2162 :             } else { // orphan the iterator

  0007e	eb 1a		 jmp	 SHORT $LN5@Orphan_ran
$LN4@Orphan_ran:

; 2163 :                 _Temp->_Myproxy = nullptr;

  00080	48 8b 45 10	 mov	 rax, QWORD PTR _Temp$2[rbp]
  00084	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2164 :                 *_Pnext         = _Temp->_Mynextiter;

  0008b	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$[rbp]
  0008f	48 8b 4d 10	 mov	 rcx, QWORD PTR _Temp$2[rbp]
  00093	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00097	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN5@Orphan_ran:

; 2165 :             }
; 2166 :         }

  0009a	eb 9b		 jmp	 SHORT $LN2@Orphan_ran
$LN3@Orphan_ran:

; 2167 :     }

  0009c	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000a0	5d		 pop	 rbp
  000a1	c3		 ret	 0
?_Orphan_range_unlocked@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAXPEAUFCMDParameter@@0@Z ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?_Xlength@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@CAXXZ PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Xlength, COMDAT

; 2146 :     [[noreturn]] static void _Xlength() {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2147 :         _Xlength_error("vector too long");

  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0001e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 2148 :     }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?_Xlength@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@CAXXZ ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Al$ = 0
_My_data$ = 8
_Myfirst$ = 16
_Mylast$ = 24
_Myend$ = 32
this$ = 128
?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Tidy, COMDAT

; 2044 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2045 :         auto& _Al         = _Getal();

  0001e	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
  0002a	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 2046 :         auto& _My_data    = _Mypair._Myval2;

  0002e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax

; 2047 :         pointer& _Myfirst = _My_data._Myfirst;

  00039	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0003d	48 83 c0 08	 add	 rax, 8
  00041	48 89 45 10	 mov	 QWORD PTR _Myfirst$[rbp], rax

; 2048 :         pointer& _Mylast  = _My_data._Mylast;

  00045	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00049	48 83 c0 10	 add	 rax, 16
  0004d	48 89 45 18	 mov	 QWORD PTR _Mylast$[rbp], rax

; 2049 :         pointer& _Myend   = _My_data._Myend;

  00051	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00055	48 83 c0 18	 add	 rax, 24
  00059	48 89 45 20	 mov	 QWORD PTR _Myend$[rbp], rax

; 2050 : 
; 2051 :         _My_data._Orphan_all();

  0005d	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00061	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 2052 : 
; 2053 :         if (_Myfirst) { // destroy and deallocate old array

  00066	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  0006a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006e	74 66		 je	 SHORT $LN2@Tidy

; 2054 :             _Destroy_range(_Myfirst, _Mylast, _Al);

  00070	4c 8b 45 00	 mov	 r8, QWORD PTR _Al$[rbp]
  00074	48 8b 45 18	 mov	 rax, QWORD PTR _Mylast$[rbp]
  00078	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0007b	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  0007f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00082	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ; std::_Destroy_range<std::allocator<FCMDParameter> >

; 2055 :             _ASAN_VECTOR_REMOVE;
; 2056 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00087	48 8b 45 20	 mov	 rax, QWORD PTR _Myend$[rbp]
  0008b	48 8b 4d 10	 mov	 rcx, QWORD PTR _Myfirst$[rbp]
  0008f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00092	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00095	48 2b c1	 sub	 rax, rcx
  00098	48 99		 cdq
  0009a	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0009f	48 f7 f9	 idiv	 rcx
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  000a9	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000ac	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  000b0	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z ; std::allocator<FCMDParameter>::deallocate

; 2057 : 
; 2058 :             _Myfirst = nullptr;

  000b5	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  000b9	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2059 :             _Mylast  = nullptr;

  000c0	48 8b 45 18	 mov	 rax, QWORD PTR _Mylast$[rbp]
  000c4	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2060 :             _Myend   = nullptr;

  000cb	48 8b 45 20	 mov	 rax, QWORD PTR _Myend$[rbp]
  000cf	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@Tidy:

; 2061 :         }
; 2062 :     }

  000d6	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  000da	5d		 pop	 rbp
  000db	c3		 ret	 0
?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?_Change_array@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXQEAUFCMDParameter@@_K1@Z
_TEXT	SEGMENT
_Al$ = 0
_My_data$ = 8
_Myfirst$ = 16
_Mylast$ = 24
_Myend$ = 32
this$ = 128
_Newvec$ = 136
_Newsize$ = 144
_Newcapacity$ = 152
?_Change_array@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXQEAUFCMDParameter@@_K1@Z PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Change_array, COMDAT

; 2022 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2023 :         // orphan all iterators, discard old array, acquire new array
; 2024 :         auto& _Al         = _Getal();

  0002d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
  00039	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 2025 :         auto& _My_data    = _Mypair._Myval2;

  0003d	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00044	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax

; 2026 :         pointer& _Myfirst = _My_data._Myfirst;

  00048	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0004c	48 83 c0 08	 add	 rax, 8
  00050	48 89 45 10	 mov	 QWORD PTR _Myfirst$[rbp], rax

; 2027 :         pointer& _Mylast  = _My_data._Mylast;

  00054	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00058	48 83 c0 10	 add	 rax, 16
  0005c	48 89 45 18	 mov	 QWORD PTR _Mylast$[rbp], rax

; 2028 :         pointer& _Myend   = _My_data._Myend;

  00060	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00064	48 83 c0 18	 add	 rax, 24
  00068	48 89 45 20	 mov	 QWORD PTR _Myend$[rbp], rax

; 2029 : 
; 2030 :         _My_data._Orphan_all();

  0006c	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00070	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 2031 : 
; 2032 :         if (_Myfirst) { // destroy and deallocate old array

  00075	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  00079	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0007d	74 45		 je	 SHORT $LN2@Change_arr

; 2033 :             _Destroy_range(_Myfirst, _Mylast, _Al);

  0007f	4c 8b 45 00	 mov	 r8, QWORD PTR _Al$[rbp]
  00083	48 8b 45 18	 mov	 rax, QWORD PTR _Mylast$[rbp]
  00087	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0008a	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  0008e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00091	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UFCMDParameter@@@std@@@std@@YAXPEAUFCMDParameter@@QEAU1@AEAV?$allocator@UFCMDParameter@@@0@@Z ; std::_Destroy_range<std::allocator<FCMDParameter> >

; 2034 :             _ASAN_VECTOR_REMOVE;
; 2035 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00096	48 8b 45 20	 mov	 rax, QWORD PTR _Myend$[rbp]
  0009a	48 8b 4d 10	 mov	 rcx, QWORD PTR _Myfirst$[rbp]
  0009e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a4	48 2b c1	 sub	 rax, rcx
  000a7	48 99		 cdq
  000a9	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  000ae	48 f7 f9	 idiv	 rcx
  000b1	4c 8b c0	 mov	 r8, rax
  000b4	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  000b8	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000bb	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  000bf	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z ; std::allocator<FCMDParameter>::deallocate
$LN2@Change_arr:

; 2036 :         }
; 2037 : 
; 2038 :         _Myfirst = _Newvec;

  000c4	48 8b 45 10	 mov	 rax, QWORD PTR _Myfirst$[rbp]
  000c8	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Newvec$[rbp]
  000cf	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2039 :         _Mylast  = _Newvec + _Newsize;

  000d2	48 6b 85 90 00
	00 00 50	 imul	 rax, QWORD PTR _Newsize$[rbp], 80 ; 00000050H
  000da	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Newvec$[rbp]
  000e1	48 03 c8	 add	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 8b 4d 18	 mov	 rcx, QWORD PTR _Mylast$[rbp]
  000eb	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2040 :         _Myend   = _Newvec + _Newcapacity;

  000ee	48 6b 85 98 00
	00 00 50	 imul	 rax, QWORD PTR _Newcapacity$[rbp], 80 ; 00000050H
  000f6	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR _Newvec$[rbp]
  000fd	48 03 c8	 add	 rcx, rax
  00100	48 8b c1	 mov	 rax, rcx
  00103	48 8b 4d 20	 mov	 rcx, QWORD PTR _Myend$[rbp]
  00107	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2041 :         _ASAN_VECTOR_CREATE;
; 2042 :     }

  0010a	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  0010e	5d		 pop	 rbp
  0010f	c3		 ret	 0
?_Change_array@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXQEAUFCMDParameter@@_K1@Z ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 0
_Max$ = 8
_Geometric$ = 16
this$ = 112
_Newsize$ = 120
?_Calculate_growth@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Calculate_growth, COMDAT

; 1970 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1971 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1972 :         const size_type _Oldcapacity = capacity();

  00023	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00027	e8 00 00 00 00	 call	 ?capacity@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::capacity
  0002c	48 89 45 00	 mov	 QWORD PTR _Oldcapacity$[rbp], rax

; 1973 :         const auto _Max              = max_size();

  00030	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?max_size@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::max_size
  00039	48 89 45 08	 mov	 QWORD PTR _Max$[rbp], rax

; 1974 : 
; 1975 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0003d	33 d2		 xor	 edx, edx
  0003f	48 8b 45 00	 mov	 rax, QWORD PTR _Oldcapacity$[rbp]
  00043	b9 02 00 00 00	 mov	 ecx, 2
  00048	48 f7 f1	 div	 rcx
  0004b	48 8b 4d 08	 mov	 rcx, QWORD PTR _Max$[rbp]
  0004f	48 2b c8	 sub	 rcx, rax
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 39 45 00	 cmp	 QWORD PTR _Oldcapacity$[rbp], rax
  00059	76 06		 jbe	 SHORT $LN2@Calculate_

; 1976 :             return _Max; // geometric growth would overflow

  0005b	48 8b 45 08	 mov	 rax, QWORD PTR _Max$[rbp]
  0005f	eb 30		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1977 :         }
; 1978 : 
; 1979 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00061	33 d2		 xor	 edx, edx
  00063	48 8b 45 00	 mov	 rax, QWORD PTR _Oldcapacity$[rbp]
  00067	b9 02 00 00 00	 mov	 ecx, 2
  0006c	48 f7 f1	 div	 rcx
  0006f	48 8b 4d 00	 mov	 rcx, QWORD PTR _Oldcapacity$[rbp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 45 10	 mov	 QWORD PTR _Geometric$[rbp], rax

; 1980 : 
; 1981 :         if (_Geometric < _Newsize) {

  0007d	48 8b 45 78	 mov	 rax, QWORD PTR _Newsize$[rbp]
  00081	48 39 45 10	 cmp	 QWORD PTR _Geometric$[rbp], rax
  00085	73 06		 jae	 SHORT $LN3@Calculate_

; 1982 :             return _Newsize; // geometric growth would be insufficient

  00087	48 8b 45 78	 mov	 rax, QWORD PTR _Newsize$[rbp]
  0008b	eb 04		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1983 :         }
; 1984 : 
; 1985 :         return _Geometric; // geometric growth is sufficient

  0008d	48 8b 45 10	 mov	 rax, QWORD PTR _Geometric$[rbp]
$LN1@Calculate_:

; 1986 :     }

  00091	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00095	5d		 pop	 rbp
  00096	c3		 ret	 0
?_Calculate_growth@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?capacity@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 96
?capacity@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::capacity, COMDAT

; 1886 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1887 :         auto& _My_data = _Mypair._Myval2;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 1888 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00023	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00027	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0002b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00033	48 2b c1	 sub	 rax, rcx
  00036	48 99		 cdq
  00038	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0003d	48 f7 f9	 idiv	 rcx

; 1889 :     }

  00040	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?capacity@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?max_size@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
this$ = 96
?max_size@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::max_size, COMDAT

; 1881 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1882 :         return (_STD min)(

  0001b	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEBAAEBV?$allocator@UFCMDParameter@@@2@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SA_KAEBV?$allocator@UFCMDParameter@@@2@@Z ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::max_size
  0002c	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  00030	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00035	48 89 45 48	 mov	 QWORD PTR $T2[rbp], rax
  00039	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  0003d	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  00041	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1883 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1884 :     }

  00049	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?max_size@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z
_TEXT	SEGMENT
this$ = 80
_Val$ = 88
?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::push_back, COMDAT

; 871  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 872  :         _Emplace_one_at_back(_Val);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Val$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ??$_Emplace_one_at_back@AEBUFCMDParameter@@@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAUFCMDParameter@@AEBU2@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Emplace_one_at_back<FCMDParameter const &>

; 873  :     }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ??1?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S1$ = 8
$T1 = 73
this$ = 112
??1?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::~vector<FCMDParameter,std::allocator<FCMDParameter> >, COMDAT

; 765  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 766  :         _Tidy();

  0001e	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00022	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAXXZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Tidy

; 767  : #if _ITERATOR_DEBUG_LEVEL != 0
; 768  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00027	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8d 4d 08	 lea	 rcx, QWORD PTR $S1$[rbp]
  00037	e8 00 00 00 00	 call	 ??$?0UFCMDParameter@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UFCMDParameter@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><FCMDParameter>
  0003c	48 8d 45 08	 lea	 rax, QWORD PTR $S1$[rbp]
  00040	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 769  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  00044	48 c7 45 49 00
	00 00 00	 mov	 QWORD PTR $T1[rbp], 0
  0004c	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00050	48 8d 55 49	 lea	 rdx, QWORD PTR $T1[rbp]
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 ??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  0005c	48 8b d0	 mov	 rdx, rax
  0005f	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  00063	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 770  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 771  :     }

  00068	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0006c	5d		 pop	 rbp
  0006d	c3		 ret	 0
??1?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::~vector<FCMDParameter,std::allocator<FCMDParameter> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vector
;	COMDAT ??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
tv83 = 72
tv69 = 72
this$ = 96
??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ PROC ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::vector<FCMDParameter,std::allocator<FCMDParameter> >, COMDAT

; 609  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__14F7CB70_vector
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 89 45 48	 mov	 QWORD PTR tv69[rbp], rax
  00023	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00027	48 8b 4d 48	 mov	 rcx, QWORD PTR tv69[rbp]
  0002b	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@UFCMDParameter@@@std@@V?$_Vector_val@U?$_Simple_types@UFCMDParameter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1>::_Compressed_pair<std::allocator<FCMDParameter>,std::_Vector_val<std::_Simple_types<FCMDParameter> >,1><>

; 610  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 89 45 48	 mov	 QWORD PTR tv83[rbp], rax
  00038	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?_Getal@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@AEAAAEAV?$allocator@UFCMDParameter@@@2@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::_Getal
  00041	48 8b d0	 mov	 rdx, rax
  00044	48 8d 4d 41	 lea	 rcx, QWORD PTR $T2[rbp]
  00048	e8 00 00 00 00	 call	 ??$?0UFCMDParameter@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UFCMDParameter@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><FCMDParameter>
  0004d	48 8b d0	 mov	 rdx, rax
  00050	48 8b 4d 48	 mov	 rcx, QWORD PTR tv83[rbp]
  00054	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 611  :     }

  00059	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0005d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ENDP ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::vector<FCMDParameter,std::allocator<FCMDParameter> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SA_KAEBV?$allocator@UFCMDParameter@@@2@@Z
_TEXT	SEGMENT
__formal$ = 80
?max_size@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SA_KAEBV?$allocator@UFCMDParameter@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001b	48 b8 33 33 33
	33 33 33 33 03	 mov	 rax, 230584300921369395	; 0333333333333333H

; 738  :     }

  00025	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@UFCMDParameter@@@std@@@std@@SA_KAEBV?$allocator@UFCMDParameter@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<FCMDParameter> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@UFCMDParameter@@@std@@QEAAPEAUFCMDParameter@@_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@UFCMDParameter@@@std@@QEAAPEAUFCMDParameter@@_K@Z PROC ; std::allocator<FCMDParameter>::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z ; std::_Get_size_of_n<80>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@UFCMDParameter@@@std@@QEAAPEAUFCMDParameter@@_K@Z ENDP ; std::allocator<FCMDParameter>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z PROC ; std::allocator<FCMDParameter>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 6b 45 60 50	 imul	 rax, QWORD PTR _Count$[rbp], 80 ; 00000050H
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b6	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000bb	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?deallocate@?$allocator@UFCMDParameter@@@std@@QEAAXQEAUFCMDParameter@@_K@Z ENDP ; std::allocator<FCMDParameter>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$allocator@UFCMDParameter@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$allocator@UFCMDParameter@@@std@@QEAA@XZ PROC	; std::allocator<FCMDParameter>::allocator<FCMDParameter>, COMDAT

; 962  :     constexpr allocator() noexcept {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??0?$allocator@UFCMDParameter@@@std@@QEAA@XZ ENDP	; std::allocator<FCMDParameter>::allocator<FCMDParameter>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Application\Application.cpp
;	COMDAT ?CheckParameterCmdLine@Application@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 96
Parametr$ = 104
data$ = 112
?CheckParameterCmdLine@Application@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@Z PROC ; Application::CheckParameterCmdLine, COMDAT

; 75   : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9021FEEF_Application@cpp
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 76   : 	return false;

  00025	c6 45 40 00	 mov	 BYTE PTR $T1[rbp], 0
  00029	48 8b 4d 68	 mov	 rcx, QWORD PTR Parametr$[rbp]
  0002d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00032	0f b6 45 40	 movzx	 eax, BYTE PTR $T1[rbp]

; 77   : }

  00036	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
?CheckParameterCmdLine@Application@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@Z ENDP ; Application::CheckParameterCmdLine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Application\Application.cpp
;	COMDAT ?ParseCmdLine@Application@@QEAAXXZ
_TEXT	SEGMENT
i$1 = 0
parameter$2 = 16
buf$3 = 96
tv228 = 224
tv219 = 224
tv209 = 224
tv201 = 224
tv191 = 224
tv183 = 224
tv176 = 224
tv168 = 224
tv162 = 224
tv144 = 224
tv134 = 224
tv94 = 224
tv74 = 224
this$ = 272
?ParseCmdLine@Application@@QEAAXXZ PROC			; Application::ParseCmdLine, COMDAT

; 28   : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9021FEEF_Application@cpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 29   : 	for (size_t i = 0; i < lpCmdLine.size(); i++)

  0001f	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  00027	eb 0b		 jmp	 SHORT $LN4@ParseCmdLi
$LN2@ParseCmdLi:
  00029	48 8b 45 00	 mov	 rax, QWORD PTR i$1[rbp]
  0002d	48 ff c0	 inc	 rax
  00030	48 89 45 00	 mov	 QWORD PTR i$1[rbp], rax
$LN4@ParseCmdLi:
  00034	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 83 c0 10	 add	 rax, 16
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00047	48 39 45 00	 cmp	 QWORD PTR i$1[rbp], rax
  0004b	0f 83 40 03 00
	00		 jae	 $LN1@ParseCmdLi

; 30   : 	{
; 31   : 		if (lpCmdLine[i] == '-')

  00051	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00058	48 83 c0 10	 add	 rax, 16
  0005c	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv74[rbp], rax
  00063	48 8b 55 00	 mov	 rdx, QWORD PTR i$1[rbp]
  00067	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv74[rbp]
  0006e	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00073	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00076	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00079	0f 85 0d 03 00
	00		 jne	 $LN9@ParseCmdLi

; 32   : 		{
; 33   : 			++i;

  0007f	48 8b 45 00	 mov	 rax, QWORD PTR i$1[rbp]
  00083	48 ff c0	 inc	 rax
  00086	48 89 45 00	 mov	 QWORD PTR i$1[rbp], rax

; 34   : 			FCMDParameter parameter;

  0008a	48 8d 4d 10	 lea	 rcx, QWORD PTR parameter$2[rbp]
  0008e	e8 00 00 00 00	 call	 ??0FCMDParameter@@QEAA@XZ
  00093	90		 npad	 1

; 35   : 			char buf[64] = { '\0' };

  00094	48 8d 45 60	 lea	 rax, QWORD PTR buf$3[rbp]
  00098	48 8b f8	 mov	 rdi, rax
  0009b	33 c0		 xor	 eax, eax
  0009d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000a2	f3 aa		 rep stosb
$LN5@ParseCmdLi:

; 36   : 			while (i < lpCmdLine.size() && (lpCmdLine[i] != ' ' && lpCmdLine[i] != '-'))

  000a4	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ab	48 83 c0 10	 add	 rax, 16
  000af	48 8b c8	 mov	 rcx, rax
  000b2	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  000b7	48 39 45 00	 cmp	 QWORD PTR i$1[rbp], rax
  000bb	0f 83 98 00 00
	00		 jae	 $LN6@ParseCmdLi
  000c1	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c8	48 83 c0 10	 add	 rax, 16
  000cc	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv94[rbp], rax
  000d3	48 8b 55 00	 mov	 rdx, QWORD PTR i$1[rbp]
  000d7	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv94[rbp]
  000de	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  000e3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000e6	83 f8 20	 cmp	 eax, 32			; 00000020H
  000e9	74 6e		 je	 SHORT $LN6@ParseCmdLi
  000eb	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000f2	48 83 c0 10	 add	 rax, 16
  000f6	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv134[rbp], rax
  000fd	48 8b 55 00	 mov	 rdx, QWORD PTR i$1[rbp]
  00101	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv134[rbp]
  00108	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0010d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00110	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00113	74 44		 je	 SHORT $LN6@ParseCmdLi

; 37   : 			{
; 38   : 				strncat_s(buf, &lpCmdLine[i], 1);

  00115	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0011c	48 83 c0 10	 add	 rax, 16
  00120	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv144[rbp], rax
  00127	48 8b 55 00	 mov	 rdx, QWORD PTR i$1[rbp]
  0012b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv144[rbp]
  00132	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00137	41 b8 01 00 00
	00		 mov	 r8d, 1
  0013d	48 8b d0	 mov	 rdx, rax
  00140	48 8d 4d 60	 lea	 rcx, QWORD PTR buf$3[rbp]
  00144	e8 00 00 00 00	 call	 ??$strncat_s@$0EA@@@YAHAEAY0EA@DPEBD_K@Z ; strncat_s<64>

; 39   : 				++i;

  00149	48 8b 45 00	 mov	 rax, QWORD PTR i$1[rbp]
  0014d	48 ff c0	 inc	 rax
  00150	48 89 45 00	 mov	 QWORD PTR i$1[rbp], rax

; 40   : 			}

  00154	e9 4b ff ff ff	 jmp	 $LN5@ParseCmdLi
$LN6@ParseCmdLi:

; 41   : 			parameter.Parameter = buf;

  00159	48 8d 55 60	 lea	 rdx, QWORD PTR buf$3[rbp]
  0015d	48 8d 4d 10	 lea	 rcx, QWORD PTR parameter$2[rbp]
  00161	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 42   : 			memset(buf, '\0', strlen(buf));

  00166	48 8d 4d 60	 lea	 rcx, QWORD PTR buf$3[rbp]
  0016a	e8 00 00 00 00	 call	 strlen
  0016f	4c 8b c0	 mov	 r8, rax
  00172	33 d2		 xor	 edx, edx
  00174	48 8d 4d 60	 lea	 rcx, QWORD PTR buf$3[rbp]
  00178	e8 00 00 00 00	 call	 memset

; 43   : 			if (i >= lpCmdLine.size())

  0017d	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00184	48 83 c0 10	 add	 rax, 16
  00188	48 8b c8	 mov	 rcx, rax
  0018b	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00190	48 39 45 00	 cmp	 QWORD PTR i$1[rbp], rax
  00194	72 31		 jb	 SHORT $LN10@ParseCmdLi

; 44   : 			{
; 45   : 				parameters.push_back(parameter);

  00196	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0019d	48 83 c0 40	 add	 rax, 64			; 00000040H
  001a1	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv162[rbp], rax
  001a8	48 8d 55 10	 lea	 rdx, QWORD PTR parameter$2[rbp]
  001ac	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv162[rbp]
  001b3	e8 00 00 00 00	 call	 ?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::push_back
  001b8	90		 npad	 1

; 46   : 				return;

  001b9	48 8d 4d 10	 lea	 rcx, QWORD PTR parameter$2[rbp]
  001bd	e8 00 00 00 00	 call	 ??1FCMDParameter@@QEAA@XZ
  001c2	e9 ca 01 00 00	 jmp	 $LN1@ParseCmdLi
$LN10@ParseCmdLi:

; 47   : 			}
; 48   : 
; 49   : 			if (lpCmdLine[i] == '-')

  001c7	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001ce	48 83 c0 10	 add	 rax, 16
  001d2	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv168[rbp], rax
  001d9	48 8b 55 00	 mov	 rdx, QWORD PTR i$1[rbp]
  001dd	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv168[rbp]
  001e4	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  001e9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001ec	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001ef	75 3c		 jne	 SHORT $LN11@ParseCmdLi

; 50   : 			{
; 51   : 				--i;

  001f1	48 8b 45 00	 mov	 rax, QWORD PTR i$1[rbp]
  001f5	48 ff c8	 dec	 rax
  001f8	48 89 45 00	 mov	 QWORD PTR i$1[rbp], rax

; 52   : 				parameters.push_back(parameter);

  001fc	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00203	48 83 c0 40	 add	 rax, 64			; 00000040H
  00207	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv176[rbp], rax
  0020e	48 8d 55 10	 lea	 rdx, QWORD PTR parameter$2[rbp]
  00212	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv176[rbp]
  00219	e8 00 00 00 00	 call	 ?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::push_back
  0021e	90		 npad	 1

; 53   : 				continue;

  0021f	48 8d 4d 10	 lea	 rcx, QWORD PTR parameter$2[rbp]
  00223	e8 00 00 00 00	 call	 ??1FCMDParameter@@QEAA@XZ
  00228	e9 fc fd ff ff	 jmp	 $LN2@ParseCmdLi
$LN11@ParseCmdLi:

; 54   : 			}
; 55   : 			++i;

  0022d	48 8b 45 00	 mov	 rax, QWORD PTR i$1[rbp]
  00231	48 ff c0	 inc	 rax
  00234	48 89 45 00	 mov	 QWORD PTR i$1[rbp], rax

; 56   : 			if (lpCmdLine[i] == '-')

  00238	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0023f	48 83 c0 10	 add	 rax, 16
  00243	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv183[rbp], rax
  0024a	48 8b 55 00	 mov	 rdx, QWORD PTR i$1[rbp]
  0024e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv183[rbp]
  00255	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0025a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0025d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00260	75 3c		 jne	 SHORT $LN7@ParseCmdLi

; 57   : 			{
; 58   : 				--i;

  00262	48 8b 45 00	 mov	 rax, QWORD PTR i$1[rbp]
  00266	48 ff c8	 dec	 rax
  00269	48 89 45 00	 mov	 QWORD PTR i$1[rbp], rax

; 59   : 				parameters.push_back(parameter);

  0026d	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00274	48 83 c0 40	 add	 rax, 64			; 00000040H
  00278	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv191[rbp], rax
  0027f	48 8d 55 10	 lea	 rdx, QWORD PTR parameter$2[rbp]
  00283	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv191[rbp]
  0028a	e8 00 00 00 00	 call	 ?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::push_back
  0028f	90		 npad	 1

; 60   : 				continue;

  00290	48 8d 4d 10	 lea	 rcx, QWORD PTR parameter$2[rbp]
  00294	e8 00 00 00 00	 call	 ??1FCMDParameter@@QEAA@XZ
  00299	e9 8b fd ff ff	 jmp	 $LN2@ParseCmdLi
$LN7@ParseCmdLi:

; 61   : 			}
; 62   : 			while (i < lpCmdLine.size() && (lpCmdLine[i] != ' ' && lpCmdLine[i] != '-'))

  0029e	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  002a5	48 83 c0 10	 add	 rax, 16
  002a9	48 8b c8	 mov	 rcx, rax
  002ac	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  002b1	48 39 45 00	 cmp	 QWORD PTR i$1[rbp], rax
  002b5	0f 83 98 00 00
	00		 jae	 $LN8@ParseCmdLi
  002bb	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  002c2	48 83 c0 10	 add	 rax, 16
  002c6	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv201[rbp], rax
  002cd	48 8b 55 00	 mov	 rdx, QWORD PTR i$1[rbp]
  002d1	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv201[rbp]
  002d8	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  002dd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002e0	83 f8 20	 cmp	 eax, 32			; 00000020H
  002e3	74 6e		 je	 SHORT $LN8@ParseCmdLi
  002e5	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  002ec	48 83 c0 10	 add	 rax, 16
  002f0	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv209[rbp], rax
  002f7	48 8b 55 00	 mov	 rdx, QWORD PTR i$1[rbp]
  002fb	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv209[rbp]
  00302	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00307	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0030a	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0030d	74 44		 je	 SHORT $LN8@ParseCmdLi

; 63   : 			{
; 64   : 				strncat_s(buf, &lpCmdLine[i], 1);

  0030f	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00316	48 83 c0 10	 add	 rax, 16
  0031a	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv219[rbp], rax
  00321	48 8b 55 00	 mov	 rdx, QWORD PTR i$1[rbp]
  00325	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv219[rbp]
  0032c	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00331	41 b8 01 00 00
	00		 mov	 r8d, 1
  00337	48 8b d0	 mov	 rdx, rax
  0033a	48 8d 4d 60	 lea	 rcx, QWORD PTR buf$3[rbp]
  0033e	e8 00 00 00 00	 call	 ??$strncat_s@$0EA@@@YAHAEAY0EA@DPEBD_K@Z ; strncat_s<64>

; 65   : 				++i;

  00343	48 8b 45 00	 mov	 rax, QWORD PTR i$1[rbp]
  00347	48 ff c0	 inc	 rax
  0034a	48 89 45 00	 mov	 QWORD PTR i$1[rbp], rax

; 66   : 			}

  0034e	e9 4b ff ff ff	 jmp	 $LN7@ParseCmdLi
$LN8@ParseCmdLi:

; 67   : 
; 68   : 			parameter.Value = buf;

  00353	48 8d 55 60	 lea	 rdx, QWORD PTR buf$3[rbp]
  00357	48 8d 4d 38	 lea	 rcx, QWORD PTR parameter$2[rbp+40]
  0035b	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 69   : 			parameters.push_back(parameter);

  00360	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00367	48 83 c0 40	 add	 rax, 64			; 00000040H
  0036b	48 89 85 e0 00
	00 00		 mov	 QWORD PTR tv228[rbp], rax
  00372	48 8d 55 10	 lea	 rdx, QWORD PTR parameter$2[rbp]
  00376	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR tv228[rbp]
  0037d	e8 00 00 00 00	 call	 ?push_back@?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAAXAEBUFCMDParameter@@@Z ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::push_back
  00382	90		 npad	 1

; 70   : 		}

  00383	48 8d 4d 10	 lea	 rcx, QWORD PTR parameter$2[rbp]
  00387	e8 00 00 00 00	 call	 ??1FCMDParameter@@QEAA@XZ
$LN9@ParseCmdLi:

; 71   : 	}

  0038c	e9 98 fc ff ff	 jmp	 $LN2@ParseCmdLi
$LN1@ParseCmdLi:

; 72   : }

  00391	48 8d a5 f8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+248]
  00398	5f		 pop	 rdi
  00399	5d		 pop	 rbp
  0039a	c3		 ret	 0
?ParseCmdLine@Application@@QEAAXXZ ENDP			; Application::ParseCmdLine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
i$1 = 0
parameter$2 = 16
buf$3 = 96
tv228 = 224
tv219 = 224
tv209 = 224
tv201 = 224
tv191 = 224
tv183 = 224
tv176 = 224
tv168 = 224
tv162 = 224
tv144 = 224
tv134 = 224
tv94 = 224
tv74 = 224
this$ = 272
?dtor$0@?0??ParseCmdLine@Application@@QEAAXXZ@4HA PROC	; `Application::ParseCmdLine'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8d 4d 10	 lea	 rcx, QWORD PTR parameter$2[rbp]
  0000e	e8 00 00 00 00	 call	 ??1FCMDParameter@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??ParseCmdLine@Application@@QEAAXXZ@4HA ENDP	; `Application::ParseCmdLine'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Application\Application.cpp
;	COMDAT ?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
this$ = 80
inst$ = 88
prevInst$ = 96
cmdLine$ = 104
cmdshow$ = 112
?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; Application::Initialize, COMDAT

; 18   : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9021FEEF_Application@cpp
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 19   : 	hInsance = inst;

  0002a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002e	48 8b 4d 58	 mov	 rcx, QWORD PTR inst$[rbp]
  00032	48 89 08	 mov	 QWORD PTR [rax], rcx

; 20   : 	nPrevInstance = prevInst;

  00035	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8b 4d 60	 mov	 rcx, QWORD PTR prevInst$[rbp]
  0003d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 21   : 	lpCmdLine = cmdLine;

  00041	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 83 c0 10	 add	 rax, 16
  00049	48 8b 55 68	 mov	 rdx, QWORD PTR cmdLine$[rbp]
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 22   : 	nCmdShow = cmdshow;

  00055	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00059	8b 4d 70	 mov	 ecx, DWORD PTR cmdshow$[rbp]
  0005c	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 23   : 
; 24   : 	ParseCmdLine();

  0005f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00063	e8 00 00 00 00	 call	 ?ParseCmdLine@Application@@QEAAXXZ ; Application::ParseCmdLine
  00068	90		 npad	 1

; 25   : }

  00069	48 8b 4d 68	 mov	 rcx, QWORD PTR cmdLine$[rbp]
  0006d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00072	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
?Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; Application::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
this$ = 80
inst$ = 88
prevInst$ = 96
cmdLine$ = 104
cmdshow$ = 112
?dtor$0@?0??Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA PROC ; `Application::Initialize'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 68	 mov	 rcx, QWORD PTR cmdLine$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0??Initialize@Application@@QEAAXPEAUHINSTANCE__@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA ENDP ; `Application::Initialize'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Application\Application.cpp
;	COMDAT ??1Application@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1Application@@QEAA@XZ PROC				; Application::~Application, COMDAT

; 14   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9021FEEF_Application@cpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 15   : }

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 c0 40	 add	 rax, 64			; 00000040H
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 ??1?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::~vector<FCMDParameter,std::allocator<FCMDParameter> >
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 83 c0 10	 add	 rax, 16
  00033	48 8b c8	 mov	 rcx, rax
  00036	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??1Application@@QEAA@XZ ENDP				; Application::~Application
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\nahmu\source\repos\Dark Engine\Dark Engine\Source\Runtime\Core\Application\Application.cpp
;	COMDAT ??0Application@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0Application@@QEAA@XZ PROC				; Application::Application, COMDAT

; 9    : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9021FEEF_Application@cpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 c0 10	 add	 rax, 16
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 83 c0 40	 add	 rax, 64			; 00000040H
  00033	48 8b c8	 mov	 rcx, rax
  00036	e8 00 00 00 00	 call	 ??0?$vector@UFCMDParameter@@V?$allocator@UFCMDParameter@@@std@@@std@@QEAA@XZ ; std::vector<FCMDParameter,std::allocator<FCMDParameter> >::vector<FCMDParameter,std::allocator<FCMDParameter> >

; 10   : 	_inst = this;

  0003b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?_inst@Application@@0PEAV1@EA, rax ; Application::_inst

; 11   : }

  00046	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
??0Application@@QEAA@XZ ENDP				; Application::Application
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GFCMDParameter@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_GFCMDParameter@@QEAAPEAXI@Z PROC			; FCMDParameter::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1FCMDParameter@@QEAA@XZ
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_GFCMDParameter@@QEAAPEAXI@Z ENDP			; FCMDParameter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0FCMDParameter@@QEAA@$$QEAU0@@Z
_TEXT	SEGMENT
tv79 = 64
tv70 = 64
this$ = 96
__that$ = 104
??0FCMDParameter@@QEAA@$$QEAU0@@Z PROC			; FCMDParameter::FCMDParameter, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00018	48 89 45 40	 mov	 QWORD PTR tv70[rbp], rax
  0001c	48 8b 45 68	 mov	 rax, QWORD PTR __that$[rbp]
  00020	48 8b d0	 mov	 rdx, rax
  00023	48 8b 4d 40	 mov	 rcx, QWORD PTR tv70[rbp]
  00027	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00030	48 83 c0 28	 add	 rax, 40			; 00000028H
  00034	48 89 45 40	 mov	 QWORD PTR tv79[rbp], rax
  00038	48 8b 45 68	 mov	 rax, QWORD PTR __that$[rbp]
  0003c	48 83 c0 28	 add	 rax, 40			; 00000028H
  00040	48 8b d0	 mov	 rdx, rax
  00043	48 8b 4d 40	 mov	 rcx, QWORD PTR tv79[rbp]
  00047	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00050	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??0FCMDParameter@@QEAA@$$QEAU0@@Z ENDP			; FCMDParameter::FCMDParameter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0FCMDParameter@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
tv79 = 64
tv70 = 64
this$ = 96
__that$ = 104
??0FCMDParameter@@QEAA@AEBU0@@Z PROC			; FCMDParameter::FCMDParameter, COMDAT
$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00018	48 89 45 40	 mov	 QWORD PTR tv70[rbp], rax
  0001c	48 8b 45 68	 mov	 rax, QWORD PTR __that$[rbp]
  00020	48 8b d0	 mov	 rdx, rax
  00023	48 8b 4d 40	 mov	 rcx, QWORD PTR tv70[rbp]
  00027	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002c	90		 npad	 1
  0002d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 83 c0 28	 add	 rax, 40			; 00000028H
  00035	48 89 45 40	 mov	 QWORD PTR tv79[rbp], rax
  00039	48 8b 45 68	 mov	 rax, QWORD PTR __that$[rbp]
  0003d	48 83 c0 28	 add	 rax, 40			; 00000028H
  00041	48 8b d0	 mov	 rdx, rax
  00044	48 8b 4d 40	 mov	 rcx, QWORD PTR tv79[rbp]
  00048	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004d	90		 npad	 1
  0004e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00052	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00056	5d		 pop	 rbp
  00057	c3		 ret	 0
??0FCMDParameter@@QEAA@AEBU0@@Z ENDP			; FCMDParameter::FCMDParameter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
tv79 = 64
tv70 = 64
this$ = 96
__that$ = 104
?dtor$0@?0???0FCMDParameter@@QEAA@AEBU0@@Z@4HA PROC	; `FCMDParameter::FCMDParameter'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0FCMDParameter@@QEAA@AEBU0@@Z@4HA ENDP	; `FCMDParameter::FCMDParameter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1FCMDParameter@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1FCMDParameter@@QEAA@XZ PROC				; FCMDParameter::~FCMDParameter, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 83 c0 28	 add	 rax, 40			; 00000028H
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002f	5d		 pop	 rbp
  00030	c3		 ret	 0
??1FCMDParameter@@QEAA@XZ ENDP				; FCMDParameter::~FCMDParameter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0FCMDParameter@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0FCMDParameter@@QEAA@XZ PROC				; FCMDParameter::FCMDParameter, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 c0 28	 add	 rax, 40			; 00000028H
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??0FCMDParameter@@QEAA@XZ ENDP				; FCMDParameter::FCMDParameter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1530 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1532 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4878 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4879 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4880 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 80
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4874 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4875 :         return _Mypair._Get_first();

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4876 :     }

  00027	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 64
this$ = 96
_Right$ = 104
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 4870 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4871 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 89 45 40	 mov	 QWORD PTR tv79[rbp], rax
  00028	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	48 8b 4d 40	 mov	 rcx, QWORD PTR tv79[rbp]
  00033	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators

; 4872 :     }

  00038	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 0
_Ptr$1 = 8
_Al$2 = 16
$T3 = 88
this$ = 112
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 4846 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4847 :         auto& _My_data = _Mypair._Myval2;

  0001e	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00022	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 4848 :         _My_data._Orphan_all();

  00026	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 4849 :         if (_My_data._Large_string_engaged()) {

  0002f	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00033	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00038	0f b6 c0	 movzx	 eax, al
  0003b	85 c0		 test	 eax, eax
  0003d	74 4d		 je	 SHORT $LN2@Tidy_deall

; 4850 :             _ASAN_STRING_REMOVE(*this);
; 4851 :             const pointer _Ptr = _My_data._Bx._Ptr;

  0003f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00043	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00047	48 89 45 08	 mov	 QWORD PTR _Ptr$1[rbp], rax

; 4852 :             auto& _Al          = _Getal();

  0004b	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0004f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00054	48 89 45 10	 mov	 QWORD PTR _Al$2[rbp], rax

; 4853 :             _Destroy_in_place(_My_data._Bx._Ptr);

  00058	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0005c	48 83 c0 08	 add	 rax, 8
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>

; 4854 :             _My_data._Activate_SSO_buffer();

  00068	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0006c	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 4855 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00071	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00075	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00079	48 ff c0	 inc	 rax
  0007c	4c 8b c0	 mov	 r8, rax
  0007f	48 8b 55 08	 mov	 rdx, QWORD PTR _Ptr$1[rbp]
  00083	48 8b 4d 10	 mov	 rcx, QWORD PTR _Al$2[rbp]
  00087	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 4856 :         }
; 4857 : 
; 4858 :         _My_data._Mysize = 0;

  0008c	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00090	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4859 :         _My_data._Myres  = _BUF_SIZE - 1;

  00098	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0009c	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 4860 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4861 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000a4	c6 45 58 00	 mov	 BYTE PTR $T3[rbp], 0
  000a8	b8 01 00 00 00	 mov	 eax, 1
  000ad	48 6b c0 00	 imul	 rax, rax, 0
  000b1	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  000b5	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000ba	48 8d 55 58	 lea	 rdx, QWORD PTR $T3[rbp]
  000be	48 8b c8	 mov	 rcx, rax
  000c1	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
  000c6	90		 npad	 1

; 4862 :     }

  000c7	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000cb	5d		 pop	 rbp
  000cc	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 0
$T1 = 72
this$ = 96
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT

; 4835 :     _CONSTEXPR20 void _Tidy_init() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4836 :         // initialize basic_string data members
; 4837 :         auto& _My_data   = _Mypair._Myval2;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 4838 :         _My_data._Mysize = 0;

  00023	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00027	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4839 :         _My_data._Myres  = _BUF_SIZE - 1;

  0002f	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  00033	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 4840 :         _My_data._Activate_SSO_buffer();

  0003b	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0003f	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 4841 : 
; 4842 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4843 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00044	c6 45 48 00	 mov	 BYTE PTR $T1[rbp], 0
  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	48 6b c0 00	 imul	 rax, rax, 0
  00051	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00055	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0005a	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  0005e	48 8b c8	 mov	 rcx, rax
  00061	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4844 :     }

  00066	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 64
tv74 = 72
this$ = 96
_Requested$ = 104
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4739 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4740 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00020	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00024	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00029	48 89 45 40	 mov	 QWORD PTR tv76[rbp], rax
  0002d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00035	48 89 45 48	 mov	 QWORD PTR tv74[rbp], rax
  00039	4c 8b 45 40	 mov	 r8, QWORD PTR tv76[rbp]
  0003d	48 8b 55 48	 mov	 rdx, QWORD PTR tv74[rbp]
  00041	48 8b 4d 68	 mov	 rcx, QWORD PTR _Requested$[rbp]
  00045	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 4741 :     }

  0004a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 0
$T1 = 72
_Requested$ = 96
_Old$ = 104
_Max$ = 112
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4726 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4727 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00025	48 8b 45 60	 mov	 rax, QWORD PTR _Requested$[rbp]
  00029	48 83 c8 0f	 or	 rax, 15
  0002d	48 89 45 00	 mov	 QWORD PTR _Masked$[rbp], rax

; 4728 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00031	48 8b 45 70	 mov	 rax, QWORD PTR _Max$[rbp]
  00035	48 39 45 00	 cmp	 QWORD PTR _Masked$[rbp], rax
  00039	76 06		 jbe	 SHORT $LN2@Calculate_

; 4729 :             return _Max;

  0003b	48 8b 45 70	 mov	 rax, QWORD PTR _Max$[rbp]
  0003f	eb 50		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4730 :         }
; 4731 : 
; 4732 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00041	33 d2		 xor	 edx, edx
  00043	48 8b 45 68	 mov	 rax, QWORD PTR _Old$[rbp]
  00047	b9 02 00 00 00	 mov	 ecx, 2
  0004c	48 f7 f1	 div	 rcx
  0004f	48 8b 4d 70	 mov	 rcx, QWORD PTR _Max$[rbp]
  00053	48 2b c8	 sub	 rcx, rax
  00056	48 8b c1	 mov	 rax, rcx
  00059	48 39 45 68	 cmp	 QWORD PTR _Old$[rbp], rax
  0005d	76 06		 jbe	 SHORT $LN3@Calculate_

; 4733 :             return _Max;

  0005f	48 8b 45 70	 mov	 rax, QWORD PTR _Max$[rbp]
  00063	eb 2c		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4734 :         }
; 4735 : 
; 4736 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00065	33 d2		 xor	 edx, edx
  00067	48 8b 45 68	 mov	 rax, QWORD PTR _Old$[rbp]
  0006b	b9 02 00 00 00	 mov	 ecx, 2
  00070	48 f7 f1	 div	 rcx
  00073	48 8b 4d 68	 mov	 rcx, QWORD PTR _Old$[rbp]
  00077	48 03 c8	 add	 rcx, rax
  0007a	48 8b c1	 mov	 rax, rcx
  0007d	48 89 45 48	 mov	 QWORD PTR $T1[rbp], rax
  00081	48 8d 55 48	 lea	 rdx, QWORD PTR $T1[rbp]
  00085	48 8d 4d 00	 lea	 rcx, QWORD PTR _Masked$[rbp]
  00089	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  0008e	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN1@Calculate_:

; 4737 :     }

  00091	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00095	5d		 pop	 rbp
  00096	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_Alloc_max$ = 0
_Storage_max$ = 8
$T1 = 80
$T2 = 88
$T3 = 96
this$ = 128
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 4141 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4142 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  0001e	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  00032	48 89 45 00	 mov	 QWORD PTR _Alloc_max$[rbp], rax

; 4143 :         const size_type _Storage_max = // can always store small string

  00036	48 c7 45 50 10
	00 00 00	 mov	 QWORD PTR $T1[rbp], 16
  0003e	48 8d 55 50	 lea	 rdx, QWORD PTR $T1[rbp]
  00042	48 8d 4d 00	 lea	 rcx, QWORD PTR _Alloc_max$[rbp]
  00046	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  0004b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004e	48 89 45 08	 mov	 QWORD PTR _Storage_max$[rbp], rax

; 4144 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4145 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00052	48 8b 45 08	 mov	 rax, QWORD PTR _Storage_max$[rbp]
  00056	48 ff c8	 dec	 rax
  00059	48 89 45 58	 mov	 QWORD PTR $T2[rbp], rax
  0005d	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00062	48 89 45 60	 mov	 QWORD PTR $T3[rbp], rax
  00066	48 8d 55 58	 lea	 rdx, QWORD PTR $T2[rbp]
  0006a	48 8d 4d 60	 lea	 rcx, QWORD PTR $T3[rbp]
  0006e	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00073	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 4146 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4147 :         );
; 4148 :     }

  00076	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  0007a	5d		 pop	 rbp
  0007b	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 80
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 4137 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4138 :         return _Mypair._Myval2._Mysize;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]

; 4139 :     }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
this$ = 80
_Off$ = 88
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 4036 :     _NODISCARD _CONSTEXPR20 reference operator[](const size_type _Off) noexcept /* strengthened */ {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@operator:

; 4037 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4038 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");

  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00028	48 39 45 58	 cmp	 QWORD PTR _Off$[rbp], rax
  0002c	77 02		 ja	 SHORT $LN7@operator
  0002e	eb 6b		 jmp	 SHORT $LN9@operator
$LN7@operator:
  00030	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
  00037	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00043	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00048	45 33 c9	 xor	 r9d, r9d
  0004b	41 b8 c6 0f 00
	00		 mov	 r8d, 4038		; 00000fc6H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@PMHOGIIF@C?3?2Program?5Files?2Microsoft?5Visu@
  00058	b9 02 00 00 00	 mov	 ecx, 2
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00063	83 f8 01	 cmp	 eax, 1
  00066	75 03		 jne	 SHORT $LN11@operator
  00068	cc		 int	 3
  00069	33 c0		 xor	 eax, eax
$LN11@operator:
  0006b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00074	41 b9 c6 0f 00
	00		 mov	 r9d, 4038		; 00000fc6H
  0007a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@GEBPNHFD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00095	33 c0		 xor	 eax, eax
  00097	85 c0		 test	 eax, eax
  00099	75 95		 jne	 SHORT $LN7@operator
$LN9@operator:
  0009b	33 c0		 xor	 eax, eax
  0009d	85 c0		 test	 eax, eax
  0009f	0f 85 7b ff ff
	ff		 jne	 $LN4@operator

; 4039 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4040 :         return _Mypair._Myval2._Myptr()[_Off];

  000a5	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  000b1	48 03 45 58	 add	 rax, QWORD PTR _Off$[rbp]

; 4041 :     }

  000b5	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000b9	5d		 pop	 rbp
  000ba	c3		 ret	 0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 3406 :     _CONSTEXPR20 basic_string& assign(_In_z_ const _Elem* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3407 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00024	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Convert_size@_K_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64,unsigned __int64>
  00031	4c 8b c0	 mov	 r8, rax
  00034	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00038	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3408 :     }

  00041	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
_Old_ptr$1 = 0
$T2 = 72
$T3 = 73
this$ = 96
_Ptr$ = 104
_Count$ = 112
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 3386 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3387 :         // assign [_Ptr, _Ptr + _Count)
; 3388 :         if (_Count <= _Mypair._Myval2._Myres) {

  00025	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00029	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0002d	48 39 45 70	 cmp	 QWORD PTR _Count$[rbp], rax
  00031	77 51		 ja	 SHORT $LN2@assign

; 3389 :             _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _Count);
; 3390 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00033	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00037	48 8b c8	 mov	 rcx, rax
  0003a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0003f	48 89 45 00	 mov	 QWORD PTR _Old_ptr$1[rbp], rax

; 3391 :             _Mypair._Myval2._Mysize = _Count;

  00043	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00047	48 8b 4d 70	 mov	 rcx, QWORD PTR _Count$[rbp]
  0004b	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 3392 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  0004f	4c 8b 45 70	 mov	 r8, QWORD PTR _Count$[rbp]
  00053	48 8b 55 68	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00057	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  0005b	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 3393 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00060	c6 45 48 00	 mov	 BYTE PTR $T2[rbp], 0
  00064	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  00068	48 8b 4d 00	 mov	 rcx, QWORD PTR _Old_ptr$1[rbp]
  0006c	48 03 c8	 add	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3394 :             return *this;

  0007e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00082	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3395 :         }
; 3396 : 
; 3397 :         return _Reallocate_for(

  00084	4c 8b 4d 68	 mov	 r9, QWORD PTR _Ptr$[rbp]
  00088	44 0f b6 45 49	 movzx	 r8d, BYTE PTR $T3[rbp]
  0008d	48 8b 55 70	 mov	 rdx, QWORD PTR _Count$[rbp]
  00091	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00095	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
$LN1@assign:

; 3398 :             _Count,
; 3399 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3400 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3401 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3402 :             },
; 3403 :             _Ptr);
; 3404 :     }

  0009a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0009e	5d		 pop	 rbp
  0009f	c3		 ret	 0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 3215 :     _CONSTEXPR20 basic_string& operator=(_In_z_ const _Elem* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3216 :         return assign(_Ptr);

  00020	48 8b 55 58	 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00024	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00028	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3217 :     }

  0002d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
_Al$ = 0
_Right_al$ = 8
tv87 = 80
tv85 = 88
this$ = 112
_Right$ = 120
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 3165 :     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3166 :         if (this == _STD addressof(_Right)) {

  00023	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  00027	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
  0002c	48 39 45 70	 cmp	 QWORD PTR this$[rbp], rax
  00030	75 06		 jne	 SHORT $LN2@operator

; 3167 :             return *this;

  00032	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00036	eb 58		 jmp	 SHORT $LN1@operator
$LN2@operator:

; 3168 :         }
; 3169 : 
; 3170 :         auto& _Al             = _Getal();

  00038	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00041	48 89 45 00	 mov	 QWORD PTR _Al$[rbp], rax

; 3171 :         const auto& _Right_al = _Right._Getal();

  00045	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  00049	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0004e	48 89 45 08	 mov	 QWORD PTR _Right_al$[rbp], rax

; 3172 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3173 :             if (_Al != _Right_al) {
; 3174 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3175 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3176 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3177 : 
; 3178 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3179 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3180 :                     auto _New_capacity       = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3181 :                     auto _Right_al_non_const = _Right_al;
; 3182 :                     ++_New_capacity;
; 3183 :                     const auto _New_ptr = _Allocate_at_least_helper(_Right_al_non_const, _New_capacity); // throws
; 3184 :                     --_New_capacity;
; 3185 : 
; 3186 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 3187 : 
; 3188 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3189 :                     _Tidy_deallocate();
; 3190 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3191 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3192 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3193 :                 } else {
; 3194 :                     _Copy_assign_val_from_small(_Right);
; 3195 :                 }
; 3196 : 
; 3197 :                 _Pocca(_Al, _Right_al);
; 3198 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3199 :                 return *this;
; 3200 :             }
; 3201 :         }
; 3202 : 
; 3203 :         _Pocca(_Al, _Right_al);

  00052	48 8b 55 08	 mov	 rdx, QWORD PTR _Right_al$[rbp]
  00056	48 8b 4d 00	 mov	 rcx, QWORD PTR _Al$[rbp]
  0005a	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >

; 3204 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0005f	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  00063	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00067	48 89 45 50	 mov	 QWORD PTR tv87[rbp], rax
  0006b	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00077	48 89 45 58	 mov	 QWORD PTR tv85[rbp], rax
  0007b	4c 8b 45 50	 mov	 r8, QWORD PTR tv87[rbp]
  0007f	48 8b 55 58	 mov	 rdx, QWORD PTR tv85[rbp]
  00083	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00087	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3205 :         return *this;

  0008c	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
$LN1@operator:

; 3206 :     }

  00090	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00094	5d		 pop	 rbp
  00095	c3		 ret	 0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 0
$S6$ = 8
_To_delete$ = 16
this$ = 112
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3128 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3129 :         _Tidy_deallocate();

  0001e	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00022	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3130 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3131 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00027	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8d 4d 08	 lea	 rcx, QWORD PTR $S6$[rbp]
  00037	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0003c	48 8d 45 08	 lea	 rax, QWORD PTR $S6$[rbp]
  00040	48 89 45 00	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 3132 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

  00044	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 89 45 10	 mov	 QWORD PTR _To_delete$[rbp], rax

; 3133 :         _Mypair._Myval2._Myproxy = nullptr;

  0004f	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00053	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3134 :         _Delete_plain_internal(_Alproxy, _To_delete);

  0005a	48 8b 55 10	 mov	 rdx, QWORD PTR _To_delete$[rbp]
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  00062	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 3135 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3136 :     }

  00067	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00073	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00077	5d		 pop	 rbp
  00078	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
_My_data$ = 0
_Right_data$ = 8
tv140 = 80
this$ = 112
_Right$ = 120
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 3012 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3013 :         // assign by stealing _Right's buffer
; 3014 :         // pre: this != &_Right
; 3015 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3016 :         // pre: *this owns no memory, iterators orphaned
; 3017 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3018 :         auto& _My_data    = _Mypair._Myval2;

  00023	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 89 45 00	 mov	 QWORD PTR _My_data$[rbp], rax

; 3019 :         auto& _Right_data = _Right._Mypair._Myval2;

  0002b	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  0002f	48 89 45 08	 mov	 QWORD PTR _Right_data$[rbp], rax

; 3020 : 
; 3021 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3022 :         if constexpr (_Can_memcpy_val) {
; 3023 : #if _HAS_CXX20
; 3024 :             if (!_STD is_constant_evaluated())

  00033	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00038	0f b6 c0	 movzx	 eax, al
  0003b	85 c0		 test	 eax, eax
  0003d	75 43		 jne	 SHORT $LN2@Take_conte

; 3025 : #endif // _HAS_CXX20
; 3026 :             {
; 3027 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3028 :                 if (_Right_data._Large_string_engaged()) {

  0003f	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00043	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	74 0f		 je	 SHORT $LN3@Take_conte

; 3029 :                     // take ownership of _Right's iterators along with its buffer
; 3030 :                     _Swap_proxy_and_iterators(_Right);

  0004f	48 8b 55 78	 mov	 rdx, QWORD PTR _Right$[rbp]
  00053	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00057	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 3031 :                 } else {

  0005c	eb 09		 jmp	 SHORT $LN4@Take_conte
$LN3@Take_conte:

; 3032 :                     _Right_data._Orphan_all();

  0005e	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00062	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
$LN4@Take_conte:

; 3033 :                 }
; 3034 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3035 : 
; 3036 :                 _Memcpy_val_from(_Right);

  00067	48 8b 55 78	 mov	 rdx, QWORD PTR _Right$[rbp]
  0006b	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0006f	e8 00 00 00 00	 call	 ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 3037 :                 _Right._Tidy_init();

  00074	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  00078	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 3038 :                 return;

  0007d	e9 af 00 00 00	 jmp	 $LN1@Take_conte
$LN2@Take_conte:

; 3039 :             }
; 3040 :         }
; 3041 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3042 : 
; 3043 :         if (_Right_data._Large_string_engaged()) { // steal buffer

  00082	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00086	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0008b	0f b6 c0	 movzx	 eax, al
  0008e	85 c0		 test	 eax, eax
  00090	74 33		 je	 SHORT $LN5@Take_conte

; 3044 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

  00092	48 8b 45 08	 mov	 rax, QWORD PTR _Right_data$[rbp]
  00096	48 83 c0 08	 add	 rax, 8
  0009a	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0009e	48 83 c1 08	 add	 rcx, 8
  000a2	48 8b d0	 mov	 rdx, rax
  000a5	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>

; 3045 :             _Right_data._Bx._Ptr = nullptr;

  000aa	48 8b 45 08	 mov	 rax, QWORD PTR _Right_data$[rbp]
  000ae	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 3046 :             _Swap_proxy_and_iterators(_Right);

  000b6	48 8b 55 78	 mov	 rdx, QWORD PTR _Right$[rbp]
  000ba	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  000be	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 3047 :         } else { // copy small string buffer

  000c3	eb 43		 jmp	 SHORT $LN6@Take_conte
$LN5@Take_conte:

; 3048 :             _My_data._Activate_SSO_buffer();

  000c5	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data$[rbp]
  000c9	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 3049 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

  000ce	48 8b 45 08	 mov	 rax, QWORD PTR _Right_data$[rbp]
  000d2	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d6	48 ff c0	 inc	 rax
  000d9	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  000dd	48 83 c1 08	 add	 rcx, 8
  000e1	48 8b 55 00	 mov	 rdx, QWORD PTR _My_data$[rbp]
  000e5	48 83 c2 08	 add	 rdx, 8
  000e9	48 89 55 50	 mov	 QWORD PTR tv140[rbp], rdx
  000ed	4c 8b c0	 mov	 r8, rax
  000f0	48 8b d1	 mov	 rdx, rcx
  000f3	48 8b 45 50	 mov	 rax, QWORD PTR tv140[rbp]
  000f7	48 8b c8	 mov	 rcx, rax
  000fa	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3050 :             _Right_data._Orphan_all();

  000ff	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00103	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
$LN6@Take_conte:

; 3051 :         }
; 3052 : 
; 3053 :         _My_data._Myres  = _Right_data._Myres;

  00108	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0010c	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00110	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00114	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 3054 :         _My_data._Mysize = _Right_data._Mysize;

  00118	48 8b 45 00	 mov	 rax, QWORD PTR _My_data$[rbp]
  0011c	48 8b 4d 08	 mov	 rcx, QWORD PTR _Right_data$[rbp]
  00120	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00124	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 3055 : 
; 3056 :         _Right._Tidy_init();

  00128	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  0012c	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
$LN1@Take_conte:

; 3057 :     }

  00131	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00135	5d		 pop	 rbp
  00136	c3		 ret	 0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
_My_data_mem$ = 0
_Right_data_mem$ = 8
this$ = 96
_Right$ = 104
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT

; 3003 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3004 :         _STL_INTERNAL_CHECK(_Can_memcpy_val);
; 3005 :         const auto _My_data_mem =

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0002c	48 83 c0 08	 add	 rax, 8
  00030	48 89 45 00	 mov	 QWORD PTR _My_data_mem$[rbp], rax

; 3006 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3007 :         const auto _Right_data_mem =

  00034	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
  00040	48 83 c0 08	 add	 rax, 8
  00044	48 89 45 08	 mov	 QWORD PTR _Right_data_mem$[rbp], rax

; 3008 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3009 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00048	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0004e	48 8b 55 08	 mov	 rdx, QWORD PTR _Right_data_mem$[rbp]
  00052	48 8b 4d 00	 mov	 rcx, QWORD PTR _My_data_mem$[rbp]
  00056	e8 00 00 00 00	 call	 memcpy

; 3010 :     }

  0005b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
$T3 = 66
tv92 = 72
tv75 = 72
tv73 = 80
this$ = 112
_Right$ = 120
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2764 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00023	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 89 45 48	 mov	 QWORD PTR tv75[rbp], rax
  0002b	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  0002f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00034	48 89 45 50	 mov	 QWORD PTR tv73[rbp], rax
  00038	0f b6 45 40	 movzx	 eax, BYTE PTR $T1[rbp]
  0003c	88 45 41	 mov	 BYTE PTR $T2[rbp], al
  0003f	4c 8b 45 50	 mov	 r8, QWORD PTR tv73[rbp]
  00043	0f b6 55 41	 movzx	 edx, BYTE PTR $T2[rbp]
  00047	48 8b 4d 48	 mov	 rcx, QWORD PTR tv75[rbp]
  0004b	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >

; 2765 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00050	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00054	48 89 45 48	 mov	 QWORD PTR tv92[rbp], rax
  00058	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0005c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00061	48 8b d0	 mov	 rdx, rax
  00064	48 8d 4d 42	 lea	 rcx, QWORD PTR $T3[rbp]
  00068	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 4d 48	 mov	 rcx, QWORD PTR tv92[rbp]
  00074	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2766 :         _Take_contents(_Right);

  00079	48 8b 55 78	 mov	 rdx, QWORD PTR _Right$[rbp]
  0007d	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00081	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2767 :     }

  00086	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0008a	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0008e	5d		 pop	 rbp
  0008f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z
_TEXT	SEGMENT
_Idx$1 = 0
_Ptr$ = 96
_Size$ = 104
?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes, COMDAT

; 2591 :     static constexpr void _Start_element_lifetimes(_Elem* const _Ptr, const size_type _Size) {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2592 :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 2593 :         // but likely more impactful to throughput.
; 2594 : #if _HAS_CXX20
; 2595 :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 37		 je	 SHORT $LN5@Start_elem

; 2596 :             for (size_type _Idx = 0; _Idx < _Size; ++_Idx) {

  0002c	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Idx$1[rbp], 0
  00034	eb 0b		 jmp	 SHORT $LN4@Start_elem
$LN2@Start_elem:
  00036	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  0003a	48 ff c0	 inc	 rax
  0003d	48 89 45 00	 mov	 QWORD PTR _Idx$1[rbp], rax
$LN4@Start_elem:
  00041	48 8b 45 68	 mov	 rax, QWORD PTR _Size$[rbp]
  00045	48 39 45 00	 cmp	 QWORD PTR _Idx$1[rbp], rax
  00049	73 18		 jae	 SHORT $LN3@Start_elem

; 2597 :                 _STD construct_at(_Ptr + _Idx);

  0004b	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  0004f	48 8b 4d 60	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00053	48 03 c8	 add	 rcx, rax
  00056	48 8b c1	 mov	 rax, rcx
  00059	48 8b c8	 mov	 rcx, rax
  0005c	e8 00 00 00 00	 call	 ??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z ; std::construct_at<char,0>

; 2598 :             }

  00061	eb d3		 jmp	 SHORT $LN2@Start_elem
$LN3@Start_elem:
$LN5@Start_elem:

; 2599 :         }
; 2600 : #else // ^^^ C++20-or-later / pre-C++20 vvv
; 2601 :         (void) _Ptr;
; 2602 :         (void) _Size;
; 2603 : #endif // _HAS_CXX20
; 2604 :     }

  00063	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00067	5d		 pop	 rbp
  00068	c3		 ret	 0
?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
$T3 = 66
tv94 = 72
tv78 = 72
tv92 = 80
tv76 = 80
this$ = 112
_Right$ = 120
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2490 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00023	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 89 45 48	 mov	 QWORD PTR tv78[rbp], rax
  0002b	48 8b 4d 78	 mov	 rcx, QWORD PTR _Right$[rbp]
  0002f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00034	48 8b d0	 mov	 rdx, rax
  00037	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0003b	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
  00040	48 89 45 50	 mov	 QWORD PTR tv76[rbp], rax
  00044	0f b6 45 41	 movzx	 eax, BYTE PTR $T2[rbp]
  00048	88 45 42	 mov	 BYTE PTR $T3[rbp], al
  0004b	4c 8b 45 50	 mov	 r8, QWORD PTR tv76[rbp]
  0004f	0f b6 55 42	 movzx	 edx, BYTE PTR $T3[rbp]
  00053	48 8b 4d 48	 mov	 rcx, QWORD PTR tv78[rbp]
  00057	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
  0005c	90		 npad	 1

; 2491 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0005d	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  00061	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00065	48 89 45 48	 mov	 QWORD PTR tv94[rbp], rax
  00069	48 8b 45 78	 mov	 rax, QWORD PTR _Right$[rbp]
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00075	48 89 45 50	 mov	 QWORD PTR tv92[rbp], rax
  00079	4c 8b 45 48	 mov	 r8, QWORD PTR tv94[rbp]
  0007d	48 8b 55 50	 mov	 rdx, QWORD PTR tv92[rbp]
  00081	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  00085	e8 00 00 00 00	 call	 ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
  0008a	90		 npad	 1

; 2492 :     }

  0008b	48 8b 45 70	 mov	 rax, QWORD PTR this$[rbp]
  0008f	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00093	5d		 pop	 rbp
  00094	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 65
$T3 = 66
tv94 = 72
tv78 = 72
tv92 = 80
tv76 = 80
this$ = 112
_Right$ = 120
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0000a	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0000e	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 65
tv86 = 72
tv69 = 72
this$ = 96
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2479 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 89 45 48	 mov	 QWORD PTR tv69[rbp], rax
  00023	0f b6 55 40	 movzx	 edx, BYTE PTR $T1[rbp]
  00027	48 8b 4d 48	 mov	 rcx, QWORD PTR tv69[rbp]
  0002b	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2480 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00030	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00034	48 89 45 48	 mov	 QWORD PTR tv86[rbp], rax
  00038	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00041	48 8b d0	 mov	 rdx, rax
  00044	48 8d 4d 41	 lea	 rcx, QWORD PTR $T2[rbp]
  00048	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0004d	48 8b d0	 mov	 rdx, rax
  00050	48 8b 4d 48	 mov	 rcx, QWORD PTR tv86[rbp]
  00054	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2481 :         _Tidy_init();

  00059	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0005d	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2482 :     }

  00062	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00066	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	48 83 c0 08	 add	 rax, 8
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 2284 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 96
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 2283 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00017	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001c	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00020	48 8b 7d 60	 mov	 rdi, QWORD PTR this$[rbp]
  00024	33 c0		 xor	 eax, eax
  00026	b9 10 00 00 00	 mov	 ecx, 16
  0002b	f3 aa		 rep stosb
  0002d	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8d 65 48	 lea	 rsp, QWORD PTR [rbp+72]
  00035	5f		 pop	 rdi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Idx$1 = 0
this$ = 96
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 2246 :     constexpr void _Activate_SSO_buffer() noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2247 :         // start the lifetime of the array elements
; 2248 : #if _HAS_CXX20
; 2249 :         if (_STD is_constant_evaluated()) {

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 30		 je	 SHORT $LN5@Activate_S

; 2250 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {

  00027	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Idx$1[rbp], 0
  0002f	eb 0b		 jmp	 SHORT $LN4@Activate_S
$LN2@Activate_S:
  00031	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  00035	48 ff c0	 inc	 rax
  00038	48 89 45 00	 mov	 QWORD PTR _Idx$1[rbp], rax
$LN4@Activate_S:
  0003c	48 83 7d 00 10	 cmp	 QWORD PTR _Idx$1[rbp], 16
  00041	73 14		 jae	 SHORT $LN5@Activate_S

; 2251 :                 _Bx._Buf[_Idx] = value_type();

  00043	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  00047	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0004b	48 03 c8	 add	 rcx, rax
  0004e	48 8b c1	 mov	 rax, rcx
  00051	c6 40 08 00	 mov	 BYTE PTR [rax+8], 0

; 2252 :             }

  00055	eb da		 jmp	 SHORT $LN2@Activate_S
$LN5@Activate_S:

; 2253 :         }
; 2254 : #endif // _HAS_CXX20
; 2255 :     }

  00057	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0005b	5d		 pop	 rbp
  0005c	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 64
this$ = 96
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT

; 2242 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2243 :         return _BUF_SIZE <= _Myres;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 20 10	 cmp	 QWORD PTR [rax+32], 16
  00024	72 09		 jb	 SHORT $LN3@Large_stri
  00026	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv66[rbp], 1
  0002d	eb 07		 jmp	 SHORT $LN4@Large_stri
$LN3@Large_stri:
  0002f	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv66[rbp], 0
$LN4@Large_stri:
  00036	0f b6 45 40	 movzx	 eax, BYTE PTR tv66[rbp]

; 2244 :     }

  0003a	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 0
this$ = 96
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2233 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2234 :         const value_type* _Result = _Bx._Buf;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 c0 08	 add	 rax, 8
  00023	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax

; 2235 :         if (_Large_string_engaged()) {

  00027	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	74 11		 je	 SHORT $LN2@Myptr

; 2236 :             _Result = _Unfancy(_Bx._Ptr);

  00037	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003f	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00044	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax
$LN2@Myptr:

; 2237 :         }
; 2238 : 
; 2239 :         return _Result;

  00048	48 8b 45 00	 mov	 rax, QWORD PTR _Result$[rbp]

; 2240 :     }

  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 0
this$ = 96
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2224 :     _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2225 :         value_type* _Result = _Bx._Buf;

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 c0 08	 add	 rax, 8
  00023	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax

; 2226 :         if (_Large_string_engaged()) {

  00027	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	74 11		 je	 SHORT $LN2@Myptr

; 2227 :             _Result = _Unfancy(_Bx._Ptr);

  00037	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003f	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00044	48 89 45 00	 mov	 QWORD PTR _Result$[rbp], rax
$LN2@Myptr:

; 2228 :         }
; 2229 : 
; 2230 :         return _Result;

  00048	48 8b 45 00	 mov	 rax, QWORD PTR _Result$[rbp]

; 2231 :     }

  0004c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 2213 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001f	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QEAA@XZ ; std::_Container_base12::_Container_base12
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 83 c0 08	 add	 rax, 8
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2214 : 
; 2215 :     // length of internal buffer, [1, 16]:
; 2216 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2217 :     // roundup mask for allocated buffers, [0, 15]:
; 2218 :     static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
; 2219 :                                            : sizeof(value_type) <= 2 ? 7
; 2220 :                                            : sizeof(value_type) <= 4 ? 3
; 2221 :                                            : sizeof(value_type) <= 8 ? 1
; 2222 :                                                                      : 0;
; 2223 : 
; 2224 :     _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2225 :         value_type* _Result = _Bx._Buf;
; 2226 :         if (_Large_string_engaged()) {
; 2227 :             _Result = _Unfancy(_Bx._Ptr);
; 2228 :         }
; 2229 : 
; 2230 :         return _Result;
; 2231 :     }
; 2232 : 
; 2233 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2234 :         const value_type* _Result = _Bx._Buf;
; 2235 :         if (_Large_string_engaged()) {
; 2236 :             _Result = _Unfancy(_Bx._Ptr);
; 2237 :         }
; 2238 : 
; 2239 :         return _Result;
; 2240 :     }
; 2241 : 
; 2242 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {
; 2243 :         return _BUF_SIZE <= _Myres;
; 2244 :     }
; 2245 : 
; 2246 :     constexpr void _Activate_SSO_buffer() noexcept {
; 2247 :         // start the lifetime of the array elements
; 2248 : #if _HAS_CXX20
; 2249 :         if (_STD is_constant_evaluated()) {
; 2250 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2251 :                 _Bx._Buf[_Idx] = value_type();
; 2252 :             }
; 2253 :         }
; 2254 : #endif // _HAS_CXX20
; 2255 :     }
; 2256 : 
; 2257 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2258 :         // checks whether _Off is in the bounds of [0, size()]
; 2259 :         if (_Mysize < _Off) {
; 2260 :             _Xran();
; 2261 :         }
; 2262 :     }
; 2263 : 
; 2264 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2265 :         // checks whether _Off is in the bounds of [0, size())
; 2266 :         if (_Mysize <= _Off) {
; 2267 :             _Xran();
; 2268 :         }
; 2269 :     }
; 2270 : 
; 2271 :     [[noreturn]] static void _Xran() {
; 2272 :         _Xout_of_range("invalid string position");
; 2273 :     }
; 2274 : 
; 2275 :     _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2276 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2277 :         return (_STD min)(_Size, _Mysize - _Off);
; 2278 :     }
; 2279 : 
; 2280 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2281 :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 2282 :         // renaming `_String_val` (and fixing the visualizer).
; 2283 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 2284 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2285 : 
; 2286 :         value_type _Buf[_BUF_SIZE];
; 2287 :         pointer _Ptr;
; 2288 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2289 :     };
; 2290 :     _Bxty _Bx;
; 2291 : 
; 2292 :     size_type _Mysize = 0; // current length of string

  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 2293 :     size_type _Myres  = 0; // current storage reserved for string

  00040	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00044	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 2213 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  0004c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 80
_Al$ = 88
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 740  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 741  :         return _Al;

  00020	48 8b 45 50	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 742  :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 80
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 736  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 737  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1

; 738  :     }

  00022	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 976  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 977  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 978  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00020	48 8b 4d 58	 mov	 rcx, QWORD PTR _Count$[rbp]
  00024	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YA_K_K@Z ; std::_Get_size_of_n<1>
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 979  :     }

  00031	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00025	48 83 7d 58 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  0002a	75 07		 jne	 SHORT $LN10@deallocate
  0002c	48 83 7d 60 00	 cmp	 QWORD PTR _Count$[rbp], 0
  00031	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00033	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 03		 jne	 SHORT $LN12@deallocate
  0006d	cc		 int	 3
  0006e	33 c0		 xor	 eax, eax
$LN12@deallocate:
  00070	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00079	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 7b ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	48 8b 55 60	 mov	 rdx, QWORD PTR _Count$[rbp]
  000ae	48 8b 4d 58	 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000b2	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000b7	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000bb	5d		 pop	 rbp
  000bc	c3		 ret	 0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 962  :     constexpr allocator() noexcept {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2310 : [[noreturn]] inline void _Xlen_string() {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2311 :     _Xlength_error("string too long");

  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
  0001e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2312 : }

  00023	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 439  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 440  : #if _HAS_CXX20
; 441  :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0f		 je	 SHORT $LN2@assign

; 442  :             return _Primary_char_traits::assign(_Left, _Right);

  0002c	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00030	48 8b 4d 50	 mov	 rcx, QWORD PTR _Left$[rbp]
  00034	e8 00 00 00 00	 call	 ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Char_traits<char,int>::assign
  00039	eb 0d		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 443  :         }
; 444  : #endif // _HAS_CXX20
; 445  :         _Left = _Right;

  0003b	48 8b 45 50	 mov	 rax, QWORD PTR _Left$[rbp]
  0003f	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  00043	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00046	88 08		 mov	 BYTE PTR [rax], cl
$LN1@assign:

; 446  :     }

  00048	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 64
tv69 = 72
_First$ = 96
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 386  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 387  :         // find length of null-terminated string
; 388  : #if _HAS_CXX17
; 389  : #ifdef __cpp_char8_t
; 390  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 391  : #if _HAS_U8_INTRINSICS
; 392  :             return __builtin_u8strlen(_First);
; 393  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 394  :             return _Primary_char_traits::length(_First);
; 395  : #endif // _HAS_U8_INTRINSICS
; 396  :         } else
; 397  : #endif // __cpp_char8_t
; 398  :         {
; 399  :             return __builtin_strlen(_First);

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR _First$[rbp]
  0001f	48 89 45 40	 mov	 QWORD PTR tv68[rbp], rax
  00023	48 c7 45 48 ff
	ff ff ff	 mov	 QWORD PTR tv69[rbp], -1
$LL3@length:
  0002b	48 ff 45 48	 inc	 QWORD PTR tv69[rbp]
  0002f	48 8b 45 40	 mov	 rax, QWORD PTR tv68[rbp]
  00033	48 8b 4d 48	 mov	 rcx, QWORD PTR tv69[rbp]
  00037	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  0003b	75 ee		 jne	 SHORT $LL3@length
  0003d	48 8b 45 48	 mov	 rax, QWORD PTR tv69[rbp]

; 400  :         }
; 401  : #else // _HAS_CXX17
; 402  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 403  : #endif // _HAS_CXX17
; 404  :     }

  00041	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 80
_Right$ = 88
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 181  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 182  : #if _HAS_CXX20
; 183  :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@assign

; 184  :             _STD construct_at(_STD addressof(_Left), _Right);

  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR _Left$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPEADAEAD@Z ; std::addressof<char>
  00035	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z ; std::construct_at<char,char const &,0>

; 185  :         } else

  00041	eb 0d		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 186  : #endif // _HAS_CXX20
; 187  :         {
; 188  :             _Left = _Right;

  00043	48 8b 45 50	 mov	 rax, QWORD PTR _Left$[rbp]
  00047	48 8b 4d 58	 mov	 rcx, QWORD PTR _Right$[rbp]
  0004b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0004e	88 08		 mov	 BYTE PTR [rax], cl
$LN3@assign:

; 189  :         }
; 190  :     }

  00050	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_Loop_forward$1 = 0
_Src$2 = 8
_Idx$3 = 16
_Idx$4 = 24
_First1$ = 112
_First2$ = 120
_Count$ = 128
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 80   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 81   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 82   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 83   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 84   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 85   : #if _HAS_CXX20
; 86   :         if (_STD is_constant_evaluated()) {

  00028	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002d	0f b6 c0	 movzx	 eax, al
  00030	85 c0		 test	 eax, eax
  00032	0f 84 db 00 00
	00		 je	 $LN11@move

; 87   :             // dest: [_First1, _First1 + _Count)
; 88   :             // src: [_First2, _First2 + _Count)
; 89   :             // We need to handle overlapping ranges.
; 90   :             // If _First1 is in the src range, we need a backward loop.
; 91   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 92   : 
; 93   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 94   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 95   :             bool _Loop_forward = true;

  00038	c6 45 00 01	 mov	 BYTE PTR _Loop_forward$1[rbp], 1

; 96   : 
; 97   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {

  0003c	48 8b 45 78	 mov	 rax, QWORD PTR _First2$[rbp]
  00040	48 89 45 08	 mov	 QWORD PTR _Src$2[rbp], rax
  00044	eb 0b		 jmp	 SHORT $LN4@move
$LN2@move:
  00046	48 8b 45 08	 mov	 rax, QWORD PTR _Src$2[rbp]
  0004a	48 ff c0	 inc	 rax
  0004d	48 89 45 08	 mov	 QWORD PTR _Src$2[rbp], rax
$LN4@move:
  00051	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  00058	48 8b 4d 78	 mov	 rcx, QWORD PTR _First2$[rbp]
  0005c	48 03 c8	 add	 rcx, rax
  0005f	48 8b c1	 mov	 rax, rcx
  00062	48 39 45 08	 cmp	 QWORD PTR _Src$2[rbp], rax
  00066	74 12		 je	 SHORT $LN3@move

; 98   :                 if (_First1 == _Src) {

  00068	48 8b 45 08	 mov	 rax, QWORD PTR _Src$2[rbp]
  0006c	48 39 45 70	 cmp	 QWORD PTR _First1$[rbp], rax
  00070	75 06		 jne	 SHORT $LN12@move

; 99   :                     _Loop_forward = false;

  00072	c6 45 00 00	 mov	 BYTE PTR _Loop_forward$1[rbp], 0

; 100  :                     break;

  00076	eb 02		 jmp	 SHORT $LN3@move
$LN12@move:

; 101  :                 }
; 102  :             }

  00078	eb cc		 jmp	 SHORT $LN2@move
$LN3@move:

; 103  : 
; 104  :             if (_Loop_forward) {

  0007a	0f b6 45 00	 movzx	 eax, BYTE PTR _Loop_forward$1[rbp]
  0007e	85 c0		 test	 eax, eax
  00080	74 47		 je	 SHORT $LN13@move

; 105  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {

  00082	48 c7 45 10 00
	00 00 00	 mov	 QWORD PTR _Idx$3[rbp], 0
  0008a	eb 0b		 jmp	 SHORT $LN7@move
$LN5@move:
  0008c	48 8b 45 10	 mov	 rax, QWORD PTR _Idx$3[rbp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 45 10	 mov	 QWORD PTR _Idx$3[rbp], rax
$LN7@move:
  00097	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  0009e	48 39 45 10	 cmp	 QWORD PTR _Idx$3[rbp], rax
  000a2	74 23		 je	 SHORT $LN6@move

; 106  :                     _First1[_Idx] = _First2[_Idx];

  000a4	48 8b 45 10	 mov	 rax, QWORD PTR _Idx$3[rbp]
  000a8	48 8b 4d 70	 mov	 rcx, QWORD PTR _First1$[rbp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 8b 4d 10	 mov	 rcx, QWORD PTR _Idx$3[rbp]
  000b6	48 8b 55 78	 mov	 rdx, QWORD PTR _First2$[rbp]
  000ba	48 03 d1	 add	 rdx, rcx
  000bd	48 8b ca	 mov	 rcx, rdx
  000c0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000c3	88 08		 mov	 BYTE PTR [rax], cl

; 107  :                 }

  000c5	eb c5		 jmp	 SHORT $LN5@move
$LN6@move:

; 108  :             } else {

  000c7	eb 44		 jmp	 SHORT $LN14@move
$LN13@move:

; 109  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {

  000c9	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR _Count$[rbp]
  000d0	48 89 45 18	 mov	 QWORD PTR _Idx$4[rbp], rax
  000d4	eb 0b		 jmp	 SHORT $LN10@move
$LN8@move:
  000d6	48 8b 45 18	 mov	 rax, QWORD PTR _Idx$4[rbp]
  000da	48 ff c8	 dec	 rax
  000dd	48 89 45 18	 mov	 QWORD PTR _Idx$4[rbp], rax
$LN10@move:
  000e1	48 83 7d 18 00	 cmp	 QWORD PTR _Idx$4[rbp], 0
  000e6	74 25		 je	 SHORT $LN14@move

; 110  :                     _First1[_Idx - 1] = _First2[_Idx - 1];

  000e8	48 8b 45 18	 mov	 rax, QWORD PTR _Idx$4[rbp]
  000ec	48 8b 4d 70	 mov	 rcx, QWORD PTR _First1$[rbp]
  000f0	48 03 c8	 add	 rcx, rax
  000f3	48 8b c1	 mov	 rax, rcx
  000f6	48 8b 4d 18	 mov	 rcx, QWORD PTR _Idx$4[rbp]
  000fa	48 8b 55 78	 mov	 rdx, QWORD PTR _First2$[rbp]
  000fe	48 03 d1	 add	 rdx, rcx
  00101	48 8b ca	 mov	 rcx, rdx
  00104	0f b6 49 ff	 movzx	 ecx, BYTE PTR [rcx-1]
  00108	88 48 ff	 mov	 BYTE PTR [rax-1], cl

; 111  :                 }

  0010b	eb c9		 jmp	 SHORT $LN8@move
$LN14@move:

; 112  :             }
; 113  : 
; 114  :             return _First1;

  0010d	48 8b 45 70	 mov	 rax, QWORD PTR _First1$[rbp]
  00111	eb 18		 jmp	 SHORT $LN1@move
$LN11@move:

; 115  :         }
; 116  : #endif // _HAS_CXX20
; 117  : 
; 118  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00113	4c 8b 85 80 00
	00 00		 mov	 r8, QWORD PTR _Count$[rbp]
  0011a	48 8b 55 78	 mov	 rdx, QWORD PTR _First2$[rbp]
  0011e	48 8b 4d 70	 mov	 rcx, QWORD PTR _First1$[rbp]
  00122	e8 00 00 00 00	 call	 memmove

; 119  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 120  : 
; 121  :         return _First1;

  00127	48 8b 45 70	 mov	 rax, QWORD PTR _First1$[rbp]
$LN1@move:

; 122  :     }

  0012b	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  0012f	5d		 pop	 rbp
  00130	c3		 ret	 0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_Idx$1 = 0
_First1$ = 96
_First2$ = 104
_Count$ = 112
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 49   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__1326DD76_xstring
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 50   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 51   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 52   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 53   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 54   : #if _HAS_CXX20
; 55   :         if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 48		 je	 SHORT $LN5@copy

; 56   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 57   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {

  00031	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR _Idx$1[rbp], 0
  00039	eb 0b		 jmp	 SHORT $LN4@copy
$LN2@copy:
  0003b	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  0003f	48 ff c0	 inc	 rax
  00042	48 89 45 00	 mov	 QWORD PTR _Idx$1[rbp], rax
$LN4@copy:
  00046	48 8b 45 70	 mov	 rax, QWORD PTR _Count$[rbp]
  0004a	48 39 45 00	 cmp	 QWORD PTR _Idx$1[rbp], rax
  0004e	74 23		 je	 SHORT $LN3@copy

; 58   :                 _First1[_Idx] = _First2[_Idx];

  00050	48 8b 45 00	 mov	 rax, QWORD PTR _Idx$1[rbp]
  00054	48 8b 4d 60	 mov	 rcx, QWORD PTR _First1$[rbp]
  00058	48 03 c8	 add	 rcx, rax
  0005b	48 8b c1	 mov	 rax, rcx
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Idx$1[rbp]
  00062	48 8b 55 68	 mov	 rdx, QWORD PTR _First2$[rbp]
  00066	48 03 d1	 add	 rdx, rcx
  00069	48 8b ca	 mov	 rcx, rdx
  0006c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006f	88 08		 mov	 BYTE PTR [rax], cl

; 59   :             }

  00071	eb c8		 jmp	 SHORT $LN2@copy
$LN3@copy:

; 60   : 
; 61   :             return _First1;

  00073	48 8b 45 60	 mov	 rax, QWORD PTR _First1$[rbp]
  00077	eb 15		 jmp	 SHORT $LN1@copy
$LN5@copy:

; 62   :         }
; 63   : #endif // _HAS_CXX20
; 64   : 
; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00079	4c 8b 45 70	 mov	 r8, QWORD PTR _Count$[rbp]
  0007d	48 8b 55 68	 mov	 rdx, QWORD PTR _First2$[rbp]
  00081	48 8b 4d 60	 mov	 rcx, QWORD PTR _First1$[rbp]
  00085	e8 00 00 00 00	 call	 memcpy

; 66   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 67   : 
; 68   :         return _First1;

  0008a	48 8b 45 60	 mov	 rax, QWORD PTR _First1$[rbp]
$LN1@copy:

; 69   :     }

  0008e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00092	5d		 pop	 rbp
  00093	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 64
_Obj$ = 96
<_Args_0>$ = 104
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__B7320FC0_xutility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 17		 je	 SHORT $LN2@Construct_

; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002c	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00030	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
  00035	48 8b 55 68	 mov	 rdx, QWORD PTR <_Args_0>$[rbp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>

; 252  :     } else

  00041	eb 2a		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00043	48 8b 4d 60	 mov	 rcx, QWORD PTR _Obj$[rbp]
  00047	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	b9 10 00 00 00	 mov	 ecx, 16
  00054	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00059	48 89 45 40	 mov	 QWORD PTR $T1[rbp], rax
  0005d	48 8b 45 68	 mov	 rax, QWORD PTR <_Args_0>$[rbp]
  00061	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00064	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00068	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
$LN3@Construct_:

; 256  :     }
; 257  : }

  0006d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00071	5d		 pop	 rbp
  00072	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\type_traits
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 80
??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 1589 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__3DF2A533_type_traits
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1590 :     return __builtin_addressof(_Val);

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR _Val$[rbp]

; 1591 : }

  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0_Basic_container_proxy_ptr12@std@@IEAA@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT

; 1453 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1446 :     _Container_proxy* _Ptr = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1453 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
??0_Basic_container_proxy_ptr12@std@@IEAA@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ PROC ; std::_Basic_container_proxy_ptr12::_Release, COMDAT

; 1448 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1449 :         _Ptr = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1450 :     }

  00026	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ENDP ; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\utility
;	COMDAT ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 96
_New_val$ = 104
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0D603829_utility
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00020	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR _Val$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _New_val$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00039	48 8b 45 00	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
_Right$ = 104
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_locked, COMDAT

; 1234 :     void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1235 :         _Lockit _Lock(_LOCK_DEBUG);

  00020	ba 03 00 00 00	 mov	 edx, 3
  00025	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1236 :         _Swap_proxy_and_iterators_unlocked(_Right);

  0002f	48 8b 55 68	 mov	 rdx, QWORD PTR _Right$[rbp]
  00033	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked

; 1237 :     }

  0003c	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00046	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_locked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 0
this$ = 96
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT

; 1229 :     void _Orphan_all_locked_v3() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1230 :         _Lockit _Lock(_LOCK_DEBUG);

  0001b	ba 03 00 00 00	 mov	 edx, 3
  00020	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1231 :         _Orphan_all_unlocked_v3();

  0002a	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1232 :     }

  00033	48 8d 4d 00	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0003d	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z
_TEXT	SEGMENT
_Temp$ = 0
this$ = 96
_Right$ = 104
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked, COMDAT

; 1393 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1394 :     _Container_proxy* _Temp = _Myproxy;

  00020	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 89 45 00	 mov	 QWORD PTR _Temp$[rbp], rax

; 1395 :     _Myproxy                = _Right._Myproxy;

  0002b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1396 :     _Right._Myproxy         = _Temp;

  00039	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  0003d	48 8b 4d 00	 mov	 rcx, QWORD PTR _Temp$[rbp]
  00041	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1397 : 
; 1398 :     if (_Myproxy) {

  00044	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00048	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004c	74 0e		 je	 SHORT $LN2@Swap_proxy

; 1399 :         _Myproxy->_Mycont = this;

  0004e	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@Swap_proxy:

; 1400 :     }
; 1401 : 
; 1402 :     if (_Right._Myproxy) {

  0005c	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  00060	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00064	74 0e		 je	 SHORT $LN3@Swap_proxy

; 1403 :         _Right._Myproxy->_Mycont = &_Right;

  00066	48 8b 45 68	 mov	 rax, QWORD PTR _Right$[rbp]
  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006d	48 8b 4d 68	 mov	 rcx, QWORD PTR _Right$[rbp]
  00071	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Swap_proxy:

; 1404 :     }
; 1405 : }

  00074	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00078	5d		 pop	 rbp
  00079	c3		 ret	 0
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$1 = 0
$T2 = 72
this$ = 96
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT

; 1369 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1370 :     if (!_Myproxy) { // no proxy, already done

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	75 02		 jne	 SHORT $LN5@Orphan_all

; 1371 :         return;

  00025	eb 45		 jmp	 SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1372 :     }
; 1373 : 
; 1374 :     // proxy allocated, drain it
; 1375 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

  00027	48 c7 45 48 00
	00 00 00	 mov	 QWORD PTR $T2[rbp], 0
  0002f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 83 c0 08	 add	 rax, 8
  0003a	48 8d 55 48	 lea	 rdx, QWORD PTR $T2[rbp]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
  00046	48 89 45 00	 mov	 QWORD PTR _Pnext$1[rbp], rax
  0004a	eb 0c		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0004c	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00050	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00054	48 89 45 00	 mov	 QWORD PTR _Pnext$1[rbp], rax
$LN4@Orphan_all:
  00058	48 83 7d 00 00	 cmp	 QWORD PTR _Pnext$1[rbp], 0
  0005d	74 0d		 je	 SHORT $LN1@Orphan_all

; 1376 :         _Pnext->_Myproxy = nullptr;

  0005f	48 8b 45 00	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00063	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1377 :     }

  0006a	eb e0		 jmp	 SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 1378 : }

  0006c	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators, COMDAT

; 1407 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1408 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1409 : #if _HAS_CXX20
; 1410 :     if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 0f		 je	 SHORT $LN2@Swap_proxy

; 1411 :         _Swap_proxy_and_iterators_unlocked(_Right);

  0002c	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  00030	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00034	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked

; 1412 :     } else

  00039	eb 0d		 jmp	 SHORT $LN3@Swap_proxy
$LN2@Swap_proxy:

; 1413 : #endif // _HAS_CXX20
; 1414 :     {
; 1415 :         _Swap_proxy_and_iterators_locked(_Right);

  0003b	48 8b 55 58	 mov	 rdx, QWORD PTR _Right$[rbp]
  0003f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00043	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
$LN3@Swap_proxy:

; 1416 :     }
; 1417 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1418 :     _Swap_proxy_and_iterators_unlocked(_Right);
; 1419 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1420 : }

  00048	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 80
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 1380 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1381 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1382 : #if _HAS_CXX20
; 1383 :     if (_STD is_constant_evaluated()) {

  0001b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 0b		 je	 SHORT $LN2@Orphan_all

; 1384 :         _Orphan_all_unlocked_v3();

  00027	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1385 :     } else

  00030	eb 09		 jmp	 SHORT $LN3@Orphan_all
$LN2@Orphan_all:

; 1386 : #endif // _HAS_CXX20
; 1387 :     {
; 1388 :         _Orphan_all_locked_v3();

  00032	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00036	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN3@Orphan_all:

; 1389 :     }
; 1390 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1391 : }

  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT

; 1198 :     _CONSTEXPR20 _Container_base12() noexcept = default;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1199 : 
; 1200 :     _Container_base12(const _Container_base12&)            = delete;
; 1201 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1202 : 
; 1203 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1204 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1205 : 
; 1206 :     template <class _Alloc>
; 1207 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1208 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1209 :         _Construct_in_place(*_New_proxy, this);
; 1210 :         _Myproxy            = _New_proxy;
; 1211 :         _New_proxy->_Mycont = this;
; 1212 :     }
; 1213 : 
; 1214 :     template <class _Alloc>
; 1215 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1216 :         // pre: no iterators refer to the existing proxy
; 1217 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1218 :         _Construct_in_place(*_New_proxy, this);
; 1219 :         _New_proxy->_Mycont = this;
; 1220 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1221 :     }
; 1222 : 
; 1223 :     _Container_proxy* _Myproxy = nullptr;

  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1198 :     _CONSTEXPR20 _Container_base12() noexcept = default;

  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
??0_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 80
_Mycont_$ = 88
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT

; 1190 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00020	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00024	48 8b 4d 58	 mov	 rcx, QWORD PTR _Mycont_$[rbp]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1191 : 
; 1192 :     const _Container_base12* _Mycont       = nullptr;
; 1193 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1190 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr_user$ = 0
_Ptr_container$ = 8
_Min_back_shift$ = 16
_Back_shift$ = 24
_Ptr$ = 112
_Bytes$ = 120
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 154  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 155  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 156  :     _Bytes += _Non_user_size;

  00023	48 8b 45 78	 mov	 rax, QWORD PTR _Bytes$[rbp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  0002e	48 8b 4d 78	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00032	48 89 01	 mov	 QWORD PTR [rcx], rax

; 157  : 
; 158  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00035	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 45 00	 mov	 QWORD PTR _Ptr_user$[rbp], rax

; 159  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00040	b8 08 00 00 00	 mov	 eax, 8
  00045	48 6b c0 ff	 imul	 rax, rax, -1
  00049	48 8b 4d 00	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  0004d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00051	48 89 45 08	 mov	 QWORD PTR _Ptr_container$[rbp], rax
$LN4@Adjust_man:

; 160  : 
; 161  :     // If the following asserts, it likely means that we are performing
; 162  :     // an aligned delete on memory coming from an unaligned allocation.
; 163  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00055	b8 08 00 00 00	 mov	 eax, 8
  0005a	48 6b c0 fe	 imul	 rax, rax, -2
  0005e	48 8b 4d 00	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  00062	48 ba fa fa fa
	fa fa fa fa fa	 mov	 rdx, -361700864190383366 ; fafafafafafafafaH
  0006c	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00070	75 02		 jne	 SHORT $LN14@Adjust_man
  00072	eb 77		 jmp	 SHORT $LN15@Adjust_man
$LN14@Adjust_man:
$LN7@Adjust_man:
  00074	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  0007a	83 c0 09	 add	 eax, 9
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  00084	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00090	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00095	45 33 c9	 xor	 r9d, r9d
  00098	44 8b c0	 mov	 r8d, eax
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  000a2	b9 02 00 00 00	 mov	 ecx, 2
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 03		 jne	 SHORT $LN19@Adjust_man
  000b2	cc		 int	 3
  000b3	33 c0		 xor	 eax, eax
$LN19@Adjust_man:
  000b5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  000bb	83 c0 09	 add	 eax, 9
  000be	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000c7	44 8b c8	 mov	 r9d, eax
  000ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000e5	33 c0		 xor	 eax, eax
  000e7	85 c0		 test	 eax, eax
  000e9	75 89		 jne	 SHORT $LN7@Adjust_man
$LN15@Adjust_man:
  000eb	33 c0		 xor	 eax, eax
  000ed	85 c0		 test	 eax, eax
  000ef	0f 85 60 ff ff
	ff		 jne	 $LN4@Adjust_man

; 164  : 
; 165  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 166  :     // in range [_Min_back_shift, _Non_user_size]
; 167  : #ifdef _DEBUG
; 168  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000f5	48 c7 45 10 10
	00 00 00	 mov	 QWORD PTR _Min_back_shift$[rbp], 16

; 169  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 170  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 171  : #endif // _DEBUG
; 172  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fd	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  00101	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  00105	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00108	48 2b c1	 sub	 rax, rcx
  0010b	48 89 45 18	 mov	 QWORD PTR _Back_shift$[rbp], rax
$LN10@Adjust_man:

; 173  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010f	48 83 7d 18 10	 cmp	 QWORD PTR _Back_shift$[rbp], 16
  00114	72 09		 jb	 SHORT $LN16@Adjust_man
  00116	48 83 7d 18 2f	 cmp	 QWORD PTR _Back_shift$[rbp], 47 ; 0000002fH
  0011b	77 02		 ja	 SHORT $LN16@Adjust_man
  0011d	eb 77		 jmp	 SHORT $LN17@Adjust_man
$LN16@Adjust_man:
$LN13@Adjust_man:
  0011f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00125	83 c0 13	 add	 eax, 19
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  0012f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0013b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00140	45 33 c9	 xor	 r9d, r9d
  00143	44 8b c0	 mov	 r8d, eax
  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@FLDGEGM@C?3?2Program?5Files?2Microsoft?5Visu@
  0014d	b9 02 00 00 00	 mov	 ecx, 2
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00158	83 f8 01	 cmp	 eax, 1
  0015b	75 03		 jne	 SHORT $LN20@Adjust_man
  0015d	cc		 int	 3
  0015e	33 c0		 xor	 eax, eax
$LN20@Adjust_man:
  00160	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00166	83 c0 13	 add	 eax, 19
  00169	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00172	44 8b c8	 mov	 r9d, eax
  00175	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1MA@IKJDCOIC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  00190	33 c0		 xor	 eax, eax
  00192	85 c0		 test	 eax, eax
  00194	75 89		 jne	 SHORT $LN13@Adjust_man
$LN17@Adjust_man:
  00196	33 c0		 xor	 eax, eax
  00198	85 c0		 test	 eax, eax
  0019a	0f 85 6f ff ff
	ff		 jne	 $LN10@Adjust_man

; 174  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001a0	48 8b 45 70	 mov	 rax, QWORD PTR _Ptr$[rbp]
  001a4	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  001a8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 175  : }

  001ab	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  001af	5d		 pop	 rbp
  001b0	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 80
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 85   :         void* _Allocate(const size_t _Bytes) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__67F55BEA_xmemory
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 86   :         return ::operator new(_Bytes);

  0001b	48 8b 4d 50	 mov	 rcx, QWORD PTR _Bytes$[rbp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 87   :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 64
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 330  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00009	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2DED1E19_exception
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 331  :     _THROW(bad_array_new_length{});

  0001a	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0001e	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QEAA@XZ ; std::bad_array_new_length::bad_array_new_length
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
  0002a	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0002e	e8 00 00 00 00	 call	 _CxxThrowException
$LN2@Throw_bad_:

; 332  : }

  00033	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UEAA@XZ
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QEAA@AEBV01@@Z
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 141  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 140  :         : bad_alloc("bad array new length")

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00022	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AEAA@QEBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  0002b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00036	48 89 08	 mov	 QWORD PTR [rax], rcx

; 142  :     }

  00039	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003d	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 55 58	 mov	 rdx, QWORD PTR __that$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@AEBV01@@Z ; std::exception::exception
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00013	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  00018	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001c	5d		 pop	 rbp
  0001d	c3		 ret	 0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 80
_Message$ = 88
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 129  :         : exception(_Message, 1)

  00020	41 b8 01 00 00
	00		 mov	 r8d, 1
  00026	48 8b 55 58	 mov	 rdx, QWORD PTR _Message$[rbp]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@QEBDH@Z ; std::exception::exception

; 130  :     {

  00033	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  0003e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 131  :     }

  00041	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 80
__flags$ = 88
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00017	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  0001c	8b 45 58	 mov	 eax, DWORD PTR __flags$[rbp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 0e		 je	 SHORT $LN2@scalar
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 64
this$ = 96
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 94   :     {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  0001b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00024	74 0e		 je	 SHORT $LN3@what
  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002e	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
  00032	eb 0b		 jmp	 SHORT $LN4@what
$LN3@what:
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
  0003b	48 89 45 40	 mov	 QWORD PTR tv69[rbp], rax
$LN4@what:
  0003f	48 8b 45 40	 mov	 rax, QWORD PTR tv69[rbp]

; 96   :     }

  00043	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 80
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00026	48 89 08	 mov	 QWORD PTR [rax], rcx

; 90   :         __std_exception_destroy(&_Data);

  00029	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002d	48 83 c0 08	 add	 rax, 8
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 __std_exception_destroy

; 91   :     }

  00039	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 96
_Other$ = 104
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  0001c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00021	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   :         : _Data()

  0002f	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00033	48 83 c0 08	 add	 rax, 8
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 10 00 00 00	 mov	 ecx, 16
  00041	f3 aa		 rep stosb

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00043	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00047	48 83 c0 08	 add	 rax, 8
  0004b	48 8b 4d 68	 mov	 rcx, QWORD PTR _Other$[rbp]
  0004f	48 83 c1 08	 add	 rcx, 8
  00053	48 8b d0	 mov	 rdx, rax
  00056	e8 00 00 00 00	 call	 __std_exception_copy

; 74   :     }

  0005b	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0005f	48 8d 65 48	 lea	 rsp, QWORD PTR [rbp+72]
  00063	5f		 pop	 rdi
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 96
_Message$ = 104
__formal$ = 112
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00015	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7280C444_vcruntime_exception@h
  00021	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00026	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00031	48 89 08	 mov	 QWORD PTR [rax], rcx

; 65   :         : _Data()

  00034	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 83 c0 08	 add	 rax, 8
  0003c	48 8b f8	 mov	 rdi, rax
  0003f	33 c0		 xor	 eax, eax
  00041	b9 10 00 00 00	 mov	 ecx, 16
  00046	f3 aa		 rep stosb

; 67   :         _Data._What = _Message;

  00048	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8b 4d 68	 mov	 rcx, QWORD PTR _Message$[rbp]
  00050	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 68   :     }

  00054	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8d 65 48	 lea	 rsp, QWORD PTR [rbp+72]
  0005c	5f		 pop	 rdi
  0005d	5d		 pop	 rbp
  0005e	c3		 ret	 0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 635  :     _NODISCARD static constexpr long long(max)() noexcept {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__595ABB90_limits
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 636  :         return LLONG_MAX;

  00017	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH

; 637  :     }

  00021	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 178  : _EXPORT_STD _NODISCARD constexpr bool is_constant_evaluated() noexcept {

$LN3:
  00000	40 55		 push	 rbp
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9A2CA802_xtr1common
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 179  :     return __builtin_is_constant_evaluated();

  00017	32 c0		 xor	 al, al

; 180  : }

  00019	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.38.33030\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 80
_Where$ = 88
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 168  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__84C50014_vcruntime_new@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 169  :         (void)_Size;
; 170  :         return _Where;

  00020	48 8b 45 58	 mov	 rax, QWORD PTR _Where$[rbp]

; 171  :     }

  00024	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
END
